# 前端开发知识点

<https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md>

    HTML&CSS：
        对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、
        HTML5、CSS3、Flexbox

    JavaScript：
        数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、
        DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs

    其他：
        移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力

## 前端面试

一面：页面布局、css盒模型、DOM事件、HTTP协议、面向对象、原型链、算法、安全、通信
二面：vue 源码、优缺点、原理、生命周期
三面：业务负责人，职业生涯特色业务，角色，推动了、改变了什么
终面：HR面试，沟通、性格、潜力

抽象设计能力、项目把控能力、经验。

## 面试准备

* 职位描述 JD 分析
* 业务分析或实战模拟
* 技术栈准备
* 自我介绍

## 问题

### HTML5的离线储存怎么使用，工作原理

在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。
原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。
离线的情况下，浏览器就直接使用离线存储的资源。

#### 如何使用

1. 页面头部像下面一样加入一个manifest的属性: `<html manifest="cache.manifest">`
1. 在cache.manifest文件的编写离线存储的资源；

    ```
    CACHE MANIFEST
    #v0.11
    CACHE:
    js/app.js
    css/style.css
    NETWORK:
    resource/logo.png
    FALLBACK:
    // offline.html在离线状态时，操作window.applicationCache进行需求实现。
    ```

#### 自动化工具: (<http://yanhaijing.com/html/2014/12/28/html5-manifest/>)

manifest 文件中的 cache 部分不能使用通配符，必须手动指定，这实在太让人不可理解，文件一多，就成了体力活了，这里介绍的 grunt-manifest 能自动生成 manifest 文件的目的。grunt-manifest 依赖 grunt

如下的命令可以安装grunt-manifest，并加入到依赖文件。

```bash
npm install grunt-manifest --save-dev
```

如下的代码，可以在 grunt 中载入 grunt-manifest，然后便可使用。

```bash
grunt.loadNpmTasks('grunt-manifest');
```

使用grunt-manifest的一个典型的配置文件如下所示：

```javascript
grunt.initConfig({
  manifest: {
    generate: {
      options: {
        basePath: "../",
        cache: ["js/app.js", "css/style.css"]
        network: ["http://*", "https://*"],
        fallback: ["/ /offline.html"],
        exclude: ["js/jquery.min.js"],
        preferOnline: true,
        verbose: true,
        timestamp: true
      },
      src: [
            "some_files/*.html",
          "js/*.min.js",
          "css/*.css"
      ],
      dest: "index.manifest"
    }
  }
});
```

其中 options 定义生成 manifest 的一些自定义参数，src是要生成的文件，dest是输出文件。

options 下有很多参数，主要参数如下：

* basePath 设置出入文件的根目录
* cache 手动添加缓存文件
* network 手动添加网络文件
* fallback 手动添加后备文件
* exclude 设置不添加到cache的文件
* verbose 是否添加版权信息
* timestamp 是否添加时间戳
* 这里有 Basejs 的配置文件和生成的 manifest 文件的例子。

### 如何实现浏览器内多个标签页之间的通信? (阿里)

WebSocket、SharedWorker；
也可以调用 localStorage、cookies等本地存储方式；

localStorage 另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信；
注意quirks：Safari 在无痕模式下设置 localStorage 值时会抛出 QuotaExceededError 的异常；

### webSocket如何兼容低浏览器？(阿里)

* Adobe Flash Socket
* ActiveX HTMLFile (IE)
* 基于 multipart 编码发送 XHR
* 基于长轮询的 XHR

### 页面可见性（Page Visibility API） 可以有哪些用途？

通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;
在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；

### 说几条写JavaScript的基本规范？

1. 不要在同一行声明多个变量。
1. 请使用 `===/!==` 来比较 true/false 或者数值
1. 使用对象字面量替代 new Array 这种形式
1. 不要使用全局函数。
1. Switch 语句必须带有 default分支
1. 函数不应该有时候有返回值，有时候没有返回值。
1. For 循环必须使用大括号
1. If 语句必须使用大括号
1. for-in 循环中的变量 应该使用 var  关键字明确限定作用域，从而避免作用域污染。

### Design Pattern

* Singleton object (见 design_pattern.md)

## Test

```javascript
// Load the test dependencies
var app = require('../../server'),
    request = require('supertest'),
    should = require('should'),
    mongoose = require('mongoose'),
    User = mongoose.model('User'),
    Article = mongoose.model('Article');

// Define global test variables
var user, article;

// Create an 'Articles' controller test suite
describe('Article Controller Unit Tests:', function() {
    // Define a pre-tests function
    beforeEach(function(done) {
        // Create a new 'User' model instance
        user = new User({
            firstName: 'Full',
            lastName: 'Name',
            displayName: 'Full Name',
            email: 'test@test.com',
            username: 'username',
            password: 'password'
        });

        // Save the new 'User' model instance
        user.save(function() {
            article = new Article({
                title: 'Article Title',
                content: 'Article Content',
                user: user
            });

            article.save(function(err) {
                done();
            });
        });
    });

    // Test the 'Article' GET methods
    describe('Testing the GET methods', function() {
        it('Should be able to get the list of articles', function(done) {
            // Create a SuperTest request
            request(app).get('/api/articles/')
                .set('Accept', 'application/json')
                .expect('Content-Type', /json/)
                .expect(200)
                .end(function(err, res) {
                    // res.body.should.have.lengthOf(1).and.be.an.Array;  //should.js
                    res.body.should.be.an.instanceof(Array).and.have.lengthOf(1); // should.js
                    // res.body.should.be.an.Array.and.have.lengthOf(1);  // this doesn't work in late should.js since Array cannot chain
                    res.body[0].should.have.property('title', article.title); // here is should.js
                    res.body[0].should.have.property('content', article.content); // here is should.js

                    done();
                });
        });

        it('Should be able to get the specific article', function(done) {
            // Create a SuperTest request
            request(app).get('/api/articles/' + article.id)
                .set('Accept', 'application/json')
                .expect('Content-Type', /json/)
                .expect(200)
                .end(function(err, res) {
                    // res.body.should.be.an.Object.and.have.property('title', article.title); // here is should.js
                    // res.body.should.have.property('content', article.content); // here is should.js

                    done();
                });
        });
    });

    // Define a post-tests function
    afterEach(function(done) {
        // Clean the database
        Article.remove(function() {
            User.remove(function() {
                done();
            });
        });
    });
});
```

### Test Automation 自动化测试

```javascript
// Invoke 'strict' JavaScript mode
'use strict';

// Define the Grunt configuration method
module.exports = function(grunt) {
    // Initialize Grunt configuraiton
    grunt.initConfig({
        // Configure the grunt-env task
        env: {
            test: {
                NODE_ENV: 'test'
            },
            dev: {
                NODE_ENV: 'development'
            }
        },
        // Configure the grunt-nodemon task
        nodemon: {
            dev: {
                script: 'server.js',
                options: {
                    ext: 'js,html',
                    watch: ['server.js', 'config/**/*.js', 'app/**/*.js']
                }
            },
            debug: {
                script: 'server.js',
                options: {
                    nodeArgs: ['--debug'],
                    ext: 'js,html',
                    watch: ['server.js', 'config/**/*.js', 'app/**/*.js']
                }
            }
        },
        // Configure the grunt-mocha-test task
        mochaTest: {
            src: 'app/tests/**/*.js',
            options: {
                reporter: 'spec'
            }
        },
        // Configure the grunt-karma task
        karma: {
            unit: {
                configFile: 'karma.conf.js'
            }
        },
        // Configure the grunt-protractor-runner task
        protractor: {
            e2e: {
                options: {
                    configFile: 'protractor.conf.js'
                }
            }
        },
        // Configure the grunt-contrib-jshint task
        jshint: {
            all: {
                src: ['server.js', 'config/**/*.js', 'app/**/*.js', 'public/js/*.js', 'public/modules/**/*.js'],
                options: {
                    node: true,
                    predef: [
                        "define",
                        "require",
                        "exports",
                        "module",
                        "describe",
                        "before",
                        "beforeEach",
                        "after",
                        "afterEach",
                        "it",
                        "inject",
                        "expect"
                    ]
                }
            }
        },
        // Configure the grunt-contrib-csslint task
        csslint: {
            all: {
                src: 'public/modules/**/*.css'
            }
        },
        // Configure the grunt-contrib-watch task
        watch: {
            js: {
                files: ['server.js', 'config/**/*.js', 'app/**/*.js', 'public/js/*.js', 'public/modules/**/*.js'],
                tasks: ['jshint']
            },
            css: {
                files: 'public/modules/**/*.css',
                tasks: ['csslint']
            }
        },
        // Configure the grunt-concurrent task
        concurrent: {
            dev: {
                tasks: ['nodemon', 'watch'],
                options: {
                    logConcurrentOutput: true
                }
            },
            debug: {
                tasks: ['nodemon:debug', 'watch', 'node-inspector'],
                options: {
                    logConcurrentOutput: true
                }
            }
        },
        // Configure the grunt-node-inspector task
        'node-inspector': {
            debug: {}
        }
    });

    // Load the external Grunt tasks
    grunt.loadNpmTasks('grunt-env');
    grunt.loadNpmTasks('grunt-nodemon');
    grunt.loadNpmTasks('grunt-mocha-test');
    grunt.loadNpmTasks('grunt-karma');
    grunt.loadNpmTasks('grunt-protractor-runner');
    grunt.loadNpmTasks('grunt-contrib-jshint');
    grunt.loadNpmTasks('grunt-contrib-csslint');
    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.loadNpmTasks('grunt-concurrent');
    grunt.loadNpmTasks('grunt-node-inspector');

    // Create the 'default' Grunt task
    grunt.registerTask('default', ['env:dev', 'lint', 'concurrent:dev']);

    // Create the 'debug' Grunt task
    grunt.registerTask('debug', ['env:dev', 'lint', 'concurrent:debug']);

    // Create the 'test' Grunt task
    grunt.registerTask('test', ['env:test', 'mochaTest', 'karma', 'protractor']);

    // Create the 'lint' Grunt task
    grunt.registerTask('lint', ['jshint', 'csslint']);
};
```