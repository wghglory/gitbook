# 前后端通信

## 同源策略和限制

源：协议、域名、端口

限制：不是一个源的文档没有权利去操作另一个源的文档，包括 cookie, localStorage, indexDB, DOM 无法获取, Ajax 无法发送

## 前后端通信方式

* Ajax 同源限制
* websocket 不受限制，因为请求头中加入了 Origin
* CORS 支持同源和非同源

## 创建 Ajax 要点

XMLHttpRequest 对象的工作流程、兼容性、事件触发条件和顺序

```javascript
/**
 * [json 实现 ajax 的json]
 * @param  {[type]} options [description]
 * @return {[type]}         [description]
 */
util.json = function(options) {
  var opt = {
    url: '',
    type: 'get',
    data: {},
    success: function() {},
    error: function() {}
  };
  util.extend(opt, options);
  if (opt.url) {
    var xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');
    var data = opt.data,
      url = opt.url,
      type = opt.type.toUpperCase(),
      dataArr = [];
    for (var k in data) {
      dataArr.push(k + '=' + data[k]);
    }
    if (type === 'GET') {
      url = url + '?' + dataArr.join('&');
      xhr.open(type, url.replace(/\?$/g, ''), true);
      xhr.send();
    }
    if (type === 'POST') {
      xhr.open(type, url, true);
      xmlhttp.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
      xhr.send(dataArr.join('&'));
    }
    xhr.onload = function() {
      // 304 缓存中数据未变，206 video等大文件媒体资源成功
      if (xhr.status === 200 || xhr.status === 304) {
        var res;
        if (opt.success && opt.success instanceof Function) {
          res = xhr.responseText;
          if (typeof res === 'string') {
            res = JSON.parse(res);
            opt.success.call(xhr, res);
          }
        }
      } else {
        if (opt.error && opt.error instanceof Function) {
          opt.error.call(xhr, res);
        }
      }
    };
  }
};
```

## 跨域

* JSONP
* Hash(hash改变页面不刷新，?后面是search，改变会刷新页面)
* postMessage
* websocket
* CORS（支持跨域的变种ajax，当发送ajax跨域请求时，http 请求头加入 origin）

### JSONP

利用 script 标签可以不同源加载实现的。JSONP 只支持 GET 请求

1. 在主站客户端 window 全局注册一个函数cb
1. url 传递参数和回调函数名字
1. 服务端解析 url 后根据参数拿到数据，执行这个函数，数据作为函数的参数
1. 删除全局注册函数

#### JSONP 的优缺点

1. 优点
    * 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支持
    * 在请求完毕后可以通过调用 callback 的方式回传结果。将回调方法的权限给了调用方。这个就相当于将 controller 层和 view 层分开了。我提供的 JSONP 服务只提供纯服务的数据，至于提供服务以后的页面渲染和后续 view 操作都由调用者来自己定义就好了。如果有两个页面需要渲染同一份数据，你们只需要有不同的渲染逻辑就可以了，逻辑都可以使用同一个 JSONP 服务。

1. 缺点
    * 它只支持 GET 请求而不支持 POST 等其它类型的HTTP请求
    * JSONP 在调用失败的时候不会返回各种 HTTP 状态码。
    * 安全性。万一假如提供 JSONP 的服务存在页面注入漏洞，即它返回的 javascript 的内容被人控制的。那么所有调用这个 JSONP 的网站都会存在漏洞。于是无法把危险控制在一个域名下。所以在使用 JSONP 的时候必须要保证使用的 JSONP 服务必须是安全可信的。

JSONP.html 页面定义一个函数，然后在远程 remote.js 中传入数据进行调用。

```html
<!DOCTYPE>
<html>
<head>
    <script>
    var localHandler = function(data){
        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };
    </script>
    <script src="http://remoteserver.com/remote.js"></script>
</head>
<body>
</body>
</html>
```

remote.js文件代码如下：

```javascript
localHandler({"result":"我是远程js带来的数据"});
```

但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是 JSONP 的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？

只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端 "我想要一段调用 XXX 函数的js代码，请你返回给我"，于是服务器就可以按照客户端的需求来生成js脚本并响应了。

看JSONP.html页面的代码：

```html
<!DOCTYPE>
<html>
<head>
    <script>
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function(data){
        alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
    };

    // 提供 JSONP 服务的 url 地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&callback=flightHandler";

    // 创建 script 标签，设置其属性
    var script = document.createElement('script');
    script.setAttribute('src', url);

    // 把 script 标签加入 head，此时调用开始
    document.getElementsByTagName('head')[0].appendChild(script);
    </script>
</head>
<body>
</body>
</html>
```

不再直接把远程js文件写死，而是编码实现动态查询，而这也正是JSONP客户端实现的核心部分。我们看到调用的 url 中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。

服务器读取 url 生成代码：

```javascript
flightHandler({
    "code": "CA1998",
    "price": 1780,
    "tickets": 5
});
```

jQuery 如何实现 JSONP 调用？

```html
<!DOCTYPE>
<html>
<head>
      <script src="jquery.min.js"></script>
      <script type="text/javascript">
      $(document).ready(function(){
        $.ajax({
             type: "get",
             async: false,
             url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998",
             dataType: "jsonp",
             jsonp: "callback",//传递给请求处理程序或页面的，用以获得JSONP回调函数名的参数名(一般默认为:callback)
             jsonpCallback:"flightHandler",//自定义的JSONP回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据
             success: function(json){
                 alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');
             },
             error: function(){
                 alert('fail');
             }
         });
     });
     </script>
     </head>
  <body>
  </body>
</html>
```

为什么我这次没有写 flightHandler 这个函数呢？而且竟然也运行成功了！jquery 在处理 JSONP 类型的 ajax 时（，虽然 jquery 也把 JSONP 归入了 ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供 success属性方法来调用。

```javascript
/**
  * [function 在页面中注入js脚本]
  * @param  {[type]} url     [description]
  * @param  {[type]} charset [description]
  * @return {[type]}         [description]
  */
util.createScript = function(url, charset) {
  var script = document.createElement('script');
  script.setAttribute('type', 'text/javascript');
  charset && script.setAttribute('charset', charset);
  script.setAttribute('src', url);
  script.async = true;
  return script;
};

/**
  * [function 获取一个随机的5位字符串]
  * @param  {[type]} prefix [description]
  * @return {[type]}        [description]
  */
util.getName = function(prefix) {
  return prefix + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);
};

/**
  * [function jsonp]
  * @param  {[type]} url      [description]
  * @param  {[type]} onsucess [description]
  * @param  {[type]} onerror  [description]
  * @param  {[type]} charset  [description]
  * @return {[type]}          [description]
  */
util.jsonp = function(url, onsuccess, onerror, charset) {
  var callbackName = util.getName('tt_player');
  window[callbackName] = function() {
    if (onsuccess && util.isFunction(onsuccess)) {
      onsuccess(arguments[0]);
    }
  };
  var script = util.createScript(url + '&callback=' + callbackName, charset);
  script.onload = script.onreadystatechange = function() {
    if (!script.readyState || /loaded|complete/.test(script.readyState)) {
      script.onload = script.onreadystatechange = null;
      // 移除该script的 DOM 对象
      if (script.parentNode) {
        script.parentNode.removeChild(script);
      }
      // 删除函数或变量
      window[callbackName] = null;
    }
  };
  script.onerror = function() {
    if (onerror && util.isFunction(onerror)) {
      onerror();
    }
  };
  document.getElementsByTagName('head')[0].appendChild(script);
};
```

### Hash 原理

页面A 中通过 `iframe` 嵌入 B，需求是 A 给 B 发消息

1. 拿到 B 的 url
1. 改变 B 的 hash
1. B 中接受 onhashchange

```javascript
// 利用hash，场景是当前页面 A 通过 iframe 嵌入了跨域的页面 B
// 在A中伪代码如下：
var B = document.getElementsByTagName('iframe');
B.src = B.src + '#' + 'data';

// 在B中的伪代码如下
window.onhashchange = function () {
  var data = window.location.hash;
};
```

### Websocket

WebSocket是一种通信协议，使用 `ws://`（非加密）和 `wss://`（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。

```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
```

上面代码中，有一个字段是 Origin，表示该请求的请求源（origin），即发自哪个域名。正是因为有了Origin这个字段，所以 WebSocket 才没有实行同源政策。

1. `var ws = new WebSocket('wss://echo.websocket.org');`
1. `onopen, onmessage, onclose`

```javascript
// Websocket【参考资料】http://www.ruanyifeng.com/blog/2017/05/websocket.html
var ws = new WebSocket('wss://echo.websocket.org');

ws.onopen = function (evt) {
  console.log('Connection open ...');
  ws.send('Hello WebSockets!');
};

ws.onmessage = function (evt) {
  console.log('Received Message: ', evt.data);
  ws.close();
};

ws.onclose = function (evt) {
  console.log('Connection closed.');
};
```

### postMessage

窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息

```javascript
// A 中代码
window.postMessage('data', 'http://B.com');

// B中监听代码
window.addEventListener('message', function (event) {
    console.log(event.origin);
    console.log(event.source);
    console.log(event.data);
}, false);
```

这是一个安全的跨域通信方法，`postMessage(message,targetOrigin)`也是HTML5引入的特性。 可以给任何一个 window 发送消息，不论是否同源。第二个参数可以是`*`但如果你设置了一个 URL 但不相符，那么该事件不会被分发。看一个普通的使用方式吧：

```javascript
/*
 * In window A's scripts, with A being on <http://example.com:8080>:
 */

var popup = window.open(...popup details...);

// This does nothing, assuming the window hasn't changed its location.
popup.postMessage("The user is 'bob' and the password is 'secret'",
                  "https://secure.example.net");

// This will successfully queue a message to be sent to the popup, assuming
// the window hasn't changed its location.
popup.postMessage("hello there!", "http://example.com");

function receiveMessage(event)
{
  // Do we trust the sender of this message?  (might be
  // different from what we originally opened, for example).
  if (event.origin !== "http://example.com")
    return;

  // event.source is popup
  // event.data is "hi there yourself!  the secret response is: rheeeeet!"
}
window.addEventListener("message", receiveMessage, false);
```

```javascript
/*
 * In the popup's scripts, running on <http://example.com>:
 */

// Called sometime after postMessage is called
function receiveMessage(event)
{
  // Do we trust the sender of this message?
  if (event.origin !== "http://example.com:8080")
    return;

  // event.source is window.opener
  // event.data is "hello there!"

  // Assuming you've verified the origin of the received message (which
  // you must do in any case), a convenient idiom for replying to a
  // message is to call postMessage on event.source and provide
  // event.origin as the targetOrigin.
  event.source.postMessage("hi there yourself!  the secret response " +
                           "is: rheeeeet!",
                           event.origin);
}

window.addEventListener("message", receiveMessage, false);
```

### CORS 跨域资源共享

参考资料：

* <https://www.maxcdn.com/one/visual-glossary/cors/>
* <https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS>

CORS 就是为了让 AJAX 可以实现可控的跨域访问而生的。

1. 服务器设置 `Access-Control-Allow-Origin` HTTP 响应头之后，允许浏览器跨域请求。
1. 浏览器在头信息之中，增加一个 Origin 字段。Origin 字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。
1. 服务器根据这个值，决定是否同意这次请求。CORS 支持所有类型的 HTTP 请求

如果服务器同意，响应结果头：

```
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
```

#### Cookie, withCredentials 属性

**step 1**:

CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定 `Access-Control-Allow-Credentials` 字段。

```
Access-Control-Allow-Credentials: true
```

**step 2**:

另一方面，开发者必须在 AJAX 请求中打开 `withCredentials` 属性。

```javascript
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```

否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。

但是，如果省略 `withCredentials` 设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭 `withCredentials`。

```javascript
xhr.withCredentials = false;
```

> 需要注意的是，如果要发送Cookie，`Access-Control-Allow-Origin` 就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 `document.cookie` 也无法读取服务器域名下的 Cookie。

```javascript
// CORS 参考资料: http://www.ruanyifeng.com/blog/2016/04/cors.html

// url（必选），options（可选）
// 实现了 CORS 通信

fetch('/some/url/', {
    method: 'get',
    // 配置 CORS
}).then(function (response) {

}).catch(function (err) {
  // 出错了，等价于 then 的第二个参数，但这样更好用更直观
});
```

#### 为什么 fetch、CORS 会实现跨域通信？

ajax 跨域请求默认会被浏览器拦截，fetch、CORS 在请求头加入了 origin，服务器端设置了 Access-Control-Allow-Origin 发在源是允许就返回数据。