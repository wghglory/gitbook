# v8 将内存分为 新生代 和 老生代。

## 新生代

- 大多数对象
- 存活时间短
- 空间小
- 分为2块内存：使用状态（from 空间）和 闲置状态（to 空间）
- 采用 `Scavenge` 算法
- 新对象创建时使用 from 空间，当 from 空间满了后，存活对象复制到了 to 空间；不存活的消灭，完成一次 from 到 to 空间的转化。再次垃圾回收时执行上述操作。

当存活对象经历过一次 `Scavenge` 回收后或者 to 空间内存占用比超过25%，**对象晋升**：新生代拷贝到老生代。

## 老生代

* 存活时间长
* 老生代内存空间大，不能用 `Scavenge` 算法复制那么多空间里的对象
* 垃圾回收采用 `Mark-Sweep` 和 `Mark-Compact`

`Mark-Sweep`:

遍历所有对象，标记活着的对象。清楚阶段只清楚没被标记的少数死活对象，效率高

但有一个缺点，就是对象清除后内存不连续，内存碎片。

`Mark-Compact`:

为了解决上述内存碎片。将活的对象在内存区域进行移动，清理掉边界外的内存。因为涉及到对象移动，所以效率很低，但好处就是保证了不会有碎片。

> 因为效率低，v8 不会在每次 Mark-Sweep 后就执行 Mark-Compact，而是当新生代对象晋升时发现碎片空间不够用后才进行 Mark-Compact。

### 三种回收策略比较

回收策略 | 速度  | 空间、碎片 | 是否移动对象
--|--|--|--
Scavenge  |  速度快 |  双倍空间无碎片 |  不移动对象
Mark-Sweep  | 中速  | 有碎片  |  不移动对象
Mark-Compact  | 最慢  | 无碎片  |  移动对象

### 垃圾回收引起的性能问题

垃圾回收的三种算法都会停止应用逻辑，待垃圾回收完成后再恢复执行应用逻辑，这个现象叫做**全停顿**！为了避免它：

1. 限制内存大小：新生代64位系统 32M, 老生代64位 1400M
1. 增量式垃圾回收：不要一口气回收，回收一会执行一会应用逻辑再回收。增量标记、延迟清除、增量式整理。