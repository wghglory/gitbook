# 渲染机制

## doctype

DTD (document type definition，文档类型定义) 告诉浏览器文档类型，浏览器再决定用什么引擎解析渲染他

doctype 告诉浏览器 当前DTD（当前使用的文档类型）

常见的 doctype 类型：

* html5：<!DOCTYPE>
* html4.01 strict：不包括废弃标签如 font
* html4.01 transitional 过渡版本

## 浏览器渲染过程

1. 首先，解析 HTML Source，构建 DOM Tree
1. 同时，解析 CSS Style，构建 CSSOM Tree
1. 然后，组合 DOM Tree 与 CSSOM Tree，去除不可见元素，构建 Render Tree
1. 再执行 Reflow，根据 Render Tree 计算每个可见元素的布局（几何属性）
1. 最后，执行 Repaint，通过绘制流程，将每个像素渲染到屏幕上。

在第三步，==在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。==

> 所以，css 解析顺序: 从右到左进行查找。如果从左到右的顺序，那么每条选择器都需要遍历整个DOM树，性能很受影响。所谓高效的 CSS 就是让浏览器在查找 style 匹配的元素的时候尽量进行少的查找, 所以选择器最好写的简洁一点。

![渲染机制](http://om1o84p1p.bkt.clouddn.com/1503820272.png?imageMogr2/thumbnail/!70p)

![DOM tree](http://om1o84p1p.bkt.clouddn.com/1503820311.png?imageMogr2/thumbnail/!70p)

![CSSOM tree](http://om1o84p1p.bkt.clouddn.com/1503820343.png?imageMogr2/thumbnail/!70p)

![Render tree](http://om1o84p1p.bkt.clouddn.com/1503820367.png?imageMogr2/thumbnail/!70p)

![Layout](http://om1o84p1p.bkt.clouddn.com/1503820395.png?imageMogr2/thumbnail/!70p)

Layout 告诉 render tree 每个元素位置，宽高等信息。

### 重排 reflow

页面字体大小改变或者元素移动位置等，浏览器需要重新计算每个元素盒子模型的位置。这个过程叫 reflow。回炉（重新塑形）。举个例子，页面上节点是以树的形式展现的。假如我使用 JavaScript 砍掉一个节点，这棵树为了不脱节，肯定要重新梳理一遍，将砍掉的那个断点重新结合起来又形成一颗完整的树，而这个结合梳理过程就是这里的 reflow，所谓回流，就是由于某些原因（如修改），要将元素回过头来重新“流”一遍

**触发 reflow**:

1. 增删改 DOM 结点
1. 移动DOM 位置，动画
1. css 样式 display, height等改变
1. resize scroll 有可能
1. 修改网页字体（不要这样做，性能问题）
1. 特殊：offset、scroll、clientX、getComputedStyle、currentStyle：

由于浏览器在处理批量修改页面元素样式时，会将批量操作缓存起来，然后再做一次 reflow 过程（异步 reflow），避免每次操作都执行 reflow 消耗资源。但是如果在某个上述特殊操作之后立马调用了以上执行属性，为了等够得到最新的样式，会检查缓存的操作，是否需要 reflow，这样就 flush 出最新的样式。

**如何减少 reflow**？

1. 不轻易增删改DOM，不要修改网页字体，不轻易移动DOM 等。
1. 减少不必要的DOM深度。改变DOM节点树上任何一个层级都会影响从根结点一直到修改的子节点。
1. 精简css，去除没有用处的css
1. 如果你想让复杂的表现发生改变，例如动画效果，那么请在这个流动线之外实现它。使用position-absolute 或 position-fixed来实现它。
1. 避免不必要的复杂的css选择符，尤其是使用子选择器，或消耗更多的CPU去做选择器匹配。
1. 减少样式的重新计算，即减少 offset、scroll、client*、getComputedStyle、currentStyle 的使用，因为每次调用都会刷新操作缓冲区，执行 reflow & repaint。
1. 避免 `window.onresize`

### 重绘 repaint

repaint happens when you change the look of an element without changing the size and shape. This doesn't cause reflow as geometry of the element didn't changed.

触发 repaint：

* change background color
* change text color
* visibility hidden

DOM 改变，如添加了新元素，reflow repaint 都发生。

如何尽量减少repaint频率：减少页面颜色改变。最后一次性添加结点，而不要每次操作 DOM 都立马修改DOM。

### 注意

> Render Tree 只包含渲染网页所需要的节点
> Reflow 过程是布局计算每个对象的精确位置和大小
> Repaint 过程则是将 Render Tree 的每个像素渲染到屏幕上。

## 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？(重要)

从URL规范、HTTP协议、DNS、CDN、数据库查询、到浏览器流式解析、CSS规则构建、layout、repaint、onload/DOMContentLoaded、JS执行、JS API绑定等等

1. 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;
1. 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;
1. 通过 DNS 解析获取网址的 IP 地址，设置 UA 等信息发出第二个GET请求;
1. 进行 HTTP 协议会话，客户端发送报头(请求报头);
1. 进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;
1. 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;
1. 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;
1. 浏览器开始下载 html文档(响应报头，状态码200)，同时使用缓存;
1. 文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js），同时设置了 cookie;
1. 页面开始渲染DOM（这里继续说），JS 根据 DOM API 操作 DOM，执行事件绑定等，页面显示完成。

### 参考

<https://segmentfault.com/a/1190000008849210>