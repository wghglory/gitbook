# 渲染机制

## doctype

DTD (document type defination，文档类型定义) 告诉浏览器文档类型，浏览器再决定用什么引擎解析渲染他

doctype 告诉浏览器 当前DTD（当前使用的文档类型）

常见的doctype类型：

* html5：<!DOCTYPE>
* html4.01 strict：不包括废弃标签如 font
* html4.01 transitional 过渡版本

## 浏览器渲染过程，浏览器输入url后发生了什么

1. 首先，解析 HTML Source，构建 DOM Tree；
2. 同时，解析 CSS Style，构建 CSSOM Tree；
3. 然后，组合 DOM Tree 与 CSSOM Tree，去除不可见元素，构建 Render Tree；
4. 再执行 Reflow，根据 Render Tree 计算每个可见元素的布局（几何属性）；
5. 最后，执行 Repaint，通过绘制流程，将每个像素渲染到屏幕上。

在第三步，==在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。==

> 所以，css 解析顺序: 从右到左进行查找。如果从左到右的顺序，那么每条选择器都需要遍历整个DOM树，性能很受影响。所谓高效的CSS就是让浏览器在查找style匹配的元素的时候尽量进行少的查找, 所以选择器最好写的简洁一点。

![渲染机制](http://om1o84p1p.bkt.clouddn.com/1503820272.png?imageMogr2/thumbnail/!70p)

![DOM tree](http://om1o84p1p.bkt.clouddn.com/1503820311.png?imageMogr2/thumbnail/!70p)

![CSSOM tree](http://om1o84p1p.bkt.clouddn.com/1503820343.png?imageMogr2/thumbnail/!70p)

![Render tree](http://om1o84p1p.bkt.clouddn.com/1503820367.png?imageMogr2/thumbnail/!70p)

![Layout](http://om1o84p1p.bkt.clouddn.com/1503820395.png?imageMogr2/thumbnail/!70p)

Layout 告诉 render tree 每个元素位置，宽高等信息。

### 重排 reflow

浏览器计算每个元素盒子模型的位置。这个过程叫reflow。回炉（重新塑形）。举个例子，页面上节点是以树的形式展现的。假如我使用JavaScript砍掉一个节点，这棵树为了不脱节，肯定要重新梳理一遍，将砍掉的那个断点重新结合起来又形成一颗完整的树，而这个结合梳理过程就是这里的reflow，所谓回流，就是由于某些原因（如修改），要将元素回过头来重新“流”一遍

**触发 reflow：**

1. 增删改 DOM 结点
1. 移动DOM 位置，动画
1. css 样式 display, height等改变
1. resize scroll 有可能
1. 修改网页字体（不要这样做，性能问题）
1. 特殊：offset、scroll、client*、getComputedStyle、currentStyle：

由于浏览器在处理批量修改页面元素样式时，会将批量操作缓存起来，然后再做一次 reflow 过程（异步 reflow），避免每次操作都执行 reflow 消耗资源。但是如果在某个上述特殊操作之后立马调用了以上执行属性，为了等够得到最新的样式，会检查缓存的操作，是否需要 reflow，这样就 flush 出最新的样式。


**如何减少 reflow？**

1. 不轻易增删改DOM，不要修改网页字体，不轻易移动DOM 等。
1. 减少不必要的DOM深度。改变DOM节点树上任何一个层级都会影响从根结点一直到修改的子节点。
1. 精简css，去除没有用处的css
1. 如果你想让复杂的表现发生改变，例如动画效果，那么请在这个流动线之外实现它。使用position-absolute或position-fixed来实现它。
1. 避免不必要的复杂的css选择符，尤其是使用子选择器，或消耗更多的CPU去做选择器匹配。
1. 减少样式的重新计算，即减少 offset、scroll、client*、getComputedStyle、currentStyle 的使用，因为每次调用都会刷新操作缓冲区，执行 reflow & repaint。

### 重绘 repaint

浏览器根据盒子位置、大小等属性把元素画出来。

触发 repaint：

1. DOM 改动
1. Css 改动

如何尽量减少repaint频率：最后一次性添加结点，而不要每次操作 DOM 都立马修改DOM。

### 注意

> Render Tree 只包含渲染网页所需要的节点；
> Reflow 过程是布局计算每个对象的精确位置和大小；
> Repaint 过程则是将 Render Tree 的每个像素渲染到屏幕上。

#### 参考

<https://segmentfault.com/a/1190000008849210>

