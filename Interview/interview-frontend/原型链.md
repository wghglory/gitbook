## 总结

```
new 构造函数 --> 实例对象
实例对象.__proto__ === 原型对象 == 构造函数.prototype
原型对象.constructor === 构造函数
```

![原型链](http://om1o84p1p.bkt.clouddn.com/1503746533.png?imageMogr2/thumbnail/!70p)

### 创建对象方法

```javascript
// method 1：原型链默认指向object
let o1 = { name: 'hello' }       // Object { name : 'hello' }
let o11 = new Object({ name: 'heelow' })   // Object { name: 'hellow' }

// method 2：构造函数
let F = function(x){ this.name = x }
let o2 = new F('wang')    // F { name: 'wang' }

F.prototype.say = function(){ console.log('COMMON METHOD') }
o2.say()

// method 3：Object.create
var p = {name: 'hello'}
let o3 = Object.create(p)    // Object { }
o3.name === 'hello'   // true, 其实是o3本身没有name，是通过原型链找到p,拿到了name。即o3.__proto__ === p
```

#### 原型

构造函数.prototype 就是原型对象。

#### 构造函数

```javascript
F.prototype.constructor === F  // true. F是构造函数，构造函数的prototype是原型对象，这里为Object{constructor: function, __proto__: Object}，原型对象中constructor指向了构造函数
```

#### 实例

```javascript
o2.__proto__ === F.prototype // 实例的__proto__ 指向构造函数的prototype,即原型对象。
```

#### 原型链

实例通过 `__proto__` 向上找到对应的原型对象，原型对象还有上一级原型对象，一直到`Object.prototype`顶端停止。
一些公用的方法不要放在构造函数中，因为那样实例化后每个实例都在内存中拷贝了一份。公共的方法和属性放在原型对象上。实例都可以通过原型链找到原型对象，原型对象上的方法被所有实例所共有。先找自己实力内部，没找到找最近一层原型对象，没找到的话一层一层向上查找。如果都没找到，原路返回告诉他没找到。如果中间找到了就不再向上查找

#### instandOf原理

简单说判断实例是不是由某个构造函数创建的。具体说是 `判断实例.__proto__` 和 `构造函数.prototype` (原型对象)是不是同一个引用。但注意，A 继承 B，a由A实例化创建，`a instanceOf A,B,Object` 都对，只要在原型链上级都算。这样的话就不能精确判断 a 到底是 A 还是 B 直接生成的。

这时候用 constructor 更加严谨

```javascript
a.__proto__.constructor === A   //true    原型的constructor 指向 构造函数 A
a.__proto__.constructor === Object   //false
```

![instanceOf](http://om1o84p1p.bkt.clouddn.com/1503746406.png?imageMogr2/thumbnail/!70p)

#### new 原理

- step 1: 一个新空对象创建，继承自原型对象 (`构造函数.prototype`)
- step 2: 构造函数执行，执行时参数传入，上下文 this 指向新对象
- step 3: 看构造函数结果，如果返回对象，则前两步白忙活直接返回这个对象，如果不返回对象，则返回1中的新对象

```javascript
// func 是构造函数
var newSimulate = function(func) {
  var o = Object.create(func.prototype);  //step1 新对象继承自原型对象
  var temp = func.call(o);                //step2 构造函数执行，修改this指向
  
  if (typeof temp === 'object') {         //step3 判断构造函数返回结果
    return temp;
  } else {
    return o;
  }
};
```