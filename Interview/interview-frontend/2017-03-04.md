# 前端开发知识点

(https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md)

    HTML&CSS：
        对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、
        HTML5、CSS3、Flexbox

    JavaScript：
        数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、
        DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs

    其他：
        移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力

## HTML

### HTML5的离线储存怎么使用，工作原理能不能解释一下？

在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。
原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。
离线的情况下，浏览器就直接使用离线存储的资源。

##### 如何使用：
1. 页面头部像下面一样加入一个manifest的属性: <html manifest="cache.manifest">
2. 在cache.manifest文件的编写离线存储的资源；
   CACHE MANIFEST
   #v0.11
   CACHE:
   js/app.js
   css/style.css
   NETWORK:
   resourse/logo.png
   FALLBACK:
   / /offline.html
3. 在离线状态时，操作window.applicationCache进行需求实现。

##### 自动化工具: (http://yanhaijing.com/html/2014/12/28/html5-manifest/)

manifest文件中的cache部分不能使用通配符，必须手动指定，这实在太让人不可理解，文件一多，就成了体力活了，这里介绍的 grunt-manifest能自动生成manifest文件的目的。grunt-manifest依赖grunt

如下的命令可以安装grunt-manifest，并加入到依赖文件。

```bash
npm install grunt-manifest --save-dev
```

如下的代码，可以在grunt中载入grunt-manifest，然后便可使用。

```bash
grunt.loadNpmTasks('grunt-manifest');
```

使用grunt-manifest的一个典型的配置文件如下所示：

```Javascript
grunt.initConfig({
  manifest: {
    generate: {
      options: {
        basePath: "../",
        cache: ["js/app.js", "css/style.css"]
        network: ["http://*", "https://*"],
        fallback: ["/ /offline.html"],
        exclude: ["js/jquery.min.js"],
        preferOnline: true,
        verbose: true,
        timestamp: true
      },
      src: [
            "some_files/*.html",
          "js/*.min.js",
          "css/*.css"
      ],
      dest: "index.manifest"
    }
  }
});
```

其中options定义生成manifest的一些自定义参数，src是要生成的文件，dest是输出文件。

options下有很多参数，主要参数如下：

* basePath 设置出入文件的根目录
* cache 手动添加缓存文件
* network 手动添加网络文件
* fallback 手动添加后备文件
* exclude 设置不添加到cache的文件
* verbose 是否添加版权信息
* timestamp	是否添加时间戳
* 这里有basejs的配置文件和生成的manifest文件的例子。


### 如何实现浏览器内多个标签页之间的通信? (阿里)

WebSocket、SharedWorker；
也可以调用localstorge、cookies等本地存储方式；

localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，
我们通过监听事件，控制它的值来进行页面信息通信；
注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；

### webSocket如何兼容低浏览器？(阿里)

Adobe Flash Socket 、
ActiveX HTMLFile (IE) 、
基于 multipart 编码发送 XHR 、
基于长轮询的 XHR

### 页面可见性（Page Visibility API） 可以有哪些用途？

通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;
在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；

## CSS

### 如何居中div？

<http://blog.jobbole.com/46574/>

水平居中：给div设置一个宽度，然后添加margin:0 auto属性

```css
div{
    width:200px;
    margin:0 auto;
}
```

让绝对定位的div居中

```css
div {
    position: absolute;
    width: 300px;
    height: 300px;
    margin: auto;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    background-color: pink; /* 方便看效果 */
}
```

水平垂直居中一: 负margin 一半。确定容器的宽高 宽500 高 300 的层, 设置层的外边距

```css
div {
    position: absolute
    width: 500px;
    height: 300px;
    top: 50%;
    left: 50%;
    margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */
}
```

水平垂直居中二: 未知容器的宽高，利用`transform`属性

```css
div {
    position: absolute;     /* 相对定位或绝对定位均可 */
    width:500px;
    height:300px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: pink;     /* 方便看效果 */
}
```

水平垂直居中三: 利用flex布局, 实际使用时应考虑兼容性

```css
.container {
    display: flex;
    align-items: center;        /* 垂直居中 */
    justify-content: center;    /* 水平居中 */
}
.container div {
    width: 100px;
    height: 100px;
    background-color: pink;     /* 方便看效果 */
}
```

## Javascript

### 说几条写JavaScript的基本规范？

1.不要在同一行声明多个变量。
2.请使用===/!==来比较true/false或者数值
3.使用对象字面量替代new Array这种形式
4.不要使用全局函数。
5.Switch语句必须带有default分支
6.函数不应该有时候有返回值，有时候没有返回值。
7.For循环必须使用大括号
8.If语句必须使用大括号
9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。

### JavaScript原型，原型链 ? 有什么特点？

每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。

关系：instance.constructor.prototype = instance.__proto__

特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性，如果没有的话，就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到Object内建对象。

### Javascript如何实现继承？

构造继承、原型继承、实例继承、拷贝继承

原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。

```javascript
function Parent(){
    this.name = 'wang';
}

function Child(){
    this.age = 28;
}
Child.prototype = new Parent();//继承了Parent，通过原型

var demo = new Child();
alert(demo.age);
alert(demo.name);//得到被继承的属性
```

### javascript创建对象的几种方式？

使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。


1. 对象字面量的方式

    ```Javascript
    var person = {
        firstname: "Mark",
        lastname: "Yun"
    };
```

2. 用function来模拟无参的构造函数

    ```Javascript
    function Person() {}
    var person = new Person(); //定义一个function，如果使用new"实例化",该function可以看作是一个Class
    person.name = "Mark";
    person.age = "25";
    person.work = function() {
        alert(person.name + " hello...");
    }
    person.work();
    ```

3. 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）

    ```Javascript
    function Pet(name, age, hobby) {
        this.name = name; //this作用域：当前对象
        this.age = age;
        this.hobby = hobby;
        this.eat = function() {
            alert("我叫" + this.name + ",我喜欢" + this.hobby + ",是个程序员");
        }
    }
    var maidou = new Pet("麦兜", 25, "coding"); //实例化、创建对象
    maidou.eat(); //调用eat方法
    ```

4. 用工厂方式来创建（内置对象）

    ```Javascript
    var wcDog = new Object();
    wcDog.name = "旺财";
    wcDog.age = 3;
    wcDog.work = function() {
        alert("我是" + wcDog.name + ",汪汪汪......");
    }
    wcDog.work();
    ```



5. 用原型方式来创建

    ```Javascript
    function Dog() {}
    Dog.prototype.name = "旺财";
    Dog.prototype.eat = function() {
        alert(this.name + "是个吃货");
    }
    var wangcai = new Dog();
    wangcai.eat();
    ```

6. 用混合方式来创建

    ```Javascript
    function Car(name, price) {
        this.name = name;
        this.price = price;
    }
    Car.prototype.sell = function() {
        alert("我是" + this.name + "，我现在卖" + this.price + "万元");
    }
    var camry = new Car("凯美瑞", 27);
    camry.sell();
    ```

### 如何解决跨域问题?

jsonp、iframe、window.name、window.postMessage、服务器上设置代理页面


## 你有用过哪些前端性能优化的方法？

1. 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。

2. 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数

3. 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。

4. 当需要设置的样式很多时设置className而不是直接操作style。

5. 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。

6. 图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳。

7. 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。

对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。


### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；

详细版：

1. 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;
2. 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;
3. 通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;
4. 进行HTTP协议会话，客户端发送报头(请求报头);
5. 进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;
6. 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;
7. 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;
8. 浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;
9. 文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;
10. 页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。

### 前端需要注意哪些SEO

* 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可
* 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页
* 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
* 重要内容不要用js输出：爬虫不会执行js获取内容
* 少用iframe：搜索引擎不会抓取iframe中的内容
* 非装饰性图片必须加alt
* 提高网站速度：网站速度是搜索引擎排序的一个重要指标

### 如何进行网站性能优化

* content方面

    1. 减少HTTP请求：合并文件、CSS精灵
    2. 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询
    3. 避免重定向：多余的中间访问
    4. 使Ajax可缓存
    5. 非必须组件延迟加载
    6. 未来所需组件预加载
    7. 减少DOM元素数量
    8. 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
    9. 减少iframe数量
    10. 页面静态化
    11. 使用缓存

* Server方面
    1. 使用CDN
    2. 添加Expires或者Cache-Control响应头
    3. 对组件使用Gzip压缩
    4. 配置ETag
    5. Flush Buffer Early
    6. Ajax使用GET进行请求
    7. 避免空src的img标签

* Cookie方面
    1. 减小cookie大小
    2. 引入资源的域名不要包含cookie

* css方面

    1. 将样式表放到页面顶部
    2. 不使用CSS表达式
    3. 使用不使用@import
    4. 不使用IE的Filter

* Javascript方面

    1. 将脚本放到页面底部
    2. 将javascript和css从外部引入
    3. 压缩javascript和css
    4. 删除不需要的脚本
    5. 减少DOM访问
    6. 合理设计事件监听器

* 图片方面

    1. 优化图片：根据实际颜色需要选择色深、压缩
    2. 优化css精灵
    3. 不要在HTML中拉伸图片
    4. 保证favicon.ico小并且可缓存

* 移动方面

    1. 保证组件小于25k
    2. Pack Components into a Multipart Document



### Singleton object

```Javascript
var Singleton = (function () {
    var instance;

    function createInstance() {
        var object = new Object("I am the instance");
        return object;
    }

    return {
        getInstance: function () {
            if (!instance) {
                instance = createInstance();
            }
            return instance;
        }
    };
})();

function run() {
    var instance1 = Singleton.getInstance();
    var instance2 = Singleton.getInstance();

    alert("Same instance? " + (instance1 === instance2));
}

```

### test

```javascript
// Load the test dependencies
var app = require('../../server'),
    request = require('supertest'),
    should = require('should'),
    mongoose = require('mongoose'),
    User = mongoose.model('User'),
    Article = mongoose.model('Article');

// Define global test variables
var user, article;

// Create an 'Articles' controller test suite
describe('Article Controller Unit Tests:', function() {
    // Define a pre-tests function
    beforeEach(function(done) {
        // Create a new 'User' model instance
        user = new User({
            firstName: 'Full',
            lastName: 'Name',
            displayName: 'Full Name',
            email: 'test@test.com',
            username: 'username',
            password: 'password'
        });

        // Save the new 'User' model instance
        user.save(function() {
            article = new Article({
                title: 'Article Title',
                content: 'Article Content',
                user: user
            });

            article.save(function(err) {
                done();
            });
        });
    });

    // Test the 'Article' GET methods
    describe('Testing the GET methods', function() {
        it('Should be able to get the list of articles', function(done) {
            // Create a SuperTest request
            request(app).get('/api/articles/')
                .set('Accept', 'application/json')
                .expect('Content-Type', /json/)
                .expect(200)
                .end(function(err, res) {
                    // res.body.should.have.lengthOf(1).and.be.an.Array;  //should.js
                    res.body.should.be.an.instanceof(Array).and.have.lengthOf(1); // should.js
                    // res.body.should.be.an.Array.and.have.lengthOf(1);  // this doesn't work in late should.js since Array cannot chain
                    res.body[0].should.have.property('title', article.title); // here is should.js
                    res.body[0].should.have.property('content', article.content); // here is should.js

                    done();
                });
        });

        it('Should be able to get the specific article', function(done) {
            // Create a SuperTest request
            request(app).get('/api/articles/' + article.id)
                .set('Accept', 'application/json')
                .expect('Content-Type', /json/)
                .expect(200)
                .end(function(err, res) {
                    // res.body.should.be.an.Object.and.have.property('title', article.title); // here is should.js
                    // res.body.should.have.property('content', article.content); // here is should.js

                    done();
                });
        });
    });

    // Define a post-tests function
    afterEach(function(done) {
        // Clean the database
        Article.remove(function() {
            User.remove(function() {
                done();
            });
        });
    });
});
```

### Test Automation

```javascript
// Invoke 'strict' JavaScript mode
'use strict';

// Define the Grunt configuration method
module.exports = function(grunt) {
    // Initialize Grunt configuraiton
    grunt.initConfig({
        // Configure the grunt-env task
        env: {
            test: {
                NODE_ENV: 'test'
            },
            dev: {
                NODE_ENV: 'development'
            }
        },
        // Configure the grunt-nodemon task
        nodemon: {
            dev: {
                script: 'server.js',
                options: {
                    ext: 'js,html',
                    watch: ['server.js', 'config/**/*.js', 'app/**/*.js']
                }
            },
            debug: {
                script: 'server.js',
                options: {
                    nodeArgs: ['--debug'],
                    ext: 'js,html',
                    watch: ['server.js', 'config/**/*.js', 'app/**/*.js']
                }
            }
        },
        // Configure the grunt-mocha-test task
        mochaTest: {
            src: 'app/tests/**/*.js',
            options: {
                reporter: 'spec'
            }
        },
        // Configure the grunt-karma task
        karma: {
            unit: {
                configFile: 'karma.conf.js'
            }
        },
        // Configure the grunt-protractor-runner task
        protractor: {
            e2e: {
                options: {
                    configFile: 'protractor.conf.js'
                }
            }
        },
        // Configure the grunt-contrib-jshint task
        jshint: {
            all: {
                src: ['server.js', 'config/**/*.js', 'app/**/*.js', 'public/js/*.js', 'public/modules/**/*.js'],
                options: {
                    node: true,
                    predef: [
                        "define",
                        "require",
                        "exports",
                        "module",
                        "describe",
                        "before",
                        "beforeEach",
                        "after",
                        "afterEach",
                        "it",
                        "inject",
                        "expect"
                    ]
                }
            }
        },
        // Configure the grunt-contrib-csslint task
        csslint: {
            all: {
                src: 'public/modules/**/*.css'
            }
        },
        // Configure the grunt-contrib-watch task
        watch: {
            js: {
                files: ['server.js', 'config/**/*.js', 'app/**/*.js', 'public/js/*.js', 'public/modules/**/*.js'],
                tasks: ['jshint']
            },
            css: {
                files: 'public/modules/**/*.css',
                tasks: ['csslint']
            }
        },
        // Configure the grunt-concurrent task
        concurrent: {
            dev: {
                tasks: ['nodemon', 'watch'],
                options: {
                    logConcurrentOutput: true
                }
            },
            debug: {
                tasks: ['nodemon:debug', 'watch', 'node-inspector'],
                options: {
                    logConcurrentOutput: true
                }
            }
        },
        // Configure the grunt-node-inspector task
        'node-inspector': {
            debug: {}
        }
    });

    // Load the external Grunt tasks
    grunt.loadNpmTasks('grunt-env');
    grunt.loadNpmTasks('grunt-nodemon');
    grunt.loadNpmTasks('grunt-mocha-test');
    grunt.loadNpmTasks('grunt-karma');
    grunt.loadNpmTasks('grunt-protractor-runner');
    grunt.loadNpmTasks('grunt-contrib-jshint');
    grunt.loadNpmTasks('grunt-contrib-csslint');
    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.loadNpmTasks('grunt-concurrent');
    grunt.loadNpmTasks('grunt-node-inspector');

    // Create the 'default' Grunt task
    grunt.registerTask('default', ['env:dev', 'lint', 'concurrent:dev']);

    // Create the 'debug' Grunt task
    grunt.registerTask('debug', ['env:dev', 'lint', 'concurrent:debug']);

    // Create the 'test' Grunt task
    grunt.registerTask('test', ['env:test', 'mochaTest', 'karma', 'protractor']);

    // Create the 'lint' Grunt task
    grunt.registerTask('lint', ['jshint', 'csslint']);
};
```


