# 常见跨域方法

这些跨域通信的方法大致可以分为两类：

- 一类是Hack，比如通过`title`, `navigation`等对象传递信息，JSONP可以说是一个最优秀的Hack。
- 另一类是HTML5支持，一个是`Access-Control-Allow-Origin`响应头，一个是`window.postMessage`。

### JSONP

- 原理：`<script>`是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数。
- 限制：需要创建一个DOM对象并且添加到DOM树，只能用于GET方法

JSONP利用的是`<script>`可以跨域的特性，跨域URL返回的脚本不仅包含数据，还包含一个回调：

```javascript
// URL: http://b.a.com/foo
var data = {
    foo: 'bar',
    bar: 'foo'
};
callback(data);
```

> 该例子只用于示例，实际情况应当考虑名称隐藏等问题。

然后在我们在主站`http://a.com`中，可以这样来跨域获取`http://b.a.com`的数据：

```javascript
// URL: http://a.com/foo
var callback = function(data){
    // 处理跨域请求得到的数据
};
var script = $('<script>', {src: 'http://b.a.com/bar'});
$('body').append(script);
```

其实jQuery已经封装了JSONP的使用，我们可以这样来：

```javascript
$.getJSON( "http://b.a.com/bar?callback=callback", function( data ){
    // 处理跨域请求得到的数据
});
```

`$.getJSON`与`$.get`的区别是前者会把`responseText`转换为JSON，而且当URL具有`callback`参数时， jQuery将会把它解释为一个JSONP请求，创建一个`<script>`标签来完成该请求。

> [jQuery.getJSON](http://api.jquery.com/jquery.getjson/): If the URL includes the string “callback=?” (or similar, as defined by the server-side API), the request is treated as JSONP instead. See the discussion of the jsonp data type in $.ajax() for more details.)

和所有依赖于创建HTML标签的方式一样，JSONP也不支持POST，而GET的数据是放在URL里的。 虽然[RFC 2616][rfc2610]没有提到限制到多少， 但提到了服务器可以对自己认为比较长的URL返回414状态码。一般来讲URL限长是在2000字符左右。

### 跨域资源共享（CORS）

- 原理：服务器设置`Access-Control-Allow-Origin`HTTP响应头之后，浏览器将会允许跨域请求
- 限制：浏览器需要支持HTML5，**可以支持POST，PUT等方法**

前面提到的跨域手段都是某种意义上的Hack， HTML5标准中提出的跨域资源共享（Cross Origin Resource Share，CORS）才是正道。 它支持其他的HTTP方法如PUT, POST等，可以从本质上解决跨域问题。

例如，从`http://a.com`要访问`http://b.com`的数据，通常情况下Chrome会因跨域请求而报错：

```
XMLHttpRequest cannot load http://b.com. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://a.com' is therefore not allowed access.
```

错误原因是被请求资源没有设置`Access-Control-Allow-Origin`，所以我们在`b.com`的服务器中设置这个响应头字段即可：

```java
Access-Control-Allow-Origin: *              # 允许所有域名访问，或者
Access-Control-Allow-Origin: http://a.com   # 只允许所有域名访问
```

为 `xhr` 设置 `withCredentials` 后 CORS 方法跨域还可 [携带Cookie](http://harttle.com/2016/12/28/cors-with-cookie.html)，但 PUT/POST 请求需要注意[处理 preflight 请求](http://harttle.com/2016/12/30/cors-preflight.html)。

### window.postMessage

- 原理：HTML5允许窗口之间发送消息
- 限制：浏览器需要支持HTML5，获取窗口句柄后才能相互通信

这是一个安全的跨域通信方法，`postMessage(message,targetOrigin)`也是HTML5引入的特性。 可以给任何一个window发送消息，不论是否同源。第二个参数可以是`*`但如果你设置了一个URL但不相符，那么该事件不会被分发。看一个普通的使用方式吧：

```javascript
/*
 * In window A's scripts, with A being on <http://example.com:8080>:
 */

var popup = window.open(...popup details...);

// This does nothing, assuming the window hasn't changed its location.
popup.postMessage("The user is 'bob' and the password is 'secret'",
                  "https://secure.example.net");

// This will successfully queue a message to be sent to the popup, assuming
// the window hasn't changed its location.
popup.postMessage("hello there!", "http://example.com");

function receiveMessage(event)
{
  // Do we trust the sender of this message?  (might be
  // different from what we originally opened, for example).
  if (event.origin !== "http://example.com")
    return;

  // event.source is popup
  // event.data is "hi there yourself!  the secret response is: rheeeeet!"
}
window.addEventListener("message", receiveMessage, false);
```

```javascript
/*
 * In the popup's scripts, running on <http://example.com>:
 */

// Called sometime after postMessage is called
function receiveMessage(event)
{
  // Do we trust the sender of this message?
  if (event.origin !== "http://example.com:8080")
    return;

  // event.source is window.opener
  // event.data is "hello there!"

  // Assuming you've verified the origin of the received message (which
  // you must do in any case), a convenient idiom for replying to a
  // message is to call postMessage on event.source and provide
  // event.origin as the targetOrigin.
  event.source.postMessage("hi there yourself!  the secret response " +
                           "is: rheeeeet!",
                           event.origin);
}

window.addEventListener("message", receiveMessage, false);
```

### 设置 document.domain

- 原理：相同主域名不同子域名下的页面，可以设置`document.domain`让它们同域
- 限制：同域document提供的是页面间的互操作，需要载入iframe页面

下面几个域名下的页面都是可以通过`document.domain`跨域互操作的： `http://a.com/foo`, `http://b.a.com/bar`, `http://c.a.com/bar`。 但只能以页面嵌套的方式来进行页面互操作，比如常见的`iframe`方式就可以完成页面嵌套：

```Javascript
// URL http://a.com/foo
var ifr = document.createElement('iframe');
ifr.src = 'http://b.a.com/bar'; 
ifr.onload = function(){
    var ifrdoc = ifr.contentDocument || ifr.contentWindow.document;
    ifrdoc.getElementsById("foo").innerHTML);
};

ifr.style.display = 'none';
document.body.appendChild(ifr);
```

上述代码所在的URL是`http://a.com/foo`，它对`http://b.a.com/bar`的DOM访问要求后者将 `document.domain`往上设置一级：

```javascript
// URL http://b.a.com/bar
document.domain = 'a.com'
```

**document.domain只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的**， 在Chrome中给出的错误是这样的：

```
Uncaught DOMException: Failed to set the 'domain' property on 'Document': 'baidu.com' is not a suffix of 'b.a.com'
```

### 有src的标签

- 原理：所有具有`src`属性的HTML标签都是可以跨域的，包括`<img>`, `<script>`
- 限制：需要创建一个DOM对象，只能用于GET方法

在`document.body`中`append`一个具有`src`属性的HTML标签， `src`属性值指向的URL会以GET方法被访问，该访问是可以跨域的。

> 其实样式表的`<link>`标签也是可以跨域的，只要是有`src`或`href`的HTML标签都有跨域的能力。

不同的HTML标签发送HTTP请求的时机不同，例如`<img>`在更改`src`属性时就会发送请求，而`script`, `iframe`, `link[rel=stylesheet]`只有在添加到DOM树之后才会发送HTTP请求：

```Javascript
var img = new Image();
img.src = 'http://some/picture';        // 发送HTTP请求

var ifr = $('<iframe>', {src: 'http://b.a.com/bar'});
$('body').append(ifr);                  // 发送HTTP请求
```

### navigation 对象

- 原理：iframe之间是共享`navigator`对象的，用它来传递信息
- 要求：IE6/7

有些人注意到了IE6/7的一个漏洞：`iframe`之间的`window.navigator`对象是共享的。 我们可以把它作为一个Messenger，通过它来传递信息。比如一个简单的委托：

```javascript
// a.com
navigation.onData(){
    // 数据到达的处理函数
}
typeof navigation.getData === 'function' 
    || navigation.getData()
```

```javascript
// b.com
navigation.getData = function(){
    $.get('/path/under/b.com')
        .success(function(data){
            typeof navigation.onData === 'function'
                || navigation.onData(data)
        });
}
```

与`document.navigator`类似，`window.name`也是当前窗口所有页面所共享的。也可以用它来传递信息。 同样蛋疼的办法还有传递Hash（有些人叫锚点），这是因为每次浏览器打开一个URL时，URL后面的`#xxx`部分会保留下来，那么新的页面可以从这里获得上一个页面的数据。

### 访问控制安全的讨论

在HTML5之前，JSONP已经成为跨域的事实标准了，jQuery都给出了支持。 值得注意的是它只是Hack，并没有产生额外的安全问题。 因为JSONP要成功获取数据，需要跨域资源所在服务器的配合，比如资源所在服务器需要自愿地回调一个合适的函数，所以服务器仍然有能力控制资源的跨域访问。

跨域的正道还是要使用HTML5提供的CORS头字段以及`window.postMessage`， 可以支持POST, PUT等HTTP方法，从机制上解决跨域问题。 值得注意的是`Access-Control-Allow-Origin`头字段是资源所在服务器设置的， 访问控制的责任仍然是在提供资源的服务器一方，这和JSONP是一样的。

# 跨域携带cookie

在 2014 年 W3C 发布了 [CORS Recommendation](https://www.w3.org/TR/cors/) 来允许更方便的跨域资源共享。 默认情况下浏览器对跨域请求不会携带Cookie，但鉴于 Cookie 在身份验证等方面的重要性， CORS 推荐使用额外的响应头字段来允许跨域发送 Cookie。

### 客户端代码

在`open` [XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)后，设置`withCredentials`为`true`即可让该跨域请求携带 Cookie。 注意携带的是目标页面所在域的 Cookie。

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', url);
xhr.withCredentials = true;
xhr.send();
```

如果你在使用 [jQuery](http://api.jquery.com)，可以通过[`xhrFields`](http://api.jquery.com/jquery.ajax/)来设置：

```Javascript
$.ajax({
   url: a_cross_domain_url,
   xhrFields: {
      withCredentials: true
   }
});
```

如果你在使用 [Zepto](http://zeptojs.com/)，抱歉没有办法。因为 Zepto 会在`open`之前设置`withCredentials`。 根据[WHATWG 的 XHR 标准](https://xhr.spec.whatwg.org/#the-withcredentials-attribute)在`open`之前设置是不合法的， 虽然多数浏览器不抛出错误但仍然不会携带 Cookie。

### Access-Control-Allow-Credentials

只设置客户端当然是没用的，还需要目标服务器接受你跨域发送的 Cookie。 否则会被浏览器的同源策略挡住：

[![AC-not-set](http://harttle.com/assets/img/blog/cors/allow-credentials-not-set@2x.png)](http://harttle.com/assets/img/blog/cors/allow-credentials-not-set@2x.png)

服务器同时设置[`Access-Control-Allow-Credentials`](https://www.w3.org/TR/cors/#access-control-allow-credentials-response-header)响应头为`"true"`， 即可允许跨域请求携带 Cookie。

### Access-Control-Allow-Origin

除了`Access-Control-Allow-Credentials`之外，跨域发送 Cookie 还要求 `Access-Control-Allow-Origin`[不允许使用通配符](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)。 事实上不仅不允许通配符，而且[只能指定单一域名](https://www.w3.org/TR/2010/WD-cors-20100727/#resource-sharing-check0)：

否则，浏览器还是会挡住跨域请求：

[![wildcard-Access-Control-Allow-Credentials](http://harttle.com/assets/img/blog/cors/wildcard-origin-with-credentials@2x.png)](http://harttle.com/assets/img/blog/cors/wildcard-origin-with-credentials@2x.png)

### 计算 Access-Control-Allow-Origin

既然`Access-Control-Allow-Origin`只允许单一域名， 服务器可能需要维护一个接受 Cookie 的 Origin 列表， 验证 `Origin` 请求头字段后直接将其设置为`Access-Control-Allow-Origin`的值。 （这一实践来自 [Stackoverflow](http://stackoverflow.com/questions/1653308/access-control-allow-origin-multiple-origin-domains)） 值得注意的是在 CORS 请求被重定向后 `Origin` 头字段会被置为 `null`。 此时可以选择从`Referer`头字段计算得到`Origin`。

在正确配置的情况下，在 Chrome Network 就可以看到 Cookie 请求头被跨域发送了 （注意 `Host` 和`Referer`不同域，但仍然带了`Cookie`）：

```bash
Accept:*/*
Accept-Encoding:gzip, deflate, sdch, br
Accept-Language:zh-CN,zh;q=0.8,en;q=0.6,nl;q=0.4,zh-TW;q=0.2,fr;q=0.2,de;q=0.2,ja;q=0.2
Connection:keep-alive
Cookie:auhtor:harttle; _gat=1; _ga=GA1.1.221305049.1482947002
Host:dest.com:4001
Origin:http://index.com:4001
Referer:http://index.com:4001/
User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36

```

### 服务器端代码

```javascript
const express = require('express');

var app = express();
app.get('/specific-allow-origin-with-credentials', (req, res) => {
    res.set({
        'Access-Control-Allow-Origin': 'http://index.com:4001',  //only 1 url
        'Access-Control-Allow-Credentials': true  //allow cookie
    });
    res.status(200).end('I got your cookie: ' + req.headers.cookie);
});
app.listen(4001, () => console.log('listening to 4001'));
```

完整的 Demo 可以从[harttle/cors-demo](https://github.com/harttle/cors-demo)获取。

# 复杂请求perflight

我们知道借助[`Access-Control-Allow-Origin`](https://www.w3.org/TR/cors/#access-control-allow-origin-response-header)响应头字段可以允许跨域 AJAX， 对于非**简单请求**，CORS 机制跨域会首先进行 preflight（一个 OPTIONS 请求）， 该请求成功后才会发送真正的请求。 这一设计旨在确保服务器对 CORS 标准知情，以保护不支持 CORS 的旧服务器，

[![Flowchart_showing_Simple_and_Preflight_XHR](https://upload.wikimedia.org/wikipedia/commons/c/ca/Flowchart_showing_Simple_and_Preflight_XHR.svg)](https://upload.wikimedia.org/wikipedia/commons/c/ca/Flowchart_showing_Simple_and_Preflight_XHR.svg)

> Wikipedia: https://upload.wikimedia.org/wikipedia/commons/c/ca/Flowchart_showing_Simple_and_Preflight_XHR.svg

### 简单请求

**简单请求**具体是指请求方法是[简单方法](https://www.w3.org/TR/cors/#simple-method)且请求头是[简单头](https://www.w3.org/TR/cors/#simple-header)的 HTTP 请求。具体地，

- *简单方法*包括`GET`, `HEAD`, `POST`。
- *简单头*包括：`Accept`, `Accept-Language`, `Content-Language`，以及值为`application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain` 其中之一的 `Content-Type` 头。

### 复杂请求

非简单请求浏览器会首先发送 OPTIONS 请求（成为 preflight）， 例如添加一个自定义头部`x-foo`的 HTTP 请求：

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', url);
xhr.setRequestHeader('x-foo', 'bar');
xhr.send();
```

服务器需要成功响应（2xx）并在`Access-Control-Alow-Headers`中包含`x-foo` （因为它不是[简单头部](https://www.w3.org/TR/cors/#simple-header)）：

```bash
OPTIONS /origin-redirect-with-preflight 200
Access-Control-Allow-Headers:x-foo
Access-Control-Allow-Origin:http://index.com:4001
Connection:keep-alive
Content-Length:0
```

### Access-Control-Request-Headers

[Access-Control-Request-Headers](https://www.w3.org/TR/cors/#access-control-request-headers-request-header) 是 preflight 请求中用来标识真正请求将会包含哪些头部字段， preflight 请求本身不会发送这些头字段。 例如上述请求中`Access-Control-Request-Headers`字段的值应该是`x-foo`。 服务器应当在对应的`Access-Control-Allow-Headers`响应头中包含这些字段。 否则即使返回 200 preflight 也会失败：

```
XMLHttpRequest cannot load http://mid.com:4001/access-control-allow-origin-wildcard.
Request header field x-foo is not allowed by Access-Control-Allow-Headers in preflight response.

```

### DNT 请求头

有些浏览器（如 Safari 隐身模式）会在请求中添加[`DNT`](https://en.wikipedia.org/wiki/Do_Not_Track)头， 但浏览器不会（也不应）因此而发起 preflight。 因为这一请求头是浏览器添加的，也应当对此知情。 所以响应头中也不需要包含`Access-Control-Allow-Headers`， 参照 [W3C Recommendation](https://www.w3.org/TR/cors/#cross-origin-request-with-preflight-0)，满足以下条件即可跳过 preflight：

> For request method there either is a method cache match or it is a simple method and the force preflight flag is unset. For every header of author request headers there either is a header cache match for the field name or it is a simple header.

注意只要所有`Author Header`是简单头即可跳过，这里的`DNT`虽然不是简单头但它属于 `User-Agent Header`。 注意在 [CORS](http://harttle.com/2015/10/10/cross-origin.html) 被重定向之后这一状况会变得复杂，在[重定向 CORS 跨域请求](http://harttle.com/2016/12/30/cors-redirect.html)一文有较详细的讨论。