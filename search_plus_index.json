{
  "./": {
    "url": "./",
    "title": "Introduction",
    "keywords": "",
    "body": "1. My Notebook1.1. Gitbook Cli1.2. Daily maintenance1.3. Publish1. My Notebook Make sure the repository folder name is guanghui.notebook. 1.1. Gitbook Cli cd folder npm install -g gitbook-cli gitbook init gitbook build # 生成在当前目录的默认文件夹 _book里面 gitbook build ./out # 生成在当前目录的默认文件夹 指定的 out 里面 gitbook serve # localhost:4000 配置文件，不必须 { \"title\": \"前端规范\", \"description\": \"前端规范 简介\", \"language\": \"zh-hans\", \"plugins\": [ \"-lunr\", \"-search\", \"search-plus\", //支持中文搜索 上面 search 是默认的 “-” 是去掉的意思 \"splitter\", // 这个侧边可以拉伸 \"tbfed-pagefooter\", //这个是底部加 信息 下面可以看到具体的配置 \"expandable-chapters-small\" //使左侧的章节目录可以折叠 ], \"pluginsConfig\": { \"theme-default\": { \"showLevel\": true }, \"tbfed-pagefooter\": { \"copyright\": \"Copyright &copy xxxxx\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } }, \"links\": { \"gitbook\": false, \"sharing\": { \"google\": false, \"facebook\": false, \"twitter\": false, \"all\": false } } } 1.2. Daily maintenance npm run toc npm run prettierReadme # npm run prettier git add . git commit -m 'commit' --no-verify git push 1.3. Publish Need to build _book directory before publish via gitbook build. Only 1st time publish: git branch -D gh-pages if any yarn run initPublish. Make sure master _book contains index.html, search_plus_index.json and all html files. This script will create gh-pages branch and .gitignore In future publish: yarn run publish Access result at https://wghglory.github.io/gitbook 参考资料：http://gitbook.zhangjikai.com/plugins.html Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/": {
    "url": "Angular/",
    "title": "Angular",
    "keywords": "",
    "body": "1. TOC1. TOC angular_tools angular5new angular6new components_communication form_validation form hostBinding_vs_hostListener Http i18n interceptor_global_error_handling issues map_mergeMap_switchMap_concatMap ngTemplateOutlet performance retry route rxjs_best_practice rxjs_help something subject Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Angular/angular_tools.html": {
    "url": "Angular/angular_tools.html",
    "title": "angular_tools",
    "keywords": "",
    "body": "1. Angular Tools1. Angular Tools vscode: Language Service Documentation [Compodoc & ngd]: https://github.com/compodoc/compodoc bug: https://github.com/compodoc/compodoc/issues/525#issuecomment-488822477, remove const route: Route = [{ }]'s Route for lazy modules Augury chrome extension ngrev: https://github.com/mgechev/ngrev/releases Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/angular5new.html": {
    "url": "Angular/angular5new.html",
    "title": "angular5new",
    "keywords": "",
    "body": "1. Angular 5 new features1.1. Form Validation1.2. New Router Lifecycle events1.3. RxJS 5.5 imports1.4. Universal Transfer API1.5. Other changes and Optimization1. Angular 5 new features 1.1. Form Validation Validation on blur and submit: 1.2. New Router Lifecycle events allow to track the routing cycle used to do things like show spinners, measure performance of guards GuardsCheckStart ChildActivationStart ActivationStart GuardsCheckEnd ResolveStart ResolveEnd ActivationEnd ChildActivationEnd 1.3. RxJS 5.5 imports import { Observable } from 'rxjs/Observable'; import { map, filter } from 'rxjs/operators'; const names = allUserData.pipe( map(user => user.name) filter(name => name), ); 1.4. Universal Transfer API Easily share app state between server and client version ServerTransferStateModule has been added Optimizes fetching data over HTTP More DOM manipulations/support 1.5. Other changes and Optimization bug fixes preserveWhitespace Option exportAs Zone speed improvements platformBrowserDynamic() .bootstrapModule(AppModule, { ngZone: 'noop' }) .then((ref) => {}); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/angular6new.html": {
    "url": "Angular/angular6new.html",
    "title": "angular6new",
    "keywords": "",
    "body": "1. Angular 6 new features1.1. 主要的新特性1.2. Angular elements1.3. CDK1.4. Ivy renderer1.5. Bazel and Closure compiler1.6. ng update & ng add1.7. RXJS 6, Webpack 4 & TypeScript 2.7 support1.8. Reference1. Angular 6 new features 1.1. 主要的新特性 按照官方的说法，Angular 6 体积将会更小、更加易于使用，同时运行速度也更快。当然，最重要的是，官方承诺平滑升级，没有破坏性变更。 主要新特性包括： Angular elements CDK Ivy renderer Bazel & Closure compiler ng update & ng add RXJS 6, Webpack 4, TypeScript 2.7 support 1.2. Angular elements Angular Elements 可以用来把组件打包成 Web Component，甚至可以用在非 Angular 项目里面。 1.3. CDK 利用@angular/cdk，你可以基于 @angular/material 来构建自己的 UI 组件库。同时删除了对@angular/flex-layout 的依赖，因为 CDK 将会支持响应式设计。 1.4. Ivy renderer 默认不会启用 Ivy 渲染引擎，如果你想用，需要手动修改编译参数。启用 Ivy 渲染引擎会带来很多好处：渲染速度更快、打包的体积更小，同时更加灵活。 （注：实际上这已经是第二次换渲染引擎了，第一次换到 Render2，这次换成了 Ivy，希望 Ivy 能带来让人眼前一亮的效果。） 1.5. Bazel and Closure compiler “作为一款高质量的工具， ABC (Angular + Bazel + Closure) 工程里面倾注了我们大量的努力，你可以利用它来构建高质量的 Angular 应用。 ” Bazel 是 Google 内部一直使用的强大构建工具，根据 Brad Green 在上次演讲（www.ngfans.net/topic/105/p… ）中提到的内容，Angular 项目组采用 Bazel 的原因是，为了让构建工具保持统一，同时也让外部公司能享受到 Google 内部构建工具带来的好处。 对于 Angular 来说，最看中的是 Bazel 的增量编译特性和编译速度，按照官方的说法，Bazel 的目标是：重新编译项目到浏览器能运行，只要 2 秒的时间。 Closure 也是 Google 内部一直使用的一款工具，它可以对 JS 代码进行压缩和优化，生成的包体积更小（比如典型的死码消除特性）、对 JS 引擎更加友好。 更详尽的演进路线点这里（英文，墙？）：g.co/ng/abc Bazel 的官方网站点这里（英文，墙？）：bazel.build/ Closure 的详细介绍点这里（英文，墙？）：developers.google.com/closure/com… 1.6. ng update & ng add 从 Angular CLI 1.7 开始你可以运行： ng update 这样就可以自动更新 package.json 里面定义的依赖包，RxJS 和 TypeScript 版本也会自动更新。 另一个命令是： ng add 这个命令用来帮助开发者给自己的应用增加新特性。例如，你可以把一款普通应用变成 Progressive Web Apps (PWA) ，你还可以一开始就指定应用的类型，而不是创建空白的项目。 1.7. RXJS 6, Webpack 4 & TypeScript 2.7 support 升级到 RXJS 6 可以缩小打包的体积。 Angular 目前使用的 webpack 版本是 3.x，很快 webpack 4.x 就要来了，Angular CLI 已经做好了升级的准备。同样，升级到 webpack 新版本之后，可以利用 scope hosting 特性让编译之后的体积变得更小。 最后一点就是，Angular 6 将会升级 TypeScript 到 2.7 。 1.8. Reference http://baijiahao.baidu.com/s?id=1601056475936463734&wfr=spider&for=pc https://blog.csdn.net/lc_style/article/details/80292991 (Very good) Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/components_communication.html": {
    "url": "Angular/components_communication.html",
    "title": "components_communication",
    "keywords": "",
    "body": "1. Components Communication1.1. 1. Communicating with Child Components Using @Input (Parent pass data to child)1.2. 2. Communicating with Parent Components Using @Output and EventEmitter (child pass data to parent)1.3. 3. Using Template Variables To Interact with Child Components (parent access to child data, easier than method 2)1. Components Communication 1.1. 1. Communicating with Child Components Using @Input (Parent pass data to child) I want to create a address component as a child component. The parent component, events-list, will pass the event object to the child. To get this done: child component needs import Input from angular/core parent template uses the child selector, and [input parameter name] = \"parent\" child component: events-address.component.ts //child component, talk with parent events-list.component.ts import { Component, Input } from '@angular/core'; @Component({ selector: 'events-address', template: ',,', }) export class EventsAddressComponent { @Input() address: any; //define address object } modify parent component template, [address] is child object name, \"event.location\" is parent data Upcoming Angular 2 Events Event: Price: $ Date: Time: Address: , , --> import child component to app.module import { EventsAddressComponent } from './events/events-address.component' @NgModule({ declarations: [AppComponent, EventsListComponent, EventsAddressComponent], }) 1.2. 2. Communicating with Parent Components Using @Output and EventEmitter (child pass data to parent) child component events-address.component.ts: import Output, EventEmitter define a variable accepting EventEmitter define buttonClick the EventEmitter variable emit any data from child component //child component, talk with parent events-list.component.ts import { Component, Output, EventEmitter } from '@angular/core'; @Component({ selector: 'events-address', template: 'Click me!', }) export class EventsAddressComponent { @Output() myClick = new EventEmitter(); buttonClick() { this.myClick.emit('I am from child component, should pass data to parent component'); } } parent Component events-list.component.ts: update template: (the EventEmitter variable name defined in child component) = \"randomFuncInParent($event)\" define random function in parent component class export class EventsListComponent { clickWithAnyName(dataFromChild) { alert(dataFromChild); } } 1.3. 3. Using Template Variables To Interact with Child Components (parent access to child data, easier than method 2) child component events-address.component.ts define public property and method //child component, talk with parent events-list.component.ts @Component({ selector: 'events-address', template: '', }) export class EventsAddressComponent { //use template variable to interact with child public method/property: parent accesses child data author: string = 'Guanghui Wang'; //child public property getAuthor() { alert(this.author); } } access child component data from parent component template's childPointer variable Test template variable Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/form_validation.html": {
    "url": "Angular/form_validation.html",
    "title": "form_validation",
    "keywords": "",
    "body": "1. Reactive form validation1. Reactive form validation Angular 6 Reactive Form Validation First Name First Name is required Last Name Last Name is required Email Email is required Email must be a valid email address Password Password is required Password must be at least 6 characters Register import { Component, OnInit } from '@angular/core'; import { FormBuilder, FormGroup, Validators } from '@angular/forms'; @Component({ selector: 'app', templateUrl: 'app.component.html', }) export class AppComponent implements OnInit { registerForm: FormGroup; constructor(private formBuilder: FormBuilder) {} ngOnInit() { this.registerForm = this.formBuilder.group({ firstName: ['', Validators.required], lastName: ['', Validators.required], email: ['', [Validators.required, Validators.email]], password: ['', [Validators.required, Validators.minLength(6)]], }); } // convenience getter for easy access to form fields get formControls() { return this.registerForm.controls; } onSubmit() { // stop here if form is invalid if (this.registerForm.invalid) { return; } alert(JSON.stringify(this.registerForm.value)); } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/form.html": {
    "url": "Angular/form.html",
    "title": "form",
    "keywords": "",
    "body": "1. Form1.1. Categories1.1.1. Template-drive1.1.2. Reactive Forms1. Form 1.1. Categories Template-drive Generated form model HTML validation 2-way data binding automatically tracks form and input element state Reactive Manually created form model Validation in the class No two-way data binding flexible for complex scenarios Dynamically add input elements Watch what the user types Wait validation until typing stops Different validation for different situations Immutable data structures immutable data model easier to perform an action on a value change Reactive transformations --> debounceTime or distinctUntilChanged Easily add input elements dynamically 1.1.1. Template-drive Template Form element Input element(s) Data binding Validation rules (attributes) Validation error messages Form model automatically generated Component Class Properties for data binding (data model) Methods for form operations, such as submit First Name Please enter your first name. Save onChange(event: Event){ this.someVar = (event.target).value; } 1.1.2. Reactive Forms Template Form element Input element(s) Binding to form model Component Class Form model Root FormGroup FormControl for each input element Nested FormGroups as desired FormArrays Validation rules Validation error messages Properties for managing data (data model) Methods for form operations, such as submit First Name {{formError.firstName}} Save Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/hostBinding_vs_hostListener.html": {
    "url": "Angular/hostBinding_vs_hostListener.html",
    "title": "hostBinding_vs_hostListener",
    "keywords": "",
    "body": "1. What Are @HostBinding() and @HostListener() in Angular?1.1. @HostListener() Decorator1.2. @HostBinding() Decorator1.3. Reference1. What Are @HostBinding() and @HostListener() in Angular? Let us start by creating a simple custom attribute directive. The directive below changes the background color of the host element: import { Directive, ElementRef, Renderer } from '@angular/core'; @Directive({ selector: '[app-changeBg]', }) export class ChangeBgColorDirective { constructor(private el: ElementRef, private renderer: Renderer) { this.changeBgColor('red'); } changeBgColor(color: string) { this.renderer.setElementStyle(this.el.nativeElement, 'color', color); } } You can use the above attribute directive on a component template as shown in the code block below: {{title}} Here, the component class holding the host element is created as below: import { Component } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'], }) export class AppComponent { title = 'Hey ng Developer ! '; } Right now, the app-changeBg directive will change the color of the host element. 1.1. @HostListener() Decorator @HostListener() function decorator allows you to handle events of the host element in the directive class. Let's take the following requirement: when you hover you mouse over the host element, only the color of the host element should change. In addition, when the mouse is gone, the color of the host element should change to its default color. To do this, you need to handle events raised on the host element in the directive class. In Angular, you do this using @HostListener() . To understand @HostListener() in a better way, consider another simple scenario: on the click of the host element, you want to show an alert window. To do this in the directive class, add @HostListener() and pass the event 'click' to it. Also, associate a function to raise an alert as shown in the listing below: @HostListener('click') onClick() { window.alert('Host Element Clicked'); } In Angular, the @HostListener() function decorator makes it super easy to handle events raised in the host element inside the directive class. Let's go back to our requirement that says you must change the color to red only when the mouse is hovering, and when it's gone, the color of the host element should change to black. To do this, you need to handle the mouseenter and mouseexit events of the host element in the directive class. To achieve this, modify the app-changeBg directive class as shown below: import { Directive, ElementRef, Renderer, HostListener } from '@angular/core'; @Directive({ selector: '[app-changeBg]', }) export class ChangeBgColorDirective { constructor(private el: ElementRef, private renderer: Renderer) { // this.changeBgColor('red'); } @HostListener('mouseover') onMouseOver() { this.changeBgColor('red'); } @HostListener('click') onClick() { window.alert('Host Element Clicked'); } @HostListener('mouseleave') onMouseLeave() { this.changeBgColor('black'); } changeBgColor(color: string) { this.renderer.setElementStyle(this.el.nativeElement, 'color', color); } } In the directive class, we are handling the mouseenter and mouseexit events. As you see, we are using @HostListener() to handle these host element events and assigning a function to it. So, let's use @HostListener() function decorator to handle events of the host element in the directive class. 1.2. @HostBinding() Decorator @HostBinding() function decorator allows you to set the properties of the host element from the directive class. Let's say you want to change the style properties such as height, width, color, margin, border, etc., or any other internal properties of the host element in the directive class. Here, you'd need to use the @HostBinding() decorator function to access these properties on the host element and assign a value to it in directive class. The @HostBinding() decorator takes one parameter, the name of the host element property which value we want to assign in the directive. In our example, our host element is an HTML div element. If you want to set border properties of the host element, you can do that using @HostBinding() decorator as shown below: @HostBinding('style.border') border: string; @HostListener('mouseover') onMouseOver() { this.border = '5px solid green'; } Using this code, on a mouse hover, the host element border will be set to a green, solid 5-pixel width. Therefore, using the @HostBinding decorator, you can set the properties of the host element in the directive class. 1.3. Reference https://codecraft.tv/courses/angular/custom-directives/hostlistener-and-hostbinding/ https://angular.io/guide/attribute-directives Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/Http.html": {
    "url": "Angular/Http.html",
    "title": "Http",
    "keywords": "",
    "body": "1. HTTP in angular1.1. Handling Http Errors in service1.2. Model for error1.3. Service demo1.4. Component that consumes service1.5. Use a resolver1.6. Interceptors1.6.1. Caching with interceptors1.6.2. Role of cache service1. HTTP in angular 1.1. Handling Http Errors in service inject HttpClientModule in service's constructor Encapsulate Http errors in service Don't expose implementation details to the component Use RxJS \"catchError\" operator Return custom errors to components 1.2. Model for error // Book return error model export class BookTrackerError { errorNumber: number; message: string; friendlyMessage: string; } 1.3. Service demo // book.service.ts import { Injectable } from '@angular/core'; import { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http'; import { Observable } from 'rxjs/Observable'; import { map, tap, catchError } from 'rxjs/operators'; import { ErrorObservable } from 'rxjs/observable/ErrorObservable'; import { Book } from 'app/models/book'; import { BookTrackerError } from 'app/models/bookTrackerError'; import { FormattedBook } from 'app/models/formattedBook'; @Injectable() export class BookService { constructor(private http: HttpClient) {} private handleHttpError(error: HttpErrorResponse): Observable { let dataError = new BookTrackerError(); dataError.errorNumber = 100; dataError.message = error.statusText; dataError.friendlyMessage = 'An error occurred retrieving data.'; return ErrorObservable.create(dataError); } getAll(): Observable { return this.http.get(`/api/books`).pipe(catchError((err) => this.handleHttpError(err))); } // second param is optional getOne(id: number): Observable { return this.http.get(`/api/books/${id}`, { headers: new HttpHeaders({ Accept: 'application/json', Authorization: 'my-token', }), }); } // if UI needs a formatted book getOneFormatted(id: number): Observable { return this.http.get(`/api/books/${id}`).pipe( // data convert map( (b) => { title: b.bookTitle, year: b.publicationYear, }, ), // use converted data to do some logic tap((newBook) => console.log(newBook)), ); } // return 201 if successful add(book: Book): Observable { return this.http.post(`/api/books`, book, { headers: new HttpHeaders({ 'Content-Type': 'application/json', }), // third param is optional }); } // return 204 no content if successful update(book: Book): Observable { return this.http.put(`/api/books/${book.id}`, book, { headers: new HttpHeaders({ 'Content-Type': 'application/json', }), // third param is optional }); } // return 204 no content if successful deleteBook(id: Book): Observable { return this.http.put(`/api/books/${id}`); } } 1.4. Component that consumes service // component using the service ngOnInit() { this.bookService.getAll().subscribe( (data: Book[]) => this.books = data, (err: BookTrackerError) => console.log(err.friendlyMessage), () => console.log('all done') ) } 1.5. Use a resolver If our component doesn't call bookService in ngOnInit to load data, but use a resolver. // books-resolver.service.ts import { Injectable } from '@angular/core'; import { Resolve, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router'; import { Observable } from 'rxjs/Observable'; import { catchError } from 'rxjs/operators'; import { of } from 'rxjs/observable/of'; import { Book } from 'app/models/book'; import { BookService } from 'app/core/book.service'; import { BookTrackerError } from 'app/models/bookTrackerError'; @Injectable() export class BooksResolverService implements Resolve { constructor(private bookService: BookService) {} resolve( route: ActivatedRouteSnapshot, state: RouterStateSnapshot, ): Observable { return this.bookService.getAll().pipe(catchError((err) => of(err))); } } 1.6. Interceptors Adding headers to all requests Login Reporting progress events Client-side caching Providing an interceptor: import { NgModule } from '@angular/core'; import { HTTP_INTERCEPTORS } from '@angular/common/http'; import { AddHeaderInterceptor } from './add-header.interceptor'; import { LogResponseInterceptor } from 'app/core/log-response.interceptor'; import { CacheInterceptor } from './cache.interceptor'; @NgModule({ imports: [], declarations: [], providers: [ { provide: HTTP_INTERCEPTORS, useClass: LogResponseInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: AddHeaderInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: CacheInterceptor, multi: true }, ], }) export class CoreModule {} // log response interceptor import { Injectable } from '@angular/core'; import { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpEventType, } from '@angular/common/http'; import { Observable } from 'rxjs/Observable'; import { tap } from 'rxjs/operators'; @Injectable() export class LogResponseInterceptor implements HttpInterceptor { intercept(req: HttpRequest, next: HttpHandler): Observable> { console.log(`LogResponseInterceptor - ${req.url}`); return next.handle(req).pipe( tap((event) => { if (event.type === HttpEventType.Response) { console.log(event.body); } }), ); } } // add-header.interceptor import { Injectable } from '@angular/core'; import { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http'; import { Observable } from 'rxjs/Observable'; @Injectable() export class AddHeaderInterceptor implements HttpInterceptor { intercept(req: HttpRequest, next: HttpHandler): Observable> { console.log(`AddHeaderInterceptor - ${req.url}`); let jsonReq: HttpRequest = req.clone({ setHeaders: { 'Content-Type': 'application/json' }, }); return next.handle(jsonReq); } } 1.6.1. Caching with interceptors client --> interceptor (check cache) --> no ? --> server 1.6.2. Role of cache service Provide a data structure for the cached items add items to the cache retrieve items from the cache remove items from the cache (cache invalidation) // http-cache.service.ts import { Injectable } from '@angular/core'; import { HttpResponse } from '@angular/common/http'; @Injectable() export class HttpCacheService { private requests: any = {}; constructor() {} put(url: string, response: HttpResponse): void { this.requests[url] = response; } get(url: string): HttpResponse | undefined { return this.requests[url]; } invalidateUrl(url: string): void { this.requests[url] = undefined; } invalidateCache(): void { this.requests = {}; } } // cache interceptor import { Injectable } from '@angular/core'; import { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpResponse, } from '@angular/common/http'; import { Observable } from 'rxjs/Observable'; import { tap } from 'rxjs/operators'; import { of } from 'rxjs/observable/of'; import { HttpCacheService } from 'app/core/http-cache.service'; @Injectable() export class CacheInterceptor implements HttpInterceptor { constructor(private cacheService: HttpCacheService) {} intercept(req: HttpRequest, next: HttpHandler): Observable> { // pass along non-cacheable requests and invalidate cache if (req.method !== 'GET') { console.log(`Invalidating cache: ${req.method} ${req.url}`); this.cacheService.invalidateCache(); return next.handle(req); } // attempt to retrieve a cached response const cachedResponse: HttpResponse = this.cacheService.get(req.url); // return cached response if (cachedResponse) { console.log(`Returning a cached response: ${cachedResponse.url}`); console.log(cachedResponse); return of(cachedResponse); } // send request to server and add response to cache return next.handle(req).pipe( tap((event) => { if (event instanceof HttpResponse) { console.log(`Adding item to cache: ${req.url}`); this.cacheService.put(req.url, event); } }), ); } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/i18n.html": {
    "url": "Angular/i18n.html",
    "title": "i18n",
    "keywords": "",
    "body": "1. i18n1.1. Setting up the locale of your app1.2. Template translations1.2.1. Custom id with meaning and description1.2.2. translate text with html tags1.2.3. Translate attributes1.3. Regular expressions for plurals and selections1.3.1. Pluralization1. i18n 1.1. Setting up the locale of your app To set your app's locale to another value, use the CLI parameter --configuration with the value of the locale id that you want to use: ng serve --configuration=fr 1.2. Template translations The i18n template translation process has four phases: Mark static text messages in your component templates for translation. Create a translation file: Use the Angular CLI xi18n command to extract the marked text into an industry-standard translation source file. Edit the generated translation file: Translate the extracted text into the target language. Merge the completed translation file into the app. To do this, use the Angular CLI build command to compile the app, choosing a locale-specific configuration, or specifying the following command options. --i18nFile = path to the translation file --i18nFormat = format of the translation file --i18nLocale = locale id The command replaces the original messages with translated text, and generates a new version of the app in the target language. 1.2.1. Custom id with meaning and description Hello i18n! 1.2.2. translate text with html tags Translate text without creating an element: I don't output any element 1.2.3. Translate attributes To mark an attribute for translation, add an attribute in the form of i18n-x, where x is the name of the attribute to translate. You also can assign a meaning, description, and id with the i18n-x=\"|@@\" syntax. 1.3. Regular expressions for plurals and selections 1.3.1. Pluralization Suppose that you want to say that something was \"updated x minutes ago\". In English, depending upon the number of minutes, you could display \"just now\", \"one minute ago\", or \"x minutes ago\" (with x being the actual number). Other languages might express the cardinality differently. The example below shows how to use a plural ICU expression to display one of those three options based on when the update occurred: Updated {minutes, plural, =0 {just now} =1 {one minute ago} other {{{minutes}} minutes ago}} The first parameter is the key. It is bound to the component property (minutes), which determines the number of minutes. The second parameter identifies this as a plural translation type. The third parameter defines a pluralization pattern consisting of pluralization categories and their matching values. the three options are specified according to that pluralization pattern. For talking about zero minutes, you use =0 {just now}. For one minute, you use =1 {one minute}. Any unmatched cardinality uses other {{{minutes}} minutes ago}. You could choose to add patterns for two, three, or any other number if the pluralization rules were different. For the example of \"minute\", only these three patterns are necessary in English. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/interceptor_global_error_handling.html": {
    "url": "Angular/interceptor_global_error_handling.html",
    "title": "interceptor_global_error_handling",
    "keywords": "",
    "body": "1. Global http request/response error handling1. Global http request/response error handling // http-error.interceptor.ts: import { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpErrorResponse, } from '@angular/common/http'; import { Observable, throwError } from 'rxjs'; import { catchError } from 'rxjs/operators'; export class HttpErrorInterceptor implements HttpInterceptor { intercept(request: HttpRequest, next: HttpHandler): Observable> { return next.handle(request).pipe( // retry(1), catchError((error: HttpErrorResponse) => { let errorMessage = ''; if (error.error instanceof ErrorEvent) { // client-side error errorMessage = `Error: ${error.error.message}`; } else { // server-side error errorMessage = `Error Code: ${error.status}\\nMessage: ${error.message}`; } window.alert(errorMessage); return throwError(errorMessage); }), ); } } // app.module.ts import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http'; import { AppComponent } from './app.component'; import { HttpErrorInterceptor } from './http-error.interceptor'; @NgModule({ imports: [BrowserModule, HttpClientModule], declarations: [AppComponent], bootstrap: [AppComponent], providers: [ { provide: HTTP_INTERCEPTORS, useClass: HttpErrorInterceptor, multi: true, }, ], }) export class AppModule {} Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/issues.html": {
    "url": "Angular/issues.html",
    "title": "issues",
    "keywords": "",
    "body": "1. Some issues1.1. Production error1.1.1. 1. e is not a constructor1.1.2. 2. ERROR Error: StaticInjectorError(AppModule)[t -> Overlay]:1. Some issues 1.1. Production error 1.1.1. 1. e is not a constructor ng build shows some warnings -- export something failed. When ng-zorro-antd 7.2 gets introduced into the project, @angular/cdk 6, a google material component dev kit, was used then as a dependency of ng-zorro-antd. But that cdk 6 doesn't export ScrollingModule. Although in dev environment the angular app is working well, e is not a constructor error raises in prod mode. One way to solve this issue is to upgrade @angular/cdk to \"^7.3.6\". 1.1.2. 2. ERROR Error: StaticInjectorError(AppModule)[t -> Overlay]: ERROR Error: StaticInjectorError(AppModule)[CdkConnectedOverlay -> Overlay]: StaticInjectorError(Platform: core)[CdkConnectedOverlay -> Overlay]: NullInjectorError: No provider for Overlay! When calling ng-zorro-antd select component, you might see this error due to the missing of CdkOverlayModule. As we know, javascript is minimized, it's hard to understand the error. To display the whole error, do below: ng serve --prod --optimization=false You may see this error: ng build --prod produces FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory So you need to increase memory limit: export NODE_OPTIONS=--max_old_space_size=4096 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/map_mergeMap_switchMap_concatMap.html": {
    "url": "Angular/map_mergeMap_switchMap_concatMap.html",
    "title": "map_mergeMap_switchMap_concatMap",
    "keywords": "",
    "body": "1. Understanding RxJS map, mergeMap, switchMap and concatMap1.1. The map operator1.2. MergeMap1.3. SwitchMap1.4. ConcatMap1.5. ExhaustMap1.6. Conclusion1.7. Reference1. Understanding RxJS map, mergeMap, switchMap and concatMap Bad code: nested subscribe, actually it makes parallel calls. this.form.valueChanges .subscribe( formValue => { const httpPost$ = this.http.put(`/api/course/${courseId}`, formValue); httpPost$.subscribe( res => console.log('handle successful save ...') err => console.log('handle save error ...') ); } ); 1.1. The map operator The map operator is the most common of all. For each value that the Observable emits you can apply a function in which you can modify the data. The return value will, behind the scenes, be reemitted as an Observable again so you can keep using it in your stream. It works pretty much the same as how you would use it with Arrays. The difference is that Arrays will always be just Arrays and while mapping you get the value of the current index in the Array. With Observables the type of data can be of all sorts of types. This means that you might have to do some additional operations in side your Observable map function to get the desired result. Let’s look at some examples: We first created our Observable with an array of cars. We then subscribe to this Observable 2 times. The first time we modify our data in such a way that we get an array of concatenated brand and model strings. The second time we modify our data so that we get an array of only Porsche cars. In both examples we use the Observable map operator to modify the data that is being emitted by the Observable. We return the result of our modification and the map operator then behind the scenes takes care of wrapping this in an Observable again so we can later subscribe to it. 1.2. MergeMap Now let’s say there is a scenario where we have an Observable that emits an array, and for each item in the array we need to fetch data from the server. We could do this by subscribing to the array, then setup a map that calls a function which handles the API call and then subscribe to the result. This could look like the following: Our map function returns the value of the getData function. In this case that is an Observable. This does however create a problem because now we’re dealing with an additional Observable. To further clarify this: we have from([1,2,3,4]) as our ‘outer’ Observable, and the result of the getData() as our ‘inner’ Observable. In theory we have to subscribe to both our outer and inner Observable to get the data out. This could like this: As you can might imagine this is far from ideal as we have to call Subscribe two times. This is where mergeMap comes to the rescue. MergeMap essentially is a combination of mergeAll and map. MergeAll takes care of subscribing to the ‘inner’ Observable so that we no longer have to Subscribe two times as mergeAll merges the value of the ‘inner’ Observable into the ‘outer’ Observable. This could look like this: This already is much better, but as you might already guessed mergeMap would be the best solution for this. Here’s the full example: You might also have heard about flatMap. FlatMap is an alias of mergeMap and behaves in the same way. Don’t get confused there! 1.3. SwitchMap SwitchMap has similar behaviour in that it will also subscribe to the inner Observable for you. However switchMap is a combination of switchAll and map. SwitchAll cancels the previous subscription and subscribes to the new one. For our scenario where we want to do an API call for each item in the array of the ‘outer’ Observable, switchMap does not work well as it will cancel the first 3 subscriptions and only deals with the last one. This means we will get only one result. The full example can be seen here: While switchMap wouldn’t work for our current scenario, it will work for other scenario’s. It would for example come in handy if you compose a list of filters into a data stream and perform an API call when a filter is changed. If the previous filter changes are still being processed while a new change is already made, it will cancel the previous subscription and start a new subscription on the latest change. An example can be seen here: As you can see in the console getData is only logging once with all the params. This saved us 3 API calls. const searchText$: Observable = fromEvent(this.input.nativeElement, 'keyup').pipe( map((event) => event.target.value), startWith(''), debounceTime(400), distinctUntilChanged(), ); function loadLessons(search: string): Observable { const params = new HttpParams().set('search', search); return this.http.get(`/api/lessons/${coursesId}`, { params }); } // cancel previous request and send new const lessons$: Observable = searchText$ .pipe(switchMap((search) => this.loadLessons(search))) .subscribe(); 1.4. ConcatMap The last example is concatMap. As you might expect, concatMap also subscribes to the inner Observable for you. But unlike switchMap, that unsubscribes from the current Observable if a new Observable comes in, concatMap will not subscribe to the next Observable until the current one completes. The benefit of this is that the order in which the Observables are emitting is maintained. To demonstrate this: The getData function has a random delay between 1 and 10000 milliseconds. If you check the logs you can see that the map and mergeMap operators will log whatever value comes back and don’t follow the original order. On the other hand the concatMap logs the values in the same value as they were started. // form value new change will always be sent after old value this.form.valueChanges .pipe( concatMap(formValue => this.http.put(`/api/course/${courseId}`, formValue)) ) .subscribe( saveResult => ... handle successful save ..., err => ... handle save error ... ); 1.5. ExhaustMap Clicking save button too many times before a request is completed, only when previous request is done, the further requests won't be ignored. fromEvent(this.saveButton.nativeElement, 'click') .pipe(exhaustMap(() => this.saveCourse(this.form.value))) .subscribe(); 1.6. Conclusion Mapping data to the format you need is a common task. RxJS comes with a few very neat operators that help you get the job done. To recap: map is for mapping ‘normal’ values to whatever format you need it to be. The return value will be wrapped in an Observable again, so you can keep using it in your data stream. When you have to deal with an ‘inner’ Observable it’s easier to use mergeMap, switchMap or concatMap. Use mergeMap if you simply want to flatten the data into one Observable, use switchMap if you need to flatten the data into one Observable but only need the latest value and use concatMap if you need to flatten the data into one Observable and the order is important to you. if we need to do things in sequence while waiting for completion, then concatMap is the right choice for doing things in parallel, mergeMap is the best option in case we need cancellation logic, switchMap is the way to go for ignoring new Observables while the current one is still ongoing, exhaustMap does just that 1.7. Reference https://blog.angular-university.io/rxjs-higher-order-mapping/ Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/ngTemplateOutlet.html": {
    "url": "Angular/ngTemplateOutlet.html",
    "title": "ngTemplateOutlet",
    "keywords": "",
    "body": "1. ngTemplateOutlet1.1. Configurable Components with Template Partial @Inputs1.2. Template Context1.3. Template References1. ngTemplateOutlet Insert a common template in various sections of a view that are not generated by a loop or subject to a condition. For example, you can define a template for the logo of a company and insert it in several places in the page: Company History {{companyHistory}} User info Name: Account ID: Submit The ACME company, {{employeeCount}} people working for you! 1.1. Configurable Components with Template Partial @Inputs // parent @Component({ selector: 'app-root', template: ` {{loginText}} {{signUpText}} `, }) export class AppComponent implements OnInit {} // child @Component({ selector: 'tab-container', template: ` ... ... rest of tab container component ... `, }) export class TabContainerComponent { @Input() headerTemplate: TemplateRef; // Custom template provided by parent } 1.2. Template Context @Component({ selector: 'app-root', template: ` Approximately {{lessonsCounter}} lessons ... `, }) export class AppComponent { totalEstimate = 10; ctx = { estimate: this.totalEstimate }; } 1.3. Template References @Component({ selector: 'app-root', template: ` {{loginText}} {{signUpText}} `, }) export class AppComponent implements OnInit { @ViewChild('defaultTabButtons') private defaultTabButtonsTpl: TemplateRef; ngOnInit() { console.log(this.defaultTabButtonsTpl); } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/official_learning/": {
    "url": "Angular/official_learning/",
    "title": "Angular/official_learning",
    "keywords": "",
    "body": "1. TOC1. TOC providers Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Angular/official_learning/providers.html": {
    "url": "Angular/official_learning/providers.html",
    "title": "providers",
    "keywords": "",
    "body": "1. Fundamental / NgModules / Providers + Singleton services1.1. Provider Scope1.1.1. I. providedIn and NgModules1.1.2. II. Limiting provider scope by lazy loading modules1.1.3. III. Limiting provider scope with components1.2. Providing services in modules vs. components1. Fundamental / NgModules / Providers + Singleton services ng generate service user ng g s user By default, this decorator has a providedIn property, which creates a provider for the service import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root', // 'root' specifies that Angular should provide the service in the root injector. // ** providedIn: 'root' creates Singleton service ** }) export class UserService {} 1.1. Provider Scope You should always provide your service in the root injector unless there is a case where you want the service to be available only if the consumer imports a particular @NgModule. 1.1.1. I. providedIn and NgModules It's also possible to specify that a service should be provided in a particular @NgModule. For example, if you don't want UserService to be available to applications unless they import a UserModule you've created, you can specify that the service should be provided in the module: Preferred way: enables tree-shaking of the service if nothing injects it. // user.service.ts import { Injectable } from '@angular/core'; import { UserModule } from './user.module'; @Injectable({ providedIn: UserModule, }) export class UserService {} Another way: No tree-shaking import { NgModule } from '@angular/core'; import { UserService } from './user.service'; @NgModule({ providers: [UserService], }) export class UserModule {} 1.1.2. II. Limiting provider scope by lazy loading modules When the Angular router lazy-loads a module, it creates a new injector. This injector is a child of the root application injector. Imagine a tree of injectors; there is a single root injector and then a child injector for each lazy loaded module. The router adds all of the providers from the root injector to the child injector. 当 Angular 的路由器惰性加载一个模块时，它会创建一个新的注入器。这个注入器是应用的根注入器的一个子注入器。想象一棵注入器树，它有唯一的根注入器，而每一个惰性加载模块都有一个自己的子注入器。路由器会把根注入器中的所有提供商添加到子注入器中。如果路由器在惰性加载时创建组件， Angular 会更倾向于使用从这些提供商中创建的服务实例，而不是来自应用的根注入器的服务实例。 任何在惰性加载模块的上下文中创建的组件（比如路由导航），都会获取该服务的局部实例，而不是应用的根注入器中的实例。而外部模块中的组件，仍然会收到来自于应用的根注入器创建的实例。 虽然你可以使用惰性加载模块来提供实例，但不是所有的服务都能惰性加载。比如，像路由之类的模块只能在根模块中使用。路由器需要使用浏览器中的全局对象 location 进行工作。 1.1.3. III. Limiting provider scope with components when you want to eagerly load a module that needs a service all to itself. Providing a service in the component limits the service only to that component (other components in the same module can’t access it.) @Component({ /* . . . */ providers: [UserService] }) 1.2. Providing services in modules vs. components Providing services in modules: Generally, provide services the whole app needs in the root module (Singleton) and scope services by providing them in lazy loaded modules. Providing services in components: (Non-Singleton) Register a provider with a component when you must limit a service instance to a component and its child components. For example, a user editing component, UserEditorComponent, that needs a private copy of a caching UserService should register the UserService with the UserEditorComponent. Then each new instance of the UserEditorComponent gets its own cached service instance. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/performance.html": {
    "url": "Angular/performance.html",
    "title": "performance",
    "keywords": "",
    "body": "1. Performance1.1. 1. ChangeDetection OnPush1.2. 2. trackBy1.2.1. Understanding *ngFor mechanisms:1.2.2. When to Use trackBy:1.3. 3. Avoid Computing Values in the Template1.4. 4. Disable Change Detection1.5. 5. Using Lazy Loading1.6. 6. Executing event handlers quickly1.7. 7. Input setters and OnChanges1.8. 8. AOT1.9. Reference1. Performance Runtime performance in Angular ties to its change detection process, which includes three steps: Run event handlers Update data bindings Propagate DOM updates and repaint Angular must wait for the event handler's callback to finish before change detection can continue and the update rendered. 1.1. 1. ChangeDetection OnPush By default, Angular runs change detection on all components every time something changes in your app — from a click event to data received from an ajax call. ( user events, timers, xhr, promises, etc. ) What if we could help Angular and give her a better indication of when to check our component? We can set the ChangeDetectionStrategy of our component to ChangeDetectionStrategy.OnPush. This tells Angular that the component only depends on his Inputs and needs to be checked in only the following cases: The Input reference changes. An event occurred from the component or one of his children. You run change detection explicitly by calling detectChanges()/tick()/markForCheck(). 1.2. 2. trackBy 1.2.1. Understanding *ngFor mechanisms: By default, when you use ngFor without trackBy, ngFor tracks array of objects changing through object identity so if new reference of array of objects is passed to the directive even if the array is with the same values, angular will not be able to detect that they are already drawn and presented in the current DOM but instead, old elements will be removed and new collection with the same values will be redrawn. 1.2.2. When to Use trackBy: Iterating over large array of objects collection In case your business logic might need to modify any of these elements through reordering, modifying specific item, deleting item, or adding a new one. 1.3. 3. Avoid Computing Values in the Template @Component({ selector: 'skills', template: ` {{ skill.calcSomething(skill) }} `, }) export class SkillsComponent { calcSomething(skill) { //... } } Reason: Angular needs to re-run your function in every change detection cycle, if the function performs expensive tasks, it can be costly. Solution: If the value is not changed dynamically at runtime, a better solution would be to: Use pure pipes — Angular executes a pure pipe only when it detects a pure change to the input value. (Angular caches the results of previous executions) Creates a new property and set the value once, for example: this.skills = this.skills.map(skill => ({ ...skill, percentage: calcSomething(skill) }); 1.4. 4. Disable Change Detection Imagine that you have a component that depends on data that changes constantly, many times per second. Updating the user interface whenever new data arrives can be expensive. A more efficient way would be to check and update the user interface every X seconds. We can do that by detaching the component’s change detector and conducting a local check every x seconds. @Component({ selector: 'giant-list', template: ` Data {{d}} `, }) class GiantList { constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) { ref.detach(); setInterval(() => { this.ref.detectChanges(); }, 5000); } } Advanced example: import { Component, Input, AfterViewInit, ChangeDetectionStrategy, ChangeDetectorRef, } from '@angular/core'; @Component({ selector: 'app-instructor-list', templateUrl: './instructor-list.component.html', changeDetection: ChangeDetectionStrategy.OnPush, }) export class InstructorListComponent implements AfterViewInit { // Suppose this time the instructor list doesn't change after it arrives @Input() instructors = []; constructor(private cdr: ChangeDetectorRef) {} // Wait until the view inits before disconnecting ngAfterViewInit() { // Since we know the list is not going to change // let's request that this component not undergo change detection at all this.crd.detach(); } // Angular provides additional controls such as the following // if the situation allows // Request a single pass of change detection for the application // this.cdr.markForCheck(); // Request a single pass of change detection for just this component // this.cdr.detectChanges(); // Connect this component back to the change detection process // this.cdr.reattach(); } 1.5. 5. Using Lazy Loading 1.6. 6. Executing event handlers quickly Search {{ instructor }} // app.component.ts import { Component } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: 'app.component.html', }) export class AppComponent { public instructors = []; searchTerm = ''; constructor(private ls: ListService) { this.instructors = ls.getList(this.searchTerm); } // Executes when user clicks the \"Search\" button. // Execution will flow into getList to perform the search. // The results arrive back into the update method and assigned // to the component. // All of this happens within the same change detection cycle. update() { this.instructors = this.ls.getList(this.searchTerm); // ajax can be slow } } // list-service.ts import { Injectable } from '@angular/core'; @Injectable() export class ListService { private instructorList = [ 'Paul Spears', 'Andrew Wiens', 'John Baur', 'Rachel Noccioli', 'Lance Finney', ]; getList(searchTerm: string) { // Though this is a simple search or a small data set, // As the data grows in length and complexity the performance of this method // will likely degrade. return this.instructorList.filter((instructor) => { return instructor === searchTerm || searchTerm === ''; }); } } Change detection process cannot complete until all callbacks and their subsequent method calls have finished executing: 1.7. 7. Input setters and OnChanges export class ChildComponent implements OnChanges { @Input() set incomingValue(val) { // this method is executed every time the value is updated by parent component } @Input() otherValues; ngOnChanges(changes: SimpleChanges) { // This method is executed every time // ANY input is updated by parent component } } Generally, problematic situations are created in the callbacks of the input setters and ngOnChanges relatively infrequently. It is often easier to spot problems when they do occur as issues are usually isolated to a single component. However, there are still a couple hazardous scenarios to point out. It is usually recommended to compute any state or UI changes needed as part of the event propagation phase of the change detection cycle. However, some situations may still occur that encourage the use of OnChanges to compute additional state needed locally within a component. Consider the filtered list example: For the sake of argument, assume that the current filter criteria and the unfiltered list are only available as inputs, and the filtered results must be computed immediately prior to display. export class ChildComponent implements OnChanges { @Input() instructorList = []; @Input() searchTerm = ''; filteredList = []; ngOnChanges(changes: SimpleChanges) { // This method is executed every time // ANY input is updated by parent component this.filteredList = this.instructorList.filter((d) => { return d === this.searchTerm || this.searchTerm === ''; }); } } This could be achieved by utilizing OnChanges. However, doing so would cause every input change to trigger a recalculation of the filtered list. If another input were added to the component, there would be a wasted calculation every time the new input value is changed. export class ChildComponent implements OnChanges { @Input() instructorList = []; @Input() searchTerm = ''; @Input() selectedInstructor; filteredList = []; // avoid using it if you can ngOnChanges(changes: SimpleChanges) { // this guard will reduce some waste but still not ideal if (changes['instructorList'] || changes['searchTerm']) { this.filteredList = this.instructorList.filter((d) => { return d === this.searchTerm || this.searchTerm === ''; }); } } } Input setters serve a similar purpose as OnChanges, however they only fire in response to updates to a corresponding input. Generally speaking, the use of input setters will lead to more performant change handlers as there is no need for identifying which input changed, nor will it be called more often than is necessary. Although the granularity of input setters make for a better default choice, it is still possible to populate the callbacks with expensive operations, and they should be treated with the same level of care as OnChanges. export class ChildComponent implements OnChanges { @Input() set instructorList(val) { this.filteredList = val.filter((d) => { return d === this.searchTerm || this.searchTerm === ''; }); } @Input() set searchTerm(val) { this.filteredList = this.instructorList.filter((d) => { return d === val || val === ''; }); } @Input() selectedInstructor; filteredList = []; } 1.8. 8. AOT The goal of change detection is to translate data changes into a newly-rendered view by updating DOM attributes. Angular runs in just-in-time (JIT) mode by default where its interpretation of component templates is executed as part of the digest cycle. This mode of operation is great when building and debugging an application, but it adds significant overhead in the browser at run time. Compiling Angular using the command line interface (CLI) with both prod mode and ahead-of-time (AOT) compiling reduces this overhead by precompiling the application’s component templates and removing the need for JIT processing. 1.9. Reference https://netbasal.com/optimizing-the-performance-of-your-angular-application-f222f1c16354 https://blog.oasisdigital.com/2017/angular-runtime-performance-guide/ Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/retry.html": {
    "url": "Angular/retry.html",
    "title": "retry",
    "keywords": "",
    "body": "1. Error handling -- retry1.1. Immediate retry1.2. Delay retry1.3. references1. Error handling -- retry 1.1. Immediate retry const http$ = this.http.get('/api/courses'); http$ .pipe( tap(() => console.log('HTTP request executed')), map((res) => Object.values(res['payload'])), shareReplay(), retryWhen((errors) => { return errors.pipe(tap(() => console.log('retrying...'))); }), ) .subscribe( (res) => console.log('HTTP response', res), (err) => console.log('HTTP Error', err), () => console.log('HTTP request completed.'), ); 1st failed, 2nd succeeded: 1.2. Delay retry const http$ = this.http.get('/api/courses'); http$ .pipe( tap(() => console.log('HTTP request executed')), map((res) => Object.values(res['payload'])), shareReplay(), retryWhen((errors) => { return errors.pipe( delayWhen(() => timer(2000)), // delay 2 seconds if error tap(() => console.log('retrying...')), take(10), // Only retry 10 times ); }), ) .subscribe( (res) => console.log('HTTP response', res), (err) => console.log('HTTP Error', err), () => console.log('HTTP request completed.'), ); let's remember that the function passed to retryWhen is only going to be called once we are returning in that function an Observable that will emit values whenever a retry is needed each time that there is an error, the delayWhen operator is going to create a duration selector Observable, by calling the timer function this duration selector Observable is going to emit the value 0 after 2 seconds, and then complete once that happens, the delayWhen Observable knows that the delay of a given input error has elapsed only once that delay elapses (2 seconds after the error occurred), the error shows up in the output of the notification Observable once a value gets emitted in the notification Observable, the retryWhen operator will then and only then execute a retry attempt Here is an example of an HTTP request that was retried 5 times, as the first 4 times were in error: And here is the network log for the same retry sequence: 1.3. references https://blog.angular-university.io/rxjs-error-handling/ Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/route.html": {
    "url": "Angular/route.html",
    "title": "route",
    "keywords": "",
    "body": "1. Route1.1. Route config1.2. ActivatedRoute params subscribe1.3. Navigate by Router1.4. ActivatedRoute to query params1.5. RouteStateSnapshot vs RouteState1. Route 1.1. Route config Suppose we are building a small app and we only have a app routing and all components are registered in app.module. import { Routes } from '@angular/router'; import { About } from './about/about'; import { Home } from './home/home'; import { RepoBrowser } from './github/repo-browser/repo-browser'; import { RepoList } from './github/repo-list/repo-list'; import { RepoDetail } from './github/repo-detail/repo-detail'; export const rootRouterConfig: Routes = [ { path: '', redirectTo: 'home', terminal: true }, { path: 'home', component: Home }, { path: 'about', component: About }, { path: 'github', component: RepoBrowser, children: [ { path: '', component: RepoList }, { path: ':org', component: RepoList, children: [{ path: '', component: RepoDetail }, { path: ':repo', component: RepoDetail }], }, ], }, ]; 1.2. ActivatedRoute params subscribe List of models: Repo list {{ repo.name }} import { Component, OnInit } from '@angular/core'; import { GithubService } from '../services/github.service'; import { Observable } from 'rxjs/Observable'; import { ActivatedRoute } from '@angular/router'; @Component({ selector: 'repo-list', styleUrls: ['./repo-list.css'], templateUrl: './repo-list.html', }) export class RepoList implements OnInit { org: string; repos: Observable; constructor(public githubService: GithubService, private route: ActivatedRoute) {} ngOnInit() { this.route.params.subscribe((params) => { this.org = params['org']; if (this.org) { this.repos = this.githubService.getReposForOrg(this.org); } }); } } 1.3. Navigate by Router Above List of Models, there is a search area. When clicking the button, the page navigates to Single Model detail page. Search Orgs import { Component } from '@angular/core'; import { Router } from '@angular/router'; import { GithubService } from '../services/github.service'; @Component({ selector: 'repo-browser', templateUrl: './repo-browser.html', styleUrls: ['./repo-browser.css'], }) export class RepoBrowser { constructor(private router: Router, private githubService: GithubService) {} searchForOrg(orgName: string) { this.githubService.getOrg(orgName).subscribe(({ name }) => { console.log(name); this.router.navigate(['/github', orgName]); }); } } 1.4. ActivatedRoute to query params Model detail page: {{ repoDetails.full_name }} this.repoDetails = {{ repoDetails | json }} import { Component, OnInit } from '@angular/core'; import { ActivatedRoute, Router } from '@angular/router'; import { GithubService } from '../services/github.service'; @Component({ selector: 'repo-detail', styleUrls: ['./repo-detail.css'], templateUrl: './repo-detail.html', }) export class RepoDetail implements OnInit { private org: string; private repo: string; public repoDetails: any = {}; constructor( public githubService: GithubService, private router: Router, private route: ActivatedRoute, ) {} ngOnInit() { this.route.params.subscribe((params) => { // query previous route info this.org = this.router.routerState.parent(this.route).snapshot.params['org']; this.repo = params['repo'] || ''; if (this.repo) { this.githubService.getRepoForOrg(this.org, this.repo).subscribe((repoDetails) => { this.repoDetails = repoDetails; }); } }); } } 1.5. RouteStateSnapshot vs RouteState RouteStateSnapshot is an immutable data structure representing the state of the router at a particular moment in time. Any time a component is added or removed or parameter is updated, a new snapshot is created. RouterState is similar to RouteStateSnapshot, except that it represents the state of the router changing over time. ActivatedRoute: ActivatedRoute provides access to the url, params, data, queryParams, and fragment observables Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/rxjs_best_practice.html": {
    "url": "Angular/rxjs_best_practice.html",
    "title": "rxjs_best_practice",
    "keywords": "",
    "body": "1. RxJS best practices in Angular1.1. Pipeable/lettable operators1.2. Using pure functions1.3. Avoiding memory leaks1.4. Avoiding nested subscribes1.5. Avoiding manual subscribes in Angular1.6. Don’t pass streams to components directly1.7. Don’t pass streams to services1.8. Sharing subscriptions1.9. When to use Subjects1.10. Clean code practices1.11. Angular embraces RxJS1. RxJS best practices in Angular 1.1. Pipeable/lettable operators Since version 5.5 RxJS has introduced these so called pipeable operators which are easier to import than patch operators, and also have treeshaking advantages. For application developers, lettable operators are much easier to manage: Rather then relying upon operators being patched into Observable.prototype, lettable operators are explicitly imported into the modules in which they are used. It’s easy for TypeScript and bundlers to determine whether the lettable operators imported into a module are actually used. And if they are not, they can be left unbundled. If prototype patching is used, this task is manual and tedious. For library authors, lettable operators are much less verbose than call-based alternative, but it’s the correct inference of types that is — the biggest advantage. This example illustrates the difference between doing it the old way and the new way. // BAD: This is the old way and should be avoided (patch operators) // as we can see the operators (filter, map) are part of the // Observable prototype import 'rxjs/add/operator/filter'; import 'rxjs/add/operator/map'; const new$ = Observable.interval$.filter((v) => v % 2 === 0).map((v) => v * 2); // GOOD: This is the new and improved way (lettable operators) // we just use the pipe operator where we pass operators that // we can import from 'rxjs/operators' import { filter, map } from 'rxjs/operators'; const new$ = interval$.pipe(filter((v) => v % 2 === 0), map((v) => v * 2)); 1.2. Using pure functions RxJS follows the concepts of functional reactive programming which basically means that we will use pure functions to create our reactive flow. A function is pure when: It doesn’t mutate anything It will always return the same value based on the same parameters It doesn’t have any side effects. It can’t mutate state outside of the function In the beginning it might seem pragmatic to use side effects, but that mostly means we aren’t fully thinking reactively. Therefore avoid side effects at much as possible. 1.3. Avoiding memory leaks To consume a stream we need to subscribe to that stream. When we subscribe to that stream a subscription will be created. That subscription will keep on living until the stream is completed or until we unsubscribe manually from that stream. Managing subscriptions is very important and in a number of cases we will have to manually unsubscribe an existing subscription to avoid memory leaks. Take this example for instance: class AppComponent implements OnInit { ngOnInit() { // The following stream will produce values every second // 0--1--2--3--4--5--6--... const interval$ = interval(1000); // Even when this component gets destroyed, // the stream will keep producing values... // This means the console will keep on logging // This is a classic example of a memory-leak const subscription = interval$.subscribe((r) => console.log(r)); } } To remove the memory-leak in this component we can keep track of the subscriptions by taking advantage of the ngOnDestroy() lifecycle hook of Angular: class AppComponent implements OnInit, OnDestroy { subscriptions = []; ngOnInit() { const interval$ = interval(1000); const subscription = interval$.subscribe((r) => console.log(r)); // manually keep track of the subscriptions in a subscription array this.subscriptions.push(subscription); } ngOnDestroy() { // when the component get's destroyed, unsubscribe all the subscriptions this.subscriptions.forEach((sub) => sub.unsubscribe()); } } However, when we are using a bunch of subscriptions, it can become quite dirty. Before, we talked about the fact that a subscription will live until we manually unsubscribe (like we just did in the snippet above), but also until the stream gets completed. A cool way to handle this issue is to use a Subject that we next in the ngOnDestroy() lifecycle hook of Angular: class AppComponent implements OnInit, OnDestroy { destroy$ = new Subject(); ngOnInit() { // interval$: 0--1--2--3--4--5--6--... // destroy$: -------------true| // result: 0--1--2--3--4| const interval$ = interval(1000); interval$ // let the interval$ stream live // until the destroy$ Subject gets a value .pipe(takeUntil(this.destroy$)) .subscribe((r) => console.log(r)); } ngOnDestroy() { // when the component get's destroyed, pass something to the destroy$ Subject this.destroy$.next(true); } } 1.4. Avoiding nested subscribes Nesting subscribes is something that needs to be avoided as much as possible. It makes the code unreadable, complex, and introduces side effects. It basically forces you to NOT think reactively. Take this Angular example for instance: class AppComponent { user: User; constructor(private route: ActivatedRoute, private userService: UserService) { // when the params of the route changes, // we want to fetch the user and set the user property // // VERY BAD: nesting subscribes is ugly and takes away // the control over a stream this.route.params .pipe(map((v) => v.id)) .subscribe((id) => this.userService.fetchById(id).subscribe((user) => (this.user = user))); } } The previous implementation is considered a bad-practice. It’s recommended to use higher-order streams like mergeMap or switchMap. Let’s have a look at this example: class AppComponent { user: User; constructor(private route: ActivatedRoute, private userService: UserService) { // when the params of the route changes, // we want to fetch the user and set the user property // // GOOD: we have created a single subscribe which makes // the flow way easier and gives us the control we need this.route.params .pipe(map((v) => v.id), switchMap((id) => this.userService.fetchById(id))) .subscribe((user) => (this.user = user)); } } 1.5. Avoiding manual subscribes in Angular To consume a stream we need to subscribe that stream, that’s simply how observables work. But what if a component needs values from 5 different streams… Would that mean, that we want to subscribe to all of these streams and manually map all the values to unique properties, just to make it work? That would suck, right?! Angular has this super cool feature called the async pipe. It’s used to consume streams directly in the template The async pipe does 3 things for us: It subscribes to the stream and passes the value to a component It unsubscribes automatically when the component gets destroyed (removes a lot of unsubscribe logic) Triggers change detection automatically This means we don’t have to manually subscribe nor unsubscribe anymore. Which cleans up the code a lot. Let’s have a look at the cleaned up previous example: @Component({ ... template: ` ` }) class AppComponent { // expose a user$ stream that will be // subscribed in the template with the async pipe user$ = this.route.params.pipe( map(v => v.id), switchMap(id => this.userService.fetchById(id)) ); constructor( private route: ActivatedRoute, private userService: UserService) { } } 1.6. Don’t pass streams to components directly One of the most important aspects of software architecture might be the concept of decoupling pieces of code. Therefore we could consider passing streams to child components as a bad practice because it creates a very tight link between the parent component and the child component. They are no longer decoupled since subscriptions in the child component might trigger actions in the parent component. We never want the child component to be responsible of initiating data calls right?! That’s the task of the smart component. See the difference between smart and dumb components here. A component should always receive an object or value and should not even care if that object or value comes from a stream or not. // BAD // app.component.ts @Component({ selector: 'app', template: ` ` }) class AppComponent { // this http call will get called when the // user-detail component subscribes to users$ // We don't want that users$ = this.http.get(...); ... } // user-detail.component.ts @Component({ selector: 'user-detail', template: `` }) class UserDetailComponent implements OnInit { @Input() user$: Observable; user: User; ngOnInit(){ // WHOOPS! This child component subscribes to the stream // of the parent component which will do an automatic XHR call // because Angular HTTP returns a cold stream this.user$.subscribe(u => this.user = u); } } It would be better to handle the subscription in the parent component itself: // GOOD // app.component.ts @Component({ selector: 'app', template: ` ` }) class AppComponent implements OnInit { users$: Observable = this.http.get(...); user: User; ngOnInit(){ // the app component (smart) subscribes to the user$ which will // do an XHR call here this.users$ = this.http.get(...); } ... } // user-detail.component.ts @Component({ selector: 'user-detail', template: `` }) class UserDetailComponent { // This component doesn't even know that we are using RxJS which // results in better decoupling @Input() user: User; } The responsibility of the component is clear. The user-detail is meant to be dumb and is completely decoupled from its parent. There are however situations where we would like to create a stream from an input. In that case we could take a look at this library: ngx-reactivetoolkit 1.7. Don’t pass streams to services Although, it might seem like a pragmatic solution to pass streams directly to services, it could be seen as a bad practice if we consider the decoupling again. By passing a stream to a service we don’t know what’s going to happen to it. The stream could be subscribed to, or even combined with another stream that has a longer lifecycle, that could eventually determine the state of our application. Subscriptions might trigger unwanted behavior. And after all, services don’t care that your components are using streams. Take this example for instance: // BAD // app.component.ts class AppComponent { users$ = this.http.get(...) filteredusers$ = this.fooService .filterUsers(this.users$); // Passing stream directly: BAD ... } // foo.service.ts class FooService { // return a stream based on a stream // BAD! because we don't know what will happen here filterUsers(users$: Observable): Observable { return users$.pipe( map(users => users.filter(user => user.age >= 18)) } } It would be better to use higher order streams for these situations. Use switchMap over mergeMap if possible, since it will unsubscribe the previous stream. The following example is better since all the RxJS logic is centralized in one place where the subscribing and unsubscribing happens: The smart component. // GOOD // app.component.ts class AppComponent { users$ = this.http.get(...) filteredusers$ = this.users$ .pipe(switchMap(users => this.fooService.filterUsers(users))); ... } // foo.service.ts class FooService { // this is way cleaner: this service doesn't even know // about streams now filterUsers(users: User): User[] { return users.pipe(filter(user => user.age >= 18); } } 1.8. Sharing subscriptions Since most streams are cold by default, every subscription will trigger the producer of these streams. The execution of the producer logic on every subscription, might not be what we want if we have multiple subscriptions. Eg. Subscribing to Angular its http.get() multiple times will actually perform multiple xhr calls. The following example will trigger the xhr call twice because numberOfUsers$ depends on users$. @Component({ selector: 'app', template: ` Number of users: {{numberOfUsers$|async}} ` }) // BAD class AppComponent { users$ = this.http.get(...) // the subscription on this stream will execute the xhr call again numberOfUsers$ = this.users$.pipe(map(v => v.length); } In those cases we might want to share the subscriptions. The following example uses the share() operator: @Component({ selector: 'app', template: ` Number of users: {{numberOfUsers$|async}} ` }) // GOOD class AppComponent { users$ = this.http.get(...).pipe(share()); numberOfUsers$ = this.users$.pipe(map(v => v.length); } Sharing a stream makes it hot. This means that if we subscribe after the value is produced, we will miss that value. In that case we might want to use shareReplay(1) instead of share(). This will keep the last value in memory for us. It’s a common mistake to share everything. We don’t always want to work with hot streams and sharing subscriptions comes with a small performance cost.Also, lazy streams have their advantages. Angular also provides a great alternative that can reduce the sharing of streams to a minimum by using the async as else syntax.. Personally I would consider the use of this feature as a best practice. The following example reduces the number of streams, the number of subscriptions and gives us an easy way to show a loading indicator. @Component({ selector: 'app', template: ` Number of users: Loading... ` }) class AppComponent { // This stream will only subscribed to once users$ = this.http.get(...); } 1.9. When to use Subjects A Subject is both a hot observable and an observer at the same time. This gives us the opportunity to next values into the stream ourselves. Subjects tend to be overused by people that didn’t make the mind switch towards reactive programming yet. Only use them when really needed, for instance it’s ok to use Subjects in the following scenarios: When mocking streams in tests const fetchAll$ = new Subject(); // use a Subject as a mock usersServiceMock.fetchAll.mockReturnValue(fetchAll$); fetchAll$.next(fakeUser); When we want to create streams from outputs in Angular @Component({ ... template: ` ` }) class AppComponent { search$ = new Subject(); // ----t-----te-----ter----term... } When handling circular references I’m not going to dive in this to deep, but Dominic Elm does an awesome job explaining this in this great article For most other cases an operator or Observable.create might be enough. Note: A BehaviorSubject is commonly used because it has a getValue() function. That would also be considered a bad practice. When we are trying to fetch a specific value it usually means we are not thinking reactive. 1.10. Clean code practices Consistent code indentation and formatting can improve the readability of complex streams: Align operators below each other foo$.pipe( map(...) filter(...) tap(...) ) Extract into different streams when it becomes unreadable Put complexer functionality in private methods (make the reactive flow clear) Avoid the use of brackets for readability, that’s personal preference. 1.11. Angular embraces RxJS We already saw a glimpse of why Angular is a framework that really embraces the use of RxJS. Therefore it’s recommended to use the functionality that Angular provides. The ActivatedRoute has exposes a params stream. The HttpClient both return streams The Form and FormControl both have a valueChanges property that returns a stream The async pipe is an awesome feature that really helps us to use the streams in our templates Using the ngOnInit() lifecycle function to initialize streams can help us for mocking purposes Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/rxjs_help.html": {
    "url": "Angular/rxjs_help.html",
    "title": "rxjs_help",
    "keywords": "",
    "body": "1. Rxjs helpful functions1.1. The rule combination to use to enforce a lettable-operator-only policy would be:1. Rxjs helpful functions // retry.ts import { Observable } from 'rxjs/Observable'; import { delay, retryWhen, scan } from 'rxjs/operators'; export function retry(count: number, wait: number): (source: Observable) => Observable { return retryWhen((errors) => errors.pipe( // Each time an error occurs, increment the accumulator. // When the maximum number of retries have been attempted, throw the error. scan((acc, error) => { if (acc >= count) { throw error; } return acc + 1; }, 0), // Wait the specified number of milliseconds between retries. delay(wait), ), ); } // demo import { ajax } from 'rxjs/observable/dom/ajax'; import { of } from 'rxjs/observable/of'; import { catchError, map } from 'rxjs/operators'; import { retry } from './retry'; const name = ajax .getJSON('/api/employees/alice') .let(retry(3, 1000)) .map((employee) => employee.name) .catch((error) => of(null)); // OR const name = ajax .getJSON('/api/employees/alice') .pipe(retry(3, 1000), map((employee) => employee.name), catchError((error) => of(null))); 1.1. The rule combination to use to enforce a lettable-operator-only policy would be: https://github.com/ReactiveX/rxjs-tslint: // tslint.json { \"rulesDirectory\": [\"node_modules/rxjs-tslint\"], \"rules\": { \"rxjs-collapse-imports\": true, \"rxjs-pipeable-operators-only\": true, \"rxjs-no-static-observable-methods\": true, \"rxjs-proper-imports\": true } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/something.html": {
    "url": "Angular/something.html",
    "title": "something",
    "keywords": "",
    "body": "1. Something useful staff1.1. *ngIf, [hidden]1.2. Class1.3. Style1. Something useful staff 1.1. *ngIf, [hidden] *ngIf removes DOM. [hidden] = \"condition\" hides DOM. 1.2. Class [class.green] = \"condition\" [ngClass] = \"{ green: condition, alert: condition }\" [ngClass] = \"aFun()\" aFun () { return { green: condition, alert: condition } // or return [ 'class1', 'class2' ] // or return 'class1 class2' } 1.3. Style [style.color] = \"a === a ? '#fff': '#000'\" [ngStyle] = \"{ color: a === a ? '#fff': '#000', background: b === b ? 'yellow': 'green' }\" Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Angular/subject.html": {
    "url": "Angular/subject.html",
    "title": "subject",
    "keywords": "",
    "body": "1. Difference between Subject and BehaviorSubject1.1. BehaviorSubject1.2. Subject1. Difference between Subject and BehaviorSubject A BehaviorSubject holds one value. When it is subscribed it emits the value immediately. A Subject doesn't hold a value. Subject example (with RxJS 5 API): const subject = new Rx.Subject(); subject.next(1); subject.subscribe((x) => console.log(x)); Console output will be empty BehaviorSubject example: const subject = new Rx.BehaviorSubject(); subject.next(1); subject.subscribe((x) => console.log(x)); 1.1. BehaviorSubject BehaviorSubject will return the initial value or the current value on Subscription var subject = new Rx.BehaviorSubject(0); // 0 is the initial value subject.subscribe({ next: (v) => console.log('observerA: ' + v), // output initial value, then new values on `next` triggers }); subject.next(1); // output new value 1 for 'observer A' subject.next(2); // output new value 2 for 'observer A', current value 2 for 'Observer B' on subscription subject.subscribe({ next: (v) => console.log('observerB: ' + v), // output current value 2, then new values on `next` triggers }); subject.next(3); With output: observerA: 0; observerA: 1; observerA: 2; observerB: 2; observerA: 3; observerB: 3; 1.2. Subject Subject doesnot return the current value on Subscription. It triggers only on .next(value)call and return/output the value var subject = new Rx.Subject(); subject.next(1); //Subjects will not output this value subject.subscribe({ next: (v) => console.log('observerA: ' + v), }); subject.subscribe({ next: (v) => console.log('observerB: ' + v), }); subject.next(2); subject.next(3); With the following output on the console: observerA: 2; observerB: 2; observerA: 3; observerB: 3; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/": {
    "url": "Basic/",
    "title": "Basic",
    "keywords": "",
    "body": "1. TOC1. TOC design_pattern hash 碰撞 IaaS-PaaS-SaaS 的区别 nodejs_interview oop performance shift_operator sql to learn webpack 原理 代理 代码优化 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Basic/algorithm/": {
    "url": "Basic/algorithm/",
    "title": "Basic/algorithm",
    "keywords": "",
    "body": "1. TOC1. TOC array_vs_linkedList 算法 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Basic/algorithm/array_vs_linkedList.html": {
    "url": "Basic/algorithm/array_vs_linkedList.html",
    "title": "array_vs_linkedList",
    "keywords": "",
    "body": "1. Array vs Linked list1. Array vs Linked list Array Linked List Cost of accessing an element O(1) O(n) Storage feature Continuous block Separate Memory requirement Fixed size (some may unused); May not be available as a large block; Good for small type, int. No unused memory; but extra memory for pointer variables; Usually available for multiple small blocks; Good for storing complex type (16 bytes), Node type (4 byte), totally 20 for one whole (complex)(pointerNode) -> Cost of inserting an element At beginning: o(n), shifting all elements by 1 index; At end: o(1); Avg: o(n) At beginning: o(1); At end: o(n); Avg: o(n) Ease of use Easy hard Dynamic list: first allocating a fixed size array in memory. When adding extra elements which above the size, it creates a double size array in new memory address and copies original array to new array, so this is costing. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/algorithm/算法.html": {
    "url": "Basic/algorithm/算法.html",
    "title": "算法",
    "keywords": "",
    "body": "1. 算法1. 算法 https://juejin.im/entry/58759e79128fe1006b48cdfd https://segmentfault.com/a/1190000009857470 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/amazon/": {
    "url": "Basic/amazon/",
    "title": "Basic/amazon",
    "keywords": "",
    "body": "1. TOC1. TOC leadership_principles online_assessment prep system_design Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Basic/amazon/leadership_principles.html": {
    "url": "Basic/amazon/leadership_principles.html",
    "title": "leadership_principles",
    "keywords": "",
    "body": "1. Amazon leadership principles1. Amazon leadership principles Customer Obsession real-time chat UPMC mapQuest Leaders start with the customer and work backwards. They work vigorously to earn and keep customer trust. Although leaders pay attention to competitors, they obsess over customers. Ownership Ub tahoe: instead of a beautiful dropdownList, accordion, implement a reusable plugin, although the layout stays ugly for a while, long-term, easy to maintain, more efficient to use in future. in SNH, SMS message, angular issue, other teams, they ask for help and I help Leaders are owners. They think long term and don’t sacrifice long-term value for short-term results. They act on behalf of the entire company, beyond just their own team. They never say “that’s not my job\". Invent and Simplify Unity xml T4 log4net + redis/queue Leaders expect and require innovation and invention from their teams and always find ways to simplify. They are externally aware, look for new ideas from everywhere, and are not limited by “not invented here\". As we do new things, we accept that we may be misunderstood for long periods of time. Are Right, A Lot performance UnitOfWork, Cache reusable dropdown plugin Leaders are right a lot. They have strong judgment and good instincts. They seek diverse perspectives and work to disconfirm their beliefs. Learn and Be Curious how memcache achieve distribute cache? how to use nosql to improve db performance instead of too many joins? Leaders are never done learning and always seek to improve themselves. They are curious about new possibilities and act to explore them. Hire and Develop the Best no hire experience, but in Tahoe, I introduced ES2015, naming convention, coding style help new employees (Vishal) with angular Leaders raise the performance bar with every hire and promotion. They recognize exceptional talent, and willingly move them throughout the organization. Leaders develop leaders and take seriously their role in coaching others. We work on behalf of our people to invent mechanisms for development like Career Choice. Insist on the Highest Standards UPMC mapQuest, based on customer feedback performance Cache, best user experience Leaders have relentlessly high standards - many people may think these standards are unreasonably high. Leaders are continually raising the bar and driving their teams to deliver high quality products, services and processes. Leaders ensure that defects do not get sent down the line and that problems are fixed so they stay fixed. Think Big instead of single beautiful dropdownList, create reusable, maintainable plugin create a jquery-like helper library, helperClass Thinking small is a self-fulfilling prophecy. Leaders create and communicate a bold direction that inspires results. They think differently and look around corners for ways to serve customers. Bias for Action UPMC chart.js, open-source to create charts instead of microsoft server-generated images Speed matters in business. Many decisions and actions are reversible and do not need extensive study. We value calculated risk taking. Frugality find open source chart plugin -- chart.js Accomplish more with less. Constraints breed resourcefulness, self-sufficiency and invention. There are no extra points for growing headcount, budget size or fixed expense. Earn Trust admit mistake when SPA layout changes, an anchor raises error when peers ask, offer help as much as I can Leaders listen attentively, speak candidly, and treat others respectfully. They are vocally self-critical, even when doing so is awkward or embarrassing. Leaders do not believe their or their team’s body odor smells of perfume. They benchmark themselves and their teams against the best. Dive Deep real-time chat, discuss with peers about database design log4net + redis Leaders operate at all levels, stay connected to the details, audit frequently, and are skeptical when metrics and anecdote differ. No task is beneath them. Have Backbone; Disagree and Commit Jay decides ui and func Leaders are obligated to respectfully challenge decisions when they disagree, even when doing so is uncomfortable or exhausting. Leaders have conviction and are tenacious. They do not compromise for the sake of social cohesion. Once a decision is determined, they commit wholly. Deliver Results UPMC mapQuest result satisfied customer log4net + redis, has setbacks/obstacles, but carry on Leaders focus on the key inputs for their business and deliver them with the right quality and in a timely fashion. Despite setbacks, they rise to the occasion and never settle. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/amazon/online_assessment.html": {
    "url": "Basic/amazon/online_assessment.html",
    "title": "online_assessment",
    "keywords": "",
    "body": "1. Given a movie, find similar movies1.1. balanced Parenthesis1. Given a movie, find similar movies using System; using System.Linq; using System.Collections.Generic; namespace MyCollections { public class Movie { private readonly int movieId; private readonly float rating; private List similarMovies; // Similarity is bidirectional public Movie(int movieId, float rating) { this.movieId = movieId; this.rating = rating; similarMovies = new List(); } public int getId() { return movieId; } public float getRating() { return rating; } public float Rating { get { return rating; } } public int Id { get { return movieId; } } public void addSimilarMovie(Movie movie) { similarMovies.Add(movie); movie.similarMovies.Add(this); } public List getSimilarMovies() { return similarMovies; } /* * Implement a function to return top rated movies in the network of movies * reachable from the current movie * eg: A(Rating 1.2) * / \\ * B(2.4) C(3.6) * \\ / * D(4.8) * In the above example edges represent similarity and the number is rating. * getMovieRecommendations(A,2)should return C and D (sorting order doesn't matter so it can also return D and C) * getMovieRecommendations(A,4) should return A, B, C, D (it can also return these in any order eg: B,C,D,A) * getMovieRecommendations(A,1) should return D. Note distance from A to D doesn't matter, return the highest rated. * * @param movie * @param numTopRatedSimilarMovies: number of movies we want to return * @return List of top rated similar movies */ public static IList getMovieRecommendations(Movie movie, int numTopRatedSimilarMovies) { if (movie == null) { throw new ArgumentNullException(\"movie\"); } HashSet moviesInNetwork = new HashSet(new MovieComparer()); // Flatten the network in a HashSet // Two problems with my implementation: // 1. It's recursive so it won't work for very large networks (as demonstrated in the sample Program below) // 2. It's O(n^2), worst case when every single movie is related to every other movies (n*(n-1)), not so good... GetDistinctMovies(movie, moviesInNetwork); // Order the movies by rating value (descending) and take the number of movies we want to return. // Orderby is a quicksort O(nlog(n)) // I cannot make any assumption concerning the numTopRatedSimilarMovies range so I didn't try to optimize anything here. return (from m in moviesInNetwork orderby m.Rating descending select m).Take(numTopRatedSimilarMovies).ToList(); } private static void GetDistinctMovies(Movie movie, HashSet knownMovies) { // Contains method is O(1) for HashSet if (knownMovies.Contains(movie)) return; // Add method is O(1) for HashSet knownMovies.Add(movie); foreach (var similarMovie in movie.getSimilarMovies()) { GetDistinctMovies(similarMovie, knownMovies); } } /// /// Movie comparer, used in the HashSet constructor. I assumed movie Ids are unique. /// private class MovieComparer : IEqualityComparer { public bool Equals(Movie m1, Movie m2) { return m1.Id == m2.Id; } public int GetHashCode(Movie movie) { return movie.Id; } } } public class Program { public static void Main() { try { Movie.getMovieRecommendations(null, 10); } catch (ArgumentNullException ex) { Console.WriteLine(ex.Message); } var A = new Movie(0, 1.2f); var B = new Movie(1, 2.4f); var C = new Movie(2, 3.6f); A.addSimilarMovie(B); A.addSimilarMovie(C); //B.addSimilarMovie (C); var D = new Movie(3, 4.8f); D.addSimilarMovie(B); D.addSimilarMovie(C); //D.addSimilarMovie (A); ShowRecommentations(A, 2); ShowRecommentations(A, 4); ShowRecommentations(A, 1); Console.WriteLine(\"Now with a very **deep** network\"); Random rating = new Random(); var movieId = 0; var X = new Movie(movieId, (float)rating.NextDouble() * 5); var currentMovie = X; while (movieId 1.1. balanced Parenthesis Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/amazon/prep.html": {
    "url": "Basic/amazon/prep.html",
    "title": "prep",
    "keywords": "",
    "body": "1. Amazon seattle1. Amazon seattle Interviewer 1: Coding & Algorithms & Data Structures Interviewer 2: Coding & Problem Solving Interviewer 3: Problem Solving & Design (logical & maintainable/software) Interviewer 4: Architecture & System Design – This interview will test your understanding of distributed systems, concurrency/multi-threading, etc. Asking clarifying questions and gathering requirements is KEY for this interview. Please use this link to prepare https://www.hackerrank.com/domains/distributed-systems/client-server/page:1 namespace TcpEchoServer { public class TcpEchoServer { public static void Main() { Console.WriteLine(\"Starting echo server...\"); int port = 1234; TcpListener listener = new TcpListener(IPAddress.Loopback, port); listener.Start(); TcpClient client = listener.AcceptTcpClient(); NetworkStream stream = client.GetStream(); StreamWriter writer = new StreamWriter(stream, Encoding.ASCII) { AutoFlush = true }; StreamReader reader = new StreamReader(stream, Encoding.ASCII); while (true) { string inputLine = \"\"; while (inputLine != null) { inputLine = reader.ReadLine(); writer.WriteLine(\"Echoing string: \" + inputLine); Console.WriteLine(\"Echoing string: \" + inputLine); } Console.WriteLine(\"Server saw disconnect from client.\"); } } } } namespace TcpEchoClient { class TcpEchoClient { public static void Main(string[] args) { Console.WriteLine(\"Starting echo client...\"); int port = 1234; TcpClient client = new TcpClient(\"localhost\", port); NetworkStream stream = client.GetStream(); StreamReader reader = new StreamReader(stream); StreamWriter writer = new StreamWriter(stream) { AutoFlush = true }; while (true) { Console.Write(\"Enter text to send: \"); string lineToSend = Console.ReadLine(); Console.WriteLine(\"Sending to server: \" + lineToSend); writer.WriteLine(lineToSend); string lineReceived = reader.ReadLine(); Console.WriteLine(\"Received from server: \" + lineReceived); } } } } [x] Google Amazon parking lot example design [x] https://www.careercup.com/page?pid=trees-and-graphs-interview-questions Google “solve boggle board algorithm” [x] Understand the difference between breadth and depth, when to use each one etc. [x] http://codercareer.blogspot.com/p/binary-tree-interview-questions.html [x] Google “binary search questions” https://www.hackerrank.com/challenges/tree-height-of-a-binary-tree https://www.hackerrank.com/challenges/tree-level-order-traversal https://www.hackerrank.com/challenges/balanced-brackets https://www.hackerrank.com/challenges/contacts https://www.hackerrank.com/challenges/find-the-running-median https://www.hackerrank.com/challenges/swap-nodes-algo Please also review: https://www.hiredintech.com/classrooms/system-design/lesson/52 Leadership Principles – The principles are an important aspect who we are at Amazon and the culture we maintain. As you review the 14 principles be prepared to answer a question about your work delivering on a project, challenges you might have faced, problems you had to work through, meeting a deadline, etc. You will be expected to walk us through various example in your life in which you exhibited the leadership principles. You can use this link in preparing for the questions to expect. https://careerservices.wayne.edu/behavioralinterviewinfo.pdf Design Pattern SOA Distributed system: https://www.hackerrank.com/domains/distributed-systems/client-server/page:1 microService sharding large scale map-reduce, SOA, loading balance DNS lookups, TCP/IP 一道是 anagrams, 另一道是 group anagram 的变形, 最后问了一下 hashmap 出现 collision 会发生什么。leetcode 49 和 242 原题. hashmap 的题目说出来 hashCode, bucket, linkedList, key-value pair 基本就可以了. 关注一亩三分地微博： Warald Onsite 面经: 第一轮: First Common Ancestor of two nodes in a graph. 第二轮: Given two strings and a dictionary, only one character can be changed at a time, the changed string must also be found in the dictionary. Write a function to decide if it is possible that the 1st string can be changed to the 2nd string. using ctci.Contracts; using System; namespace Chapter01 { public class Q1_05_One_Away_A : IQuestion { public static bool OneEditReplace(String s1, String s2) { bool foundDifference = false; for (int i = 0; i 1) { return false; } /* Get shorter and longer string.*/ String s1 = first.Length 第三轮: Two sum, multiple pairs. 第四轮: System design. 跪的妥妥的. 10000 cameras, 100 hours of video each. 30 fps. Police need to input a plate number and find the path of a suspicious vehicle. (Estimate the size of the video, e.g., blueray disc is 2 hours and 20 GB. No need to scan all of the videos. Estimate the time that a vehicle can be seen between 2 traffic cameras, e.g., 0.3 miles and 30 miles per hour, then select 1 out of 100). Web client, load balancer, servers, db. 第五轮: 纯粹 Behavior questions,要结合工作中实际的例子说明. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/amazon/system_design.html": {
    "url": "Basic/amazon/system_design.html",
    "title": "system_design",
    "keywords": "",
    "body": "1. tiny url1.1.1. 10000 cameras, 100 hours of video each. 30 fps. Police need to input a plate number and find the path of a suspicious vehicle. (Estimate the size of the video, e.g., blueray disc is 2 hours and 20 GB. No need to scan all of the videos. Estimate the time that a vehicle can be seen between 2 traffic cameras, e.g., 0.3 miles and 30 miles per hour, then select 1 out of 100). Web client, load balancer, servers, db.1.1.2. Design a kind of kindle fire application where we can subscribe news channel and read the news from all publishers as a digital format1.1.3. Design a kindle app for mobile device and think about the large scale service that would support content distribution for it and how you would design it1.1.4. You have a cluster with 100 machines that need time to be synced. The central time server can only handle 10 requests at a time. How will you set this up?1.1.5. How will you design the backend of product recommender system on amazon.com1. tiny url how long is the original url length? 30 => 120 bytes => db storage how long is the shortened url length? less than 10 => we can use 2nd method since long id 2132132132123 returns a string \"DTiRtHL\" with length 7. One Simple Solution could be Hashing. Use a hash function to convert long string to short string. In hashing, that may be collisions (2 long urls map to same short url) and we need a unique short url for every long url so that we can access long url back. A Better Solution is to use the integer id stored in database and convert the integer to character string that is at most 6 characters long. This problem can basically seen as a base conversion problem where we have a 10 digit input number and we want to convert it into a 6 character long string. using System; using System.Text; public class TinyURL { static string ALPHABET_MAP = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; static int BASE = ALPHABET_MAP.Length; //62 public static string Encode(long index) { StringBuilder sb = new StringBuilder(); while (index > 0) { sb.Append(ALPHABET_MAP[(int)(index % BASE)]); index /= BASE; } char[] arr = sb.ToString().ToCharArray(); //Array.Reverse(arr); return new string(arr); } public static long Decode(string str) { long num = 0; // if using reverse, use this for loop //for (int i = 0, len = str.Length; i = 0; i--) { num = num * BASE + ALPHABET_MAP.IndexOf(str[i]); } return num; } public static void Main(string[] args) { Console.WriteLine($\"Encoding for {int.MaxValue} is {Encode(int.MaxValue)}\"); //6 digit Console.WriteLine($\"Decoding for bLMuvc is {Decode(\"bLMuvc\")}\"); //6 digit Console.WriteLine($\"Encoding for 123 is {Encode(123)}\"); Console.WriteLine(\"Decoding for 9b is \" + Decode(\"9b\")); } } reducing the response time of the server by using a distributed system to share the load based on geography by using a central server but many caching servers at various geographical locations reducing the storage space database design backup and failover security issues prevent people from creating links to handling old/obsolete urls while creating the url we can say to the user that it will be deleted if the url is never used for more than say 3 years may be allow the user to login and delete unused ones user friendly things browser plugins to speed up creating links (youtube sharing has an option to create short urls) giving report to user about the usage statistics mobile app to create urls quickly 1.1.1. 10000 cameras, 100 hours of video each. 30 fps. Police need to input a plate number and find the path of a suspicious vehicle. (Estimate the size of the video, e.g., blueray disc is 2 hours and 20 GB. No need to scan all of the videos. Estimate the time that a vehicle can be seen between 2 traffic cameras, e.g., 0.3 miles and 30 miles per hour, then select 1 out of 100). Web client, load balancer, servers, db. Assuming each camera captures 640 x 480 p video & all data stored in a raw format, its easy to do calculation that per camera storage requirement is around 10 GB of data per hour. The given spec matches. So we are good. 30 miles per hour of speed == 0.5 miles per sec. Since cameras are placed at 0.3 mile, a moving vehicle will always be captured every sec by a new camera. Db Design - Either cameras are doing OCR to figure out numbers at camera level, or the video is being stored on a central server where OCR is being done. For every frame, if a vehicle is identified, the number plate, timestamp & camera id is stored. I will index the DB on number plate. So for a given number, query can be done such that all rows with the number plate can be fetched ordered by timestamp. This way, the path of the number plate can be easily traced. 1.1.2. Design a kind of kindle fire application where we can subscribe news channel and read the news from all publishers as a digital format how many articles are created per day => estimate db storage subject: news, sports, movie channels, observer: vipUser, regularUser message: Article vipUser can subscribe all channels while regularUser can subscribe most 5. 1.1.3. Design a kindle app for mobile device and think about the large scale service that would support content distribution for it and how you would design it features: read txt, epub formats in device sync: add these documents to cloud sign in, read repositories from cloud categorize books, news, docs for cloud all documents discover and push books to user based on search result, payment history search a book and read 1st chapter to trial, buy books help: ask an issue, feedback share book to facebook reading editor: font, theme, process, bookmark, table of content others: resolution for different mobiles 1.1.4. You have a cluster with 100 machines that need time to be synced. The central time server can only handle 10 requests at a time. How will you set this up? Way 1: divide the cluster into groups of 10 and the central time server syncs with 1st group, then 2nd. pros: easy to maintain grouping grouping map can be stored on central time server cons: if central server fails, may need to do resyncing if one or more of the servers in a group fail to sync or take too long then the other servers will be kept waiting Way 2: create 10 groups and assign masters in groups, those masters sync with the central server and they in turn push out to slaves in the group. Way 3: central server have a list of unsynced, syncing and synced servers. the central server can start with a random 10 servers and change their state from to be unsynced to syncing and update the lists. When a server finished syncing, its state is changed to synced and added to the synced list. Next, a new server can be synced if space is available. pros: servers don't constantly wait unnecessarily a priority can be assigned to certain servers if dependencies exist can retry on sync errors cons: if central server fails, need to redo syncing. To combat this each server can store their state, so when the central server comes back online, it can poll the cluster to see what needs to be done and recreate its lists 1.1.5. How will you design the backend of product recommender system on amazon.com Depending upon what he is searching on Relating that searched Item to what he Purchased in the history Respecting User preference on Public Review of the Product Products that People who bought the same product along with the product searched by the current User. Best Brand Products that matches the searched product. Sort according to the best discount on the product searched Product which offers Free Shipping Coming to the Design The search itself can arrange the matched items in a tree/Graph structure. When the user traversing down a path, user is exploring more and more since the system should never be able to say that it can no longer search your product. Check the movie online assessment Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/angular1/": {
    "url": "Basic/angular1/",
    "title": "Basic/angular1",
    "keywords": "",
    "body": "1. TOC1. TOC Angular1 ng-model-options Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Basic/angular1/Angular1.html": {
    "url": "Basic/angular1/Angular1.html",
    "title": "Angular1",
    "keywords": "",
    "body": "1. AngularJS questions (Most comes from dotnetTricks)1.1. Service, Factory, Provider1.2. Routing1.2.1. How angular is compiled1.2.2. How Data binding happens (apply, digest, watch)1.2.3. Digest life cycle1.2.4. How to handles exception automatically?1.2.5. $watch, $watchGroup, $watchCollection1.2.6. Difference between $observe and $watch1.2.7. $parse and $eval1.2.8. Isolate scope1.2.9. How Angular service return a promise?1.2.10. Interceptor? What are common uses of it?1. AngularJS questions (Most comes from dotnetTricks) 1.1. Service, Factory, Provider Factory allows you to add some logic before creating the object. It returns the created object. app.factory('myFactory', function() { var obj = {}; obj.name = ''; obj.setName = function(name) { obj.name = name; }; return obj; }); //usage: myFactory.setName('wang'); $scope.Name = myFactory.name; when to use: use it with constructor Service: Doesn't return anything app.service('myService', function() { this.name = ''; this.setName = function(newname) { this.name = newname; return this.name; }; }); //usage: $scope.Name = myService.setName('wang'); when to use: a singleton object. when needing to share a single object across the application. Authenticated user details Provider: create a configurable service object. app.provider('configurable', function() { var privateName = ''; this.setName = function(newName) { privateName = newName; }; this.$get = function() { return { name: privateName }; }; }); //usage: app.config(function(configurableProvider) { configurableProvider.setName('wang'); }); $scope.Name = configurable.name; 1.2. Routing To build a SPA. divide app into multiple views and bind different views. $routeProvider, ngRoute module let app = angular.module('myApp', ['ngRoute']); app.config(['$routeProvider'], function($routeProvider) { $routeProvider .when('/products', { templateUrl: 'Views/products.html', controller: 'productController', }) .when('/products/:productId', { templateUrl: 'Views/product.html', controller: 'productController', }) .otherwise({ redirectTo: '/index', }); }); 1.2.1. How angular is compiled The compiler allows you attaching new behaviors or attributes to any Html element. Angular uses $compiler service to compile page after DOM is fully loaded. 2 phases: Compile: It traverse the DOM and collect directives. Foreach directive, it adds it to a list of directives. It will sort that list by priority. Then each directive's compile function is executed, and each compile function returns a linking function, which is then composed into a combined linking function. Link: link function gets called. This in turn calls linking function of individual directives, registering listeners on the elements and setting up $watch with the scope. after combining directives with a scope, it produces the view. prelink: executed before elements are linked. Not safe to do DOM transformation postlink: executed after elements are linked. Safe to do DOM transformation The concept of compile and link comes from C language, where you first compile the code and then link it to execute it 1.2.2. How Data binding happens (apply, digest, watch) $watch: observe scope variable change. $scope.$watch('name', function(newVal, oldVal) {}); $digest: iterates thru all watchers and check if value has changed. If changing, calls the listener with new value and old value. $apply: angular auto updates only model changes within angular context. if any model change happens outside of context, like DOM events, setTimeout, XHR ajax, third party libraries, we need inform angular of the changes by calling $apply manually. When $apply finishes, angular calls $digest internally so all bindings are updated. document.getElementById('hello').addEventListener( 'click', function() { $scope.$apply(function() { $scope.time = new Date(); }); }, false, ); digest is faster than apply, since apply triggers watchers on the entire scope chain (parents, children) while digest only current scope and its children. 1.2.3. Digest life cycle responsible for updating DOM elements with model changes, executing watcher functions digest loop is fired when browser receives an event that can be managed by angular context. It includes 2 smaller loops digest loop keeps iterating until the $evalAsnc queue is empty and $watch list doesn't detect any model change $evalAsync queue contains all tasks which are scheduled by $evalAsync function from a directive or controller $watch list contains all watches correspondence to each DOM element which is bound to the $scope object. These watches are resolved in the $digest loop through a process called dirty checking. If a values changes, $scope is dirty, another digest loop is triggered. 1.2.4. How to handles exception automatically? when error occurs in one of watchers, digest cannot handle errors via $exceptionHandler service. In this case you have to handle manually. while apply uses try catch block to handle errors then pass them to exceptionHandler service. function $apply(exp){ try return $eval(exp) catch(e) $exceptionHandler(e); finally $root.digest(); } 1.2.5. $watch, $watchGroup, $watchCollection $watch: watch a variable $watchGroup: watch variables in array $scope.a = 1; $scope.b = 2; $scope.$watchGroup(['a', 'b'], function(newval, oldval) {}); $watchCollection: watch if any property changes in an object $scope.names = ['a', 'b', 'c']; //{'a':1,'b':2} $scope.$watchCollection('names', function(newval, oldval) {}); 1.2.6. Difference between $observe and $watch $observe is a method on the attr object which is only used to observe attribute change $watch is a method on the $scope object which is to watch expression(string, function) 1.2.7. $parse and $eval $parse is a service that converts an expression into a function. Then function can be invoked and passed a context(usually scope) in order to retrieve the expression's value $eval executes an expression on the current scope and returns the result $scope.a = 1; $scope.b = 2; $scope.$eval('b+a'); 1.2.8. Isolate scope by default, a custom directive has access to parent scope. If we don't have access to parent scope, only access to current directive's scope. angular.module('myapp').directive('hi', function() { return { scope: {}, // create an isolate scope template: 'Name: {{emp.name}}', }; }); Below is not from dotnetTricks 1.2.9. How Angular service return a promise? To add promise functionality to a service, we inject the $q dependency in the service angular.factory('testService', function($q) { return { getName: function() { var deferred = $q.defer(); //API call here that returns data testAPI.getName().then(function(name) { deferred.resolve(name); }); return deferred.promise; }, }; }); The $q library is a helper provider that implements promises and deferred objects to enable asynchronous functionality. Pasted from https://www.codementor.io/angularjs/tutorial/angularjs-interview-questions-sample-answers 1.2.10. Interceptor? What are common uses of it? An interceptor is a middleware code where all the $http requests go through. The interceptor is a factory that are registered in $httpProvider. You have 2 types of requests and response that go through the interceptor. This piece of code is very useful for error handling, authentication or middleware in all the requests/responses. Pasted from https://www.codementor.io/angularjs/tutorial/angularjs-interview-questions-sample-answers Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/angular1/ng-model-options.html": {
    "url": "Basic/angular1/ng-model-options.html",
    "title": "ng-model-options",
    "keywords": "",
    "body": "1. angular-1.3 之 ng-model-options 指令1.1.1. 通过 updataOn 指定同步 ng-model 的时间1.1.2. 通过 debounce 延迟模型更新1.1.3. 通过$rollbackViewValue 同步模型和视图1. angular-1.3 之 ng-model-options 指令 ng-model-options是 angular-1.3 新出的一个指令，允许我们控制 ng-model 何时进行同步。比如: 当某个确定的事件被触发的时候 在指定的防抖动延迟时间之后，这样视图值就会在指定的时间之后被同步到模型. 在 angular-1.2 版本就可以实现的 ng-model 双向绑定的核心代码: Hello {{name}} 它是实时同步更新的，input 中每输入一个字，就立刻同步到数据模型。这是因为每次输入 input 都会触发一个 input 的事件，然后 angular 就会执行的$digest 循环，直到模型稳定下来。我们不用手动设置任何事件监听来同步更新视图和模型。 然而由于每次键盘按下都会触发$digest 循环，所以当你在输入 input 内容的时候，angular 不得不处理所有绑定在 scope 上的 watch 监听。这样它执行的效率就取决于你在 scope 上绑定了多少 watch 监听、以及这些监听的回调函数是怎样的，这个代价是十分昂贵的。 如果我们能够自己控制$digest 的触发，比如当用户停止输入 300 毫秒后触发，又或者是当 input 元素失去焦点的时候再触发，那不是更好么? 于是 angular-1.3 的 ng-model-options 就为我们做了这件事。 1.1.1. 通过 updataOn 指定同步 ng-model 的时间 ng-model-options 提供了一系列的选项去控制 ng-model 的更新。 通过 updateOn 参数我们可以定义 input 触发$digest 的事件。举个栗子，我们希望当 input 失去焦点的时候更新模型，只需要按照如下的配置来实现: Hello {{name}} ng-model-options=\"{ updateOn: 'blur' }\"告诉 angular 在 input 触发了 onblur 事件的时候再更新 ng-model，而不是每次按下键盘就立即更新 model。 http://plnkr.co/edit/URMCoON9qDFnxdlyiDSS?p=preview 如果我们想要保留默认的更新模型事件，另外再给它添加其它触发$digest 的事件，可以使用一个特殊的事件: default。通过空格分隔的字符串来给它添加多个事件。下面这段代码能够在输入的时候同步更新模型，并且当 input 失去焦点的时候也更新模型. Hello {{name}} http://plnkr.co/edit/6VtaJrCIuO5ePfoz8UXA?p=preview (效果其实不太看不出来的...因为虽然 blur 的时候它在同步，但是其实输入的时候已经同步完了) 1.1.2. 通过 debounce 延迟模型更新 接下来让我们看看怎么指定更新的延迟时间。我们可以通过 ng-model-options 来延迟模型的更新，以此来降低当用户和模型交互时触发的$digest 循环的次数。这不仅减少了$digest 循环的次数，同时也是处理异步数据模型时提升用户体验度的一个好方法。 想象有这样一个元素: input[type=\"search\"]，每当用户正在输入的时候，数据模型就会更新，并且用最新的字段向后台提交请求。这样是没错的。然而我们很可能并不想让用户每次按键的时候就立刻更新模型，而是希望当用户输入完了一段有意义的搜索字段以后才更新模型。在这种情况下，我们正适合使用 ng-model-options 的 debounce 参数。debounce 定义了模型更新的延迟毫秒数(需要是整数)。比如刚才提到的这种情况，我们希望当用户停止输入 1000 毫秒以后再更新模型，停止输入 1000 毫秒差不多应该就是输入完了一段有意义的内容了吧。我们可以像下面这样，定义 debounce 参数的值为 1000。 Search results for: {{searchQuery}} 现在当输入搜索内容的时候，会有 1 秒的延迟。http://plnkr.co/edit/lpFwWsTvZxMGfHFe38Bk?p=preview 我们还可以做更多的配置: 为指定的事件指定延迟时间。为不同的事件指定不同的延时，可以通过给 debounce 属性定义一个 json 对象来实现: 属性名代表事件名，属性值代表延迟时间。如果某个事件不需要延迟，那么它的属性值就是 0。 下面这个栗子实现了这样的模型: 当用户在 input 里输入的时候，延迟 1000 毫秒更新模型，但是当 input 元素失去焦点的时候，立刻更新模型: Search results for: {{searchQuery}} http://plnkr.co/edit/yYsfcjW8KVt9ZESQUSB2?p=preview 1.1.3. 通过$rollbackViewValue 同步模型和视图 由于我们通过 ng-model-options 来控制了模型的更新时间，所有在很多时候模型和视图就会出现不同步的情况。举个栗子，我们配置 ng-model-options，让 input 在失去焦点的时候同步数据模型，当用户正在输入内容时，数据模型没有发生更新。 假设在这种情境下，你希望在数据模型更新前把视图上的值回滚到它真实的值。这时，$rollbackViewValue 可以同步数据模型到视图。这个方法会把数据模型的值返回给视图，同时取消所有的将要发生的延迟同步更新事件。 执行了 $rollbackViewValue() 方法 myValue1: \"{{ myValue1 }}\" 没有执行了 $rollbackViewValue() 方法 myValue2: \"{{ myValue2 }}\" app.controller('Rollback'，function($scope) { $scope.resetWithRollback = function(e) { if (e.keyCode == 27) { // press esc $scope.myForm2.myInput1.$rollbackViewValue(); } }; $scope.resetWithoutRollback = function(e) { if (e.keyCode == 27) { // press esc angular.noop() } } }); http://plnkr.co/edit/iMY8IqH5f8NLuIAxY8zN?p=preview myValue1 使用了$rollbackViewValue()方法，可以回滚文本域里的值和数据模型同步，但是 myValue2 是不能的。 需要特别注意的一点是，在使用了 ng-model-options 这种情况下，如果直接修改模型值，有时可能让视图同步，有时却不能，什么意思，看这个栗子: app.controller('Rollback'，function($scope) { $scope.resetWithRollback = function(e) { if (e.keyCode == 27) { $scope.myValue1 = ''; //使用了$rollbackViewValue，总是可以同步视图，清空myValue1值 $scope.myForm2.myInput1.$rollbackViewValue(); } }; $scope.resetWithoutRollback = function(e) { if (e.keyCode == 27) { //并不是每次都可以成功的同步的，有时可以，有时不可以. $scope.myValue2 = ''; } } }); http://plnkr.co/edit/vve2Xh7LROQLQFa6FFrn?p=preview 按 Esc 的时候，不是直接回滚视图值到当前的数据模型，而是先设置数据模型为空，然后再回滚视图值。而 myValue2，直接设置数据模型为空，不使用回滚。 在 demo 里多试几次就会发现，在这种情况下，在 myValue2 的 input 里按 Esc，有时可以同步视图值为空，有时则不能。 所以，在用了 ng-model-opitons 的时候，如果在模型没有被视图同步之前需要让视图被模型同步，不能简单通过设置模型，必须使用$rollbackViewValue()方法。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/angular4/": {
    "url": "Basic/angular4/",
    "title": "Basic/angular4",
    "keywords": "",
    "body": "1. TOC1. TOC Angular2 的数据绑定 Angular2 装饰器 modules Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Basic/angular4/Angular2的数据绑定.html": {
    "url": "Basic/angular4/Angular2的数据绑定.html",
    "title": "Angular2 的数据绑定",
    "keywords": "",
    "body": "1. Angular2 的数据绑定1.1. 分类1.2. 使用1.2.1. 方括号单向数据绑定1.2.2. 字符串插值绑定1.2.3. 圆括号单向数据绑定（事件绑定）1.2.4. 使用双向数据绑定1.3. 实现原理1. Angular2 的数据绑定 1.1. 分类 方括号单向数据绑定。 [目标]=\"表达式\": 数据流动方向为组件 --> 模板 字符串插值绑定。 ``: 数据流动方向为组件 --> 模板 圆括号单向数据绑定。 (目标)=\"表达式\": 数据流动方向为模板 --> 组件。通常用来处理事件。 双向绑定。 [(目标)]=\"表达式\": 数据流动方向为模板 组件 1.2. 使用 1.2.1. 方括号单向数据绑定 绑定属性时需要分清属性(property)和特性(attribute)绑定，绑定样式时有四种可选操作 property 绑定 property 是存在于 DOM 里的，例如 input 元素的 value 属性。 为了防止表达式返回 null，在表达式后面跟上一个? 每个元素的 property 可以参考文档 attribute 绑定 attribute 是存在于 HTML 元素里的，不是所有的 HTML 元素的 property 都和 attribute 相符，比如说 colspan。NG 提供了绑定 attribute 属性的解决办法。 {{model.getProduct(1)?.name || 'None'}} 类和样式绑定 可以直接绑定 HTML 元素的样式或者类，也可以使用 NG 提供的指令达到目标。 类绑定 有三种方式。 [class]=\"表达式\": 把表达式的结果替代原来存在的 class [class]=\"getClasses(1)\" [class.myClass]=\"表达式\": 根据表达式返回结果添加 myClass 这个类 [class.myClass]=\"model.getProduct(2).price [ngClass]=\"map\": 把 map 对象的值添加到 class 里去，支持三种返回值:字符串,数组,对象 //html [ngClass] = 'map'; //ts map = { 'text-xs-center bg-danger': product.name == 'Kayak', 'bg-info': product.price 样式绑定 同样三种方式。不过没有替换样式的写法。 [style.color]=\"表达式\": 把表达式的结果设置成单个样式属性。 [style.font-size.em]=\"表达式\": 把表达式的结果设置成指定的样式和单位值。 [ngStyle]=\"map\": 把样式设置成 map 对象的值。 //ts map = { fontSize: '30px', 'margin.px': 100, color: product.price > 50 ? 'red' : 'green', }; 1.2.2. 字符串插值绑定 它被用于宿主元素的文本内容中。也是一种单向数据绑定，常常用于显示某个数据。 {{data||getData()}} 1.2.3. 圆括号单向数据绑定（事件绑定） 事件绑定用于响应宿主元素发送的事件。是用户交互的核心。事件种类请参考文档 {{i + 1}} 也可以直接传入一个 Event 对象到组件里去。 当需要传入 HTML 元素到组件时，可以借助模板引用变量 1.2.4. 使用双向数据绑定 使用 ngModel 指令可以简化了双向绑定的语法。 其实 NG 中的双向绑定就是同时利用了两个方向上的单向绑定,拆开看其实就是： 1.3. 实现原理 NG 不像 angular1.x 使用脏检查来更新数据，而是使用了 zone.js 库来监视数据的变更，当组件里的数据发生了改变，NG 会渲染模板 DOM。当 DOM 的事件被触发了，NG 会改变组件里的数据。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/angular4/Angular2装饰器.html": {
    "url": "Basic/angular4/Angular2装饰器.html",
    "title": "Angular2 装饰器",
    "keywords": "",
    "body": "1. Angular 2 装饰器1. Angular 2 装饰器 装饰器是一个函数，它将元数据添加到类、类成员（属性、方法）和函数参数。 装饰器是一个 JavaScript 的语言特性，装饰器在 TypeScript 里已经实现，并被推荐到了 ES2016（也就是 ES7）。 要想应用装饰器，把它放到被装饰对象的上面或左边。 Angular 使用自己的一套装饰器来实现应用程序各部件之间的相互操作 @NgModule 装饰器，它接收一个用来描述模块属性的元数据对象。其中最重要的属性是： declarations - 声明本模块中拥有的视图类。 Angular 有三种视图类：组件、指令和管道。 exports - declarations 的子集，可用于其它模块的组件模板。 imports - 本模块声明的组件模板需要的类所在的其它模块。 providers - 服务的创建者，并加入到全局服务列表中，可用于应用任何部分。 bootstrap - 指定应用的主视图（称为根组件），它是所有其它视图的宿主。只有根模块才能设置bootstrap属性。 @Component 组件装饰器，它把紧随其后的类标记成了组件类。能接受一个配置对象， Angular 会基于这些信息创建和展示组件及其视图。 moduleId - 为与模块相关的 URL（例如templateUrl）提供基地址。 selector - CSS 选择器，它告诉 Angular 在父级 HTML 中查找标签，创建并插入该组件。 例如，如果应用的 HTML 包含， Angular 就会把HeroListComponent的一个实例插入到这个标签中。 templateUrl - 组件 HTML 模板的模块相对地址，如前所示。 providers - 组件所需服务的依赖注入提供商数组。 这是在告诉 Angular：该组件的构造函数需要一个HeroService服务，这样组件就可以从服务中获得数据 @Injectable 装饰器，声明当前类有一些依赖，当依赖注入器创建该类的实例时，这些依赖应该被注入到构造函数中。 @Pipe({...})装饰器，声明当前类是一个管道，并且提供关于该管道的元数据 @Directive 装饰器，声明当前类是一个指令，并提供关于该指令的元数据 @Input() @Output() @HostBinding @HostListener @ContentChild 装饰器: 装饰器 介绍 @Input() myProperty; 声明一个输入属性，以便我们可以通过属性绑定更新它。(比如： ). @Output() myEvent = new EventEmitter(); 声明一个输出属性，以便我们可以通过事件绑定进行订阅。(比如：). @HostBinding('[class.valid]') isValid; 把宿主元素的属性(比如 CSS 类：valid)绑定到指令/组件的属性(比如：isValid)。 @HostListener('click', ['$event']) onClick(e) {...} 通过指令/组件的方法(例如onClick)订阅宿主元素的事件(例如click)，可选传入一个参数($event)。 @ContentChild(myPredicate) myChildComponent; 把组件内容查询(myPredicate)的第一个结果绑定到类的myChildComponent属性。 @ContentChildren(myPredicate) myChildComponents; 把组件内容查询(myPredicate)的全部结果，绑定到类的myChildComponents属性。 @ViewChild(myPredicate) myChildComponent; 把组件视图查询(myPredicate)的第一个结果绑定到类的myChildComponent属性。对指令无效。 @ViewChildren(myPredicate) myChildComponents; 把组件视图查询(myPredicate)的全部结果绑定到类的myChildComponents属性。对指令无效 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/angular4/modules.html": {
    "url": "Basic/angular4/modules.html",
    "title": "modules",
    "keywords": "",
    "body": "1. Modules1. Modules import { NgModule } from '@angular/core'; import { RouterModule } from '@angular/router'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [CommonModule], declarations: [], providers: [], bootstrap: [], }) export class userModule {} Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/design_pattern.html": {
    "url": "Basic/design_pattern.html",
    "title": "design_pattern",
    "keywords": "",
    "body": "1. Design Pattern1.1. Singleton Pattern1.2. Factory Method Pattern1.3. Facade Pattern1.4. Proxy Pattern1.5. Adapter Pattern1.6. DI1. Design Pattern 1.1. Singleton Pattern Singleton pattern is one of the simplest design patterns. This pattern ensures that a class has only one instance and provides a global point of access to it. var Singleton = (function() { var instance; function createInstance() { var object = new Object('I am the instance'); return object; } return { getInstance: function() { if (!instance) { instance = createInstance(); } return instance; }, }; })(); function run() { var instance1 = Singleton.getInstance(); var instance2 = Singleton.getInstance(); alert('Same instance? ' + (instance1 === instance2)); } 1.2. Factory Method Pattern In Factory pattern, we create object without exposing the creation logic. In this pattern, an interface is used for creating an object, but let subclass decide which class to instantiate. The creation of object is done when it is required. The Factory method allows a class later instantiation to subclasses. 1.3. Facade Pattern Facade pattern hides the complexities of the system and provides an interface to the client using which the client can access the system. This pattern involves a single wrapper class which contains a set of members which are required by client. These members access the system on behalf of the facade client and hide the implementation details. The facade design pattern is particularly used when a system is very complex or difficult to understand because system has a large number of interdependent classes or its source code is unavailable. 1.4. Proxy Pattern The proxy design pattern is used to provide a surrogate object, which references to other object. Proxy pattern involves a class, called proxy class, which represents functionality of another class. 1.5. Adapter Pattern Adapter pattern acts as a bridge between two incompatible interfaces. This pattern involves a single class called adapter which is responsible for communication between two independent or incompatible interfaces. 1.6. DI Dependency Injection (DI) is a software design pattern that allow us to develop loosely coupled code. DI is a great way to reduce tight coupling between software components. DI also enables us to better manage future changes and other complexity in our software. The purpose of DI is to make code maintainable. The Dependency Injection pattern uses a builder object to initialize objects and provide the required dependencies to the object means it allows you to \"inject\" a dependency from outside the class. For example, Suppose your Client class needs to use a Service class component, then the best you can do is to make your Client class aware of an IService interface rather than a Service class. In this way, you can change the implementation of the Service class at any time (and for how many times you want) without breaking the host code. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/dotnet/": {
    "url": "Basic/dotnet/",
    "title": "Basic/dotnet",
    "keywords": "",
    "body": "1. TOC1. TOC DI dotnet_interview dotnetFramework lock reflection SignalR 集群 webapi 面向切面变成 AOP Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Basic/dotnet/DI.html": {
    "url": "Basic/dotnet/DI.html",
    "title": "DI",
    "keywords": "",
    "body": "1. DI 原理解析及 Castle、Unity 框架使用1. DI 原理解析及 Castle、Unity 框架使用 控制反转（Inversion of Control）目的是解耦合 ==DI 基本原理本质上是通过容器来反射创建实例== class Person { public void Say() { Console.WriteLine(\"Person's say method is Called\"); } } // 反射代码(className:类的全限定名) private static object CreateInstance(Assembly assembly, string className) { var type = assembly.GetType(className); return type != null ? Activator.CreateInstance(type) : null; } // 执行(XX为命名空间) static void Main(string[] args) { var obj = CreateInstance(Assembly.GetExecutingAssembly(), \"XX.Person\"); var person = obj as Person; if (person != null) { person.Say(); } Console.ReadKey(); } 在上面能看到 1 个问题，一般情况下既然使用 DI，就不知道具体的注入对象，所以强调面向接口编程。所以实际上一般先定义接口，再通过 DI 容器创建对象。 interface IPerson { void Say(); } class Person : IPerson { public void Say() { Console.WriteLine(\"Person's say method is Called\"); } } //执行 static void Main(string[] args) { var obj = CreateInstance(Assembly.GetExecutingAssembly(), \"Demo.Person\"); var person = obj as IPerson; if (person != null) { person.Say(); } Console.ReadKey(); } DI 框架流行的有 Castle Windsor, Unity...(Autofac, Spring.Net) ==在 DI 框架中，一般需要将对象注册到容器中，然后从容器解析出来。== Castle Install-Package Castle.Windsor //待注入类 interface ITransient { } interface IPerson { void Say(); } class Person : IPerson, ITransient { public void Say() { Console.WriteLine(\"Person's say method is Called\"); } } //注册解析方式一 static void Main(string[] args) { using (var container = new WindsorContainer()) { container.Register(Component.For()); var person = container.Resolve(); person.Say(); } Console.ReadKey(); } //注册解析方式二 public class AssmInstaller : IWindsorInstaller { public void Install(IWindsorContainer container, IConfigurationStore store) { container.Register(Classes.FromThisAssembly() //选择Assembly .IncludeNonPublicTypes() //约束Type .BasedOn() //约束Type .WithService.DefaultInterfaces() //匹配类型 .LifestyleTransient()); //注册生命周期 } } static void Main(string[] args) { using (var container = new WindsorContainer()) { container.Install(new AssmInstaller()); var person = container.Resolve(); person.Say(); } Console.ReadKey(); } 构造函数注入 class Task : ITransient { public IPerson Person { get; set; } public Task(IPerson person) { Person = person; Person.Say(); } } static void Main(string[] args) { using (var container = new WindsorContainer()) { container.Install(new AssmInstaller()); container.Resolve(); } Console.ReadKey(); } 属性注入 class Task : ITransient { public IPerson Person { get; set; } public Task() { } public void Say() { Person.Say(); } } static void Main(string[] args) { using (var container = new WindsorContainer()) { container.Install(new AssmInstaller()); container.Resolve().Say(); } Console.ReadKey(); } MVC 集成 Install-Package Castle.Windsor.Mvc Application_Start 注册 protected void Application_Start() { RouteConfig.RegisterRoutes(RouteTable.Routes); var container = new WindsorContainer() .Install(FromAssembly.This()); var controllerFactory = new WindsorControllerFactory(container.Kernel); ControllerBuilder.Current.SetControllerFactory(controllerFactory); } Installer 注册 public class AssmInstaller : IWindsorInstaller { public void Install(IWindsorContainer container, IConfigurationStore store) { container.Register(Classes.FromThisAssembly() .IncludeNonPublicTypes() .BasedOn() .WithService.DefaultInterfaces() .LifestyleTransient()); container.Register(Classes.FromThisAssembly() .BasedOn() .LifestyleTransient() ); } } 这样 Castle Windsor 就能接管解析 Controller 了 Unity Install-Package Unity 待注入类 public interface IPerson { void Say(); } public class Person : IPerson { public void Say() { Console.WriteLine(\"Person's say method is Called\"); } } 注册解析一 static void Main(string[] args) { using (var container = new UnityContainer()) { container.RegisterType(new TransientLifetimeManager()); var person = container.Resolve(); person.Say(); } Console.ReadKey(); } 注册解析二 static void Main(string[] args) { using (var container = new UnityContainer()) { container.RegisterInstance(new Person()); var person = container.Resolve(); person.Say(); } Console.ReadKey(); } 构造函数注入 class Task : ITask { public IPerson Person { get; set; } public Task(IPerson person) { Person = person; Person.Say(); } } public interface ITask { } static void Main(string[] args) { using (var container = new UnityContainer()) { container.RegisterInstance(new Person()); container.RegisterType(); container.Resolve(); } Console.ReadKey(); } 属性注入 class Task : ITask { [Dependency] public IPerson Person { get; set; } public Task(IPerson person) { Person = person; } public void Say() { Person.Say(); } } static void Main(string[] args) { using (var container = new UnityContainer()) { container.RegisterInstance(new Person()); container.RegisterType(); var task = container.Resolve(); task.Say(); } Console.ReadKey(); } MVC 集成 Install-Package Unity.Mvc Application_Start 注册 protected void Application_Start() { RouteConfig.RegisterRoutes(RouteTable.Routes); var container = new UnityContainer(); container.RegisterType(); DependencyResolver.SetResolver(new UnityDependencyResolver(container)); } 这样 Unity 就接管了 Controller 的创建 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/dotnet/dotnet_interview.html": {
    "url": "Basic/dotnet/dotnet_interview.html",
    "title": "dotnet_interview",
    "keywords": "",
    "body": "1. .net interview1.1.1. 冒泡排序1.1.2. StringBuilder vs string1.1.3. 单例模式1. .net interview 1.1.1. 冒泡排序 for (int i = 0; i data[j + 1]) { int temp = data[j]; data[j] = data[j + 1]; data[j + 1] = temp; } } } 1.1.2. StringBuilder vs string string joinWords(string[] words) { string sentence =\"\"; foreach (string w in words) { sentence += w; } return sentence; } On each concatenation, a new copy of the string is created, and the two strings are copied over, character by character. The first iteration requires us to copy x characters. The second iteration requires copying 2x characters. The third iteration requires 3x, and so on. The total time is O(x + 2x + ... + nx) => O(n^2). StringBuilder simply creates a resizable array of all the strings, copying them back to a string only when necessary. O(n) using System.Text; string joinWords(string[] words) { StringBuilder sentence = new StringBuilder(); foreach (string w in words) { sentence.append(w); } return sentence.toString(); } 1.1.3. 单例模式 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。 控制资源的情况下，方便资源之间的互相通信。如线程池等。 Windows 的 Task Manager（任务管理器） windows 的 Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 网站的计数器，一般也是采用单例模式实现，否则难以同步。 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。 Web 应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。 多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。 HttpApplication 也是单例的典型应用。熟悉 ASP.Net(IIS) 的整个请求生命周期的人应该知道 HttpApplication 也是单例模式，所有的 HttpModule 都共享一个 HttpApplication 实例。 实现方法： static 属性里面 new，构造函数 private，如果是要求多线程情况，线程安全要 double check 实现 1.将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例； 2.在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。 饿汉式 静态常量(经典写法) public class Singleton { private static Singleton _instance = new Singleton(); private Singleton() { } public static Singleton Instance() { return _instance; } } 适用：单/多线程 模式：饿汉式（静态常量）[可用] 优点：写法比较简单，避免了线程同步问题 缺点：没能实现延迟加载 静态代码块 public class Singleton2 { private static Singleton2 _instance; static Singleton2() { _instance = new Singleton2(); } private Singleton2(){} public Singleton2 Instance() { return _instance; } } 适用：单/多线程 模式：饿汉式（静态代码块）[可用] 优点：写法比较简单，避免了线程同步问题 缺点：没能实现延迟加载 懒汉式 线程不安全 public class Singleton3 { private static Singleton3 _instance; private Singleton3() { } public static Singleton3 Instance() { return _instance ?? (_instance = new Singleton3()); } } 适用：单线程 模式：懒汉式(线程不安全)[不可用] 优点：适用于单线程，实现简单，延迟加载 缺点：多线程不安全，违背了单列模式的原则 线程安全 public class Singleton4 { private static Singleton4 _instance; private static readonly object SyncObject = new object(); private Singleton4() { } public static Singleton4 Instance() { lock (SyncObject) { if (_instance == null) { _instance = new Singleton4(); } } return _instance; } } 适用：单线程 模式：懒汉式(线程安全，不推荐) 优点：线程安全；延迟加载； 缺点：这种实现方式增加了额外的开销，损失了性能(当有多个调用时，第一个调用的会进入 lock，而其他的则等待第一个结束后才能调用，后面的依次访问、等待……) 双重检查锁定 public class Singleton5 { private static Singleton5 _instance; private static readonly object SyncObject = new object(); private Singleton5() { } public static Singleton5 Instance() { if (_instance==null) { lock (SyncObject) { if (_instance == null) { _instance = new Singleton5(); } } } return _instance; } } 适用：单/多线程 模式：双重检查锁定(Double-Check Locking)(线程安全，推荐) 优点：线程安全；延迟加载；效率较高(只会实例化一次，首先会判断是否实例化过，如果实例化了，直接返回实例，不需要进入 lock；如果未实例化，进入 lock，就算是多个调用也无妨，第一次调用的会实例化，第二个进入 lock 时会再次判断是否实例化，这样线程就不会阻塞了。) 缺点：基本没有 静态内部类 public class Singleton6 { private Singleton6() { } private static class SingletonInstance { public static Singleton6 Instance = new Singleton6(); } public static Singleton6 Instance() { return SingletonInstance.Instance; } } 适用：单/多线程 模式：静态内部类(线程安全，推荐) 优点：避免了线程不安全；延迟加载；效率高(这种方式跟饿汉式方式采用的机制类似：都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方是：饿汉式只要 Singleton 类被装载就会实例化，没有 Lazy-Loading 的作用；而静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 Instance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。) 缺点：基本没有 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/dotnet/dotnetFramework.html": {
    "url": "Basic/dotnet/dotnetFramework.html",
    "title": "dotnetFramework",
    "keywords": "",
    "body": "1.1.1. Describe the Events in the Life Cycle of a Web Application.1.1.2. What is connection pooling and how to enable and disable connection pooling?1.1.3. State the differences between the Dispose() and Finalize()1.1.4. Differentiate between managed and unmanaged code?1.1.5. Describe the roles of CLR in .NET Framework1.1.6. Explain covariance(协变) and contra-variance(逆变) in .NET Framework 4.0. Give an example for each.1.1.7. httpHandler, httpModule1.1.1. Describe the Events in the Life Cycle of a Web Application. A web application starts when a browser requests a page of the application first time. The request is received by the IIS which then starts ASP.NET worker process (aspnet_wp.exe). The worker process then allocates a process space to the assembly and loads it. An application_start event occurs followed by Session_start. The request is then processed by the ASP.NET engine and sends back response in the form of HTML. The user receives the response in the form of page. The page can be submitted to the server for further processing. The page submitting triggers postback event that causes the browser to send the page data, also called as view state to the server. When server receives view state, it creates new instance of the web form. The data is then restored from the view state to the control of the web form in Page_Init event. The data in the control is then available in the Page_load event of the web form. The cached event is then handled and finally the event that caused the postback is processed. The web form is then destroyed. When the user stops using the application, Session_end event occurs and session ends. The default session time is 20 minutes. The application ends when no user accessing the application and this triggers Application_End event. Finally all the resources of the application are reclaimed by the Garbage collector. 1.1.2. What is connection pooling and how to enable and disable connection pooling? Connection pool is created when we open connection first time. When a new connection is created with same connection string as the first one, it reuses the same and existing connection object from the pool without creating a new one. If the connection string is different then a new connection pooling will be created, thus won't use the existing connection object. By default, we have connection pooling enabled in .Net. To disable connection pooling, set Pooling = false in the connection string. 1.1.3. State the differences between the Dispose() and Finalize() CLR uses the Dispose and Finalize methods to perform garbage collection of run-time objects of .NET applications. The Finalize method is called automatically by the runtime. CLR has a garbage collector (GC), which periodically checks for objects in heap that are no longer referenced by any object or program. It calls the Finalize method to free the memory used by such objects. The Dispose method is called by the programmer. Dispose is another method to release the memory used by an object. The Dispose method needs to be explicitly called in code to dereference an object from the heap. The Dispose method can be invoked only by the classes that implement the IDisposable interface. 1.1.4. Differentiate between managed and unmanaged code? Managed code is the code that is executed directly by the CLR instead of the operating system. The code compiler first compiles the managed code to intermediate language (IL) code, also called as MSIL code. This code doesn't depend on machine configurations and can be executed on different machines. Managed code execution order: Choosing a language compiler (JIT) Compiling the code to MSIL Compiling MSIL to native code Executing the code. Unmanaged code is the code that is executed directly by the operating system outside the CLR environment. It is directly compiled to native machine code which depends on the machine configuration. In the managed code, since the execution of the code is governed by CLR, the runtime provides different services, such as garbage collection, type checking, exception handling, and security support. These services help provide uniformity in platform and language-independent behavior of managed code applications. In the unmanaged code, the allocation of memory, type safety, and security is required to be taken care of by the developer. If the unmanaged code is not properly handled, it may result in memory leak. Examples of unmanaged code are ActiveX components and Win32 APIs that execute beyond the scope of native CLR. 1.1.5. Describe the roles of CLR in .NET Framework CLR provides an environment to execute .NET applications on target machines. CLR is also a common runtime environment for all .NET code irrespective of their programming language, as the compilers of respective language in .NET Framework convert every source code into a common language known as MSIL or IL (Intermediate Language). CLR also provides various services to execute processes, such as memory management service and security services. CLR performs various tasks to manage the execution process of .NET applications. The responsibilities of CLR are listed as follows: Automatic memory management Garbage Collection Code Access Security Code verification JIT compilation of .NET code 1.1.6. Explain covariance(协变) and contra-variance(逆变) in .NET Framework 4.0. Give an example for each. In .NET 4.0, the CLR supports covariance and contravariance of types in generic interfaces and delegates. Covariance enables you to cast a generic type to its base types, that is, you can assign a instance of type IEnumerable to a variable of type IEnumerable. For example, IEnumerable str1= new List (); IEnumerable str2= str1; Contravariance allows you to assign a variable of Action to a variable of type Action. For example, IComparer obj1 = GetComparer() IComparer obj2 = obj1; .NET framework 4.0 uses some language keywords (out and in) to annotate covariance and contra-variance. Out is used for covariance, while in is used for contra-variance. Variance can be applied only to reference types, generic interfaces, and generic delegates. These cannot be applied to value types and generic types. 1.1.7. httpHandler, httpModule Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/dotnet/lock.html": {
    "url": "Basic/dotnet/lock.html",
    "title": "lock",
    "keywords": "",
    "body": "1. lock1.1.1. lock(this)1.1.2. lock(private obj)1.1.3. lock(string)1.1.4. 总结1. lock 首先先上官方 Msdn 的说法 lock 关键字可确保当一个线程位于代码的临界区时，另一个线程不会进入该临界区。 如果其他线程尝试进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。 lock 关键字在块的开始处调用 Enter，而在块的结尾处调用 Exit。 ThreadInterruptedException 引发，如果 Interrupt 中断等待输入 lock 语句的线程。通常，应避免锁定 public 类型，否则实例将超出代码的控制范围。 常见的结构 lock (this)、lock (typeof (MyType)) 和 lock (\"myLock\") 违反此准则：如果实例可以被公共访问，将出现 lock (this) 问题。如果 MyType 可以被公共访问，将出现 lock (typeof (MyType)) 问题。由于进程中使用同一字符串的任何其他代码都将共享同一个锁，所以出现 lock(\"myLock\") 问题。最佳做法是定义 private 对象来锁定, 或 private static 对象变量来保护所有实例所共有的数据。在 lock 语句的正文不能使用 等待 关键字。 Enter 指的是 Monitor.Enter(获取指定对象上的排他锁。)，Exit 指的是 Monitor.Exit(释放指定对象上的排他锁。) 有上面 msdn 的解释及 Exit 方法，可以这样猜测“直到该对象被释放”，”该对象“应该是指锁的对象，对象释放了或者对象改变了，其他的线程才可以进入代码临界区（是不是可以这样来理解？）。 在多线程中，每个线程都有自己的资源，但是代码区是共享的，即每个线程都可以执行相同的函数。这可能带来的问题就是几个线程同时执行一个函数，导致数据的混乱，产生不可预料的结果，因此我们必须避免这种情况的发生。 打个比方，有这样一个情景，很多公司所在的大厦的厕所的蹲位都是小单间型的，也就是一次只能进去一个人，那么为了避免每次进去一个人，那怎么做呢？不就是一个人进去之后顺手把门锁上么？这样你在里面干啥事，外边的人也只能等待你解放完了，才能进入。而蹲位的资源（蹲位，手纸等）是共享的。 最常使用的锁是如下格式的代码段： private static object objlock = new object(); lock (objlock) { //要执行的代码逻辑 } 为什么锁的对象是私有的呢？还是以厕所为例子吧，私有就好比，这把锁只有你能访问到，而且最好这把锁不会因为外力而有所改变，别人访问不到，这样才能保证你进去了，别人就进不去了，如果是公有的，就好比你蹲位小单间的锁不是安装在里面而是安装在外边的，别人想不想进就不是你所能控制的了，这样也不安全。 1.1.1. lock(this) 通过字面的意思就是锁的当前实例对象。那是否对其他实例对象产生影响？那下面看一个例子： namespace Wolfy.LockDemo { class Program { static void Main(string[] args) { Test t = new Test(); Test t2 = new Test(); Thread[] threads = new Thread[10]; for (int i = 0; i { t2.Print(); }); //为每个线程设置一个名字 threads[i].Name = \"thread\" + i; } //开启创建的十个线程 for (int i = 0; i 如果在不加锁的情况下输出如下： 从上面的输出结果也可以看出，线程出现了争抢的现象，而这并不是我们想要的结果，我们想要的是，每次只有一个线程去执行 Print 方法。那我们就尝试一下 lock(this) class Test { public void Print() { lock (this) { for (int i = 0; i 输出结果 从输出结果，觉得大功告成了，可是现在情况又来了，在项目中的其他的地方，有同事也这样写了这样的代码，又创建了一个 Test 对象，而且他也知道使用多线程执行耗时的工作，那么就会出现类似下面的代码。 namespace Wolfy.LockDemo { class Program { static void Main(string[] args) { Test t = new Test(); Test t2 = new Test(); t2.Age = 20; Thread[] threads = new Thread[10]; for (int i = 0; i { t.Print(); t2.Print(); }); //为每个线程设置一个名字 threads[i].Name = \"thread\" + i; } //开启创建的十个线程 for (int i = 0; i 这里为 Test 加了一个 Age 属性，为了区别当前创建的对象不是同一个对象。 输出的结果为 在输出的结果中已经出现了线程抢占执行的情况了，而不是一个线程执行完另一个线程在执行。 1.1.2. lock(private obj) 那么我们现在使用一个全局的私有的对象试一试。 namespace Wolfy.LockDemo { class Program { private static object objLock = new object(); static void Main(string[] args) { Test t = new Test(); Test t2 = new Test(); t2.Age = 20; Thread[] threads = new Thread[10]; for (int i = 0; i { lock (objLock) { t.Print(); t2.Print(); } }); //为每个线程设置一个名字 threads[i].Name = \"thread\" + i; } //开启创建的十个线程 for (int i = 0; i 输出的结果 从输出的结果也可以看出，有序的，每次进来一个线程执行。 那通过上面的比较可以有这样的一个结论，lock 的结果好不好，还是关键看锁的谁，如果外边能对这个谁进行修改，lock 就失去了作用。所以一般情况下，使用静态的并且是只读的对象。 也就有了类似下面的代码 private static readonly object objLock = new object(); 你可能会说，不对啊，你下面的代码跟上面的代码不一样啊，为什么就得出这样的结论？难道就不能把 Object 放在 test 类中么，放在 test 类中的话，在 new Test()的时候，其实放在 Test 中也是可以的，只要保证 objLock 在外部是无法修改的就可以。 上面说的最多的是 lock 对象，那么它能不能 lock 值类型？ 答案是否定的，如 当然 lock(null)也是不行的，如图 虽然编译可以通过，但是运行就会出错。 1.1.3. lock(string) string 也是应用类型，从语法上来说是没有错的。 但是锁定字符串尤其危险，因为字符串被公共语言运行库 (CLR)“暂留”。 这意味着整个程序中任何给定字符串都只有一个实例，就是这同一个对象表示了所有运行的应用程序域的所有线程中的该文本。因此，只要在应用程序进程中的任何位置处具有相同内容的字符串上放置了锁，就将锁定应用程序中该字符串的所有实例。通常，最好避免锁定 public 类型或锁定不受应用程序控制的对象实例。例如，如果该实例可以被公开访问，则 lock(this) 可能会有问题，因为不受控制的代码也可能会锁定该对象。这可能导致死锁，即两个或更多个线程等待释放同一对象。出于同样的原因，锁定公共数据类型（相比于对象）也可能导致问题。而且 lock(this)只对当前对象有效，如果多个对象之间就达不到同步的效果。lock(typeof(Class))与锁定字符串一样，范围太广了。 1.1.4. 总结 lock 的是引用类型的对象，string 类型除外。 ==lock 推荐的做法是使用静态的、只读的、私有的对象。== 保证 lock 的对象在外部无法修改才有意义，如果 lock 的对象在外部改变了，对其他线程就会畅通无阻，失去了 lock 的意义。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/dotnet/reflection.html": {
    "url": "Basic/dotnet/reflection.html",
    "title": "reflection",
    "keywords": "",
    "body": "1. .net 反射1.1.1. 常用的反射例子1.1.2. 反射中经常使用的类1.1.3. 示例1.1.4. .net 反射优缺点1.1.5. 使用反射机制调用方法的四步曲1.1.6. System.Reflection.Assembly 类1.1.7. System.Type 类1.1.8. 反射方法1.1.9. 四、反射属性1.1.10. 五、反射字段1.1.11. 六、反射特性1.1.12. 七、常用实例1. .net 反射 反射就是动态发现类型信息的能力。它帮助程序设计人员在程序==运行时利用一些信息去动态地使用类型==，这些信息在设计时是未知的，这种能力类型于后期绑定。反射还支持的更高级的行为，能在运行时==动态创建新类型，并且对这些新类型的操作进行调用==。 1.1.1. 常用的反射例子 变化数据库，通过反射动态读取配置文件 SqlHelper SqlDataReader 读取数据库，表明通过反射加载 开发 windows form 插件： 创建接口项目，通过接口定义插件实现方式 创建插件项目，创建两个插件一个实现汉英翻译功能，一个实现定时关机功能。插件项目要引用接口项目。编译时让插件项目生成在主程序的 debug/plugin 目录下 创建主程序，主程序要添加对接口项目的引用(不需要对插件引用，对插件的调用是动态的) 主程序中读取 Plugin 目录下的所有 dll 文件，加载成 Assembly。Ass.GetExportedTypes 读取 Assembly 中的公共类型。 IsAssignableFrom 判断对象能否委派给某类型，是否是类并且不能使抽象类 1.1.2. 反射中经常使用的类 Assembly 类 Assembly 类是可重用、无版本冲突并且可自我描述的公共语言运行库应用程序构造块。可以使用 Assembly.Load 和 Assembly.LoadFrom 方法动态地加载程序集。 Type 类 反射的中心是 System.Type 类。System.Type 类是一个抽象类，代表公用类型系统中的一种类型。这个类使您能够查询类型名、类型中包含的模块和名称空间、以及该类型是一个数值类型还是一个引用类型。System.Type 类使您能够查询几乎所有与类型相关的属性，包括类型访问限定符、类型是否、类型的 COM 属性等等。 Activator 类 Activator 类支持动态创建.NET 程序集和 COM 对象。可以通过 CreateComInstanceFrom、CreateInstance、CreateInstanceFrom、GetObject 四个静态方法加载 COM 对象或者程序集，并能创建指定类型的实例。 Binder 类 Binder 类是一个用于执行类型转换的绑定器，Type 对象的 InvokeMember 方法接受 Binder 对象，这个对象描述了如何将传递给 InvokeMember 的参数转换成方法实际需要的类型。Binder 类是一个抽象类，要创建绑定器，需要重写方法 BindToMethod、BindToField、SelectMehtod、SelectProperty 和 ChangeType。 DefaultMemberAttribute 类 DefaultMemberAttribute 类用于类型并带有一个指明默认成员名称的字符串参数。能够通过 InvokeMember 调用默认成员，而不需要传递调用成员的名称。当需要绑定器但不需要特别的绑定行为时就可以使用它。 还有一些对元素类型信息描述的类，ConstrutorInfo（构造函数）、MethodInfo（方法）、FieldInfo（字段）、PropertyInfo（属性）、EventInfo（事件）、MemberInfo（成员）、ParameterInfo（参数）。如果查询得到了具有任何类型信息的实例，就可以获得该类型中任意元素的类型信息，当然出于安全原因，不保证会得到程序集中的任何信息。 1.1.3. 示例 using System; using System.Collections.Generic; using System.Text; namespace ReflectionSample { public class ClassSample { // 默认构造 public ClassSample() { this.name = \"您调用了默认构造创建了一个类实例。\"; } // 带参构造 public ClassSample(string name) { this.name = name; } // 字段 public string name; public string Field; // 属性 private string property; public string Property { set { this.property = value; } get { return property; } } // public方法 public string PublicClassMethod() { return string.Format(\"您反射了一个Public方法\"); } // private方法 private string PrivateClassMethod() { return string.Format(\"您反射了一个Private方法\"); } // static方法 public static string StaticMethod() { return \"您反射了一个Static方法\"; } // 帶參方法 public string ParameterMethod(string para) { return para; } public event EventHandler eventHandler; public void DoEvent() { eventHandler(null,EventArgs.Empty); } } } using System; using System.Data; using System.Configuration; using System.Web; using System.Web.Security; using System.Web.UI; using System.Web.UI.WebControls; using System.Web.UI.WebControls.WebParts; using System.Web.UI.HtmlControls; using System.Reflection; using ReflectionSample; public partial class _Default : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { string path = Server.MapPath(Request.Path); string filePath = path.Substring(0, path.LastIndexOf(''\\\\'')) + @\"\\bin\\ReflectionSample.dll\"; // 获取程序集 Assembly classSampleAssembly = Assembly.LoadFrom(filePath); // 从程序集中获取指定对象类型 Type classSampleType = classSampleAssembly.GetType(\"ReflectionSample.ClassSample\"); // 通过对象类型创建对象实例 ClassSample s1 = Activator.CreateInstance(classSampleType) as ClassSample; Response.Write(s1.name + \"（使用Activator创建一个实例）\"); // 动态调用无参构造 ConstructorInfo studentConstructor1 = classSampleType.GetConstructor(new Type[] { }); ClassSample s2 = studentConstructor1.Invoke(new object[] { }) as ClassSample; Response.Write(s2.name + \"\"); // 动态调用有参构造 ConstructorInfo studentConstructor2 = classSampleType.GetConstructor(new Type[] { typeof(string) }); ClassSample s3 = studentConstructor2.Invoke(new object[] { \"您调用了有参构造创建了一个类实例。\" }) as ClassSample; Response.Write(s3.name + \"\"); // 调用非静态方法 string returnValue1 = classSampleType.InvokeMember(\"PublicClassMethod\", BindingFlags.InvokeMethod | BindingFlags.Public | BindingFlags.Instance, null, s1, new object[] { }) as string; Response.Write(returnValue1 + \"\"); // 调用静态方法 string returnValue2 = classSampleType.InvokeMember(\"StaticMethod\", BindingFlags.InvokeMethod | BindingFlags.Public | BindingFlags.Static, null, s1, new object[] { }) as string; Response.Write(returnValue2 + \"\"); // 调用私有方法 string returnValue3 = classSampleType.InvokeMember(\"PrivateClassMethod\", BindingFlags.InvokeMethod | BindingFlags.NonPublic | BindingFlags.Instance, null, s1, new object[] { }) as string; Response.Write(returnValue3 + \"\"); //反射参数 MethodInfo parameterMethod = classSampleType.GetMethod(\"ParameterMethod\"); ParameterInfo[] paras = parameterMethod.GetParameters(); for (int i = 0; i 1.1.4. .net 反射优缺点 缺点： 编译器无法对对象进行类型检查 编写更多的代码来实现 速度慢 优势： 为创建对象和调用其他方法提供了替代方案。比如为了提高代码的灵活性 将指定具体类推迟到了运行时刻。 1.1.5. 使用反射机制调用方法的四步曲 加载程序集 获取类的类型 创建该类的实例 调用该实例的方法 System.Reflection.Assembly 类中有两个静态方法 Assembly.Load(string assemblyName)和 Assembly.LoadFrom(string fileName)来把程序集加载到应用程序序域中。 在.NET 中当一个对象被创建时，幕后到底发生了什么？当我们运行某一个应用程序时，.NET CLR 会首先创建一个应用程序域来容纳这个应用程序，接着将应该引用的程序集加载到应用程序域中。其中 MSCorLib.dll 是一个程序集，它包含了很多系统命名空间及其子命名空间中的类：System;System.Text,System.IO 等。然后 CLR 加载正在运行的应用程序所属的程序集。 namespace ClassLibrarySport { // define abstract class public abstract class Sport { protected string Name; public abstract string GetName(); public abstract string GetDuration(); } } namespace ClassLibrarySomeSports { public class Football : ClassLibrarySport.Sport { public Football() { Name = \"Football\"; } public override string GetName() { return Name; } public override string GetDuration() { return \"four 15 minute quarters\"; } } } // reflection usage: using System; using System.Reflection; namespace ConsoleAssemblyTest { class Program { static void Main(string[] args) { Assembly assembly = Assembly.LoadFrom(@\"E:\\ClassLibrarySomeSports\\bin\\Debug\\ClassLibrarySomeSports.dll\"); Type[] types = assembly.GetTypes(); Console.WriteLine(\"Get Type From ClassLibrarySomeSports.dll:\"); for (int i = 0; i 类型 作用 Assembly 通过此类可以加载操纵一个程序集，并获取程序集内部信息 EventInfo 该类保存给定的事件信息 FieldInfo 该类保存给定的字段信息 MethodInfo 该类保存给定的方法信息 MemberInfo 该类是一个基类，它定义了 EventInfo、FieldInfo、MethodInfo、PropertyInfo 的多个公用行为 Module 该类可以使你能访问多个程序集中的给定模块 ParameterInfo 该类保存给定的参数信息 PropertyInfo 该类保存给定的属性信息 1.1.6. System.Reflection.Assembly 类 通过 Assembly 可以动态加载程序集，并查看程序集的内部信息，其中最常用的就是 Load()这个方法。 Assembly assembly=Assembly.Load(\"MyAssembly\"); 利用 Assembly 的 object CreateInstance(string) 方法可以反射创建一个对象，参数 0 为类名。 1.1.7. System.Type 类 Type 是最常用到的类，通过 Type 可以得到一个类的内部信息，也可以通过它反射创建一个对象。一般有三个常用的方法可得到 Type 对象。 利用 typeof() 得到 Type 对象 Type type=typeof(Example); 利用 System.Object.GetType() 得到 Type 对象 Example example=new Example(); Type type=example.GetType(); 利用 System.Type.GetType() 得到 Type 对象 Type type=Type.GetType(\"MyAssembly.Example\",false,true); 注意参数 0 是类名，参数 1 表示若找不到对应类时是否抛出异常，参数 1 表示类名是否区分大小写 例子： 我们最常见的是利用反射与 Activator 结合来创建对象。 Assembly assembly= Assembly.Load(\"MyAssembly\"); Type type=assembly.GetType(\"Example\"); object obj=Activator.CreateInstance(type); 1.1.8. 反射方法 通过 System.Reflection.MethodInfo 能查找到类里面的方法 Type type=typeof(Example); MethodInfo[] listMethodInfo=type.GetMethods(); foreach(MethodInfo methodInfo in listMethodInfo) Cosole.WriteLine(\"Method name is \"+methodInfo.Name); 我们也能通过反射方法执行类里面的方法 Assembly assembly= Assembly.Load(\"MyAssembly\"); Type type=assembly.GetType(\"Example\"); object obj=Activator.CreateInstance(type); MethodInfo methodInfo=type.GetMethod(\"Hello World\"); //根据方法名获取MethodInfo对象 methodInfo.Invoke(obj,null); //参数1类型为object[]，代表Hello World方法的对应参数，输入值为null代表没有参数 1.1.9. 四、反射属性 通过 System.Reflection.PropertyInfo 能查找到类里面的属性 常用的方法有 GetValue（object,object[]) 获取属性值和 SetValue(object,object,object[]) 设置属性值 Type type=typeof(Example); PropertyInfo[] listPropertyInfo=type.GetProperties(); foreach(PropertyInfo propertyInfo in listPropertyInfo) ​ Console.WriteLine(\"Property name is \"+ propertyInfo.Name); 我们也可以通过以下方法设置或者获取一个对象的属性值 Assembly assembly=Assembly.Load(\"MyAssembly\"); Type type=assembly.GetType(\"Example\"); object obj=Activator.CreateInstance(type); PropertyInfo propertyInfo=obj.GetProperty(\"Name\"); //获取Name属性对象 var name=propertyInfo.GetValue(obj,null）; //获取Name属性的值 PropertyInfo propertyInfo2=obj.GetProperty(\"Age\"); //获取Age属性对象 propertyInfo.SetValue(obj,34,null); //把Age属性设置为34 1.1.10. 五、反射字段 通过 System.Reflection.FieldInfo 能查找到类里面的字段 它包括有两个常用方法 SetValue（object ,object )和 GetValue（object) 因为使用方法与反射属性非常相似 1.1.11. 六、反射特性 通过 System.Reflection.MemberInfo 的 GetCustomAttributes(Type,bool)就可反射出一个类里面的特性,以下例子可以反射出一个类的所有特性 Type type=typeof(\"Example\"); object[] typeAttributes=type.GetCustomAttributes(false); //获取Example类的特性 foreach(object attribute in typeAttributes) Console.WriteLine(\"Attributes description is \"+attribute.ToString()); 通过下面例子，可以获取 Example 类 Name 属性的所有特性 public class Example { [DataMemberAttribute] publics string Name { get; set; } } Type type = typeof(Example); PropertyInfo propertyInfo = type.GetProperty(\"Name\"); //获取Example类的Name属性 foreach (object attribute in propertyInfo.GetCustomAttributes(false)) { //遍历Name属性的所有特性 Console.WriteLine(\"Property attribute: \"+attribute.ToString()); } 1.1.12. 七、常用实例 虽然反射有很多奥妙之处，但要注意使用反射生成对象会耗费很多性能，所能必须了解反射的特性，在合适的地方使用。最常见例子就是利用单体模式与反射一并使用，在 BLL 调用 DAL 的时候，通过一个反射工厂生成 DAL 实例。 namespace Project.Common { public class Factory { //记录dal的对象 private static Hashtable dals; //用assemblyString记录DAL程序集的全名称 private static string assemblyString = ConfigurationManager.AppSettings[\"LinqDAL\"]; private static Assembly assembly; static Factory() { dals = new Hashtable(); assembly = Assembly.Load(assemblyString); } private static object CreateInstance(string typeName) { //当第一次加载时，将反射对象保存于dals集合里 if (!dals.ContainsKey(typeName)) { //创建反射对象 object object1 = assembly.CreateInstance(typeName); if (object1 == null) throw new Exception(\"未能创建此对象\"); //把对象加入dals集合 dals[\"typeName\"] = object1; } return dals[\"typeName\"]; } public static IExampleDAL CreateExampleDAL() { return (IExampleDAL)CreateInstance(assemblyString + \".ExampleDAL\"); } } class Program { //利用工厂模式生成对象 static void Main(string[] args) { IExampleDAL iExampleDAL=Factory.CreateExampleDAL(); ................. Console.ReadKey(); } } } namespace Project.IDAL { public interface IExampleDAL { /// /// 插入Example行，若插入成功，则返回新增Example的行数 /// ///Example对象 ///返回新增Example行数，默认值为-1 int AddExample(Example example); /// /// 更新Example表,Update成功返回已经更新的数据条数,失败返回-1 /// ///Example对象 ///Update成功返回已经更新的数据条数,失败返回-1 int UpdateExample(Example example); /// /// 删除Example表中ID等于exampleID的行,返回已删除行数 /// ///Example对象的ID值 ///返回删除行数 int DeleteExample(int exampleID); /// /// 获取Example表的所有行 /// ///返回Example表中的所有Example对象 IList GetList(); /// /// 根据ID获取对应Example对象 /// /// /// Example GetExampleByID(int id); } } namespace Project.DAL { public class ExampleDAL:IExampleDAL { public int AddExample(Example example) { //实现AddExample方法 } } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/dotnet/SignalR集群.html": {
    "url": "Basic/dotnet/SignalR集群.html",
    "title": "SignalR 集群",
    "keywords": "",
    "body": "1. Asp.Net SignalR 集群会遇到的问题1.1. SqlServer 来做底板1.2. redis 来做底板1. Asp.Net SignalR 集群会遇到的问题 当客户端数量上来，一台 server 自然是吃不消的。多个 server 集群部署是必然的解决方案。再通过负载均衡，嗯 简直是完美。但是问题也接踵而来。每个 server 只能管理到当前 server 下的 client，比如 server1 要给连接在 server2 的 client 发一条消息是实现不了的。 这时我们需要“底板”中间件，什么叫底板 ，也就是在 server 的集群上再加一层，由底板来维护这些 server，像上面 server1 给连接在 server2 的 client 发消息，底板会告诉 server2 给 client 发一条消息。就达到了我们需要的效果 常用的有 Redis 与 SqlServer，其实 Redis 性能是最优的。 1.1. SqlServer 来做底板 需要下载 nuget 包 Microsoft.AspNet.SignalR.SqlServer 然后在 startup 类中进行配置,也是非常简单的,数据库是 signalR。把程序运行一下，我们会得到以下这些表 1.2. redis 来做底板 需要下载 nuget 包 Microsoft.AspNet.SignalR.Redis 同样在 startup 类中进行配置， GlobalHost.DependencyResolver.UseRedis(\"localhost\", 6379, string.Empty, \"signalR\"); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/dotnet/webapi.html": {
    "url": "Basic/dotnet/webapi.html",
    "title": "webapi",
    "keywords": "",
    "body": "1.1.1. Explain what is REST and RESTFUL?1.1.2. Explain the architectural style for creating web api?1.1.3. what tools are required to test your web api?1.1.4. what are the HTTP methods supported by REST?1.1.5. Mention what is the difference between SOAP and REST?1.1.6. Explain Web API Routing?1.1.7. List out the differences between WCF and Web API?1.1.8. What are the advantages of using REST in Web API?1.1.9. Difference between WCF Rest and Web API?1.1.10. List out differences between MVC and Web API?1.1.11. What are the advantages of Web API?1.1.12. Can we return view from Web API?1.1.13. How we can restrict access to methods with specific HTTP verbs in Web API?1.1.14. Explain how to give alias name for action methods in Web API?1.1.15. What is the difference between MVC Routing and Web API Routing?1.1.16. Explain Exception Filters?1.1.17. Explain about the new features added in Web API 2.0 version?1.1.18. How can we pass multiple complex types in Web API?1.1.19. Write a code snippet for passing arraylist in Web API?1.1.20. Give an example of MVC Routing?1.1.21. How we can handle errors in Web API?1.1.22. Explain how we can handle error from HttpResponseException?1.1.23. How to register Web API exception filters?1.1.24. Write a code snippet to register exception filters from action?1.1.25. Write a code snippet to register exception filters from controller?1.1.26. Write a code snippet to register exception filters globally?1.1.27. How to handle error using HttpError?1.1.28. Write a code snippet to show how we can return 404 error from HttpError?1.1.29. How to enable tracing in Web API?1.1.30. Explain how Web API tracing works?1.1.31. Explain Authentication in Web API?1.1.32. Explain ASP.NET Identity?1.1.33. What are Authentication Filters in Web API?1.1.34. How to set the Authentication filters in Web API?1.1.35. Explain method – \"AuthenticateAsync\" in Web API?1.1.36. Explain method – ChallengeAsync in Web API?1.1.37. What are media types?1.1.38. List out few media types of HTTP?1.1.39. Explain Media Formatters in Web API?1.1.40. How to serialize read*only properties?1.1.41. How to get Microsoft JSON date format?1.1.42. How to indent the JSON in web API?1.1.43. How to JSON serialize anonymous and weakly types objects?1.1.44. What is the use of IgnoreDataMember1.1.45. How to write indented XML in Web API?1.1.46. How to set Per*Type xml serializer?1.1.47. What is UnderPosting and \"OverPosting\" in Web API?1.1.48. How to handle validation errors in Web API?1.1.49. Give an example of creating custom action filter in Web API?1.1.50. How to apply custom action filter in WebAPI.config?1.1.51. What is BSON in Web API?1.1.52. How to enable BSON in server?1.1.53. How parameter binding works in Web API?1.1.54. Why to use \"FromUri\" in Web API?1.1.55. Why to use \"FromBody\" in Web API?1.1.56. Why to use \"IValueprovider\" interface in Web API?1.1.1. Explain what is REST and RESTFUL? REST represents REpresentational State Transfer; it is relatively new aspect of writing web api. RESTFUL is referred for web services written by applying REST architectural concept are called RESTful services, it focuses on system resources and how state of resource should be transported over HTTP protocol to a different clients written in different language. In RESTFUL web service http methods like GET, POST, PUT and DELETE can be used to perform CRUD operations. 1.1.2. Explain the architectural style for creating web api? HTTP for client server communication XML/JSON as formatting language: Simple URI as the address for the services Stateless communication 1.1.3. what tools are required to test your web api? Chrome postman, SOAPUI tool for SOAP WS and Firefox \"poster\" plugin for RESTFUL services. 1.1.4. what are the HTTP methods supported by REST? GET: It requests a resource at the request URL. It should not contain a request body as it will be discarded. May be it can be cached locally or on the server. POST: It submits information to the service for processing; it should typically return the modified or new resource PUT: At the request URL it update the resource DELETE: At the request URL it removes the resource OPTIONS: It indicates which techniques are supported HEAD: About the request URL it returns meta information 1.1.5. Mention what is the difference between SOAP and REST? SOAP is a protocol through which two computer communicates by sharing XML document SOAP permits only XML SOAP based reads cannot be cached SOAP is like custom desktop application, closely connected to the server SOAP is slower than REST It runs on HTTP but envelopes the message Rest is a service architecture and design for network*based software architectures REST supports many different data formats REST reads can be cached A REST client is more like a browser; it knows how to standardized methods and an application has to fit inside it REST is faster than SOAP It uses the HTTP headers to hold meta information 1.1.6. Explain Web API Routing? Routing is the mechanism of pattern matching as we have in MVC. These routes will get registered in Route Tables. Below is the sample route in Web API – Routes.MapHttpRoute( Name: \"MyFirstWebAPIRoute\", routeTemplate: \"api/{controller}/{id} defaults: new { id = RouteParameter.Optional} }; 1.1.7. List out the differences between WCF and Web API? WCF It is framework build for building or developing service oriented applications. WCF can be consumed by clients which can understand XML. WCF supports protocols like – HTTP, TCP, Named Pipes etc. Web API It is a framework which helps us to build/develop HTTP services Web API is an open source platform. It supports most of the MVC features which keep Web API over WCF. 1.1.8. What are the advantages of using REST in Web API? REST always used to make less data transfers between client and server which makes REST an ideal for using it in mobile apps. Web API supports HTTP protocol thereby it reintroduces the old way of HTTP verbs for communication. 1.1.9. Difference between WCF Rest and Web API? WCF Rest \"WebHttpBinding\" to be enabled for WCF Rest. For each method there has to be attributes like – \"WebGet\" and \"WebInvoke\" For GET and POST verbs respectively. Web API Unlike WCF Rest we can use full features of HTTP in Web API. Web API can be hosted in IIS or in application. 1.1.10. List out differences between MVC and Web API? MVC MVC is used to create a web app, in which we can build web pages. For JSON it will return JSONResult from action method. All requests are mapped to the respective action methods. Web API This is used to create a service using HTTP verbs. This returns XML or JSON to client. All requests are mapped to actions using HTTP verbs. 1.1.11. What are the advantages of Web API? OData Filters Content Negotiation Self Hosting Routing Model Bindings 1.1.12. Can we return view from Web API? No. We cannot return view from Web API. 1.1.13. How we can restrict access to methods with specific HTTP verbs in Web API? Attribute programming is used for this functionality. Web API will support to restrict access of calling methods with specific HTTP verbs. We can define HTTP verbs as attribute over method as shown below [HttpPost] public void UpdateTestCustomer(Customer c) { TestCustomerRepository.AddCustomer(c); } 1.1.14. Explain how to give alias name for action methods in Web API? Using attribute \"ActionName\" we can give alias name for Web API actions. Eg: [HttpPost] [ActionName(\"AliasTestAction\")] public void UpdateTestCustomer(Customer c) { TestCustomerRepository.AddCustomer(c); } 1.1.15. What is the difference between MVC Routing and Web API Routing? There should be at least one route defined for MVC and Web API to run MVC and Web API application respectively. In Web API pattern we can find \"api/\" at the beginning which makes it distinct from MVC routing. In Web API routing \"action\" parameter is not mandatory but it can be a part of routing. 1.1.16. Explain Exception Filters? Exception filters will be executed whenever controller methods (actions) throws an exception which is unhandled. Exception filters will implement \"IExceptionFilter\" interface. 1.1.17. Explain about the new features added in Web API 2.0 version? OWIN Attribute Routing External Authentication Web API OData 1.1.18. How can we pass multiple complex types in Web API? Using ArrayList Newtonsoft JArray 1.1.19. Write a code snippet for passing arraylist in Web API? ArrayList paramList = new ArrayList(); Category c = new Category { CategoryId = 1, CategoryName = \"SmartPhones\"}; Product p = new Product { ProductId = 1, Name = \"Iphone\", Price = 500, CategoryID = 1 }; paramList.Add(c); paramList.Add(p); 1.1.20. Give an example of MVC Routing? Below is the sample code snippet to show MVC Routing – routes.MapRoute( name: \"MyRoute\", //route name url: \"{controller}/{action}/{id}\", //route pattern defaults: new { controller = \"a4academicsController\", action = \"a4academicsAction\", id = UrlParameter.Optional } ); 1.1.21. How we can handle errors in Web API? HttpResponseException Exception Filters Registering Exception Filters HttpError 1.1.22. Explain how we can handle error from HttpResponseException? public TestClass MyTestAction(int id) { TestClass c = repository.Get(id); if (c == null) { throw new HttpResponseException(HttpStatusCode.NotFound); } return c; } HttpResponseMessage myresponse = new HttpResponseMessage(HttpStatusCode.Unauthorized); myresponse.RequestMessage = Request; myresponse.ReasonPhrase = ReasonPhrase; 1.1.23. How to register Web API exception filters? From Action From Controller Global registration 1.1.24. Write a code snippet to register exception filters from action? [NotImplExceptionFilter] public TestCustomer GetMyTestCustomer(int custid) { //Your code goes here } 1.1.25. Write a code snippet to register exception filters from controller? [NotImplExceptionFilter] public class TestCustomerController : Controller { //Your code goes here } 1.1.26. Write a code snippet to register exception filters globally? GlobalConfiguration.Configuration.Filters.Add(new MyTestCustomerStore.NotImplExceptionFilterAttribute()); 1.1.27. How to handle error using HttpError? HttpError will be used to throw the error info in response body. CreateErrorResponse method is used along with this, which is an extension method defined in \"HttpRequestMessageExtensions\". 1.1.28. Write a code snippet to show how we can return 404 error from HttpError? string message = string.Format(\"TestCustomer id = {0} not found\", customerid); return Request.CreateErrorResponse(HttpStatusCode.NotFound, message); 1.1.29. How to enable tracing in Web API? in Register method of WebAPIConfig.cs file. config.EnableSystemDiagnosticsTracing(); 1.1.30. Explain how Web API tracing works? Tracing in Web API done in facade pattern i.e, when tracing for Web API is enabled, Web API will wrap different parts of request pipeline with classes, which performs trace calls. 1.1.31. Explain Authentication in Web API? Web API authentication will happen in host. In case of IIS it uses Http Modules for authentication or we can write custom Http Modules. When host is used for authentication it used to create principal, which represent security context of the application. 1.1.32. Explain ASP.NET Identity? This is the new membership system for ASP.NET. This allows to add features of login in our application. One ASP.NET Identity System Persistence Control 1.1.33. What are Authentication Filters in Web API? Authentication Filter will let you set the authentication scheme for actions or controllers. So this way our application can support various authentication mechanisms. 1.1.34. How to set the Authentication filters in Web API? Authentication filters can be applied at the controller or action level. Decorate attribute – \"IdentityBasicAuthentication\" over controller where we have to set the authentication filter. 1.1.35. Explain method – \"AuthenticateAsync\" in Web API? \"AuthenticateAsync\" method will create IPrincipal and will set on request Task AuthenticateAsync( HttpAuthenticationContext mytestcontext, CancellationToken mytestcancellationToken ) 1.1.36. Explain method – ChallengeAsync in Web API? to add authentication challenges to response. Below is the method signature – Task ChallengeAsync( HttpAuthenticationChallengeContext mytestcontext, CancellationToken mytestcancellationToken ) 1.1.37. What are media types? It is also called MIME, which is used to identify the data. In Html, media types is used to describe message format in the body. 1.1.38. List out few media types of HTTP? Image/Png Text/HTML Application/Json 1.1.39. Explain Media Formatters in Web API? Media Formatters in Web API can be used to read the CLR object from our HTTP body and Media formatters are also used for writing CLR objects of message body of HTTP. 1.1.40. How to serialize read*only properties? Read*Only properties can be serialized in Web API by setting the value \"true\" to the property SerializeReadOnlyTypes of class: DataContractSerializerSettings 1.1.41. How to get Microsoft JSON date format? Use \"DateFormatHandling\" property in serializer settings as below var myjson = GlobalConfiguration.Configuration.Formatters.JsonFormatter; myjson.SerializerSettings.DateFormatHandling = Newtonsoft.Json.DateFormatHandling.MicrosoftDateFormat; 1.1.42. How to indent the JSON in web API? var mytestjson = GlobalConfiguration.Configuration.Formatters.JsonFormatter; mytestjson.SerializerSettings.Formatting = Newtonsoft.Json.Formatting.Indented; 1.1.43. How to JSON serialize anonymous and weakly types objects? Using Newtonsoft.Json.Linq.JObject we can serialize and deserialize weakly typed objects. 1.1.44. What is the use of IgnoreDataMember By default if the properties are public then those can be serialized and deserialized, if we does not want to serialize the property then decorate the property with this attribute. 1.1.45. How to write indented XML in Web API? To write the indented xml set \"indent\" property to true. 1.1.46. How to set Per*Type xml serializer? We can use method – \"SetSerializer\". Below is the sample code snippet for using it var mytestxml = GlobalConfiguration.Configuration.Formatters.XmlFormatter; // Use XmlSerializer for instances of type \"Product\" mytestxml.SetSerializer(new XmlSerializer(typeof(MyTestCustomer))); 1.1.47. What is UnderPosting and \"OverPosting\" in Web API? \"UnderPosting\" When client leaves out some of the properties while binding then it’s called under–posting. \"OverPosting\" – If the client sends more data than expected in binding then it’s called overposting. 1.1.48. How to handle validation errors in Web API? Web API will not return error to client automatically on validation failure. So its controller’s duty to check the model state and response to that. We can create a custom action filter for handling the same. 1.1.49. Give an example of creating custom action filter in Web API? public class MyCustomModelAttribute : ActionFilterAttribute { public override void OnActionExecuting(HttpActionContext actionContext) { if (actionContext.ModelState.IsValid == false) { //Code goes here } } } In case validation fails here it returns HTTP response which contains validation errors. 1.1.50. How to apply custom action filter in WebAPI.config? Add a new action filter in \"Register\" method as shown * public static class WebApiConfig { public static void Register(HttpConfiguration config) { config.Filters.Add(new MyCustomModelAttribute()); } } How to set the custom action filter in action methods in Web API? Below is the sample code of action with custom action filter – public class MyCustomerTestController : ApiController { [MyCustomModelAttribute] public HttpResponseMessage Post(MyTestCustomer customer) { } } 1.1.51. What is BSON in Web API? It’s is a binary serialization format. \"BSON\" stands for \"Binary JSON\". BSON serializes objects to key*value pair as in JSON. Its light weight and its fast in encode/decode. 1.1.52. How to enable BSON in server? Add \"BsonMediaTypeFormatter\" in WebAPI.config as shown below public static class WebApiConfig { public static void Register(HttpConfiguration config) { config.Formatters.Add(new BsonMediaTypeFormatter()); } } 1.1.53. How parameter binding works in Web API? If it is simple parameters like – bool, int, double etc. then value will be obtained from the URL. Value read from message body in case of complex types. 1.1.54. Why to use \"FromUri\" in Web API? In Web API to read complex types from URL we will use \"FromUri\" attribute to the parameter in action method. Eg: public MyValuesController : ApiController { public HttpResponseMessage Get([FromUri] MyCustomer c) { ... } } 1.1.55. Why to use \"FromBody\" in Web API? This attribute is used to force Web API to read the simple type from message body. \"FromBody\" attribute is along with parameter. Eg: public HttpResponseMessage Post([FromBody] int customerid, [FromBody] string customername) { ... } 1.1.56. Why to use \"IValueprovider\" interface in Web API? This interface is used to implement custom value provider. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/dotnet/面向切面变成AOP.html": {
    "url": "Basic/dotnet/面向切面变成AOP.html",
    "title": "面向切面变成 AOP",
    "keywords": "",
    "body": "1. 面向切面编程1.1. 例子1. 面向切面编程 你的程序写好了。现在发现要针对所有业务操作添加一个日志，或者在前面加一道权限控制，怎么办呢？传统的做法是，改造每个业务方法，这样势必把代码弄得一团糟 aop 的思想是引导你从另一个切面来看待和插入这些工作。日志不管加在哪，它其实都是属于日志系统这个角度的。权限控制也一样。aop 允许你以一种统一的方式在运行时期在想要的地方插入这些逻辑。 Middleware 思想 1.1. 例子 中间件、拦截器、过滤器、.net actionFilter, exceptionFilter Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/": {
    "url": "Basic/frontend/",
    "title": "Basic/frontend",
    "keywords": "",
    "body": "1. TOC1. TOC cookie_localStorage_sessionStorage DOM 事件 Graceful-degradation_vs progressive-enhancement grunt_vs_gulp interview_闭包 Javascript 异步编程 Javascript 运行机制 JIT_vs_AOT JS 对象_原型链 JS 对象_继承 Object.defineProperty oop_delete_from_list React_Angular_Vue view_位置 webpack-hot-reloading_browserSync 原理 内存泄漏和垃圾回收 前端开发知识点 前端路由原理 前端面试杂 协议_HTTP 协议_HTTP2 协议_TCP_UDP_Http 的区别 协议_Websocket_SSE_vs_polling 协议_WebSocket 图片隐层且浏览器不下载 安全 模块化_AMD_CMD_UMD 浏览器渲染机制 浏览器缓存 深拷贝_浅拷贝 盒模型及宽高 算法 资源 preload_prefetch 通信_跨域 错误监控 页面性能 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Basic/frontend/cookie_localStorage_sessionStorage.html": {
    "url": "Basic/frontend/cookie_localStorage_sessionStorage.html",
    "title": "cookie_localStorage_sessionStorage",
    "keywords": "",
    "body": "1. Cookie, localStorage, sessionStorage 区别1.1. Cookie1.1.1. 什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）1.2. localStorage1. Cookie, localStorage, sessionStorage 区别 cookie 在浏览器和服务器间来回传递。 sessionStorage 和 localStorage 不会 cookie 有 secure 属性要求 HTTPS 传输 cookie 属性有名，值，max-age，path, domain，secure cookie 默认有效期为浏览器会话，一旦用户关闭浏览器，数据就丢失，通过设置 max-age=seconds 属性告诉浏览器 cookie 有效期 cookie 作用域通过文档源和文档路径来确定，通过 path 和 domain 进行配置，web 页面同目录或子目录文档都可访问 浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M sessionStorage 和 localStorage 有更多丰富易用的接口 sessionStorage 和 localStorage 各自独立的存储空间 sessionStorage 在窗口关闭前有效，关闭窗口而非浏览器就会丢失数据。在新标签或窗口打开一个页面会初始化一个新的会话 localStorage 的数据会一直存在，即使在浏览器被关闭以后。localStorage 的修改会促发其他文档窗口的 update 事件，所以可以多窗口通信 Storage 对象通常被当做普通 javascript 对象使用：通过设置属性来存取字符串值，也可以通过 setItem(key, value) 设置，getItem(key) 读取，removeItem(key) 删除，clear() 删除所有数据，length 表示已存储的数据项数目，key(index) 返回对应索引的 key 1.1. Cookie 通过 cookie 保存数据的方法为：document.cookie = 'name=qiu; max-age=9999; path=/; domain=domain; secure';。设置 max-age=0 可以删除指定 cookie var cookieUtil = (function(window, undefined) { var doc = window.document; var cookieUtil = { /** * 根据 opt 中设置的值设置cookie * * @param {Object} opt 包含cookie信息的对象，选项如下 * key {string} 需要设置的名字 * value {string} 需要设置的值 * maxAge {number} 有效期 * domain {string} domain * path {string} path * secure {boolean} secure * * @return {string} opt 对应的设置 cookie的字符串 */ setItem: function(opt) { var result = []; var str; if (opt.key) { result.push(encodeURIComponent(opt.key) + '=' + encodeURIComponent(opt.value)); if ('maxAge' in opt) { result.push('max-age=' + opt.maxAge); } if ('domain' in opt) { result.push('domain=' + opt.domain); } if ('path' in opt) { result.push('path=' + opt.path); } if (opt.secure) { result.push('secure'); } str = result.join('; '); doc.cookie = str; } return str; }, /** * 从 cookie 读取指定 key 的值，如果key有多个值，返回数组，如果没有 * 对应key，返回undefined * * @param {string} key 需要从 cookie 获取值得 key * @return {string|Array|undefined} 根据cookie数据返回不同值 */ getItem: function(key) { key = encodeURIComponent(key); var result; var pairs = doc.cookie.split('; '); var i, len, item, value; for (i = 0, len = pairs.length; i 1.1.1. 什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做） 如果静态文件都放在主域名下，那静态文件请求的时候都带有的 cookie 的数据提交给 server 的，非常浪费流量，所以不如隔离开。 因为 cookie 有域的限制，因此不能跨域提交请求，故使用非主域名的时候，请求头中就不会带有 cookie 数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。同时这种方式不会将 cookie 传入 Web Server，也减少了 Web Server 对 cookie 的处理分析环节，提高了 webserver 的 http 请求的解析速度。 1.2. localStorage localStorage.setItem('x', 1); // storage x->1 localStorage.getItem('x'); // return value of x // 枚举所有存储的键值对 for (var i = 0, len = localStorage.length; i 多个标签页通信主要是利用了 localStorage 的增删改事件监听 页面 A 发送事件: function sendMsg(text) { window.localStorage.setItem('msg', text); } 页面 B 接收事件: window.addEventListener('storage', function(evt) { if (evt.key === 'msg') console.log(evt.newValue); }); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/DOM事件.html": {
    "url": "Basic/frontend/DOM事件.html",
    "title": "DOM 事件",
    "keywords": "",
    "body": "1. DOM 事件1.1. 事件级别1.2. 事件模型1.3. 事件流1.3.1. 事件委托(event delegation)？为何有事件委托存在？它有什么好处？1.4. 描述事件捕获流程1.5. Event 对象常见应用1.6. 自定义事件1.7. document.DOMContentLoaded, window.onload, document.readyState1.7.1. IE 和 Chrome 标准浏览器事件处理的解决办法(老题目，了解)1. DOM 事件 1.1. 事件级别 DOM0: element.onclick = function() {}; DOM2: element.addEventListener('click', function() {}, false); DOM3: element.addEventListener('keyup', function() {}, false); 1.2. 事件模型 捕获（上到下）、冒泡（下到上） 1.3. 事件流 捕获阶段 --> 目标阶段 --> 冒泡阶段 Capture: When you clicked, browser knows a click event occurred. It starts from the window (lowest level/root of your website), then goes to document, then html root tag, then body, then table... its trying to reach as the lowest level of element as possible. This is called capture phase. (从上到下到达目标元素) Target: When browser reach the lowest level of element. In this case, you have clicked on a table cell (table data) hence target would be td tag. Then browser checks whether you have any click handler attached to this element. If there is any, browser executes that click handler. This is called target phase. (执行目标元素的事件) Bubbling: After firing click handler attached to td, browser walks toward root. One level upward and check whether there is any click handler attached with table row (tr element). If there is any it will execute that. Then it goes to tbody, table, body, html, document, window. In this stage its moving upward and this is called event bubbling or bubbling phase. (从目标元素向上直到 window, 所有注册的事件都会一次由内向外执行) 1.3.1. 事件委托(event delegation)？为何有事件委托存在？它有什么好处？ You clicked on cell but all the event handler with parent elements will be fired. This is actually very powerful (check event delegation). 因为有事件冒泡，才会有事件委托出现。 好处：不需要循环为每个子元素 li 注册事件，节省空间和运算效率。第二如果不使用事件委托，添加新 li 时候还要为它注册事件，麻烦。用 e.CurrentTarget 获取父级元素。e.target 拿到 \b 当前被点击的 li。 1.4. 描述事件捕获流程 window --> document --> html (document.documentElement) --> body --> ... --> target 1.5. Event 对象常见应用 event.preventDefault(); event.stopPropagation(); event.stopImmediatePropagation(); // 如果一个元素注册了多个点击事件，第一个事件触发时候想终止第二个事件触发，在第一个事件中调用此方法 event.target; // 被点击的子元素 event.currentTarget; // 绑定事件父级元素 https://jsfiddle.net/thisman/gkdeocd6/ 1.6. 自定义事件 浏览器： let ev = new Event('myEvent'); dom.addEventListener('myEvent', () => {}); // fire the event dom.dispatchEvent(ev); 也可以使用 new CustomEvent('name', obj) 传递数据 Node 端自定义事件： // 使用 EventEmitter 模块 const EventEmitter = require('events'); class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter(); myEmitter.on('event', () => { console.log('an event occurred!'); }); myEmitter.emit('event'); 1.7. document.DOMContentLoaded, window.onload, document.readyState The DOMContentLoaded event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading. document.addEventListener('DOMContentLoaded', function(event) { console.log('DOM fully loaded and parsed. Images might be loading'); }); for (var i = 0; i The load event is fired when everything has finished loading. window.addEventListener('load', function(event) { console.log('All resources finished loading!'); }); The Document.readyState property of a document describes the loading state of the document. The readyState of a document can be one of following: loading: The document is still loading. interactive(DOMContentLoaded): The document has finished loading and the document has been parsed but sub-resources such as images, stylesheets and frames are still loading. complete(load): The document and all sub-resources have finished loading. The state indicates that the load event is about to fire. https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState 1.7.1. IE 和 Chrome 标准浏览器事件处理的解决办法(老题目，了解) IE 只有事件只能在冒泡阶段触发。标准浏览器通过 addEventListener('click', function(){}, true/false) 来指定触发阶段。false 为冒泡阶段触发。 IE: attachEvent('click', function(){}) 添加事件 detachEvent('click', function(){}) 删除事件 标准浏览器 DOM 中的事件对象 type：获取事件类型 target：事件目标 stopPropagation() 阻止事件冒泡 preventDefault() 阻止事件的默认行为 IE 中的事件对象 type：获取事件类型 srcElement：事件目标 cancelBubble = true 阻止事件冒泡 returnValue = false 阻止事件的默认行为 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/Graceful-degradation_vs progressive-enhancement.html": {
    "url": "Basic/frontend/Graceful-degradation_vs progressive-enhancement.html",
    "title": "Graceful-degradation_vs progressive-enhancement",
    "keywords": "",
    "body": "1. Graceful degradation versus Progressive enhancement (优雅降级和渐进增强)1.1. Graceful degradation(╮(╯﹏╰)╭)1.2. Progressive enhancement(✌️)1.3. Sum1.3.1. When to use what1. Graceful degradation versus Progressive enhancement (优雅降级和渐进增强) 都试图兼顾软件在不同环境下的运行状态。渐进增强是从一个基本的功能点出发，不断扩充新的特性功能，越好的浏览器得到越好的效果，是在向前看。优雅降级是一开始就想好一个相对较为完整的解决方案，当遇到老的浏览器时，效果和特性有所折损，是一种想回看的思维。现代开发渐进增强更有优势。 1.1. Graceful degradation(╮(╯﹏╰)╭) graceful degradation is the practice of building your web functionality so that it provides a certain level of user experience in more modern browsers, but it will also degrade gracefully to a lower level of user in experience in older browsers. This lower level is not as nice to use for your site visitors, but it does still provide them with the basic functionality that they came to your site to use; things do not break for them. Print this page Print a copy of your confirmation. Select the \"Print\" icon in your browser, or select \"Print\" from the \"File\" menu. 1.2. Progressive enhancement(✌️) Starting with a baseline of usable functionality, then increasing the richness of the user experience step by step by testing for support for enhancements before applying them. Progressive enhancement is similar, but it does things the other way round. You start by establishing a basic level of user experience that all browsers will be able to provide when rendering your web site, but you also build in more advanced functionality that will automatically be available to browsers that can use it. example: gmail, better browser has better experience. Thank you for your order. Please print this page for your records. (function(){ // true means javascript enabled if(document.getElementById){ var pt = document.getElementById('print'); if(pt && typeof window.print === 'function'){ var but = document.createElement('input'); but.setAttribute('type','button'); but.setAttribute('value','Print this now'); but.onclick = function(){ window.print(); }; pt.appendChild(but); } } })(); 1.3. Sum graceful degradation starts from the status quo 现状 of complexity and tries to fix for the lesser experience whereas progressive enhancement starts from a very basic, working example and allows for constant extension for future environments. Degrading gracefully means looking back whereas enhancing progressively means looking forward whilst keeping your feet on firm ground. It can be said that both progressive enhancement and graceful degradation try to do the same thing: keep our products useful to every user. Progressive enhancement is a more sophisticated and at the same time stable way of assuring that but it takes more time and effort. Graceful degradation can be used more easily as a patch for an already existing product; it means harder maintenance later on, but requires less initial work. 1.3.1. When to use what graceful degradation becomes viable in a few situations: You retrofit an old product and you don’t have the time, access or insight to change or replace it. You just don’t have time to finish a product with full progressive enhancement (often a sign of bad planning or running out of budget). The product you have is an edge case, for example very high traffic sites where every millisecond of performance means a difference of millions of dollars. Your product by definition is so dependent on scripting that it makes more sense to maintain a “basic” version rather than enhancing one (Maps, email clients, feed readers). In all other cases, progressive enhancement will make both the end users and you happier: Regardless of environment and ability you deliver a product that works. When a new browser comes out or a browser extension becomes widely adopted you can enhance to yet another level without having to touch the original solution — graceful degradation would require you to alter the original solution. You allow technology to be what it is supposed to be — an aid to reach a goal faster than without it, not a “must” to be able to reach a goal in the first place. If you need to add new features, you can do so after checking if they are supported at a certain stage, or you can add it to the most basic level of functionality and make it better in more sophisticated environments. In any case, the maintenance happens at the same spot and not in two different places. Keeping a progressively enhanced product up-to-date is much less work than maintaining two versions. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/grunt_vs_gulp.html": {
    "url": "Basic/frontend/grunt_vs_gulp.html",
    "title": "grunt_vs_gulp",
    "keywords": "",
    "body": "1. Grunt vs gulp1.1. Gulp1.2. Grunt1. Grunt vs gulp 1.1. Gulp Gulp 优势： 代码优于配置策略，写代码控制而不是像 grunt 传入大 json 配置 高效：核心设计基于 Unix 流的概念。通过利用 Node.js 强大的流，通过管道连接，不需要往磁盘写中间文件，可以更快地完成构建。 插件纯粹：Gulp 的每个插件只完成一个功能，这也是 Unix 的设计原则之一，各个功能通过流进行整合并完成复杂的任务。 Gulp 的核心 API 只有 5 个 var gulp = require('gulp'); var jshint = require('gulp-jshint'); var concat = require('gulp-concat'); var rename = require('gulp-rename'); var uglify = require('gulp-uglify'); // Lint JS gulp.task('lint', function() { return gulp .src('src/*.js') .pipe(jshint()) .pipe(jshint.reporter('default')); }); // Concat & Minify JS gulp.task('minify', function() { return gulp .src('src/*.js') .pipe(concat('all.js')) .pipe(gulp.dest('dist')) .pipe(rename('all.min.js')) .pipe(uglify()) .pipe(gulp.dest('dist')); }); // Watch Our Files gulp.task('watch', function() { gulp.watch('src/*.js', ['lint', 'minify']); }); // Default gulp.task('default', ['lint', 'minify', 'watch']); 1.2. Grunt // core grunt.initConfig({huge json}) // Load Our Plugins grunt.loadNpmTasks('grunt-contrib-watch'); // Register Default Task grunt.registerTask('default', ['jshint', 'concat', 'uglify']); // Invoke 'strict' JavaScript mode 'use strict'; // Define the Grunt configuration method module.exports = function(grunt) { // Initialize Grunt configuration grunt.initConfig({ // Configure the grunt-env task env: { test: { NODE_ENV: 'test', }, dev: { NODE_ENV: 'development', }, }, // Configure the grunt-nodemon task nodemon: { dev: { script: 'server.js', options: { ext: 'js,html', watch: ['server.js', 'config/**/*.js', 'app/**/*.js'], }, }, debug: { script: 'server.js', options: { nodeArgs: ['--debug'], ext: 'js,html', watch: ['server.js', 'config/**/*.js', 'app/**/*.js'], }, }, }, // Configure the grunt-mocha-test task mochaTest: { src: 'app/tests/**/*.js', options: { reporter: 'spec', }, }, // Configure the grunt-karma task karma: { unit: { configFile: 'karma.conf.js', }, }, // Configure the grunt-protractor-runner task protractor: { e2e: { options: { configFile: 'protractor.conf.js', }, }, }, // Configure the grunt-contrib-jshint task jshint: { all: { src: [ 'server.js', 'config/**/*.js', 'app/**/*.js', 'public/js/*.js', 'public/modules/**/*.js', ], options: { node: true, predef: [ 'define', 'require', 'exports', 'module', 'describe', 'before', 'beforeEach', 'after', 'afterEach', 'it', 'inject', 'expect', ], }, }, }, // Configure the grunt-contrib-csslint task csslint: { all: { src: 'public/modules/**/*.css', }, }, // Configure the grunt-contrib-watch task watch: { js: { files: [ 'server.js', 'config/**/*.js', 'app/**/*.js', 'public/js/*.js', 'public/modules/**/*.js', ], tasks: ['jshint'], }, css: { files: 'public/modules/**/*.css', tasks: ['csslint'], }, }, // Configure the grunt-concurrent task concurrent: { dev: { tasks: ['nodemon', 'watch'], options: { logConcurrentOutput: true, }, }, debug: { tasks: ['nodemon:debug', 'watch', 'node-inspector'], options: { logConcurrentOutput: true, }, }, }, // Configure the grunt-node-inspector task 'node-inspector': { debug: {}, }, }); // Load the external Grunt tasks grunt.loadNpmTasks('grunt-env'); grunt.loadNpmTasks('grunt-nodemon'); grunt.loadNpmTasks('grunt-mocha-test'); grunt.loadNpmTasks('grunt-karma'); grunt.loadNpmTasks('grunt-protractor-runner'); grunt.loadNpmTasks('grunt-contrib-jshint'); grunt.loadNpmTasks('grunt-contrib-csslint'); grunt.loadNpmTasks('grunt-contrib-watch'); grunt.loadNpmTasks('grunt-concurrent'); grunt.loadNpmTasks('grunt-node-inspector'); // Create the 'default' Grunt task grunt.registerTask('default', ['env:dev', 'lint', 'concurrent:dev']); // Create the 'debug' Grunt task grunt.registerTask('debug', ['env:dev', 'lint', 'concurrent:debug']); // Create the 'test' Grunt task grunt.registerTask('test', ['env:test', 'mochaTest', 'karma', 'protractor']); // Create the 'lint' Grunt task grunt.registerTask('lint', ['jshint', 'csslint']); }; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/interview_闭包.html": {
    "url": "Basic/frontend/interview_闭包.html",
    "title": "interview_闭包",
    "keywords": "",
    "body": "1. 闭包是什么？closure1.1. 闭包有三个特性：1.2. 闭包有什么用，使用场景1.3. 闭包的缺点1.4. 函数套函数就是闭包吗？1. 闭包是什么？closure 内层函数可以访问外层函数的变量。外层函数的局部变量得到暂存。 专业说法：当一个内部函数引用其外部函数的变量时，就形成了一个闭包。 闭包就是一个具有封闭功能与包裹功能的结构，是为了实现具有私有访问空间的函数的，函数可以构成闭包，因为函数内部定义的数据函数外部无法访问，即函数具有封闭性；函数可以封装代码即具有包裹性，所以函数可以构成闭包。 1.1. 闭包有三个特性： 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 1.2. 闭包有什么用，使用场景 当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会“污染”全局的变量时，就可以用闭包来定义这个模块。 1.3. 闭包的缺点 闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 1.4. 函数套函数就是闭包吗？ 不是！当一个内部函数被其外部函数之外的变量引用时，才会形成了一个闭包。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/Javascript异步编程.html": {
    "url": "Basic/frontend/Javascript异步编程.html",
    "title": "Javascript 异步编程",
    "keywords": "",
    "body": "1. javascript 异步编程1.1. 回调函数1.2. Promise1.3. await/async1.4. event1.4.1. event + promise + await/async1.4.2. rxjs1. javascript 异步编程 1.1. 回调函数 var result = function() { setTimeout(() => { return 5; }, 1000); }; console.log(result()); // undefined 用回调函数处理怎么弄呢？让 result 的参数为一个回调函数就可以了，于是代码变成下面这样 var result = function(callback) { setTimeout(() => { callback(5); }, 1000); }; result(console.log); 现在我们用一个真实的 io 调用替代抢红包，新建一个 numbers.txt，在里面写若干个红包金额,代码如下： const fs = require('fs'); const readFileAsArray = function(file, cb) { fs.readFile(file, (err, data) => { if (err) return cb(err); const lines = data .toString() .trim() .split('\\n'); cb(null, lines); }); }; readFileAsArray('./numbers.txt', (err, lines) => { if (err) throw err; const numbers = lines.map(Number); console.log(`分别抢到了${numbers}块红包`); }); 定义了一个 readFileAsArray 函数，传两个参：文件名和回调函数，然后调用这个函数，把回调函数写入第二个参数里，就可以控制代码执行顺序了。不过，回调的缺点就是写多了，层层嵌套，又会造成回调地狱的坑爹情况，代码变得难以维护和阅读。 1.2. Promise Promise 实现了控制反转。原来这个顺序的控制是在代码那边而不是程序员控制，现在有了 Promise，控制权就由人来掌握了，通过一系列 Promise 的方法如 then/catch/all/race 等控制异步流程。Promise 文档 function doAsyncWork() { // perform async calls if (success) resolve(data); else reject(reason); } let p: Promise = new Promise(doAsyncWork); // combine let p: Promise = new Promise((resolve, reject) => { // perform async calls setTimeout(() => { let foundBooks: string[] = util.GetBookTitlesByCategory(cat); if (foundBooks.length > 0) { resolve(foundBooks); } else { reject('No books found for that category.'); } }, 2000); }); // handling promise result let p: Promise = MethodThatReturnsPromise(); p .then( (titles) => { console.log(`Found titles: ${titles}`); throw 'something bad happened'; return titles.length; }, (reason) => { return 0; }, ) .then((numOfBooks) => console.log(`Number of books found: ${numOfBooks}`)) .catch((reason) => console.log(`Error: ${reason}`)); const fs = require('fs'); const readFileAsArray = function(file) { return new Promise((resolve, reject) => { fs.readFile(file, (err, data) => { if (err) { reject(err); } const lines = data.toString().split('\\n'); resolve(lines); }); }); }; readFileAsArray('./numbers.txt') .then((lines) => { const numbers = lines.map(Number); console.log(`分别抢到了${numbers}块红包`); }) .catch((error) => console.error(error)); 在这里已经把控制权交给了程序员，代码也变得更好理解。虽然 Promise 有 单值/不可取消 等缺点，不过在现在大部分的情况下实现异步还是够用的。 1.3. await/async 有没有简化的办法呢？ES7 推出了一个语法糖：await/async，它的内部封装了 Promise 和 Generator 的组合使用方式 async function doAsyncWork() { let results = await getDataFromServer(); // getDataFromServer returns promise console.log(results); } console.log('Calling server to retrieve data...'); doAsyncWork(); console.log('Results will be displayed when ready...'); const fs = require('fs'); const readFileAsArray = function(file) { return new Promise((resolve, reject) => { fs.readFile(file, (err, data) => { if (err) { reject(err); } const lines = data.toString().split('\\n'); resolve(lines); }); }); }; async function result() { try { const lines = await readFileAsArray('./numbers.txt'); const numbers = lines.map(Number); console.log(`分别抢到了${numbers}块红包`); } catch (err) { console.log('await出错！'); console.log(err); } } result(); 这样做的结果是不是让代码可读性更高了！而且也屏蔽了 Promise 和 Generator 的细节。 1.4. event 另一个实现异步的方式是 event，回调(promise、await/async)和 event 的关系就像计划经济和市场经济一样，一个是人为的强制性的控制，一个是根据需求和供给这只看不见的手控制。 const EventEmitter = require('events'); const fs = require('fs'); class MyEventEmitter extends EventEmitter { executeAsync(asyncFunc, args) { this.emit('开始'); console.time('执行耗时'); asyncFunc(args, (err, data) => { if (err) return this.emit('error', err); this.emit('data', data); console.timeEnd('执行耗时'); this.emit('结束'); }); } } const myEventEmitter = new MyEventEmitter(); myEventEmitter.on('开始', () => { console.log('开始执行了'); }); myEventEmitter.on('data', (data) => { console.log(`分别抢到了${data}块红包`); }); myEventEmitter.on('结束', () => { console.log('结束执行了'); }); myEventEmitter.on('error', (err) => { console.error(err); }); myEventEmitter.executeAsync(fs.readFile, './numbers.txt'); 这种事件驱动非常灵活，也不刻意去控制代码的顺序，一旦有事件的供给(emit)，它就会立刻消费事件(on)，不过正是因为这样，它的缺点也很明显：让程序的执行流程很不清晰。 1.4.1. event + promise + await/async 结合 event 和 promise 的写法: const EventEmitter = require('events'); const fs = require('fs'); class MyEventEmitter extends EventEmitter { async executeAsync(asyncFunc, args) { this.emit('开始'); try { console.time('执行耗时'); const data = await asyncFunc(args); this.emit('data', data); console.timeEnd('执行耗时'); this.emit('结束'); } catch (err) { console.log('出错了!'); this.emit('error', err); } } } const readFileAsArray = function(file) { return new Promise((resolve, reject) => { fs.readFile(file, (err, data) => { if (err) { reject(err); } const lines = data.toString().split('\\r\\n'); resolve(lines); }); }); }; const myEventEmitter = new MyEventEmitter(); myEventEmitter.on('开始', () => { console.log('开始执行了'); }); myEventEmitter.on('data', (data) => { console.log(`分别抢到了${data}块红包`); }); myEventEmitter.on('结束', () => { console.log('结束执行了'); }); myEventEmitter.on('error', (err) => { console.error(err); }); myEventEmitter.executeAsync(readFileAsArray, './numbers.txt'); 这种结合的方式基本上可以应付现今的异步场景了，缺点嘛。。。就是代码量比较多 1.4.2. rxjs 简单介绍下 rxjs 和异步的关系：它可以把数据转化成一股流，无论这个数据是同步得到的还是异步得到的，是单值还是多值。 Rx.Observable.of 来包装单值同步数据 Rx.Observable.fromPromise 来包装单值异步数据 Rx.Observable.fromEvent 来包装多值异步数据 const fs = require('fs'); const Rx = require('rxjs'); const EventEmitter = require('events'); class MyEventEmitter extends EventEmitter { async executeAsync(asyncFunc, args) { this.emit('开始'); try { console.time('执行耗时'); const data = await asyncFunc(args); this.emit('data', data); console.timeEnd('执行耗时'); this.emit('结束'); } catch (err) { console.log('出错了!'); this.emit('error', err); } } } const readFileAsArray = function(file) { return new Promise((resolve, reject) => { fs.readFile(file, (err, data) => { if (err) { reject(err); } const lines = data.toString().split('\\r\\n'); resolve(lines); }); }); }; const myEventEmitter = new MyEventEmitter(); myEventEmitter.executeAsync(readFileAsArray, './numbers.txt'); let dataObservable = Rx.Observable.fromEvent(myEventEmitter, 'data'); let subscription = dataObservable.subscribe( (data) => { console.log(`分别抢到了${data}块红包`); }, (err) => { console.error(err); }, (complete) => { console.info('complete!'); }, ); rxjs 还有很多重要的概念，比如生产者 Observe 和消费者 Observable、推拉模型、各种方便的操作符和函数式编程等等 Object.observe() This feature is obsolete Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/Javascript运行机制.html": {
    "url": "Basic/frontend/Javascript运行机制.html",
    "title": "Javascript 运行机制",
    "keywords": "",
    "body": "1. 单线程1.1. 任务队列1.2. 理解 event loop1.3. 哪些语句被会在异步队列1.4. 理解放入到异步队列的时机1.5. 例子1. 单线程 一个时间只能做一件事 1.1. 任务队列 异步队列，运行栈里面放的是同步任务队列。 1.2. 理解 event loop js 运行分为同步任务和异步任务，同步任务先执行，都执行完了才会执行异步任务。以下前 2 个例子就是先执行同步任务 console, while ，之后才执行 setTimeout 。 js 引擎把所有同步任务放到运行栈中，异步任务不会放在运行栈中，而是放到 event table。浏览器 timer 模块 拿走 setTimeout，到了时间后（下面例子 1s 时）从 event table 把任务放到 异步队列 event queue 中（注意：不是遇到 setTimeout 就把异步任务放到异步队列中，即使 setTimeout 时间设置 0，浏览器一般默认给 4ms。setTimeout 的时间就是 event table 把任务放到 event loop 的时间）。单线程的 js 执行完所有运行栈中的同步任务后，异步队列中的任务被放到了运行栈中并执行。运行栈不断监听异步队列是否有任务需要执行，有的话就拿过来执行，这个循环过程就是事件循环 Event loop. So when exactly can functions in the event queue move over to the call stack? Well, the JavaScript engine follows a very simple rule: there’s a process that constantly checks whether the call stack is empty, and whenever it’s empty, it checks if the event queue has any function waiting to be invoked. If it does, then the first function in the queue gets invoked and moved over into the call stack. If the event queue is empty, then this monitoring process just keeps on running indefinitely. And voila — what I just described is the infamous Event Loop! 1.3. 哪些语句被会在异步队列 开启异步任务： setTimeout, setInterval DOM 事件，addEventListener('click', function(){}, false) Promise 1.4. 理解放入到异步队列的时机 异步任务放入到异步队列的时机是 setTimeout 传入的时间，不是立马放入。即使时间传入 0，默认 4ms。 1.5. 例子 console.log(1); setTimeout(function() { console.log(2); }, 0); console.log(3); console.log(4); // 结果为 1 3 4 2 console.log('A'); setTimeout(function() { console.log('B'); }, 0); while (1) {} // 结果为：A // B 永远不会输出。运行栈 while 没执行完毕，不会去查看异步队列。 for (var i = 0; i for 循环是同步任务，在运行栈执行 4 次。第一次执行时，发现调用 setTimeout，浏览器 js 引擎并没立马把它放到异步队列。当 for 同步任务全部执行完毕（1ms 以内）后，过了一秒异步队列中有了 4 个 setTimeout 里面的函数体。运行栈检测到异步队列中的 4 个函数体，一个个取到运行栈中依次执行，此时的 i = 4，所以最终结果 4 4 4 4。（几乎是同时出现结果，而不是 1s 出现一个） 想要结果为 0 1 2 3 的办法： let 形成块级作用域 for 循环里面每个 li[i].index = i; 使用闭包 for (var i = 0; i Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/JIT_vs_AOT.html": {
    "url": "Basic/frontend/JIT_vs_AOT.html",
    "title": "JIT_vs_AOT",
    "keywords": "",
    "body": "1. JIT vs AOT1. JIT vs AOT AOT：Ahead Of Time，指在运行前编译，比如普通的静态编译 JIT：Just In Time，指在运行时编译，边运行边编译，比如 java 虚拟机在运行时就用到 JIT 技术 由于 JIT 编译耗费运行时间，则对于某些优化点就无法做到百分百支持，必须在代码优化和执行卡顿之间做一个权衡，AOT 就没有这个问题，另外，AOT 可以做到编译后持久化到存储，而 JIT 一般是每运行一次就会搞一遍重复的编译。 JIT 在这里的优势就是，它能精准地得知运行时状态，而不是像 AOT 那样预测，成本更低，如果一个 AOT 优化的成本过高，则应该选择 JIT。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/JS对象_原型链.html": {
    "url": "Basic/frontend/JS对象_原型链.html",
    "title": "JS 对象_原型链",
    "keywords": "",
    "body": "1. 原型链和原型1.1. 创建对象方法1.1.1. Object.create 的原理1.2. 基本概念1.2.1. 原型1.2.2. 构造函数1.2.3. 实例1.2.4. 原型链1.2.5. instanceOf 原理1.2.6. new 原理1. 原型链和原型 new 构造函数 --> 实例对象 实例对象.__proto__ === 原型对象 === 构造函数.prototype 原型对象.constructor === 构造函数 1.1. 创建对象方法 对象字面量的方式、内置工厂 new Object let o1 = { name: 'hello' }; // Object { name : 'hello' } let o11 = new Object({ name: 'hi' }); // Object { name: 'hi' } var wcDog = new Object(); wcDog.name = '旺财'; wcDog.age = 3; 用 function 来模拟无参的构造函数 function Person() {} var person = new Person(); //定义一个function，如果使用 new \"实例化\"，该 function 可以看作是一个 Class person.name = 'Mark'; person.age = '25'; person.work = function() { alert(person.name + ' hello...'); }; person.work(); 用 function 来模拟参构造函数来实现（用 this 关键字定义构造的上下文属性。每个实例属性不同，方法一般不在这定义，应定义到原型中） function Pet(name, age, hobby) { this.name = name; //this作用域：当前对象 this.age = age; this.hobby = hobby; this.eat = function() { alert('我叫' + this.name + ',我喜欢' + this.hobby + ',是个程序员'); }; } var maidou = new Pet('麦兜', 25, 'coding'); //实例化、创建对象 maidou.eat(); //调用eat方法 用原型方式来创建(所有实例共有属性和方法) function Dog() {} Dog.prototype.name = '旺财'; Dog.prototype.eat = function() { alert(this.name + '是个吃货'); }; var wangcai = new Dog(); wangcai.eat(); 用混合方式来创建 function Car(name, price) { this.name = name; this.price = price; } Car.prototype.sell = function() { alert('我是' + this.name + '，我现在卖' + this.price + '万元'); }; var camry = new Car('凯美瑞', 27); camry.sell(); Object.create 传入原型对象 x，得到对象 y 是 x 原型链下一级（创建新空对象，继承自原型对象，这里继承 p） var p = { name: 'hello' }; let o3 = Object.create(p); // Object { } o3.name === 'hello'; // true, 其实是o3本身没有name，是通过原型链找到p,拿到了name。即o3.__proto__ === p 1.1.1. Object.create 的原理 Object.create = function(obj) { function F() {} F.prototype = obj; return new F(); // 返回 F 的原型对象是 obj }; 1.2. 基本概念 1.2.1. 原型 构造函数.prototype 就是原型对象。 1.2.2. 构造函数 F.prototype.constructor === F; // true. F是构造函数，构造函数的prototype是原型对象，这里为Object{constructor: function, __proto__: Object}，原型对象中constructor指向了构造函数 1.2.3. 实例 o2.__proto__ === F.prototype; // 实例的__proto__ 指向构造函数的prototype,即原型对象。 1.2.4. 原型链 实例通过 __proto__ 向上找到对应的原型对象，原型对象还可以通过 __proto__ 找到上一级原型对象，一直到 Object.prototype 顶端停止。原型链依靠的是 __proto__ 而不是 prototype 一些公用的方法不要放在构造函数中，因为那样实例化后每个实例都在内存中拷贝了一份。公共的方法和属性放在原型对象上。实例都可以通过原型链找到原型对象，原型对象上的方法被所有实例所共有。先找自己实例内部，没找到找最近一层原型对象，没找到的话一层一层向上查找。如果都没找到，原路返回告诉他没找到。如果中间找到了就不再向上查找 特点：JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。当我们需要一个属性的时，Javascript 引擎会先看当前对象中是否有这个属性，如果没有的话，就会通过 __proto__ 查找他的原型对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。 1.2.5. instanceOf 原理 简单说判断实例是不是由某个构造函数创建的。原理是判断 实例.__proto__ 和 构造函数.prototype (原型对象)是不是同一个引用。但注意，A 继承 B，a 由 A 实例化创建，a instanceOf A,B,Object 都对，只要在原型链上级都算。这样的话就不能精确判断 a 到底是 A 还是 B 直接生成的。 这时候用 constructor 更加严谨 a.__proto__.constructor === A; //true 原型的constructor 指向 构造函数 A a.__proto__.constructor === Object; //false 1.2.6. new 原理 一个新空对象创建，继承自原型对象 (构造函数.prototype) 构造函数执行，执行时参数传入，上下文 this 指向新对象 看构造函数结果，如果返回对象，则前两步白忙活直接返回这个对象；如果不返回对象，则返回 step 1 中的新对象 // func 是构造函数 var newSimulate = function(func) { var o = Object.create(func.prototype); //step1 新对象继承自原型对象 var temp = func.call(o); //step2 构造函数执行，修改 this 指向 if (typeof temp === 'object') { //step3 判断构造函数返回结果 return temp; } else { return o; } }; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/JS对象_继承.html": {
    "url": "Basic/frontend/JS对象_继承.html",
    "title": "JS 对象_继承",
    "keywords": "",
    "body": "1. 面向对象继承1.1. 类的声明和实例化1.2. 继承和继承方式1.2.1. 1. 借助构造函数实现继承1.2.2. 2. 借助原型链实现继承1.2.3. 3. 组合方式1.2.4. 4. 组合继承的优化 11.2.5. 5. 组合继承的优化 2，完美方案1. 面向对象继承 1.1. 类的声明和实例化 /** * 类的声明 构造函数模拟类 */ var Animal = function() { this.name = 'Animal'; }; /** * es6中class的声明 */ class Animal2 { constructor() { this.name = 'Animal2'; } } /** * 实例化 */ console.log(new Animal(), new Animal2()); 1.2. 继承和继承方式 本质就是通过原型链。 1.2.1. 1. 借助构造函数实现继承 原理：实例化子类时，父类构造函数执行，传入 this，指向了实例化的子类。父类属性挂在到子类中 缺点：只实现了部分继承。只能继承构造函数中的属性方法，父类原型上方法或属性不会被继承。say 不存在 function Parent1() { this.name = 'parent1'; } Parent1.prototype.say = function() {}; function Child1() { Parent1.call(this); //父类构造函数执行，传入this，指向了实例化的子类。父类属性挂在到子类中。也可以apply this.type = 'child1'; } console.log(new Child1(), new Child1().say()); // 报错，没有 say 1.2.2. 2. 借助原型链实现继承 原理：子类原型对象 指向 父类的实例。我们已知 子类实例.__proto__ 就是子类的原型对象，即 构造函数.prototype (new Child2().__proto__ === Child2.prototype)。加上条件 Child2.prototype = new Parent2(); 后，new Child2().__proto__ === new Parent2()。所以子实例中的 __proto__ 通过原型链查找到了父类的属性方法 new Child2().__proto__.name 。 缺点：多个子类实例没有隔离。因为原型对象的属性大家公用。父类中增加了新的属性，那么所有实例都会同时改变，如果某个来自父类的属性值发生了变化，那么其他实例也都随着发生变化，因为所有实例的 __proto__ 都是同一个，所以相互之间会有影响。 function Parent2() { this.name = 'parent2'; this.play = [1, 2, 3]; } function Child2() { this.type = 'child2'; } Child2.prototype = new Parent2(); //子类原型对象 指向 父类的实例 var s1 = new Child2(); var s2 = new Child2(); s1.__proto__ === s2.__proto__; //true console.log(s1.play, s2.play); s1.play.push(4); console.log(s1.play, s2.play); //缺点：此时他俩引用一处，没有隔离。因为原型对象的属性大家公用 1.2.3. 3. 组合方式 优点：有方法 1 和 2 的优势 缺点： 只看 s3，不考虑 s4 的情况下，父类构造函数执行了 2 次。new Parent3(), Parent3.call(this) Child3 constructor 指向错误到了 parent function Parent3() { this.name = 'parent3'; this.play = [1, 2, 3]; } function Child3() { Parent3.call(this); this.type = 'child3'; } Child3.prototype = new Parent3(); var s3 = new Child3(); var s4 = new Child3(); s3.play.push(4); console.log(s3.play, s4.play); 1.2.4. 4. 组合继承的优化 1 原理：子类原型对象 = 父类原型对象，解决了 2 次执行构造函数的问题 缺点：还是子类的构造函数指向不对。 function Parent4() { this.name = 'parent4'; this.play = [1, 2, 3]; } function Child4() { Parent4.call(this); this.type = 'child4'; } Child4.prototype = Parent4.prototype; var s5 = new Child4(); var s6 = new Child4(); console.log(s5, s6); console.log(s5 instanceof Child4, s5 instanceof Parent4); //true,不知道到底谁直接创建的 console.log(s5.constructor); //Parent4！指向错误 1.2.5. 5. 组合继承的优化 2，完美方案 原理：Object.create() 创建的对象指向 Parent 原型对象，所以 Child 和 Parent 通过创建的对象进行了关联。不像第四个方法 Parent 和 Child 指向同一个引用。导致 constructor 即使修正后，也只能都指向 Parent 或者都 Child，即给 Child.prototype.constructor 修正为 Child 构造函数后，Parent 的 constructor 也被修成 Child 构造函数了。 function Parent5() { this.name = 'parent5'; this.play = [1, 2, 3]; } function Child5() { Parent5.call(this); this.type = 'child5'; } var x = Object.create(Parent5.prototype); console.log(x.__proto__ === Parent5.prototype); //true,新对象的上级原型链是 Parent5 原型对象，继承了 Parent5 的一切 Child5.prototype = x; //子类原型对象指向x，子实例通过 __proto__ 找到上一级 x。关系为 Child5 --> x --> Parent5 Child5.prototype.constructor = Child5; // 修正 var s7 = new Child5(); console.log(s7 instanceof Child5, s7 instanceof Parent5); //true true console.log(s7.constructor); //Child5 Object.create polyfill: function create(obj) { if (Object.create) { return Object.create(obj); } function F() {} F.prototype = obj; return new F(); // 返回 obj 的上层原型对象 } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/Object.defineProperty.html": {
    "url": "Basic/frontend/Object.defineProperty.html",
    "title": "Object.defineProperty",
    "keywords": "",
    "body": "1. Object.defineProperty1.1. 传入参数1.2. descriptor1.2.1. descriptor 默认值1.2.2. configurable1.2.3. writable1.2.4. enumerable1.2.5. set 和 get1. Object.defineProperty vue.js 和 avalon.js 都是通过它实现双向绑定的。。而且 Object.observe 也被草案发起人撤回了。。所以 defineProperty 更有必要了解了 var guanghui = {}; Object.defineProperty(guanghui, 'age', { value: 12, }); console.log(guanghui.age); // 12 1.1. 传入参数 第一个参数:目标对象 第二个参数:需要定义的属性或方法的名字。 第三个参数:目标属性所拥有的特性。（descriptor） 1.2. descriptor value: 属性的值(不用多说了) writable: 如果为 false，属性的值就不能被重写,只能为只读了 configurable: 总开关，一旦为 false，就不能再设置他的（value，writable，configurable） enumerable: 是否能在 for...in 循环中遍历出来或在 Object.keys 中列举出来。 get:一会细说 set:一会细说 1.2.1. descriptor 默认值 var guanghui = {}; Object.defineProperty(guanghui, 'age', { value: 12, }); console.log(guanghui.age); // 12 我们只设置了 value，别的并没有设置，但是 第一次的时候可以简单的理解为（暂时这样理解）它会默认帮我们把 writable，configurable，enumerable 都设上值，而且值还都是 false。。也就是说，上面代码和下面是等价的的（ 仅限于第一次设置的时候） var guanghui = {}; Object.defineProperty(guanghui, 'age', { value: 12, writable: false, enumerable: false, configurable: false, }); console.log(guanghui.age); // 12 1.2.2. configurable 总开关，第一次设置 false 之后，，第二次什么设置也不行了，比如说 var a = {}; Object.defineProperty(a, 'b', { configurable: false, }); Object.defineProperty(a, 'b', { configurable: true, }); //error: Uncaught TypeError: Cannot redefine property: b 就会报错了。。注意上面讲的默认值。。。如果第一次不设置它会怎样。。会帮你设置为 false。。所以。。第二次。再设置他会怎样？。。对喽，，会报错 1.2.3. writable 如果设置为 false，就变成只读了。。 var guanghui = {}; Object.defineProperty(guanghui, 'age', { value: 12, }); console.log(guanghui.age); // 12 console.log(guanghui.age); // 打印 12 guanghui.age = 25; // 没有错误抛出（在严格模式下会抛出，即使之前已经有相同的值） console.log(guanghui.age); // 打印 12， 赋值不起作用。 1.2.4. enumerable 属性特性 enumerable 定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举。 var guanghui = {}; Object.defineProperty(guanghui, 'age', { value: 12, enumerable: true, }); console.log(Object.keys(guanghui)); // 打印[ 'age' ] 改为 false var guanghui = {}; Object.defineProperty(guanghui, 'age', { value: 12, enumerable: false, }); console.log(Object.keys(guanghui)); // nothing 1.2.5. set 和 get 在 descriptor 中不能 同时设置访问器 (get 和 set) 和 writable 或 value，否则会错，就是说想用(get 和 set)，就不能用（writable 或 value 中的任何一个） var a = {}; Object.defineProperty(a, 'b', { set: function(newValue) { console.log('你要赋值给我,我的新值是' + newValue); }, get: function() { console.log('你取我的值'); return 2; //注意这里，我硬编码返回2 }, }); a.b = 1; // 你要赋值给我,我的新值是1 console.log(a.b); // 你取我的值 // 2 “b” 赋值 或者 取值的时候会分别触发 set 和 get 对应的函数 这就是实现 observe 的关键啊。。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/oop_delete_from_list.html": {
    "url": "Basic/frontend/oop_delete_from_list.html",
    "title": "oop_delete_from_list",
    "keywords": "",
    "body": "1. 面向对象删除选中 li(阿里面试)1. 面向对象删除选中 li(阿里面试) 阿里2017校招编程题 .del { cursor: pointer; } 第一行 这是内容区，点击X删除当前行，X 第二行 这是内容区，点击X删除当前行，X 第三行 这是内容区，点击X删除当前行，X 第四行 这是内容区，点击X删除当前行，X 这是另一个List第一行 这是内容区，点击X删除当前行，X 这是另一个List第二行 这是内容区，点击X删除当前行，X 这是另一个List第三行 这是内容区，点击X删除当前行，X 这是另一个List第四行 这是内容区，点击X删除当前行，X class List { constructor(sel) { this.ulElements = Array.from(document.querySelectorAll(sel)); let self = this; this.ulElements.forEach(item => { item.addEventListener('click', function (e) { if (e.target.className.indexOf('del') > -1) { self.removeItem.call(self, e.target); } }); }); } removeItem(target) { let self = this; let findParent = function (node) { let parent = node.parentNode; let root = self.ulElements.find(item => item === parent); if (root) { // 当能从 ul 中找到时，删除 ul 下结点 li root.removeChild(node); } else { findParent(parent); } }; findParent(target); } } window.addEventListener('DOMContentLoaded', function () { new List('.list'); }); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/React_Angular_Vue.html": {
    "url": "Basic/frontend/React_Angular_Vue.html",
    "title": "React_Angular_Vue",
    "keywords": "",
    "body": "1. 前端主流框架区别1.1. React1.2. Angular41.3. Vue.js1.3.1. React 和 Vue.js 有一些相似的特征1.4. Scalability1.5. size1. 前端主流框架区别 1.1. React a library Component-based MVC's V: small view library JSX, transpiled to React.CreateElement, which returns Virtual DOM Virtual DOM: lightweight, representation of actual DOM in memory one way data flow manage state => UI updates automatically by React React is smart to update only necessary UI by comparing previous state and new state Presentational and Container Components many ways to do the same thing, like controlled/unControlled form May need Redux, mobx need other packages - react router, fetch/axios, enzyme, Jest Create react App CLI, which cannot generate components ecosystem: react native material UI next.js mobx storybook react desktop react VR 1.2. Angular4 big framework, lots to learn slower but powerful, 拥有很多工具(http, Data Validation, rxjs, routing)，也有大量复杂的语法 2 way data binding testing utilities MVVM(angularJS): full framework with all the tooling Component-based too Typescript @Component has template or templateUrl, style or styleUrl. Styles work only in current component 默认支持 css 模块化 clear ways to do things Angular 4 is faster than Angular 2 Angular CLI, which can generate components, services ecosystem: Ionic hybrid framework nativeScript Material Design Angular Universal @ngrx/store 1.3. Vue.js Lightweight Like angular1 syntax 更加灵活的、（相对于 Angular）并不那么“专制”的解决方案。这允许你按照自己的想法来构建你的应用，而不是强制按照 Angular 规定的方式去做。它只是一个接口层，所以你可以将其作为页面的一个功能来使用，而非一个完整的 SPA。 1.3.1. React 和 Vue.js 有一些相似的特征 使用了虚拟 DOM 提供了响应式、可组件化的视图组件 关注核心库，像路由和全局状态管理则交由其他库来处理 Vue 双向数据绑定实现比 React 简单 1.4. Scalability Angular is easy to scale thanks to its design as well as a powerful CLI. React claims to be more testable and therefore scalable than Vue and I think that is partly true. Vue being just behind react, it is a good choice however it lacks a list of best scaling practices, resulting in a lot of spaghetti code. 1.5. size Vue is the smallest and contains a lot as well. Actually you might think it doesn’t matter, but say that to a cheap android 3g smartphone and I don’t think you will be so sure about it. react is bigger than Vue, but still smaller than angular. That’s all I’ve got to say. angular is way bigger, causing longer load times and performance issues on mobiles. https://www.zhihu.com/question/31809713 1. 原生 DOM 操作 vs. 通过框架封装操作。 这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。 2. 对 React 的 Virtual DOM 的误解。 React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作... 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。 innerHTML: render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size) Virtual DOM: render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change) Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。为什么要有 Virtual DOM：它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。 3. MVVM vs. Virtual DOM 相比起 React，其他 MVVM 系框架比如 AngularJS, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive/Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。MVVM 的性能也根据变动检测的实现原理有所不同：Angularjs 的脏检查使得任何变动都有固定的 O(watcher count) 的代价；Knockout/Vue/Avalon 都采用了依赖收集，在 js 和 DOM 层面都是 O(change)： 脏检查：scope digest O(watcher count) + 必要 DOM 更新 O(DOM change) 依赖收集：重新收集依赖 O(data change) + 必要 DOM 更新 O(DOM change) AngularJS 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angularjs 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。 MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的 \"scope\" 对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel / scope 实例比起 Virtual DOM 来说要昂贵很多。这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。假如没有任何复用方面的优化，由于数据是 “全新” 的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 AngularJS/knockout 实现都相对比较慢。相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。 AngularJS 和 Vue 都提供了列表重绘的优化机制，也就是 “提示” 框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 AngularJS 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。或者，你也可以直接 track by $index 来进行 “原地复用”：直接根据在数组里的位置进行复用。在题目给出的例子里，如果 AngularJS 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，AngularJS 和 Vue 用了 track by $index 以后都比 React 快: dbmon** (注意 AngularJS 默认版本无优化，优化过的在下面） 顺道说一句，React 渲染列表的时候也需要提供 key 这个特殊 prop，本质上和 track-by 是一回事。 4. 性能比较也要看场合 在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。 初始渲染：Virtual DOM > 脏检查 >= 依赖收集 小量数据更新：依赖收集 >> Virtual DOM + 优化 > 脏检查（无法优化） > Virtual DOM 无优化 大量数据更新：脏检查 + 优化 >= 依赖收集 + 优化 > Virtual DOM（无法/无需优化）>> MVVM 无优化 不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/view_位置.html": {
    "url": "Basic/frontend/view_位置.html",
    "title": "view_位置",
    "keywords": "",
    "body": "1. offsetWidth/offsetHeight, clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别1. offsetWidth/offsetHeight, clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别 offsetWidth/offsetHeight 返回值包含 content + padding + border，效果与 e.getBoundingClientRect() 相同 clientWidth/clientHeight 返回值只包含 content + padding，不包含滚动条 scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/webpack-hot-reloading_browserSync原理.html": {
    "url": "Basic/frontend/webpack-hot-reloading_browserSync原理.html",
    "title": "webpack-hot-reloading_browserSync 原理",
    "keywords": "",
    "body": "1. Webpack, browserSync1.1. webpack 热插拔 hot reloading 原理1.2. browser-sync 原理1. Webpack, browserSync 1.1. webpack 热插拔 hot reloading 原理 webpack-hot-middleware 中间件是 webpack 的一个 plugin，通常结合 webpack-dev-middleware 一起使用。借助它可以实现浏览器的无刷新更新（热更新），即 webpack 里的 HMR（Hot Module Replacement）。内部使用 Server-sent event(SSE)。 SSE 参看 Websocket_vs_polling.md 1.2. browser-sync 原理 一个网页里的所有交互动作（包括滚动，输入，点击等等），可以实时地同步到其他所有打开该网页的设备，能够节省大量的手工操作时间，从而带来流畅的开发调试体验。目前 browser-sync 可以结合 Gulp 或 Grunt 一起使用，其 API 请参考：Browser-sync API。 EventSource 的使用是比较便捷的，那为什么 browser-sync 不使用 EventSource 技术进行代码推送呢？这是因为 browser-sync 插件共做了两件事： 开发更新了一段新的逻辑，服务器实时推送代码改动信息。数据流：服务器 —> 浏览器，使用 EventSource 技术同样能够实现。 用户操作网页，滚动、输入或点击等，操作信息实时发送给服务器，然后再由服务器将操作同步给其他已打开的网页。数据流：浏览器 —> 服务器 —> 浏览器，该部分功能 EventSource 技术已无能为力。 browser-sync 使用 WebSocket 技术达到实时推送代码改动和用户操作两个目的。至于它是如何计算推送内容，根据不同推送内容采取何种响应策略，不在本次讨论范围之内。 WebSocket 参看 Websocket_vs_polling.md Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/内存泄漏和垃圾回收.html": {
    "url": "Basic/frontend/内存泄漏和垃圾回收.html",
    "title": "内存泄漏和垃圾回收",
    "keywords": "",
    "body": "1. JavaScript 内存泄漏教程1.1. 一、什么是内存泄漏？1.2. 二、垃圾回收机制1.3. 三、内存泄漏的识别方法1.3.1. 3.1 浏览器1.3.2. 3.2 命令行1.4. 四、WeakMap1.5. v8 引擎内存分配和垃圾回收1.5.1. 新生代1.5.2. 老生代1.5.3. 三种回收策略比较1.5.4. 垃圾回收引起的性能问题1. JavaScript 内存泄漏教程 http://www.ruanyifeng.com/blog/2017/04/memory-leak.html 1.1. 一、什么是内存泄漏？ 程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。 有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。 char * buffer; buffer = (char*) malloc(42); // Do something with buffer free(buffer); 上面是 C 语言代码，malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。 这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为\"垃圾回收机制\"（garbage collector）。 1.2. 二、垃圾回收机制 垃圾回收机制怎么知道，哪些内存不再需要呢？ 最常使用的方法叫做\"引用计数\"（reference counting）：语言引擎有一张\"引用表\"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。 上图中，左下角的两个值，没有任何引用，所以可以释放。 如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。 const arr = [1, 2, 3, 4]; console.log('hello world'); 上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存。 如果增加一行代码，解除arr对[1, 2, 3, 4]引用，这块内存就可以被垃圾回收机制释放了。 let arr = [1, 2, 3, 4]; console.log('hello world'); arr = null; 上面代码中，arr重置为null，就解除了对[1, 2, 3, 4]的引用，引用次数变成了0，内存就可以释放出来了。 因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。 1.3. 三、内存泄漏的识别方法 怎样可以观察到内存泄漏呢？ 经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。 1.3.1. 3.1 浏览器 Chrome 浏览器查看内存占用，按照以下步骤操作。 打开开发者工具，选择 Timeline 面板 在顶部的Capture字段里面勾选 Memory 点击左上角的录制按钮。 在页面上进行各种操作，模拟用户的使用情况。 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。 反之，就是内存泄漏了。 1.3.2. 3.2 命令行 命令行可以使用 Node 提供的process.memoryUsage方法。 console.log(process.memoryUsage()); // { rss: 27709440, // heapTotal: 5685248, // heapUsed: 3449392, // external: 8772 } process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节，含义如下。 rss（resident set size）：所有内存占用，包括指令区和堆栈。 heapTotal：\"堆\"占用的内存，包括用到的和没用到的。 heapUsed：用到的堆的部分。 external： V8 引擎内部的 C++ 对象占用的内存。 判断内存泄漏，以heapUsed字段为准。 1.4. 四、WeakMap 前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。 最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。 ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个\"Weak\"，表示这是弱引用。 下面以 WeakMap 为例，看看它是怎么解决内存泄漏的。 const wm = new WeakMap(); const element = document.getElementById('example'); wm.set(element, 'some information'); wm.get(element); // \"some information\" 上面代码中，先新建一个 WeakMap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对 element 的引用就是弱引用，不会被计入垃圾回收机制。 也就是说，DOM 节点对象的引用计数是 1，而不是 2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。WeakMap 保存的这个键值对，也会自动消失。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。 只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了它的帮助，解决内存泄漏就会简单很多。 1.5. v8 引擎内存分配和垃圾回收 v8 将内存分为 新生代 和 老生代。 1.5.1. 新生代 大多数对象 存活时间短 空间小 分为 2 块内存：使用状态（from 空间）和 闲置状态（to 空间） 采用 Scavenge 算法 新对象创建时使用 from 空间，当 from 空间满了后，存活对象复制到了 to 空间；不存活的消灭，完成一次 from 到 to 空间的转化。再次垃圾回收时执行上述操作。 当存活对象经历过一次 Scavenge 回收后或者 to 空间内存占用比超过 25%，对象晋升：新生代拷贝到老生代。 1.5.2. 老生代 存活时间长 老生代内存空间大，不能用 Scavenge 算法复制那么多空间里的对象 垃圾回收采用 Mark-Sweep 和 Mark-Compact Mark-Sweep: 遍历所有对象，标记活着的对象。清除阶段只清除没被标记的少数死活对象，效率高 但有一个缺点，就是对象清除后内存不连续，内存碎片。 Mark-Compact: 为了解决上述内存碎片。将活的对象在内存区域进行移动，清理掉边界外的内存。因为涉及到对象移动，所以效率很低，但好处就是保证了不会有碎片。 因为效率低，v8 不会在每次 Mark-Sweep 后就执行 Mark-Compact，而是当新生代对象晋升时发现碎片空间不够用后才进行 Mark-Compact。 1.5.3. 三种回收策略比较 回收策略 速度 空间、碎片 是否移动对象 Scavenge 速度快 双倍空间无碎片 不移动对象 Mark-Sweep 中速 有碎片 不移动对象 Mark-Compact 最慢 无碎片 移动对象 1.5.4. 垃圾回收引起的性能问题 垃圾回收的三种算法都会停止应用逻辑，待垃圾回收完成后再恢复执行应用逻辑，这个现象叫做全停顿！为了避免它： 限制内存大小：新生代 64 位系统 32M, 老生代 64 位 1400M 增量式垃圾回收：不要一口气回收，回收一会执行一会应用逻辑再回收。增量标记、延迟清除、增量式整理。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/前端开发知识点.html": {
    "url": "Basic/frontend/前端开发知识点.html",
    "title": "前端开发知识点",
    "keywords": "",
    "body": "1. 前端开发知识点1.1. 前端面试1.2. 面试准备1.3. 问题1.3.1. 对 Node 的优点和缺点提出了自己的看法1.3.2. .net 技术迁移1.3.3. \"attribute\" 和 \"property\" 的区别是什么？1.3.4. HTML5 的离线储存怎么使用，工作原理1.3.5. What's the difference between feature detection, feature inference, and using the UA string?1.3.6. FOUC (Flash of Unstyled Content)1.3.7. How many resources will a browser download from a given domain at a time? Traditionally, why has it been better to serve site assets from multiple domains?1.3.8. Describe z-index and how stacking context is formed1.3.9. 页面可见性（Page Visibility API） 可以有哪些用途？1.3.10. 对象到字符串的转换步骤1.3.11. 函数内部 arguments 特性, 如何将它转换为数组1.3.12. 说几条写 JavaScript 的基本规范？1.4. Test1. 前端开发知识点 https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md HTML&CSS： 对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、 HTML5、CSS3、Flexbox JavaScript： 数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、 DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs 其他： 移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力 1.1. 前端面试 一面：页面布局、css 盒模型、DOM 事件、HTTP 协议、面向对象、原型链、算法、安全、通信二面：vue 源码、优缺点、原理、生命周期三面：业务负责人，职业生涯特色业务，角色，推动了、改变了什么终面：HR 面试，沟通、性格、潜力 抽象设计能力、项目把控能力、经验。 1.2. 面试准备 职位描述 JD 分析 业务分析或实战模拟 技术栈准备 自我介绍 1.3. 问题 https://github.com/yu521088/fee-interview-questions 1.3.1. 对 Node 的优点和缺点提出了自己的看法 优点: Node 是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在 Node 上的代理服务器相比其他技术实现（如 Ruby）的服务器表现要好得多。 客户端和服务端统一语言 javascript 缺点： 早期 Node 是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺少足够多的第三方库支持。看起来，就像是 Ruby/Rails 当年的样子。 1.3.2. .net 技术迁移 ORM: node 和 前端可以借鉴 强类型: typescript razor 引擎，比 ejs，jade 都好用 1.3.3. \"attribute\" 和 \"property\" 的区别是什么？ .property, getAttribute。大部分情况值一样，但 getAttribute('checked') == 'checked', ele.checked == true 1.3.4. HTML5 的离线储存怎么使用，工作原理 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。 如何使用 页面头部像下面一样加入一个 manifest 的属性: 在 cache.manifest 文件的编写离线存储的资源； CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resource/logo.png FALLBACK: // offline.html在离线状态时，操作window.applicationCache进行需求实现。 自动化工具: (http://yanhaijing.com/html/2014/12/28/html5-manifest/) manifest 文件中的 cache 部分不能使用通配符，必须手动指定，这实在太让人不可理解，文件一多，就成了体力活了，这里介绍的 grunt-manifest 能自动生成 manifest 文件的目的。grunt-manifest 依赖 grunt 如下的命令可以安装 grunt-manifest，并加入到依赖文件。 npm install grunt-manifest --save-dev 如下的代码，可以在 grunt 中载入 grunt-manifest，然后便可使用。 grunt.loadNpmTasks('grunt-manifest'); 使用 grunt-manifest 的一个典型的配置文件如下所示： grunt.initConfig({ manifest: { generate: { options: { basePath: \"../\", cache: [\"js/app.js\", \"css/style.css\"] network: [\"http://*\", \"https://*\"], fallback: [\"/ /offline.html\"], exclude: [\"js/jquery.min.js\"], preferOnline: true, verbose: true, timestamp: true }, src: [ \"some_files/*.html\", \"js/*.min.js\", \"css/*.css\" ], dest: \"index.manifest\" } } }); 其中 options 定义生成 manifest 的一些自定义参数，src 是要生成的文件，dest 是输出文件。 options 下有很多参数，主要参数如下： basePath 设置出入文件的根目录 cache 手动添加缓存文件 network 手动添加网络文件 fallback 手动添加后备文件 exclude 设置不添加到 cache 的文件 verbose 是否添加版权信息 timestamp 是否添加时间戳 这里有 Basejs 的配置文件和生成的 manifest 文件的例子。 1.3.5. What's the difference between feature detection, feature inference, and using the UA string? Feature Detection (✅) Feature Detection is to verify if a feature works in a particular browser or not. The feature can be either a CSS property or a Java Script Method. A good example is a modern HTML5 feature Location. if (navigator.geolocation) { // detect users location here B-) and do something awesome } Feature Inference 推理 Feature Inference is to assume that a CSS property or JS method is available in all the browsers, by verifying it in a single browser. The fact is it can or it cannot be available. For ex. the text() function is implemented in Chrome, but it is not implemented in Firefox which will give out an error eventually when used. So we have to be careful. UA String Identifies your operating system, browser and its version via navigator.userAgent. These “string text of data” contains information of the browser environment you are targeting. navigator.userAgent; // Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 1.3.6. FOUC (Flash of Unstyled Content) 由于 external css 没有加载完成导致页面使用浏览器默认样式去显示页面。加载好后样式回归。 避免方法： 把 external css 放到页面 head 中而不是 body 后面。head 中 css 会阻止 DOM 解析。 代码控制 .no-fouc {display: none;} document.documentElement.className = 'no-fouc'; document.addEventListener('DOMContentLoaded', function(){ document.querySelector('.no-fouc').classList.remove('no-fouc') }) 1.3.7. How many resources will a browser download from a given domain at a time? Traditionally, why has it been better to serve site assets from multiple domains? IE7 allowed only two concurrent connections per host. But most browsers today allow more than that. IE8 allows 6 concurrent connections, Chrome allows 6, and Firefox allows 8. 多个 subdomain 查询也需要时间。Let's say you have 24 images on a page. Well, few things in life are free and there's such a thing as death by parallelization. If you host your images in 4 different subdomains, then that means that every single image could theoretically be downloaded in parallel. However, it also means that there are 3 additional DNS lookups involved. And a DNS lookup could be 100 ms, 150 ms, or sometimes longer. This added delay could easily offset any benefit of parallel downloads. You can see real-world examples of this by testing sites with http://www.webpagetest.org/ Of course the best solution is to use CSS sprites when possible to cut down on the number of requests. Most of the U.S. top ten web sites do domain sharding. What’s the optimal number? Yahoo! released a study that recommends sharding across at least two, but no more than four, domains. Above four, performance actually degrades. Note however that this was written in 2009. And in 2011 he posted a comment... Since newer browsers open more connections per domain, it’s probably better to revise the number downwards. I think 2 is a good compromise, but that’s just a hunch. It’d be great if some production property ran a test to determine the optimal number. You should also keep in mind that the big reason it's even necessary for the big sites like Yahoo and Amazon to do domain sharding is that their sites are so dynamic. The images are attached to products or stories which are displayed dynamically. So it's not feasible for them to use CSS sprites as aggressively as would be optimal. A site like StackOverflow, however, is light on these sorts of images and they have cut down on the number of requests so much that they don't need to do sharding. A big step towards making that happen is their usage of this sprites.png image... http 2.0 时代使用多个 subdomain 没必要了，反而性能不会提升。。Perhaps the strongest argument against domain sharding is that it’s unnecessary in the world of SPDY (as well as HTTP 2.0). In fact, domain sharding probably hurts performance under SPDY. SPDY supports concurrent requests (send all the request headers early) as well as request prioritization. Sharding across multiple domains diminishes these benefits. SPDY is supported by Chrome, Firefox, Opera, and IE 11. If your traffic is dominated by those browsers, you might want to skip domain sharding. 1.3.8. Describe z-index and how stacking context is formed z-index 需要配合 position (非 static) 使用。值越大，相应的 layer 位置越高。z-index 的使用场景之一是我做模态框的时候，这种我把它叫天马派，有最高层级，可能 z-index 设置 999；还有些是 低空飞行派，z-index 从 1 - 10。但我不建议乱用 z-index，其实在 html 结构写的合理的时候，大部分情况下层级上下关系根据 html 结果确定好了，不需要为人加入 z-index 去干涉合理的层级结构。认为加入可能导致 z-index 混乱。我之前有个项目就是大家随意设置 z-index。10，999， 500 等。我是觉得 z-index 对于低空飞行派，1-5 就够用了。过多了说明 html 结构不合理。 stacking context：简单理解就是具有 z 轴方向 属性的元素。该元素有层级属性，或者里面 children 有层级。 stacking context 如何形成： html 标签 Element with a position value \"absolute\" or \"relative\" and z-index value other than \"auto\". Element with a position value \"fixed\" or \"sticky\" (sticky for all mobile browsers, but not older desktop). Element that is a child of a flex (flexbox) container, with z-index value other than \"auto\". Element with a opacity value less than 1 (See the specification for opacity). Element with any of the following properties with value other than \"none\": transform perspective clip-path mask / mask-image / mask-border 特点： 同级别的 div 之间层级关系由 z-index 决定。某个 div 里面 children 的层级和该 div 的兄弟没有层级关系。 div 1 2 3 层级关系有他们的 z-index 决定，div 4 5 6 的关系由 456 决定。 DIV #1 DIV #2 DIV #3 DIV #4 DIV #5 DIV #6 https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context 1.3.9. 页面可见性（Page Visibility API） 可以有哪些用途？ 通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等; 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放； 1.3.10. 对象到字符串的转换步骤 如果对象有 toString() 方法，javascript 调用它。如果返回一个原始值（primitive value 如：string number boolean），将这个值转换为字符串作为结果 如果对象没有 toString() 方法或者返回值不是原始值，javascript 寻找对象的 valueOf() 方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果 否则，javascript 不能从 toString() 或者 valueOf() 获得一个原始值，此时 throws a TypeError 1.3.11. 函数内部 arguments 特性, 如何将它转换为数组 arguments 是所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象 arguments[index] 分别对应函数调用时的实参，并且通过 arguments 修改实参时会同时修改实参 arguments.length 为实参的个数（Function.length 表示形参长度） arguments.callee 为当前正在执行的函数本身，使用这个属性进行递归调用时需注意 this 的变化。匿名函数递归调用使用。严格模式下不能用 callee arguments.caller 为调用当前函数的函数（已被遗弃） 转换为数组： var args = Array.prototype.slice.call(arguments); var args = [].slice.call(arguments); var args = Array.from(arguments); var args = [...arguments]; 1.3.12. 说几条写 JavaScript 的基本规范？ 不要在同一行声明多个变量。 请使用 ===/!== 来比较 true/false 或者数值 使用对象字面量替代 new Array 这种形式 不要使用全局函数。 Switch 语句必须带有 default 分支 函数不应该有时候有返回值，有时候没有返回值。 For 循环必须使用大括号 If 语句必须使用大括号 for-in 循环中的变量 应该使用 var 关键字明确限定作用域，从而避免作用域污染。 1.4. Test // Load the test dependencies var app = require('../../server'), request = require('supertest'), should = require('should'), mongoose = require('mongoose'), User = mongoose.model('User'), Article = mongoose.model('Article'); // Define global test variables var user, article; // Create an 'Articles' controller test suite describe('Article Controller Unit Tests:', function() { // Define a pre-tests function beforeEach(function(done) { // Create a new 'User' model instance user = new User({ firstName: 'Full', lastName: 'Name', displayName: 'Full Name', email: 'test@test.com', username: 'username', password: 'password', }); // Save the new 'User' model instance user.save(function() { article = new Article({ title: 'Article Title', content: 'Article Content', user: user, }); article.save(function(err) { done(); }); }); }); // Test the 'Article' GET methods describe('Testing the GET methods', function() { it('Should be able to get the list of articles', function(done) { // Create a SuperTest request request(app) .get('/api/articles/') .set('Accept', 'application/json') .expect('Content-Type', /json/) .expect(200) .end(function(err, res) { // res.body.should.have.lengthOf(1).and.be.an.Array; //should.js res.body.should.be.an.instanceof(Array).and.have.lengthOf(1); // should.js // res.body.should.be.an.Array.and.have.lengthOf(1); // this doesn't work in late should.js since Array cannot chain res.body[0].should.have.property('title', article.title); // here is should.js res.body[0].should.have.property('content', article.content); // here is should.js done(); }); }); it('Should be able to get the specific article', function(done) { // Create a SuperTest request request(app) .get('/api/articles/' + article.id) .set('Accept', 'application/json') .expect('Content-Type', /json/) .expect(200) .end(function(err, res) { // res.body.should.be.an.Object.and.have.property('title', article.title); // here is should.js // res.body.should.have.property('content', article.content); // here is should.js done(); }); }); }); // Define a post-tests function afterEach(function(done) { // Clean the database Article.remove(function() { User.remove(function() { done(); }); }); }); }); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/前端路由原理.html": {
    "url": "Basic/frontend/前端路由原理.html",
    "title": "前端路由原理",
    "keywords": "",
    "body": "1. 前端路由主要由两种方式实现1.1. location.hash, hashchange1.2. History Api: history.pushState() + popstate1.2.1. reference1. 前端路由主要由两种方式实现 有一个路由表，以 path 为 key，value 是触发给 path 的回调函数。 location.hash + hashchange history.pushState() + popState 1.1. location.hash, hashchange 说一下前端路由实现的简要原理，以 hash 形式（也可以使用 History API 来处理）为例，当 url 的 hash 发生变化时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。直接看代码或许更直观。 缺点：url 不好看，不利于 SEO function Router() { this.routes = {}; this.currentUrl = ''; } Router.prototype.route = function(path, callback) { this.routes[path] = callback || function() {}; }; Router.prototype.refresh = function() { this.currentUrl = location.hash.slice(1) || '/'; this.routes[this.currentUrl](); }; Router.prototype.init = function() { window.addEventListener('load', this.refresh.bind(this), false); window.addEventListener('hashchange', this.refresh.bind(this), false); }; window.Router = new Router(); window.Router.init(); 上面路由系统 Router 对象实现，主要提供三个方法 init 监听浏览器 url hash 更新事件 route 存储路由更新时的回调到回调数组 routes 中，回调函数将负责对页面的更新 refresh 执行当前 url 对应的回调函数，更新页面 Router 调用方式以及呈现效果如下：点击触发 url 的 hash 改变，并对应地更新内容（这里为 body 背景色） turn white turn blue turn green var content = document.querySelector('body'); // change Page anything function changeBgColor(color) { content.style.backgroundColor = color; } Router.route('/', function() { changeBgColor('white'); }); Router.route('/blue', function() { changeBgColor('blue'); }); Router.route('/green', function() { changeBgColor('green'); }); 1.2. History Api: history.pushState() + popstate history.pushState(data, title, url): 修改 url 的地址 history.replaceState(data, title, url) popstate 事件: 监听地址的改变 手动的进行 pushState() 并不会触发 popstate 事件。点击浏览器前进后退时候触发。 s0 k0 var div1 = document.getElementById('div1'); var a1 = document.getElementById('a1'); var a2 = document.getElementById('a2'); var count1 = 0; var count2 = 0; history.replaceState({ count1: count1, count2: count2 }, null, ''); //最开始的状态，采用replace直接替换 a1.addEventListener('click', function() { count1++; history.pushState({ count1: count1, count2: count2 }, null, '#/s' + count1); //之后的状态，需要进行保存 a1.innerHTML = 's' + count1; }); a2.addEventListener('click', function() { count2++; history.pushState({ count1: count1, count2: count2 }, null, '#/k' + count2); //之后的状态，需要进行保存 a2.innerHTML = 'k' + count2; }); window.addEventListener('popstate', function(e) { console.log(e.state); a1.innerHTML = 's' + e.state.count1; //监听popstate事件，对状态进行还原 a2.innerHTML = 'k' + e.state.count2; }); 1.2.1. reference https://github.com/flatiron/director Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/前端面试杂.html": {
    "url": "Basic/frontend/前端面试杂.html",
    "title": "前端面试杂",
    "keywords": "",
    "body": "1. 前端开发面试题1.1. HTML5 增加功能1.2. 语义化的理解1.3. 介绍一下你对浏览器内核的理解？1.4. 常见的浏览器内核有哪些？1.5. css 多列等高如何实现？1.6. 移动端的布局用过媒体查询吗？1.7. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）1.8. display:inline-block 什么时候会显示间隙？怎么处理？(携程)1.9. javascript 代码中的\"use strict\";是什么意思 ? 使用它区别是什么？1.10. Ajax 解决浏览器缓存问题？1.11. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）1.12. jquery.extend 与 jquery.fn.extend 的区别？1.13. Object.is() 与原来的比较操作符“===”、“==”的区别？1. 前端开发面试题 https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Question XSS 攻击原理 XSS 防御措施 快速排序 选择排序 希尔排序 堆栈 队列 链表 递归 波兰式和逆波兰式理论 波兰式和逆波兰式源码 CSS 外边距合并 BFC 盒子模型 DOM 事件 http 协议知识点的整理 http 相关面试题汇总 学习网址 关于 js 中,原型对象，原型链，构造函数，实例之间关系的理解与区别 1.1. HTML5 增加功能 绘画 canvas 元素 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search CSS3 实现圆角，阴影，对文字加特效，增加了更多的 CSS 选择器和多背景 rgba 新的技术 webworker, websocket, Geolocation 1.2. 语义化的理解 html 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析 在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 1.3. 介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engine 或 Rendering Engine) 和 JS 引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS 引擎：解析和执行 javascript 来实现网页的动态效果。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 1.4. 常见的浏览器内核有哪些？ Trident 内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。 Gecko 内核：Netscape6 及以上版本，FF, MozillaSuite/SeaMonkey 等 Presto 内核：Opera7 及以上。 [Opera 内核原为：Presto，现为：Blink;] Webkit 内核：Safari, Chrome 等。 [ Chrome 的：Blink（WebKit 的分支）] 浏览器内核的解析和对比 1.5. css 多列等高如何实现？ 利用 padding-bottom|margin-bottom 正负值相抵；设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定 padding-bottom 时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的 padding-bottom 补偿这部分高度差。 使用 flex 1.6. 移动端的布局用过媒体查询吗？ 当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假， 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）。 @media (min-width: 700px) and (orientation: landscape){ .sidebar { display: none; } } 1.7. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 多数显示器默认频率是 60Hz，即 1 秒刷新 60 次，所以理论上最小间隔为 1/60＊1000ms ＝ 16.7ms 1.8. display:inline-block 什么时候会显示间隙？怎么处理？(携程) 移除空格、使用 margin 负值、使用 font-size:0、letter-spacing、word-spacing 1.9. javascript 代码中的\"use strict\";是什么意思 ? 使用它区别是什么？ 使 JS 编码更加规范化的模式，消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用 with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明，函数必须声明在顶层，不允许在非函数代码块内声明函数，arguments.callee 也不允许使用； 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的 arguments 修改，严格模式下的 eval 函数的行为和非严格模式的也不相同; 提高编译器效率，增加运行速度；为未来新版本的 Javascript 标准化做铺垫。 1.10. Ajax 解决浏览器缓存问题？ 在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(\"If-Modified-Since\",\"0\") 在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(\"Cache-Control\",\"no-cache\") 在 URL 后面加上一个随机数：\"fresh=\" + Math.random(); 在 URL 后面加上时间戳：\"nowtime=\" + new Date().getTime(); 如果是使用 jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录 1.11. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？） 参考：http://annn.me/how-to-realize-cmd-loader/ 1.12. jquery.extend 与 jquery.fn.extend 的区别？ jquery.extend 为 jquery 添加类方法，可以理解为添加静态方法 jquery.fn.extend: 源码中 jquery.fn = jquery.prototype，所以对 jquery.fn 的扩展，就是为 jquery 类添加成员函数 jquery.extend 扩展，需要通过 jquery 类来调用，而 jquery.fn.extend 扩展，所有 jquery 实例都可以直接调用。 $.fn.stringifyArray = function(array) { return JSON.stringify(array); }; $.fn.parseArray = function(array) { return JSON.parse(array); }; // 然后调用： $('').stringifyArray(array); 1.13. Object.is() 与原来的比较操作符“===”、“==”的区别？ 两等号判等，会在比较时进行类型转换； 三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回 false）； Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同。但 Object.is(NaN, NaN) 会返回 true. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/协议_HTTP.html": {
    "url": "Basic/frontend/协议_HTTP.html",
    "title": "协议_HTTP",
    "keywords": "",
    "body": "1. Http 协议特点1.1. 概念1.2. 报文组成1.3. 方法1.4. post get 区别1.5. 状态码1.6. 持久化连接1.7. 管线化1.8. HTTPS 的握手过程1.9. 是否了解公钥加密和私钥加密。1. Http 协议特点 无连接：连接一次就断掉，不会保持连接 无状态：一次连接后，服务器不回去记住上次请求的状态，通过 session 才能实现。 简单快速：每个资源都是固定的，统一资源符。uri 输入就可访问想要的 灵活：通过一个 Http 协议就可以完成不同数据类型的传输。只需要更改头文件中的数据类型。 1.1. 概念 HTTP (超文本传输协议) 是利用 TCP 在两台电脑(通常是 Web 服务器和客户端)之间传输信息的协议。客户端使用 Web 浏览器发起 HTTP 请求给 Web 服务器，Web 服务器发送被请求的信息给客户端。 基本概念： 连接(Connection)：一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。 消息(Message)：HTTP 通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。 请求(Request)：一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号 响应(Response)：一个从服务器返回的信息包括 HTTP 协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的 MIME 类型。 资源(Resource)：由 URI 标识的网络数据对象或服务。 实体(Entity)：数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。 客户机(Client)：一个为发送请求目的而建立连接的应用程序。 用户代理(Useragent)：初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。 服务器(Server)：一个接受连接并对请求返回信息的应用程序。 源服务器(Origin server)：是一个给定资源可以在其上驻留或被创建的服务器。 代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。 网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非 HTTP 系统中的资源。 通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于 HTTP 通讯，尽管通道可能是被一个 HTTP 请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。 缓存(Cache)：反应信息的局域存储。 关闭连接： 客户和服务器双方都可以通过关闭套接字来结束 TCP/IP 对话 1.2. 报文组成 请求报文：请求行、请求头、空行、请求体 请求行：http 方法、页面地址、协议、版本 请求头：key-value，告诉服务端请求内容，主要包括用户可以接受的数据类型、长度、压缩方法、最后一次修改时间、数据有效期等。 请求体: queryString 数据 请求行 GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1 请求头 Host: www.w3.org Connection: keep-alive Cache-Control: max-age=0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36 Referer: https://www.google.com.hk/ Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8,en;q=0.6 Cookie: authorstyle=yes If-None-Match: \"2cc8-3e3073913b100\" 请求头结束 If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT 空行 请求体 name=qiu&age=25 响应报文：状态行、响应头、空行、响应体 状态行：200 ok 状态行 HTTP/1.1 200 OK 响应头 Date: Tue, 08 Jul 2014 05:28:43 GMT Server: Apache/2 Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT ETag: \"40d7-3e3073913b100\" Accept-Ranges: bytes Content-Length: 16599 Cache-Control: max-age=21600 Expires: Tue, 08 Jul 2014 11:28:43 GMT P3P: policyref=\"http://www.w3.org/2001/05/P3P/p3p.xml\" 响应头结束 Content-Type: text/html; charset=iso-8859-1 空行 响应体 {\"name\": \"qiu\", \"age\": 25} 1.3. 方法 Get, post, put, patch, delete, head(获取报文头) 1.4. post get 区别 get 请求参数长度有限制，post 没有限制 get 相对 post 不安全，参数暴露在 url 中 get 参数 url 中，post 在 request body 中 get 在浏览器中回退是无害的，post 会再次提交 get url 参数完整保存在浏览器历史记录，post 不行 get 浏览器自动缓存。post 需要主动去缓存 get 只接受 ASCII 字符，post 无限制 get 的 url 可以被收藏，post 不行 1.5. 状态码 1XX：指示信息-表示请求已接受，继续处理 2XX：成功-表示请求已被成功接收 200 OK ：客户端请求成功 206 Partial Content：video/audio 文件大的时候，客户端发送了带 range 头的 get 请求，服务器完成了他 3XX：重定向-要完成请求必须进行更进一步的操作 301 Move Permanently：所请求的页面已经转移至新的 URL 302 Found：所请求的页面已经临时转移到新的 URL 304 Not Modified：客户端有缓冲的文档并发出一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用 4XX：客户端错误-请求有语法错误或请求无法实现 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 401 Unauthorized：请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 403 Forbidden：对被请求页面的访问被禁止 404 Not Found：请求资源不存在 5XX：服务错误-服务器未能实现合法的请求 500 Internal Server Error：服务器发生不可预期的错误，原来缓冲的文档还可以继续使用 503 Server Unavailable：请求未完成，服务器临时过载或当机，一段事件后恢复正常 1.6. 持久化连接 http 1.1 支持，Keep-Alive 模式 1.7. 管线化 持久连接下：请求 1 --> 响应 1 --> 请求 2 --> 响应 2 管线化：请求和响应都打包：请求 123 --> 响应 123 管线化是通过持久连接完成，至少 1.1 只有 get、head 请求可以管线化，post 有限制 初次建立不应该启动管线化、因为服务端不一定支持 1.1 不会带来性能提升，很多服务端对他支持不好，现代浏览器 chrome 默认不开启 1.8. HTTPS 的握手过程 浏览器将自己支持的一套加密规则发送给服务器。 服务器从中选出一组加密算法与 HASH 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 浏览器获得网站证书之后浏览器要做以下工作： 验证证书的合法 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。 使用约定好的 HASH 算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给服务器 网站接收浏览器发来的数据之后要做以下的操作： 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证 HASH 是否与浏览器发来的一致。 使用密码加密一段握手消息，发送给浏览器。 浏览器解密并计算握手消息的 HASH，如果与服务端发来的 HASH 一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。 http://blog.jobbole.com/105633/ 1.9. 是否了解公钥加密和私钥加密。 一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证; HTTP 网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/协议_HTTP2.html": {
    "url": "Basic/frontend/协议_HTTP2.html",
    "title": "协议_HTTP2",
    "keywords": "",
    "body": "1. HTTP/2 Server Push with Node.js1.1. About HTTP/21.2. Server Push1.3. HTTP/2 Server Push Example in Node.js1.4. HTTP/2 & Node1. HTTP/2 Server Push with Node.js node 8.4 --expose-http2 server push: 通过 full request 和 多路响应大大减少请求响应时间。不像 http 1 时代 浏览器加载 html，再分别加载里面的 js, css, image 资源。并且 http 1 每次浏览器从一个 domain 下载的资源数受限，chrome/firefox 最多同时下载 8 个。 http 2 的多路响应、加上 server push 甚至在浏览器没有向服务端发送请求时 服务端都能迅速返回所需要的资源。 Node.js 8.4.0 just arrived with the experimental support of HTTP/2, which you can enable by using the --expose-http2 flag. In this blog post, we will introduce the most important aspects of HTTP/2 Server Push and create a small Node.js app that gains benefit from using it. 1.1. About HTTP/2 通过使用 full request and response multiplexing 多路传输 等措施 减少延迟！ The primary goals for HTTP/2 are to reduce latency by enabling full request and response multiplexing, minimize protocol overhead via efficient compression of HTTP header fields, and add support for request prioritization and server push. To read more about HTTP/2 in general, check out the Introduction to HTTP/2 article. 1.2. Server Push HTTP/2 Server Push allows the server to send assets to the browser before it has even asked for them. Before we jump into HTTP/2 let's take a look how it works with HTTP/1: In HTTP/1 the client sends a request to the server, which replies with the requested content, usually with an HTML file that contains links to many assets (.js, .css, etc. files). As the browser processes this initial HTML file, it starts to resolve these links and makes separate requests to fetch them. Check out the following image that demonstrates the process. Pay extra attention to the independent requests on the timeline and to the initiator of those requests: HTTP/1 assets loading This is how HTTP/1 works, and this is how we develop our application for so many years. Why change it now? The problem with the current approach is that the user has to wait while the browser parses responses, discovers links and fetches assets. This delays rendering and increases load times. There are workarounds like inlining some assets, but it also makes the initial response bigger and slower. This is where HTTP/2 Server Push capabilities come into the picture as the server can send assets to the browser before it has even asked for them. Look at the following picture where the same website is served via HTTP/2. Check out the timeline and the initiator. You can see that HTTP/2 multiplexing reduced the number of requests, and the assets were sent immediately together with the initial request. HTTP/2 with Server Push Let's see how you can use HTTP/2 Server Push today with Node.js and speed up your client's load time. 1.3. HTTP/2 Server Push Example in Node.js With requiring the built-in http2 module, we can create our server just like we would do it with the https module. The interesting part is that we push other resources when the index.html is requested: const http2 = require('http2'); const server = http2.createSecureServer({ cert, key }, onRequest); function push(stream, filePath) { const { file, headers } = getFile(filePath); const pushHeaders = { [HTTP2_HEADER_PATH]: filePath }; stream.pushStream(pushHeaders, (pushStream) => { pushStream.respondWithFD(file, headers); }); } function onRequest(req, res) { // Push files with index.html if (reqPath === '/index.html') { push(res.stream, 'bundle1.js'); push(res.stream, 'bundle2.js'); } // Serve file res.stream.respondWithFD(file.fileDescriptor, file.headers); } This way the bundle1.js and bundle2.js assets will be sent to the browser even before it asks for them. You can find the full example here: https://github.com/RisingStack/http2-push-example 1.4. HTTP/2 & Node HTTP/2 in @nodejs can help us at many points to optimize our client-server communication. With Server Push, we can send assets to the browser before it has even asked for them to reduce the initial loading time for our users. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/协议_TCP_UDP_Http的区别.html": {
    "url": "Basic/frontend/协议_TCP_UDP_Http的区别.html",
    "title": "协议_TCP_UDP_Http 的区别",
    "keywords": "",
    "body": "1. TCP/IP、Http 的区别1.1. TCP UDP 区别1.2. HTTP1. TCP/IP、Http 的区别 TPC/IP 协议是传输层协议，主要解决数据如何在网络中传输，而 HTTP 是应用层协议，主要解决如何包装数据。关于 TCP/IP 和 HTTP 协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）TCP/IP 协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如 HTTP、FTP、TELNET 等，也可以自己定义应用层协议。WEB 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网络上。” TCP/IP 代表传输控制协议/网际协议，指的是一系列协议。“IP”代表网际协议，TCP 和 UDP 使用该协议从一个网络传送数据包到另一个网络。把IP 想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP 和 UDP 是高速公路上的“卡车”，它们携带的货物就是像 HTTP，文件传输协议 FTP 这样的协议等。​TCP 和 UDP 是 FTP、HTTP 和 SMTP 之类使用的传输层协议。 1.1. TCP UDP 区别 虽然 TCP 和 UDP 都是用来传输其他协议的，它们却有一个显著的不同：TCP 提供有保证的数据传输，而 UDP 不提供。这意味着 TCP 有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而 UDP 不提供任何这样的保证。 下面的图表试图显示不同的 TCP/IP 和其他的协议在最初 OSI 模型中的位置： 7 应用层 例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP 6 表示层 例如XDR、ASN.1、SMB、AFP、NCP 5 会话层 例如ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets 4 传输层 例如TCP、UDP、RTP、SCTP、SPX、ATP、IL 3 网络层 例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X.25 2 数据链路层 例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP 1 物理层 例如线路、无线电、光纤、信鸽 1.2. HTTP 参见 协议_HTTP.md Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/协议_Websocket_SSE_vs_polling.html": {
    "url": "Basic/frontend/协议_Websocket_SSE_vs_polling.html",
    "title": "协议_Websocket_SSE_vs_polling",
    "keywords": "",
    "body": "1. HTTP, Ajax Polling, Ajax Long polling, Websocket, Comet, SSE1.1. Regular HTTP1.2. Ajax Polling:1.3. Ajax Long-Polling:1.4. HTML5 Server Sent Events (SSE) / EventSource:1.5. HTML5 WebSockets1.5.1. 小结1.6. Comet:1. HTTP, Ajax Polling, Ajax Long polling, Websocket, Comet, SSE 1.1. Regular HTTP A client requests a webpage from a server. The server calculates the response The server sends the response to the client. 1.2. Ajax Polling: A client requests a webpage from a server using regular HTTP (see HTTP above). The requested webpage executes JavaScript which requests a file from the server at regular intervals (e.g. 0.5 seconds). The server calculates each response and sends it back, just like normal HTTP traffic. 1.3. Ajax Long-Polling: A client requests a webpage from a server using regular HTTP (see HTTP above). The requested webpage executes JavaScript which requests a file from the server. The server does not immediately respond with the requested information but waits until there's new information available. When there's new information available, the server responds with the new information. The client receives the new information and immediately sends another request to the server, re-starting the process. 1.4. HTML5 Server Sent Events (SSE) / EventSource: A client requests a webpage from a server using regular HTTP (see HTTP above). The requested webpage executes javascript which opens a connection to the server. The server sends an event to the client when there's new information available. Real-time traffic from server to client, mostly that's what you'll need You'll want to use a server that has an event loop Not possible to connect with a server from another domain If you want to read more, I found these very useful: (article), (article), (article), (tutorial). EventSource 不是一个新鲜的技术，正式一点应该叫Server-sent events，即 SSE。 webpack hot reloading 就是 \b 基于 SSE。 EventSource 本质上还是 HTTP，基于流，通过 response 流实时推送服务器信息到客户端。 新创建的 EventSource 对象拥有如下属性： 属性 描述 url(只读) es 对象请求的服务器 url readyState(只读) es 对象的状态，初始为 0，包含 CONNECTING(0)，OPEN(1)，CLOSED(2) 三种状态 withCredentials 是否允许带凭证等，默认为 false，即不支持发送 cookie 服务端实现/message接口，需要返回类型为 text/event-stream的响应头。 // 服务端： var http = require('http'); http.createServer(function(req，res){ if(req.url === '/message'){ res.writeHead(200，{ 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive' }); setInterval(function(){ res.write('data: ' + new Date() + '\\n\\n'); }, 1000); } }).listen(8888); 我们注意到，为了避免缓存，Cache-Control 特别设置成了 no-cache，为了能够发送多个 response， Connection 被设置成了 keep-alive。发送数据时，请务必保证服务器推送的数据以 data:开始，以\\n\\n结束，否则推送将会失败(约定的)。 以上，服务器每隔 1s 主动向客户端发送当前时间戳，为了接受这个信息，客户端需要监听服务器。如下： // 客户端: // 新建一个EventSource对象 const es = new EventSource('/message'); // message 是服务端支持 EventSource 的接口 es.onmessage = function(e) { console.log(e.data); // 打印服务器推送的信息 }; 如下是消息推送的过程： 你以为 es 只能监听 message 事件吗？并不是，message 只是缺省的事件类型。实际上，它可以监听任何指定类型的事件。 es.addEventListener(\"####\", function(e) {// 事件类型可以随你定义 console.log('####:', e.data); }，false); 服务器发送不同类型的事件时，需要指定 event 字段。 res.write('event: ####\\n'); res.write('data: 这是一个自定义的####类型事件\\n'); res.write('data: 多个data字段将被解析成一个字段\\n\\n'); 如下所示： 可以看到，服务端指定 event 事件名为”####”后，客户端触发了对应的事件回调，同时服务端设置的多个 data 字段，客户端使用换行符连接成了一个字符串。 不仅如此，事件流中还可以混合多种事件，请看我们是怎么收到消息的，如下： 除此之外，es 对象还拥有另外 3 个方法: onopen()、onerror()、close()，请参考如下实现。 es.onopen = function(e) { // 链接打开时的回调 console.log('当前状态readyState:', es.readyState); // open 时readyState===1 }; es.onerror = function(e) { // 出错时的回调(网络问题,或者服务下线等都有可能导致出错) console.log(es.readyState); // 出错时readyState===0 es.close(); // 出错时，chrome浏览器会每隔3秒向服务器重发原请求,直到成功. 因此出错时，可主动断开原连接. }; 使用 EventSource 技术实时更新网页信息十分高效。实际使用中，我们几乎不用担心兼容性问题，主流浏览器都了支持 EventSource，当然，除了掉队的 IE 系。对于不支持的浏览器，其 PolyFill 方案请参考HTML5 Cross Browser Polyfills。 SSE 配合 CORS 实现跨域 另外，如果需要支持跨域调用，请设置响应头 Access-Control-Allow-Origin: '*'。 如需支持发送 cookie，请设置响应头 Access-Control-Allow-Origin: req.headers.origin 和 Access-Control-Allow-Credentials: true，并且创建 es 对象时，需要明确指定是否发送凭证。如下： var es = new EventSource('/message', { withCredentials: true, }); // 创建时指定配置才是有效的 // es.withCredentials = true; // 与ajax不同，这样设置是无效的 1.5. HTML5 WebSockets A client requests a webpage from a server using regular http (see HTTP above). The requested webpage executes JavaScript which opens a connection with the server. The server and the client can now send each other messages when new data (on either side) is available. Real-time traffic from the server to the client and from the client to the server You'll want to use a server that has an event loop With WebSockets it is possible to connect with a server from another domain. It is also possible to use a third party hosted websocket server, for example Pusher or others. This way you'll only have to implement the client side, which is very easy! If you want to read more, I found these very useful: (article), (article) (tutorial). WebSocket 是基于 TCP 的全双工通讯的协议，它与 EventSource 有着本质上的不同.(前者基于 TCP，后者依然基于 HTTP) WebSocket 使用和 HTTP 相同的 TCP 端口，默认为 80， 统一资源标志符为 ws，运行在 TLS 之上时，默认使用 443，统一资源标志符为 wss。它通过 101 switch protocol 进行一次 TCP 握手，即从 HTTP 协议切换成 WebSocket 通信协议。 相对于 HTTP 协议，WebSocket 拥有如下优点： 全双工，实时性更强。 相对于 http 携带完整的头部，WebSocket 请求头部明显减少。 保持连接状态，不用再验权了。 二进制支持更强，Websocket 定义了二进制帧，处理更轻松。 Websocket 协议支持扩展，可以自定义的子协议，如 permessage-deflate 扩展。 Frame WebSocket 协议基于 Frame 而非 Stream（EventSource 是基于 Stream 的）。因此其传输的数据都是 Frame（帧）。如下便是 Frame 的结构： 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued，if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key，if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ 第一个字节包含 FIN、RSV、Opcode。 FIN：size 为 1bit，标示是否最后一帧。%x0表示还有后续帧，%x1表示这是最后一帧。 RSV1、2、3，每个 size 都是 1bit，默认值都是 0，如果没有定义非零值的含义，却出现了非零值，则 WebSocket 链接将失败。 Opcode，size 为 4bits，表示『payload data』的类型。如果收到未知的 opcode，连接将会断开。已定义的 opcode 值如下： %x0: 代表连续的帧 %x1: 文本帧 %x2: 二进制帧 %x3~7: 预留的非控制帧 %x8: 关闭握手帧 %x9: ping帧，后续心跳连接会讲到 %xA: pong帧，后续心跳连接会讲到 %xB~F: 预留的非控制帧 第二个字节包含 Mask、Payload len。 Mask：size 为 1bit，标示『payload data』是否添加掩码。所有从客户端发送到服务端的帧都会被置为 1，如果置 1，Masking-key便会赋值。 //若 server 是一个 WebSocket 服务端实例 //监听客户端消息 server.on('message', function(msg, flags) { console.log('client say: %s', msg); console.log('mask value:', flags.masked);// true，进一步佐证了客户端发送到服务端的Mask帧都会被置为1 }); //监听客户端pong帧响应 server.on('pong', function(msg, flags) { console.log('pong data: %s', msg); console.log('mask value:', flags.masked);// true，进一步佐证了客户端发送到服务端的Mask帧都会被置为1 }); Payload len：size 为 7bits，即使是当做无符号整型也只能表示 0~127 的值，所以它不能表示更大的值，因此规定”Payload data”长度小于或等于 125 的时候才用来描述数据长度。如果Payload len==126，则使用随后的 2bytes（16bits）来存储数据长度。如果Payload len==127，则使用随后的 8bytes（64bits）来存储数据长度。 以上，扩展的 Payload len 可能占据第三至第四个或第三至第十个字节。紧随其后的是”Mask-key”。 Mask-key：size 为 0 或 4bytes（32bits），默认为 0，与前面 Mask 呼应，从客户端发送到服务端的帧都包含 4bytes（32bits）的掩码，一旦掩码被设置，所有接收到的”payload data”都必须与该值以一种算法做异或运算来获取真实值。 Payload data：size 为”Extension data” 和 “Application data” 的总和，一般”Extension data”数据为空。 Extension data：默认为 0，如果扩展被定义，扩展必须指定”Extension data”的长度。 Application data：占据”Extension data”之后剩余帧的空间。 关于 Frame 的更多理论介绍不妨读读 学习 WebSocket 协议—从顶层到底层的实现原理（修订版）。 关于 Frame 的数据帧解析不妨读读 WebSocket(贰) 解析数据帧 及其后续文章。 建立连接 // 新建一个ws对象十分简单 let ws = new WebSocket('ws://127.0.0.1:10103/'); // 本地使用10103端口进行测试 新建的 WebSocket 对象如下所示： 这中间包含了一次 Websocket 握手的过程，我们分两步来理解。 第一步，客户端请求。 这是一个 GET 请求，主要字段如下： Connection: Upgrade Upgrade: websocket Sec-WebSocket-Key:61x6lFN92sJHgzXzCHfBJQ== Sec-WebSocket-Version:13 Connection 字段指定为 Upgrade，表示客户端希望连接升级。 Upgrade 字段设置为 websocket，表示希望升级至 Websocket 协议。 Sec-WebSocket-Key 字段是随机字符串，服务器根据它来构造一个 SHA-1 的信息摘要。 Sec-WebSocket-Version 表示支持的 Websocket 版本。RFC6455 要求使用的版本是 13。 甚至我们可以从请求截图里看出，Origin 是file://，而 Host 是127.0.0.1:10103，明显不是同一个域下，但依然可以请求成功，说明 Websocket 协议是不受同源策略限制的(同源策略限制的是 http 协议)。 第二步，服务端响应。 Status Code: 101 Switching Protocols 表示 Websocket 协议通过 101 状态码进行握手。 Sec-WebSocket-Accept 字段是由 Sec-WebSocket-Key 字段加上特定字符串”258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，计算 SHA-1 摘要，然后再 base64 编码之后生成的. 该操作可避免普通 http 请求，被误认为 Websocket 协议。 Sec-WebSocket-Extensions 字段表示服务端对 Websocket 协议的扩展。 以上，WebSocket 构造器不止可以传入 url，还能传入一个可选的协议名称字符串或数组。 ws = new WebSocket('ws://127.0.0.1:10103/', ['abc', 'son_protocols']); 服务端实现 ws 是一个 nodejs 版的 WebSocketServer 实现。使用 npm install ws 即可安装。 var WebSocketServer = require('ws').Server， server = new WebSocketServer({port: 10103}); server.on('connection', function(s) { s.on('message', function(msg) { //监听客户端消息 console.log('client say: %s', msg); }); s.send('server ready!');// 连接建立好后，向客户端发送一条消息 }); 以上，new WebSocketServer() 创建服务器时如需权限验证，请指定 verifyClient 为验权的函数。 server = new WebSocketServer({ port: 10103, verifyClient: verify, }); function verify(info) { console.log(Object.keys(info)); // [ 'origin', 'secure', 'req' ] console.log(info.orgin); // \"file://\" return true; // 返回true时表示验权通过，否则客户端将抛出\"HTTP Authentication failed\"错误 } 以上，verifyClient 指定的函数只有一个形参，若为它显式指定两个形参，那么第一个参数同上 info，第二个参数将是一个cb回调函数。该函数用于显式指定拒绝时的 HTTP 状态码等，它默认拥有 3 个形参，依次为： result，布尔值类型，表示是否通过权限验证。 code，数值类型，若 result 值为 false 时，表示 HTTP 的错误状态码。 name，字符串类型，若 result 值为 false 时，表示 HTTP 状态码的错误信息。 // 若verify定义如下 function verify(info, cb) { //一旦拥有第二个形参，如果不调用，默认将通过验权 cb(false, 401, '权限不够'); // 此时表示验权失败，HTTP状态码为401，错误信息为\"权限不够\" return true; // 一旦拥有第二个形参，响应就被cb接管了，返回什么值都不会影响前面的处理结果 } 除了port 和 verifyClient设置外，其它设置项及更多 API，请参考文档 ws-doc。 发送和监听消息 接下来，我们来实现消息收发。如下是客户端发送消息。 ws.onopen = function(e){ // 可发送字符串，ArrayBuffer 或者 Blob数据 ws.send('client ready!); }; 客户端监听信息。 ws.onmessage = function(e) { console.log('server say:', e.data); }; 如下是浏览器的运行截图。 消息的内容都在 Frames 栏，第一条彩色背景的信息是客户端发送的，第二条是服务端发送的。两条消息的长度都是 13。 如下是 Timing 栏，不止是 WebSocket，包括 EventSource，都有这样的黄色高亮警告。 该警告说明：请求还没完成。实际上，直到一方连接 close 掉，请求才会完成。 关闭连接 说到 close，ws 的 close 方法比 es 的略复杂。 语法：close(short code，string reason); close 默认可传入两个参数。code 是数字，表示关闭连接的状态号，默认是 1000，即正常关闭。（code 取值范围从 0 到 4999，其中有些是保留状态号，正常关闭时只能指定为 1000 或者 3000~4999 之间的值，具体请参考CloseEvent - Web APIs）。reason 是 UTF-8 文本，表示关闭的原因（文本长度需小于或等于 123 字节）。 由于 code 和 reason 都有限制，因此该方法可能抛出异常，建议 catch 下. try { ws.close(1001, 'CLOSE_GOING_AWAY'); } catch (e) { console.log(e); } ws 对象还拥有 onclose 和 onerror 监听器，分别监听关闭和错误事件。（注：EventSource 没有 onclose 监听） 拥有的属性 ws 的 readyState 属性拥有 4 个值，比 es 的 readyState 的多一个 CLOSING 的状态。 常量 描述 EventSource(值) WebSocket(值) CONNECTING 连接未初始化 0 0 OPEN 连接已就绪 1 1 CLOSING 连接正在关闭 - 2 CLOSED 连接已关闭 2 3 另外，除了两种都有的 url 属性外，WebSocket 对象还拥有更多的属性。 属性 描述 binaryType 被传输二进制内容的类型，有 blob, arraybuffer 两种 bufferedAmount 待传输的数据的长度 extensions 表示服务器选用的扩展 protocol 指的是构造器第二个参数传入的子协议名称 文件上传 以前一直是使用 ajax 做文件上传，实际上，Websocket 上传文件也是一把好刀. 其 send 方法可以发送 String，ArrayBuffer，Blob 共三种数据类型，发送二进制文件完全不在话下。 由于各个浏览器对 Websocket 单次发送的数据有限制，所以我们需要将待上传文件切成片段去发送。如下是实现。 const ws = new WebSocket('ws://127.0.0.1:10103/');// 连接服务器 const fileSelect = document.getElementById('file'); const size = 1024 * 128;// 分段发送的文件大小(字节) let curSize, total, file, fileReader; fileSelect.onchange = function(){ file = this.files[0];// 选中的待上传文件 curSize = 0;// 当前已发送的文件大小 total = file.size;// 文件大小 ws.send(file.name);// 先发送待上传文件的名称 fileReader = new FileReader();// 准备读取文件 fileReader.onload = loadAndSend; readFragment();// 读取文件片段 }; function loadAndSend(){ if(ws.bufferedAmount > size * 5){// 若发送队列中的数据太多,先等一等 setTimeout(loadAndSend，4); return; } ws.send(fileReader.result);// 发送本次读取的片段内容 curSize += size;// 更新已发送文件大小 curSize server(node): var WebSocketServer = require('ws').Server, server = new WebSocketServer({port: 10103}),// 启动服务器 fs = require('fs'); server.on('connection', function(wsServer){ var fileName, i = 0;// 变量定义不可放在全局,因每个连接都不一样,这里才是私有作用域 server.on('message', function(data, flags){// 监听客户端消息 if(flags.binary){// 判断是否二进制数据 var method = i++ ? 'appendFileSync' : 'writeFileSync'; // 当前目录下写入或者追加写入文件(建议加上try语句捕获可能的错误) fs[method]('./' + fileName, data，'utf-8'); }else{// 非二进制数据则认为是文件名称 fileName = data; } }); wsServer.send('server ready!');// 告知客户端服务器已就绪 }); 运行效果如下： 上述测试代码中没有过多涉及服务器的存储过程。通常，服务器也会有缓存区上限，如果客户端单次发送的数据量超过服务端缓存区上限，那么服务端也需要多次读取。 心跳连接 生产环境下上传一个文件远比本地测试来得复杂。实际上，从客户端到服务端，中间存在着大量的网络链路，如路由器，防火墙等等。一份文件的上传要经过中间的层层路由转发，过滤。这些中间链路可能会认为一段时间没有数据发送，就自发切断两端的连接。这个时候，由于 TCP 并不定时检测连接是否中断，而通信的双方又相互没有数据发送，客户端和服务端依然会一厢情愿的信任之前的连接，长此以往，将使得大量的服务端资源被 WebSocket 连接占用。 正常情况下，TCP 的四次挥手完全可以通知两端去释放连接。但是上述这种普遍存在的异常场景，将使得连接的释放成为梦幻。 为此，早在 websocket 协议实现时，设计者们便提供了一种 Ping/Pong Frame 的心跳机制。一端发送 Ping Frame，另一端以 Pong Frame 响应。这种 Frame 是一种特殊的数据包，它只包含一些元数据，能够在不影响原通信的情况下维持住连接。 根据规范RFC 6455，Ping Frame 包含一个值为 9 的 opcode，它可能携带数据。收到 Ping Frame 后，Pong Frame 必须被作为响应发出。Pong Frame 包含一个值为 10 的 opcode，它将包含与 Ping Frame 中相同的数据。 借助 ws 包，服务端可以这么来发送 Ping Frame。 wsServer.ping(); 同时，需要监听客户端响应的 pong Frame. wsServer.on('pong', function(data, flags) { console.log(data); // \"\" console.log(flags); // { masked: true，binary: true } }); 以上，由于 Ping Frame 不带数据，因此作为响应的 Pong Frame 的 data 值为空串。遗憾的是，目前浏览器只能被动发送 Pong Frame 作为响应（Sending websocket ping/pong frame from browser），无法通过 JS API 主动向服务端发送 Ping Frame。因此对于 web 服务，可以采取服务端主动 ping 的方式，来保持住链接。实际应用中，服务端还需要设置心跳的周期，以保证心跳连接可以一直持续。同时，还应该有重发机制，若连续几次没有收到心跳连接的回复，则认为连接已经断开，此时便可以关闭 Websocket 连接了。 Socket.IO WebSocket 出世已久，很多优秀的大神基于此开发出了各式各样的库。其中 Socket.IO 是一个非常不错的开源 WebSocket 库，旨在抹平浏览器之间的兼容性问题。它基于 Node.js，支持以下方式优雅降级： Websocket Adobe® Flash® Socket AJAX long polling AJAX multipart streaming Forever Iframe JSONP Polling 如何在项目中使用 Socket.IO，请参考第一章 socket.io 简介及使用。 1.5.1. 小结 EventSource，本质依然是 HTTP，基于流，它仅提供服务端到客户端的单向文本数据传输，不需要心跳连接，连接断开会持续触发重连。 WebSocket 双全工通信方式，基于 TCP 协议，基于帧 frame，它提供双向数据传输，支持二进制，需要心跳连接，连接断开不会重连。 EventSource 更轻量和简单，WebSocket 支持性更好（因其支持 IE10+）。通常来说，使用 EventSource 能够完成的功能，使用 WebSocket 一样能够做到，反之却不行，使用时若遇到连接断开或抛错，请及时调用各自的close 方法主动释放资源。 1.6. Comet: Comet is a collection of techniques prior to HTML5 which use streaming and long-polling to achieve real time applications. Read more on wikipedia or this article. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/协议_WebSocket.html": {
    "url": "Basic/frontend/协议_WebSocket.html",
    "title": "协议_WebSocket",
    "keywords": "",
    "body": "1. WebSocket 教程1.1. 一、为什么需要 WebSocket？1.2. 二、简介1.3. 三、客户端的简单示例1.4. 四、客户端的 API1.4.1. 4.1 WebSocket 构造函数1.4.2. 4.2 webSocket.readyState1.4.3. 4.3 webSocket.onopen1.4.4. 4.4 webSocket.onclose1.4.5. 4.5 webSocket.onmessage1.4.6. 4.6 webSocket.send()1.4.7. 4.7 webSocket.bufferedAmount1.4.8. 4.8 webSocket.onerror1.5. 五、服务端的实现1.6. 六、WebSocketd1.7. 七、参考链接1. WebSocket 教程 作者： 阮一峰 日期： 2017 年 5 月 15 日 WebSocket 是一种网络通信协议，很多高级功能都需要它。 1.1. 一、为什么需要 WebSocket？ 初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用\"轮询\"：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 1.2. 二、简介 WebSocket 协议在 2008 年诞生，2011 年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： real-time 双全工双向通信 建立在 TCP 协议之上，服务器端的实现比较容易。 可以发送文本，也可以发送二进制数据。 没有同源限制，客户端可以与任意服务器通信。 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 数据格式比较轻量，性能开销小，通信高效。 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 ws://example.com:80/some/path 1.3. 三、客户端的简单示例 WebSocket 的用法相当简单。 下面是一个网页脚本的例子（点击这里看运行结果），基本上一眼就能明白。 var ws = new WebSocket('wss://echo.websocket.org'); ws.onopen = function(evt) { console.log('Connection open ...'); ws.send('Hello WebSockets!'); }; ws.onmessage = function(evt) { console.log('Received Message: ' + evt.data); ws.close(); }; ws.onclose = function(evt) { console.log('Connection closed.'); }; 1.4. 四、客户端的 API WebSocket 客户端的 API 如下。 1.4.1. 4.1 WebSocket 构造函数 WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。 var ws = new WebSocket('ws://localhost:8080'); 执行上面语句之后，客户端就会与服务器进行连接。 实例对象的所有属性和方法清单，参见这里。 1.4.2. 4.2 webSocket.readyState readyState属性返回实例对象的当前状态，共有四种。 CONNECTING：值为 0，表示正在连接。 OPEN：值为 1，表示连接成功，可以通信了。 CLOSING：值为 2，表示连接正在关闭。 CLOSED：值为 3，表示连接已经关闭，或者打开连接失败。 下面是一个示例。 switch (ws.readyState) { case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break; } 1.4.3. 4.3 webSocket.onopen 实例对象的onopen属性，用于指定连接成功后的回调函数。 ws.onopen = function() { ws.send('Hello Server!'); }; 如果要指定多个回调函数，可以使用addEventListener方法。 ws.addEventListener('open', function(event) { ws.send('Hello Server!'); }); 1.4.4. 4.4 webSocket.onclose 实例对象的onclose属性，用于指定连接关闭后的回调函数。 ws.onclose = function(event) { var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event }; ws.addEventListener('close', function(event) { var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event }); 1.4.5. 4.5 webSocket.onmessage 实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。 ws.onmessage = function(event) { var data = event.data; // 处理数据 }; ws.addEventListener('message', function(event) { var data = event.data; // 处理数据 }); 注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。 ws.onmessage = function(event) { if (typeof event.data === String) { console.log('Received data string'); } if (event.data instanceof ArrayBuffer) { var buffer = event.data; console.log('Received arraybuffer'); } }; 除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。 // 收到的是 blob 数据 ws.binaryType = 'blob'; ws.onmessage = function(e) { console.log(e.data.size); }; // 收到的是 ArrayBuffer 数据 ws.binaryType = 'arraybuffer'; ws.onmessage = function(e) { console.log(e.data.byteLength); }; 1.4.6. 4.6 webSocket.send() 实例对象的send()方法用于向服务器发送数据。 发送文本的例子。 ws.send('your message'); 发送 Blob 对象的例子。 var file = document.querySelector('input[type=\"file\"]')w.files[0]; ws.send(file); 发送 ArrayBuffer 对象的例子。 // Sending canvas ImageData as ArrayBuffer var img = canvas_context.getImageData(0, 0, 400, 320); var binary = new Uint8Array(img.data.length); for (var i = 0; i 1.4.7. 4.7 webSocket.bufferedAmount 实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。 var data = new ArrayBuffer(10000000); socket.send(data); if (socket.bufferedAmount === 0) { // 发送完毕 } else { // 发送还没结束 } 1.4.8. 4.8 webSocket.onerror 实例对象的onerror属性，用于指定报错时的回调函数。 socket.onerror = function(event) { // handle error event }; socket.addEventListener('error', function(event) { // handle error event }); 1.5. 五、服务端的实现 WebSocket 服务器的实现，可以查看维基百科的列表。 常用的 Node 实现有以下三种。 µWebSockets Socket.IO WebSocket-Node 具体的用法请查看它们的文档，这里不详细介绍了。 1.6. 六、WebSocketd 下面，我要推荐一款非常特别的 WebSocket 服务器：Websocketd。 它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。 举例来说，下面是一个 Bash 脚本counter.sh。 #!/bin/bash echo 1 sleep 1 echo 2 sleep 1 echo 3 命令行下运行这个脚本，会输出 1、2、3，每个值之间间隔 1 秒。 $ bash ./counter.sh 1 2 3 现在，启动websocketd，指定这个脚本作为服务。 $ websocketd --port=8080 bash ./counter.sh 上面的命令会启动一个 WebSocket 服务器，端口是8080。每当客户端连接这个服务器，就会执行counter.sh脚本，并将它的输出推送给客户端。 var ws = new WebSocket('ws://localhost:8080/'); ws.onmessage = function(event) { console.log(event.data); }; 上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出 1、2、3。 有了它，就可以很方便地将命令行的输出，发给浏览器。 $ websocketd --port=8080 ls 上面的命令会执行ls命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（代码）。 更多的用法可以参考官方示例。 Bash 脚本读取客户端输入的例子 五行代码实现一个最简单的聊天服务器 websocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务greeter.js。 process.stdin.setEncoding('utf8'); process.stdin.on('readable', function() { var chunk = process.stdin.read(); if (chunk !== null) { process.stdout.write('data: ' + chunk); } }); 启动这个脚本的命令如下。 $ websocketd --port=8080 node ./greeter.js 官方仓库还有其他各种语言的例子。 1.7. 七、参考链接 How to Use WebSockets WebSockets - Send & Receive Messages Introducing WebSockets: Bringing Sockets to the Web Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/图片隐层且浏览器不下载.html": {
    "url": "Basic/frontend/图片隐层且浏览器不下载.html",
    "title": "图片隐层且浏览器不下载",
    "keywords": "",
    "body": "1. 隐藏图片且不下载1.1. visibility 和 display 区别1.2. 浏览器不下载图片的办法1. 隐藏图片且不下载 1.1. visibility 和 display 区别 visibility 隐藏元素但标签位置还占用着。display 在 DOM 树中存在，但标签在页面上不占位，审查元素其看不到大小和位置 修改常规流中元素的 display 通常会造成文档重排。修改 visibility 属性只会造成本元素的重绘。 读屏器不会读取 display: none; 元素内容；会读取 visibility: hidden; 元素内容 1.2. 浏览器不下载图片的办法 无论是 display 还是 visibility 都无法阻止图片下载。只能隐藏。 用 div 套着 img，div display none 也无法组织图片请求。 img { display: none; visibility: hidden; } 但是 div 换成 textarea 就好用，图片不会被请求。 更好的方法，使用 html template 标签 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/安全.html": {
    "url": "Basic/frontend/安全.html",
    "title": "安全",
    "keywords": "",
    "body": "1. 前端安全类1.1. CSRF1.1.1. 原理1.2. XSS1.2.1. 原理1.2.2. XSS 攻击类型1.2.3. 防御措施1. 前端安全类 XSS CSRF sql 注入：使用 parameterized stored procedure 1.1. CSRF cross-site request forgery 跨站请求伪造 1.1.1. 原理 用户登录过网站 A A 网站给用户下发 cookie 用户访问网站 B B 网站引诱用户点击 用户点击后请求了网站 A 的某个接口，因为 cookie 还在，A 网站认为该登录用户进行了操作，可能添加删除数据 很多年前微博一些大 V 突然同时关注了一些人 就是 csrf 造成的。 \b 发生前提: 用户登陆过网站 A，用户点击请求时 cookie 有效 document.write(` 来自csrf `); var iframe = document.createElement('iframe'); iframe.name = 'csrf'; iframe.style.display = 'none'; document.body.appendChild(iframe); setTimeout(() => { document.querySelector('[name=commentForm]').submit(); //执行在攻击页面该脚本 }, 1000); 防御测试: Token 验证: 访问网站是会主动上传 cookie，但不会主动传 token。访问接口是没有 token 则不予通过验证，或者 验证码 referral 验证: \b 页面来源是自己站点（同域名）才通过 隐层令牌: 隐藏在 http head 中，类似 token，使用方式有些区别 1.2. XSS cross-site scripting 跨站脚本攻击 1.2.1. 原理 不需要登录认证，向页面注入脚本，写入标签，执行有害脚本。可能是评论区添加注入的 1.2.2. XSS 攻击类型 反射型 URL 参数直接注入。http://loacalhost:8080/?fromalert(1)Google 存储型 存储到 DB 后读取时注入。xss 代码会保存到网站的数据中，比如保存到数据库，当其他用户在访问到一篇文章或一个评论时，这段代码会被从数据库中读取取出来，显示在用户页面上。XSS 攻击注入点: HTML 节点内容、HTML 属性、JavaScript 代码、富文本 1.2.3. 防御措施 让插入的东西无法执行。KB\bB 编辑器。html escape。 转义 和 > &gt var escapeHtml = function(str) { if (!str) return ''; str = str.replace(//g, '&gt;'); return str; }; .net 默认开启 XSS 防御，在提交表单的数据时会检测是否有 <> 这样危险字符，并自动转义 kbb 编辑器 使用 cookie 的 httpOnly 属性，加上了这个属性的 cookie 字段，js 是无法进行读写的 浏览器自带的 XSS 攻击拦截机制: 设置 Header X-XSS-Protection。此机制只适用于参数出现在 HTML 内容或属性 才会去拦截。只适用于反射型。并不是所有浏览器都支持 新的防御方法-CSP 内容安全策略 该安全策略的实现基于一个称作 Content-Security-Policy 的 HTTP 首部。 限制规则: child-src: 为 web workers 和其他内嵌浏览器内容定义 合法的源，例如用 和 加载到页面的内容。 connect-src: 限制能通过脚本接口加载的URL。 default-src: 为其他取指令提供备用服务 fetch directives. font-src: 限制通过 @font-face 加载的字体源。 frame-src: 限制通过类似 和 标签加载的内嵌内容源。 img-src: 限制图片和图标源 manifest-src: 限制 application manifest 文件源。 media-src: 限制通过 或 标签加载的媒体文件源。 object-src: 限制通过 , , 标签加载源。 script-src: 限制 javascript 源。 style-src: 限制层叠样式表文件源。 worker-src: 限制 Worker, SharedWorker, 或者 ServiceWorker 脚本源。 指定哪些可信，哪些不可信 'self' 'unsafe-inline''ubsafe-eval''none' XSS 攻击重点: 检测页面内容(信任规则) 'nonce-' 一次性凭证 后台 hash 传递 'strit-dynamic' 后续脚本的信任 事例 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/模块化_AMD_CMD_UMD.html": {
    "url": "Basic/frontend/模块化_AMD_CMD_UMD.html",
    "title": "模块化_AMD_CMD_UMD",
    "keywords": "",
    "body": "1. 模块化: AMD, CMD, CommonJS, UMD1.1. AMD (Asynchronous Module Definition)，代表 RequireJs1.2. CMD (Common Module Definition 公共模块定义)1.2.1. RequireJs seajs 比较1.3. CommonJS1.4. UMD（Universal Module Definition * 通用模块定义）1.5. ES6 import1.6. 自执行函数简单实现不暴露私有成员1. 模块化: AMD, CMD, CommonJS, UMD AMD 模块以浏览器第一的原则发展，异步加载模块，依赖前置提前加载，代表 RequireJS。RequireJS 从 2.0 开始，也改成可以延迟执行 CMD 异步加载，延迟执行，依赖后置就近加载，代表 seajs CommonJS 模块以服务器第一原则发展，选择同步加载，Node.js 使用 UMD 是 AMD 和 CommonJS 的糅合 ES6 import 1.1. AMD (Asynchronous Module Definition)，代表 RequireJs AMD 是 RequireJS 在推广过程中对模块定义的规范化产出，AMD 是异步加载模块，推崇依赖前置。 define('module1', ['jquery'], ($) => { //do something... }); 代码中依赖被前置，当定义模块（module1）时，就会加载依赖（jquery） define(id?, dependencies?, factory) 第一个参数 id 为字符串类型，表示了模块标识，为可选参数。若不存在则模块标识应该默认定义为在加载器中被请求脚本的标识。如果存在，那么模块标识必须为顶层的或者一个绝对的标识。第二个参数，dependencies ，是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。第三个参数，factory，是一个需要进行实例化的函数或者一个对象。 通过参数的排列组合，这个简单的 API 可以从容应对各种各样的应用场景，如下所述。 定义无依赖的模块 define({ add: function(x, y) { return x + y; }, }); 定义有依赖的模块 define(['alpha'], function(alpha) { return { verb: function() { return alpha.verb() + 1; }, }; }); 定义数据对象模块 define({ users: [], members: [], }); 具名模块 define(\"alpha\", [ \"require\", \"exports\", \"beta\" ], function( require, exports, beta ){ export.verb = function(){ return beta.verb(); // or: return require(\"beta\").verb(); } }); 包装模块 define(function(require, exports, module) { var a = require('a'), b = require('b'); exports.action = function() {}; }); // Or require(['foo', 'bar'], function(foo, bar) { foo.func(); bar.func(); }); 不考虑多了一层函数外，格式和 Node.js 是一样的：使用 require 获取依赖模块，使用 exports 导出 API。 除了 define 外，AMD 还保留一个关键字 require。require 作为规范保留的全局标识符，可以实现为 module loader，也可以不实现。 1.2. CMD (Common Module Definition 公共模块定义) CMD 是 SeaJS 在推广过程中对模块定义的规范化产出，对于模块的依赖，CMD 是延迟执行，推崇依赖就近。 define((require, exports, module) => { module.exports = { fun1: () => { var $ = require('jquery'); return $('#test'); }, }; }); 如上代码，只有当真正执行到 fun1 方法时，才回去执行 jquery。 同时 CMD 也是延自 CommonJS Modules/2.0 规范 1.2.1. RequireJs seajs 比较 //AMD define(['./a', './b'], function(a, b) { //依赖一开始就写好 a.test(); b.test(); }); //CMD define(function(require, exports, module) { //依赖可以就近书写 var a = require('./a'); a.test(); //软依赖 if (status) { var b = require('./b'); b.test(); } }); 虽然 AMD 也支持 CMD 写法，但依赖前置是官方文档的默认模块定义写法。 AMD 的 API 默认是一个当多个用，CMD 严格的区分推崇职责单一。例如：AMD 里 require 分全局的和局部的。CMD 里面没有全局的 require，提供 seajs.use() 来实现模块系统的加载启动。CMD 里每个 API 都简单纯粹。 1.3. CommonJS 提到 CMD，就不得不提起 CommonJS，CommonJS 是服务端模块的规范，由于 Node.js 被广泛认知。 根据 CommonJS 规范，一个单独的文件就是一个模块。加载模块使用 require 方法，该方法读取一个文件并执行，最后返回文件内部的 module.exports 对象。 //file1.js module.exports = { a: 1, }; //file2.js var f1 = require('./file1'); var v = f1.a + 2; module.exports = { v: v, }; CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像 Node.js 主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以 CommonJS 规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD CMD 解决方案。 1.4. UMD（Universal Module Definition * 通用模块定义） UMD 是 AMD 和 CommonJS 的一个糅合。AMD 是浏览器优先，异步加载；CommonJS 是服务器优先，同步加载。 既然要通用，怎么办呢？那就先判断是否支持 node.js 的模块，存在就使用 node.js；再判断是否支持 AMD（define 是否存在），存在则使用 AMD 的方式加载。这就是所谓的 UMD。 ((root, factory) => { if (typeof define === 'function' && define.amd) { //AMD define(['jquery'], factory); } else if (typeof exports === 'object') { //CommonJS var $ = require('jquery'); module.exports = factory($); } else { //都不是，浏览器全局定义 root.testModule = factory(root.jQuery); } })(this, ($) => { //do something... 这里是真正的函数体 }); 1.5. ES6 import ES6 modules 的 import 和 export statements 相比完全动态的 CommonJS require，有着本质的区别。 只能作为模块顶层的语句出现，不能出现在 function 里面或是 if 里面。（ECMA-262 15.2) import 的模块名只能是字符串常量。(ECMA-262 15.2.2) 不管 import 的语句出现的位置在哪里，在模块初始化的时候所有的 import 都必须已经导入完成。换句话说，ES6 imports are hoisted。(ECMA-262 15.2.1.16.4 - 8.a) import binding 是 immutable 的，类似 const。比如说你不能 import { a } from './a' 然后给 a 赋值个其他什么东西。(ECMA-262 15.2.1.16.4 - 12.c.3) 这些设计虽然使得灵活性不如 CommonJS 的 require，但却保证了 ES6 modules 的依赖关系是确定 (deterministic) 的，和运行时的状态无关，从而也就保证了 ES6 modules 是可以进行可靠的静态分析的。对于主要在服务端运行的 Node 来说，所有的代码都在本地，按需动态 require 即可。但对于要下发到客户端的 web 代码而言，要做到高效的按需使用，不能等到代码执行了才知道模块的依赖，必须要从模块的静态分析入手。这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS。正是基于这个基础上，才使得 tree-shaking 成为可能（这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking），所以说与其说 tree-shaking 这个技术怎么了不起，不如说是 ES6 module 的设计在模块静态分析上的种种考量值得赞赏。 1.6. 自执行函数简单实现不暴露私有成员 var module1 = (function() { var _count = 0; var m1 = function() { //... }; var m2 = function() { //... }; return { x: m1, y: m2, }; })(); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/浏览器渲染机制.html": {
    "url": "Basic/frontend/浏览器渲染机制.html",
    "title": "浏览器渲染机制",
    "keywords": "",
    "body": "1. 渲染机制1.1. doctype1.2. 浏览器渲染过程1.2.1. 重排 reflow1.2.2. 重绘 repaint1.2.3. 注意1.3. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？(重要)1.3.1. 参考1. 渲染机制 1.1. doctype DTD (document type definition，文档类型定义) 告诉浏览器文档类型，浏览器再决定用什么引擎解析渲染之 doctype 告诉浏览器 当前 DTD(当前使用的文档类型) 常见的 doctype 类型： html5： html4.01 strict：不包括废弃标签如 font html4.01 transitional 过渡版本 1.2. 浏览器渲染过程 首先，解析 HTML Source，构建 DOM Tree 同时，解析 CSS Style，构建 CSSOM Tree 然后，组合 DOM Tree 与 CSSOM Tree，去除不可见元素，构建 Render Tree，同时进行 Layout Painting Composition Display 页面变化重新渲染时： 再执行 Reflow，根据 Render Tree 计算每个可见元素的布局(几何属性) 最后，执行 Repaint，通过绘制流程，将每个像素渲染到屏幕上。 在第三步，在建立 Render Tree 时(WebKit 中的「Attachment」过程)，浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果(Style Rules)来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。 所以，css 解析顺序: 从右到左进行查找。如果从左到右的顺序，那么每条选择器都需要遍历整个 DOM 树，性能很受影响。所谓高效的 CSS 就是让浏览器在查找 style 匹配的元素的时候尽量进行少的查找, 所以选择器最好写的简洁一点。 Layout 告诉 render tree 每个元素位置，宽高等信息。 Painting: This is the process of filling in pixels. It involves drawing out elements. Compositing: parts of the page were drawn into potentially multiple layers they need to be drawn to the screen in the correct order so that the page renders correctly. (组合：多层显示顺序) For more information: https://developers.google.com/web/fundamentals/performance/rendering/?hl=en 1.2.1. 重排 reflow 页面字体大小改变或者元素移动位置等，浏览器需要重新计算每个元素盒子模型的位置。这个过程叫 reflow。回炉(重新塑形)。举个例子，页面上节点是以树的形式展现的。假如我使用 JavaScript 砍掉一个节点，这棵树为了不脱节，肯定要重新梳理一遍，将砍掉的那个断点重新结合起来又形成一颗完整的树，而这个结合梳理过程就是这里的 reflow，所谓回流，就是由于某些原因(如修改)，要将元素回过头来重新“流”一遍 触发 reflow: 增删改 DOM 结点 移动 DOM 位置、动画 css 样式 display, height 等改变 resize scroll 有可能 修改网页字体(不要这样做，性能问题) 特殊：offset、scroll、clientX、getComputedStyle、currentStyle： 由于浏览器在处理批量修改页面元素样式时，会将批量操作缓存起来，然后再做一次 reflow 过程(异步 reflow)，避免每次操作都执行 reflow 消耗资源。但是如果在某个上述特殊操作之后立马调用了以上执行属性，为了等够得到最新的样式，会检查缓存的操作，是否需要 reflow，这样就 flush 出最新的样式。 如何减少 reflow ？ 不轻易增删改 DOM，不要修改网页字体，不轻易移动 DOM 等。 少用 display:none 而使用 visibility:hidden 减少不必要的 DOM 深度。改变 DOM 节点树上任何一个层级都会影响从根结点一直到修改的子节点。 精简 css，去除没有用处的 css 如果你想让复杂的表现发生改变，例如动画效果，那么请在这个流动线之外实现它。使用 position-absolute 或 position-fixed 来实现它。 避免不必要的复杂的 css 选择符，尤其是使用子选择器，或消耗更多的 CPU 去做选择器匹配。 减少样式的重新计算，即减少 offset、scroll、client*、getComputedStyle、currentStyle 的使用，因为每次调用都会刷新操作缓冲区，执行 reflow & repaint。 避免 window.onresize 1.2.2. 重绘 repaint repaint happens when you change the look of an element without changing the size and shape. This doesn't cause reflow as geometry of the element didn't changed. 触发 repaint： change background color change text color visibility hidden DOM 改变，如添加了新元素，reflow repaint 都发生。 如何尽量减少 repaint 频率：减少页面颜色改变。最后一次性添加结点，而不要每次操作 DOM 都立马修改 DOM。 1.2.3. 注意 Render Tree 只包含渲染网页所需要的节点 Reflow 过程是布局计算每个对象的精确位置和大小 Repaint 过程则是将 Render Tree 的每个像素渲染到屏幕上。 1.3. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？(重要) 从 URL 规范、HTTP 协议、DNS、CDN、数据库查询、到浏览器流式解析、CSS 规则构建、layout、repaint、onload/DOMContentLoaded、JS 执行、JS API 绑定等等 在浏览器地址栏输入 URL 浏览器查看 强缓存 是否命中 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个 HTTP 头进行控制 Expires 和 Cache-Control： HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的相对过期时间 浏览器 解析 URL 获取协议，主机，端口，path。并 组装一个 HTTP(GET)请求报文 浏览器 获取主机 ip 地址，过程如下：通过 DNS 解析获取网址 浏览器缓存 本机缓存 hosts 文件 路由器缓存 ISP DNS 缓存 通过 DNS 解析获取网址 递归查询(可能存在负载均衡导致每次 IP 不一样) 打开一个 socket 与目标 IP 地址、端口建立 TCP 链接，三次握手如下： 客户端发送一个 TCP 的SYN=1，Seq=X的包到服务器端口 （客户端：我要和你连接） 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包（服务端：行啊，你发个约定指令给我，我就跟你继续通信） 客户端发送ACK=Y+1， Seq=Z（客户端：我按照约定发这个指令了） TCP 链接建立后 发送 HTTP 请求 服务器接受请求并解析，将请求转发到服务程序 服务器检查 HTTP 请求头是否包含协商缓存验证信息(Last-Modified, Etag)，如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作 服务器将响应报文通过 TCP 连接发送回浏览器 浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下： 主动方发送 Fin=1, Ack=Z, Seq= X (服务器：我给你发送结果了) 报文被动方发送 ACK=X+1, Seq=Z （客户端：我收到结果了） 报文被动方发送 Fin=1, ACK=X, Seq=Y （客户端：请关闭链接吧） 报文主动方发送 ACK=Y, Seq=X 报文 （服务器：行，我关闭了哈） 浏览器检查响应状态码：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同 如果资源可缓存，进行缓存 对响应进行解码(例如 gzip 压缩) 根据资源类型决定如何处理(假设资源为 HTML 文档) 解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，Render Tree，Layout, 执行 js 脚本，这些操作没有严格的先后顺序，以下分别解释 构建 DOM 树： Tokenizing：根据 HTML 规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据 HTML 标记关系将对象组成 DOM 树 解析过程中遇到图片、样式表、js 文件，启动下载 构建CSSOM 树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建 CSSOM 树 根据 DOM 树和 CSSOM 树构建渲染树: 从 DOM 树的根节点遍历所有可见节点，不可见节点包括：1)script, meta这样本身不可见的标签。2)被 css 隐藏的节点，如display: none 对每一个可见节点，找到恰当的 CSSOM 规则并应用 发布可视节点的内容和计算样式 js 解析如下： 浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时 document.readyState 为 loading HTML 解析器遇到没有 async 和 defer 的 script 时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write() 把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容 当解析器遇到设置了 async 属性的 script 时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用 document.write()，它们可以访问自己 script 和之前的文档元素 当文档完成解析，document.readState 变成 interactive 所有 defer 脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write() 浏览器在 Document 对象上触发 DOMContentLoaded 事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState 变为 complete , window 触发 load 事件 reflow, repaint, 显示页面(HTML 解析过程中会逐步显示页面) 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; 通过 DNS 解析获取网址的 IP 地址，设置 UA 等信息发出第二个 GET 请求; 进行 HTTP 协议会话，客户端发送报头(请求报头); 进入到 web 服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回 304; 浏览器开始下载 html 文档(响应报头，状态码 200)，同时使用缓存; 文档树建立，根据标记请求所需指定 MIME 类型的文件(比如 css、js)，同时设置了 cookie; 页面开始渲染 DOM(这里继续说)，JS 根据 DOM API 操作 DOM，执行事件绑定等，页面显示完成。 1.3.1. 参考 https://segmentfault.com/a/1190000008849210 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/浏览器缓存.html": {
    "url": "Basic/frontend/浏览器缓存.html",
    "title": "浏览器缓存",
    "keywords": "",
    "body": "1. 缓存1.1. 缓存类型1.1.1. 强缓存1.1.2. 协商缓存1.2. 浏览器请求流程图1.3. 写法1. 缓存 分类：服务器缓存，第三方缓存，浏览器缓存 http://imweb.io/topic/55c6f9bac222e3af6ce235b9 1.1. 缓存类型 强缓存与协商缓存区别：强缓存不发请求到服务器，协商缓存会发请求到服务器。 1.1.1. 强缓存 浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器。注意：以下两个 header 可以只启用一个，也可以同时启用，当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires。 Expires 设置 绝对过期时间 。http 1.0 提出的一个表示资源过期时间的 header，由服务器返回，用 GMT 格式的字符串表示，如：Expires:Thu, 31 Dec 2016 23:55:55 GMT。问题：如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大 Cache-Control max-age=[秒] — 相对时间间隔，而不是绝对过期时间。从请求时间开始到过期时间之间的秒数。 no-cache - 强制每次请求直接发送给源服务器，而不经过本地缓存版本的校验。这对于需要确认认证应用很有用（可以和 public 结合使用），或者严格要求使用最新数据的应用（不惜牺牲使用缓存的所有好处） must-revalidate no-store no-transform public private 1.1.2. 协商缓存 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回（304），但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；若未命中请求，则将资源返回客户端，并更新本地缓存数据（200）。 Last-Modified/If-Modified-Since 配合 Cache-Control 如果你第二次请求相同的数据，你可以告诉服务器你上一次获得的最后修改日期：在你的请求中发送一个 If-Modified-Since 头信息，它包含了上一次从服务器连同数据所获得的日期。如果数据从那时起没有改变，服务器将返回一个特殊的 HTTP 状态代码 304 ，这意味着 \"从上一次请求后这个数据没有改变\"，不再重新发送数据。你去缓存中拿数据。 Last-Modified：web 服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：当资源过期时（强缓存失效），发现资源具有 Last-Modified 声明，则再次向 web 服务器请求时带上头 If-Modified-Since，表示请求时间。服务器收到请求后发现有头 If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应 HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的 cache。 缺点： Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间（无法及时更新文件） 如果某些文件会被定期生成，但内容并没变，而 Last-Modified 却改变了，导致文件没法使用缓存。 HTTP 1.1 中 Etag 解决了上述问题。 Etag/If-None-Match 配合 Cache-Control Etag 例子见 Aspnetcore.Camps repo Etag：web 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache 中 Etag 的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行 Hash 后得到的。是实现与最近修改数据检查同样的功能的另一种方法：没有变化时不重新下载数据。其工作方式是：服务器发送你所请求的数据的同时，响应报文里面 Etag: hash。hash 的确定完全取决于服务器。当第二次请求相同的数据时，在浏览器请求头带上 If-None-Match: hash (hash 来自之前服务器返回的 Etag)，服务器进行比对，如果数据没有改变，服务器将返回 304 状态代码。 If-None-Match：当资源过期时（使用 Cache-Control 标识的 max-age），发现资源具有 Etag 声明，则再次向服务器请求时带上头 If-None-Match（ Etag 的值）。服务器收到请求后发现有头 If-None-Match 则与被请求资源的相应校验串进行比对，决定返回 200 或 304。 Last-Modified 与 Etag 一起使用时，服务器会优先验证 Etag。 1.2. 浏览器请求流程图 浏览器第一次请求流程图: 浏览器再次请求时: 1.3. 写法 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/深拷贝_浅拷贝.html": {
    "url": "Basic/frontend/深拷贝_浅拷贝.html",
    "title": "深拷贝_浅拷贝",
    "keywords": "",
    "body": "1. 深拷贝 和 浅拷贝1.1. 实现浅拷贝1.2. 实现深拷贝1. 深拷贝 和 浅拷贝 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 1.1. 实现浅拷贝 var obj1 = { a: 10, b: 20, c: 30 }; var obj2 = obj1; obj2.b = 100; console.log(obj1); // { a: 10, b: 100, c: 30 } 1.2. 实现深拷贝 method 1: 手动复制方式 var obj1 = { a: 10, b: 20, c: 30 }; var obj2 = { a: obj1.a, b: obj1.b, c: obj1.c }; obj2.b = 100; console.log(obj1); // { a: 10, b: 20, c: 30 } method 2: Object.assign, { ...obj } obj1 = { a: 10, b: 20, c: 30 }; obj2 = Object.assign({}, obj1); // { ...obj1 } obj2.b = 100; console.log(obj1); // { a: 10, b: 20, c: 30 } 但是对于深层嵌套的 obj，不能实现深拷贝，深层 obj 仍然是引用关系。 method 3: 转成 JSON 再转回来 用 JSON.stringify 把对象转成字符串，再用 JSON.parse 把字符串转成新的对象。 缺点：只有可以转成 JSON 格式的对象才可以这样用，像 function 没办法转成 JSON。 method 4: 第三方 jquery，有提供一个 $.extend 可以用来做 Deep Copy。 lodash，也有提供 _.cloneDeep 用来做 Deep Copy。 method 5: 递归实现深拷贝 easy version: create an empty obj which will be returned as a new object loop thru each property of original object if the value for a property is not object, assign it to new obj else if property is object, recursively call deepClone function deepClone(o) { var temp = {}; for (var k in o) { if (typeof o[k] == 'object') { temp[k] = deepClone(o[k]); } else { temp[k] = o[k]; } } return temp; } complex version: please search common.js -- deepClone Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/盒模型及宽高.html": {
    "url": "Basic/frontend/盒模型及宽高.html",
    "title": "盒模型及宽高",
    "keywords": "",
    "body": "1. 盒模型1.1. js 获取盒模型的宽高1. 盒模型 标准盒模型 + IE 盒模型（怪异盒模型） box-sizing: content-box /*标准盒模型：default*/ box-sizing: border-box /*IE 盒模型：padding border 算在 宽高中*/ 1.1. js 获取盒模型的宽高 dom.style.height; // 只能获取内联样式 dom.currentStyle.width; // IE，3种都能获得 window.getComputedStyle(dom).width; // 其他浏览器，3种都能获得 dom.getBoundingClientRect().width; // 计算一个元素在视窗中的绝对位置以及宽，高。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/算法.html": {
    "url": "Basic/frontend/算法.html",
    "title": "算法",
    "keywords": "",
    "body": "1. 算法1. 算法 阿里云金融性业务一定考算法 排序 堆栈、队列、链表 递归 波兰式和逆波兰式（时间紧张不看） 快速排序选择排序希尔排序 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/资源preload_prefetch.html": {
    "url": "Basic/frontend/资源preload_prefetch.html",
    "title": "资源 preload_prefetch",
    "keywords": "",
    "body": "1. resource preload, prefetch1.1. Cache Behavior1. resource preload, prefetch https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf preload is a declarative fetch, allowing you to force the browser to make a request for a resource without blocking the document’s onload event. Prefetch is a hint to the browser that a resource might be needed, but delegates deciding whether and when loading it is a good idea or not to the browser. Preload resources you have high-confidence will be used in the current page. Prefetch resources likely to be used for future navigation across multiple navigation boundaries. 1.1. Cache Behavior Chrome has four caches: the HTTP cache, memory cache, Service Worker cache & Push cache. Both preload and prefetched resources are stored in the HTTP cache. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/通信_跨域.html": {
    "url": "Basic/frontend/通信_跨域.html",
    "title": "通信_跨域",
    "keywords": "",
    "body": "1. 前后端通信1.1. 同源策略和限制1.2. 前后端通信方式1.2.1. 如何实现浏览器内多个标签页之间的通信? (阿里)1.2.2. WebSocket 如何兼容低浏览器？(阿里)1.3. 创建 Ajax 要点1.4. 跨域1.4.1. Jsonp1.4.2. Hash 原理1.4.3. WebSocket1.4.4. postMessage1.4.5. CORS 跨域资源共享 (Cross-Origin Resource Sharing)1. 前后端通信 1.1. 同源策略和限制 源：协议、域名、端口 限制：不是一个源的文档没有权利去操作另一个源的文档，包括 cookie, localStorage, indexDB, DOM 无法获取, Ajax 无法发送 1.2. 前后端通信方式 Ajax 同源限制 WebSocket 不受限制，因为请求头中加入了 Origin。他不是 Http，是基于 frame、双全工 tcp 协议的通信方式。 CORS 支持同源和非同源 1.2.1. 如何实现浏览器内多个标签页之间的通信? (阿里) WebSocket、SharedWorker；也可以调用 localStorage、cookies 等本地存储方式； localStorage 另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。 Safari 在无痕模式下设置 localStorage 值时会抛出 QuotaExceededError 的异常； // localStorage change, trigger below event window.addEventListener('storage', function(e) { document.querySelector('.my-key').textContent = e.key; document.querySelector('.my-old').textContent = e.oldValue; document.querySelector('.my-new').textContent = e.newValue; document.querySelector('.my-url').textContent = e.url; document.querySelector('.my-storage').textContent = e.storageArea; }); 1.2.2. WebSocket 如何兼容低浏览器？(阿里) Adobe Flash Socket ActiveX HTMLFile (IE) 基于 multipart 编码发送 XHR 基于长轮询的 XHR 1.3. 创建 Ajax 要点 XMLHttpRequest 对象的工作流程、兼容性、事件触发条件和顺序 /** * [json 实现 ajax 的json] * @param {[type]} options [description] * @return {[type]} [description] */ util.json = function(options) { var opt = { url: '', type: 'get', data: {}, success: function() {}, error: function() {}, }; util.extend(opt, options); if (opt.url) { var xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP'); var data = opt.data, url = opt.url, type = opt.type.toUpperCase(), dataArr = []; for (var k in data) { dataArr.push(k + '=' + data[k]); } if (type === 'GET') { url = url + '?' + dataArr.join('&'); xhr.open(type, url.replace(/\\?$/g, ''), true); xhr.send(); } if (type === 'POST') { xhr.open(type, url, true); xmlhttp.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); xhr.send(dataArr.join('&')); } xhr.onload = function() { // 304 缓存中数据未变，206 video等大文件媒体资源成功 if (xhr.status === 200 || xhr.status === 304) { var res; if (opt.success && opt.success instanceof Function) { res = xhr.responseText; if (typeof res === 'string') { res = JSON.parse(res); opt.success.call(xhr, res); } } } else { if (opt.error && opt.error instanceof Function) { opt.error.call(xhr, res); } } }; } }; 1.4. 跨域 Jsonp Hash (hash # 改变页面不刷新，? 后面 queryString 改变会刷新页面) postMessage (html5) WebSocket (html5) CORS（支持跨域的变种 ajax，当发送 ajax 跨域请求时，http 请求头加入 origin） 1.4.1. Jsonp 利用 script 标签可以不同源加载实现的。Jsonp 只支持 GET 请求 在主站客户端 window 全局注册一个函数 cb url 传递参数和回调函数名字 服务端解析 url 后根据参数拿到数据，执行这个函数，数据作为函数的参数 删除全局注册函数 Jsonp 的优缺点 优点 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支持 在请求完毕后可以通过调用 callback 的方式回传结果。将回调方法的权限给了调用方。这个就相当于将 controller 层和 view 层分开了。我提供的 Jsonp 服务只提供纯服务的数据，至于提供服务以后的页面渲染和后续 view 操作都由调用者来自己定义就好了。如果有两个页面需要渲染同一份数据，你们只需要有不同的渲染逻辑就可以了，逻辑都可以使用同一个 Jsonp 服务。 缺点 它只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求 Jsonp 在调用失败的时候不会返回各种 HTTP 状态码。解决：timeout 触发 onerror 事件 安全性。万一假如提供 Jsonp 的服务存在页面注入漏洞，即它返回的 javascript 的内容被人控制的。那么所有调用这个 Jsonp 的网站都会存在漏洞。于是无法把危险控制在一个域名下。所以在使用 Jsonp 的时候必须要保证使用的 Jsonp 服务必须是安全可信的。 basic demo 1 Jsonp.html 页面定义一个函数，然后在远程 remote.js 中传入数据进行调用。 var localHandler = function(data){ alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result); }; remote.js 文件代码如下： localHandler({ result: '我是远程js带来的数据' }); demo 2 怎么让远程 js 知道它应该调用的本地函数叫什么名字呢？ 通过 queryString 传递回调函数名字，Jsonp 服务端读取并动态创建 Jsonp.html 页面的代码： // 得到航班信息查询结果后的回调函数 var flightHandler = function(data){ alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。'); }; // 提供 Jsonp 服务的 url 地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = \"http://flightQuery.com/Jsonp/flightResult.aspx?code=CA1998&callback=flightHandler\"; // 创建 script 标签，设置其属性 var script = document.createElement('script'); script.setAttribute('src', url); // 把 script 标签加入 head，此时调用开始 document.getElementsByTagName('head')[0].appendChild(script); 不再直接把远程 js 文件写死，而是编码实现动态查询，而这也正是 Jsonp 客户端实现的核心部分。我们看到调用的 url 中传递了一个 code 参数，告诉服务器我要查的是 CA1998 次航班的信息，而 callback 参数则告诉服务器，我的本地回调函数叫做 flightHandler，所以请把查询结果传入这个函数中进行调用。 服务器读取 url 根据 queryString 生成代码： flightHandler({ code: 'CA1998', price: 1780, tickets: 5, }); jQuery 如何实现 Jsonp 调用？ $.ajax({ type: 'get', async: false, url: 'http://flightQuery.com/Jsonp/flightResult.aspx?code=CA1998', dataType: 'jsonp', jsonp: 'callback', //传递给请求处理程序或页面的，用以获得Jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback: 'flightHandler', //自定义的Jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写\"?\"，jQuery会自动为你处理数据 success: function(json) { alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。'); }, error: function() { alert('fail'); }, }); 为什么我这次没有写 flightHandler 这个函数呢？而且竟然也运行成功了！jquery 在处理 Jsonp 类型的 ajax 时（虽然 jquery 也把 Jsonp 归入了 ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供 success 属性方法来调用。 jsonp 错误捕获 如果你把 url 参数改成某个不存在的地址，你会惊奇的发现：虽然浏览器终端报出错误(404 或其他网络错误)，但你的 error 回调却没有被执行!? 那怎么做才能使 Jsonp 的 error 回调被执行呢？ 有两个方法，方法一：添加 timeout 参数。 $.ajax({ url: 'https://api.github.com/users/jarontai/repos', type: 'GET', dataType: 'Jsonp', // dataType 为 Jsonp timeout: 5000, // 添加timeout参数 success: function(data) { $('.result').text(JSON.stringify(data)); }, error: function(jqXHR, textStatus) { // 此时textStatus为‘timeout’ $('.result').text('error'); alert('Jsonp error!'); }, }); 添加 timeout 参数后，虽然 Jsonp 请求本身的错误没有被捕获，但是最终会因为超时而执行 error 回调。 方法二出场：使用 jquery Jsonp 插件 - https://github.com/jaubourg/jquery-jsonp $.jsonp({ url: 'https://api.github.com/users/jarontai/repos', callbackParameter: 'callback', timeout: 5000, error: function(xOptions, textStatus) { // 错误发生时，立即执行 $('.result').text('error'); alert('Jsonp error!'); }, success: function(data) { $('.result').text(JSON.stringify(data)); }, }); 使用 jsonp 插件，能够在错误发生时立即执行 error 回调，并且还附带如 数据过滤 等功能 jsonp 封装 /** * [function 在页面中注入js脚本] * @param {[type]} url [description] * @param {[type]} charset [description] * @return {[type]} [description] */ util.createScript = function(url, charset) { var script = document.createElement('script'); script.setAttribute('type', 'text/javascript'); charset && script.setAttribute('charset', charset); script.setAttribute('src', url); script.async = true; return script; }; /** * [function 获取一个随机的5位字符串] * @param {[type]} prefix [description] * @return {[type]} [description] */ util.getName = function(prefix) { return ( prefix + Math.random() .toString(36) .replace(/[^a-z]+/g, '') .substr(0, 5) ); }; /** * [function jsonp] * @param {[type]} url [description] * @param {[type]} onsucess [description] * @param {[type]} onerror [description] * @param {[type]} charset [description] * @return {[type]} [description] */ util.jsonp = function(url, onsuccess, onerror, charset) { var callbackName = util.getName('tt_player'); window[callbackName] = function() { if (onsuccess && util.isFunction(onsuccess)) { onsuccess(arguments[0]); } }; var script = util.createScript(url + '&callback=' + callbackName, charset); script.onload = script.onreadystatechange = function() { if (!script.readyState || /loaded|complete/.test(script.readyState)) { script.onload = script.onreadystatechange = null; // 移除该script的 DOM 对象 if (script.parentNode) { script.parentNode.removeChild(script); } // 删除函数或变量 window[callbackName] = null; } }; script.onerror = function() { if (onerror && util.isFunction(onerror)) { onerror(); } }; document.getElementsByTagName('head')[0].appendChild(script); }; 1.4.2. Hash 原理 页面 A 中通过 iframe 嵌入 B，\b 需求是 A 给 B 发消息 拿到 B 的 url 改变 B 的 hash B 中接受 onhashchange // 利用hash，场景是当前页面 A 通过 iframe 嵌入了跨域的页面 B // 在A中伪代码如下： var B = document.getElementsByTagName('iframe'); B.src = B.src + '#' + 'data'; // 在B中的伪代码如下 window.onhashchange = function() { var data = window.location.hash; }; 1.4.3. WebSocket WebSocket 是双全工、实时、基于 frame 的 tcp 通信协议，使用 ws://（非加密）和 wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Origin: http://example.com 上面代码中，有一个字段是 Origin，表示该请求的请求源（origin），即发自哪个域名。因为有了 Origin 这个字段，而且非 http 协议，所以 WebSocket 才没有实行同源政策。 var ws = new WebSocket('wss://echo.websocket.org'); onopen, onmessage, onclose // 客户端 var ws = new WebSocket('wss://echo.websocket.org'); ws.onopen = function(e) { console.log('Connection open ...'); ws.send('Hello WebSockets!'); }; ws.onmessage = function(e) { console.log('Received Message: ', e.data); ws.close(); }; ws.onclose = function(e) { console.log('Connection closed.'); }; 1.4.4. postMessage 窗口 A(http:A.com)向跨域的窗口 B(http:B.com)发送信息 // A 中代码 window.postMessage('Hi B, from A', 'http://B.com'); // B中监听代码 window.addEventListener( 'message', function(event) { console.log(event.origin); console.log(event.source); console.log(event.data); }, false, ); 这是一个安全的跨域通信方法，postMessage(message, targetOrigin) 也是 HTML5 引入的特性。 可以给任何一个 window 发送消息，不论是否同源。第二个参数可以是 *，但如果你设置了一个 URL 但不相符，那么该事件不会被分发。看一个普通的使用方式吧： /* * In window A's scripts, with A being on : */ var popup = window.open(...popup details...); // This does nothing, assuming the window hasn't changed its location. popup.postMessage(\"The user is 'bob' and the password is 'secret'\", \"https://secure.example.net\"); // This will successfully queue a message to be sent to the popup, assuming // the window hasn't changed its location. popup.postMessage(\"hello there!\", \"http://example.com\"); function receiveMessage(event) { // Do we trust the sender of this message? (might be // different from what we originally opened, for example). if (event.origin !== \"http://example.com\") return; // event.source is popup // event.data is \"hi there yourself! the secret response is: rheeeeet!\" } window.addEventListener(\"message\", receiveMessage, false); /* * In the popup's scripts, running on : */ // Called sometime after postMessage is called function receiveMessage(event) { // Do we trust the sender of this message? if (event.origin !== 'http://example.com:8080') return; // event.source is window.opener // event.data is \"hello there!\" // Assuming you've verified the origin of the received message (which // you must do in any case), a convenient idiom for replying to a // message is to call postMessage on event.source and provide // event.origin as the targetOrigin. event.source.postMessage( 'hi there yourself! the secret response ' + 'is: rheeeeet!', event.origin, ); } window.addEventListener('message', receiveMessage, false); 1.4.5. CORS 跨域资源共享 (Cross-Origin Resource Sharing) 参考资料： https://www.maxcdn.com/one/visual-glossary/cors/ https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS CORS 就是为了让 AJAX 可以实现可控的跨域访问而生的。 服务器设置 Access-Control-Allow-Origin HTTP 响应头之后，允许浏览器跨域请求。 浏览器在头信息之中，增加一个 Origin 字段。Origin 字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。 服务器根据这个值，决定是否同意这次请求。CORS 支持所有类型的 HTTP 请求 如果服务器同意，响应结果头： Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 Cookie, withCredentials 属性 step 1: CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，服务器需指定 Access-Control-Allow-Credentials 字段。 Access-Control-Allow-Credentials: true step 2: 客户端方面，在 AJAX 请求中打开 withCredentials 属性。 var xhr = new XMLHttpRequest(); xhr.withCredentials = true; 否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。 但是，如果省略 withCredentials 设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭 withCredentials。 xhr.withCredentials = false; 需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 document.cookie 也无法读取服务器域名下的 Cookie。 // CORS 参考资料: http://www.ruanyifeng.com/blog/2016/04/cors.html // url（必选），options（可选） // 实现了 CORS 通信 let myHeaders = new Headers({ 'Access-Control-Allow-Origin': '*', 'Content-Type': 'text/plain', }); fetch(url, { method: 'GET', headers: myHeaders, mode: 'cors', }).then((res) => { // TODO }); 为什么 fetch、CORS 会实现跨域通信？ ajax 跨域请求默认会被浏览器拦截，fetch、CORS 在请求头加入了 origin，服务器端设置了 Access-Control-Allow-Origin 发在源是允许就返回数据。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/错误监控.html": {
    "url": "Basic/frontend/错误监控.html",
    "title": "错误监控",
    "keywords": "",
    "body": "1. 保证产品质量 或 直接问错误监控1.1. 前端错误分类1.2. 错误的捕捉方式1.3. 上报错误的原理1. 保证产品质量 或 直接问错误监控 1.1. 前端错误分类 即使运行错误：代码错误 资源加载错误 1.2. 错误的捕捉方式 运行错误： try catch window.onerror 资源加载错误: 用 object.onerror(script/image.onerror)。但他们不会向上冒泡所以 window.onerror 不能检测到 performance.getEntries() 返回数组包含所有加载成功的资源，document.getElementsByTagName('img') 拿到所有资源，想减知道没加载的资源 Error 事件捕获 window.addEventListener('error', function(e){}) 比如 //baidu.com/test.js 不存在，window.onerror 是冒泡不好用，但 addEventListener 可以设置 true 去捕获到。 window.addEventListener('error', function (e) { console.log('捕获', e); }, true); iframe 加载错误 setTimeout( function () { var frame = document.getElementById( 'errFrame' ); console.log( frame.contentDocument ); var titleInIframe = ( frame.contentDocument.querySelector( 'title' ) ) if ( !titleInIframe ) { alert( 'fail to load content from iframe' ) } }, 2000 ) 延伸：跨域的 js 运行错误如何捕获？Jsonp 没响应怎么捕获错误？(1. timeout 2. json-jquery plugin) 错误提示： 错误信息：script error 出错文件： 出错行号: 0 出错列号: 0 如此做才能拿到具体信息： 客户端在 script 标签中增加 crossorigin 属性 \b 服务端设置 js 资源响应头 Access-Control-Allow-Origin:* 1.3. 上报错误的原理 使用 trackjs 等第三方服务 ajax 通信，但实际不这么做 利用 image 对象上报 (new Image()).src = 'http://baidu.com'; window.addEventListener('error', function (e) { console.log('捕获', e.target.outerHTML); // // 这里可能构建一个 时间、名字 的字符串 (new Image()).src = 'http://errorCollection.com?error=' + e.target.outerHTML; }, true); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/frontend/页面性能.html": {
    "url": "Basic/frontend/页面性能.html",
    "title": "页面性能",
    "keywords": "",
    "body": "1. 页面性能优化1.1. 异步加载方式1.1.1. 异步加载的区别1.2. 浏览器缓存1.2.1. 字体优化1.2.2. 响应式图片1.2.3. 图片优化1.2.4. 视频1.3. 性能优化工具1.3.1. 前端需要注意哪些 SEO (重要)1.4. SPA 如何处理 SEO1. 页面性能优化 减少 http 请求: 资源 \b 压缩 Gzip、合并，图片精灵。 Apache: Use mod_deflate Nginx: Use HttpGzipModule IIS: Configure HTTP Compression.aspx>) 非核心代码异步加载 --> 异步加载方式 --> 异步加载的区别，使用 defer async 比放到页面底部更 modern、更好 利用浏览器缓存 --> 缓存分类 --> 缓存原理 使用 CDN DNS 预解析: https 协议下 a 标签默认浏览器是关闭 dns 预解析。上面 meta 告诉浏览器强制打开对 a 标签的 dns 预解析。 图片优化，大小、格式。图片预加载，将样式表放在顶部，将脚本放在底部 页面静态化 减小 cookie 大小 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数 当需要设置的样式很多时设置 className 而不是直接操作 style 少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作。 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢。 避免多次重定向 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘 IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如 join 查询），减少磁盘 IO 指尽量不使用文件系统作为缓存、减少读写文件次数等。 1.1. 异步加载方式 动态脚本加载。document.createElement('script')\u001d 加载到 body, head 中 defer async 1.1.1. 异步加载的区别 defer 不阻止 \b 文档解析，浏览器遇到 \bdefer 边下载 defer script 边往下解析。全解析完之后才执行 defer script。如果多个依次执行。 async 不阻止 \b 文档解析，浏览器遇到 async 边下载 async script 边往下解析。当下载好了 js 后立即执行，此时文档解析可能还没完成，执行 js 期间停止文档解析。如果多个 async script，执行顺序与加载顺序无关 性能优化 --> test console.log('write'); document.write('write'); for (var i = 0; i 结果都是 write，for 循环数字，最后是 defer 或者 async 执行。区别 defer 按照加载顺序执行， async 不一定，看文件大小、加载时间。 1.2. 浏览器缓存 强缓存：不跟服务器对话，本地有拿来就用 \bExpires Expires: Thu 绝对时间 Cache-Control max-age：3600s 相对时间(以他为准，避免服务器和本地电脑时间不一致) 协商缓存: 问服务器磁盘上的缓存能不能用 Last-Modified If-Modified-Since 他俩值一样。服务器下发 Last-Modified, \b传给服务器If-Modified-Since 因为服务器要对比。 Etag If-None-Match Etag 判断文件内容是否变化 跟缓存的 http 头有哪些？Expires, Cache-Control, Last-Modified, If-Modified-Since, Etag 1.2.1. 字体优化 首先我们使用字体图标代替图片，这是常规的优化。但自定义图标、字体还需要被下载才能完全显示，没下载完成之前页面不会显示。 FontFaceObserver 原理：当字体图标下载完成后在 body 加上一个 class -- jsFontLoaded @font-face 定义到 style.css style.css 里面的 body { font-family: 使用常规的字体 }。在 body.jsFontLoaded { font-family: @font-face } in App.js 增加 Observer 1.2.2. 响应式图片 JS 或者服务端硬编码，resize 事件，判断屏幕大小加载不同的图片 img srcset 方法 picture 标签 -> source svg 第三方库 polyfill 1.2.3. 图片优化 图片优化：以前切图，现在某些效果可以用使用 css3。字体图标替换 图片分类：jpg 小，png 大透明，gif，svg 地图，apng，webp webpack image-loader: 自动对图片进行压缩优化等处理 css sprite：制作网站 GoPng http://alloyteam.github.io/gopng 概念：将多个小图片拼接到一个图片中。通过 background-position 和 元素尺寸 调节需要显示的背景图案。 优点： 减少 HTTP 请求数，极大地提高页面加载速度 增加图片信息重复度，提高压缩比，减少图片大小 更换风格方便，绿色、红色的样字一样的图标可以通过 background-position 改变 缺点： 图片合并麻烦 维护麻烦，修改一个图片可能需要重新布局整个图片 注意手机端一般像素是 pc 端一半，gopng 生成的像素是 pc 端的 fis3 grunt-sprite 响应式动态图片加载 sdk 需要默认图片 分辨率信息告诉服务器 服务器返回优质图片 picture 标签: 1.2.4. 视频 video 标签，不同浏览器默认样式不同 flash 播放器，过时 需求 按照设计师要求制作播放器 用户进来就能看 第三方 videojs flowplayer 视频优化点 提前加载视频资源、依赖。flowplayer 支持 html5 和 swf。如果使用 flash，即使 swf 文件写在图片前面，默认浏览器还是会最后加载 swf 这样的多媒体资源。这导致图片阻塞了视频加载。优化点就是如何才能让视频依赖前置。方法是使用样式 link 此时这些资源立马加载，之后这些资源从浏览器缓存中取出来很快。 1.3. 性能优化工具 YSlow Google PageSpeed pingdom jsPerf dromaeo 微软压力测试工具，模拟每秒轰炸 chrome 自带 performance 监控 1.3.1. 前端需要注意哪些 SEO (重要) 合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可 语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页 重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用 js 输出：爬虫不会执行 js 获取内容 少用 iframe：搜索引擎不会抓取 iframe 中的内容 非装饰性图片必须加 alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 1.4. SPA 如何处理 SEO 因为搜索引擎无法通过 js 抓取信息，所以 SPA 的 SEO 需要格外处理。 You can setup a headless browser like PhantomJS to run on your server. It will execute all the javascript on your page. Then you can send that result to Google. This will fix your problem, but someone has to manage the server for PhantomJS. Opening and processing all these webpages is slow. It might take several servers. Phantom isn't as stable as you'd hoped. react server render 首次生成 html 返回给浏览器。ReactDOMServer.renderToString 没人没时间，则用 PhantomJS 搞预渲染。 连这个都没时间弄的话，去接入 prerender 等预渲染服务。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/hash碰撞.html": {
    "url": "Basic/hash碰撞.html",
    "title": "hash 碰撞",
    "keywords": "",
    "body": "1. hash 碰撞--equals()与 hashCode()1.1. equals()方法详解1.2. hashcode() 方法详解1.3. Hashset、Hashmap、Hashtable 与 hashcode()和 equals()的密切关系1. hash 碰撞--equals()与 hashCode() 1.1. equals()方法详解 equals()方法是用来判断其他的对象是否和该对象相等. equals()方法在 object 类中定义如下： public boolean equals(Object obj) { return (this == obj); } 很明显是对两个对象的地址值进行的比较（即比较引用是否相同）。但是我们知道，String 、Math、Integer、Double 等这些封装类在使用 equals()方法时，已经覆盖了 object 类的 equals() 方法。 比如在 String 类中如下： public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = count; if (n == anotherString.count) { char v1[] = value; char v2[] = anotherString.value; int i = offset; int j = anotherString.offset; while (n– != 0) { if (v1[i++] != v2[j++]) return false; } return true; } } return false; } 很明显，这是进行的内容比较，而已经不再是地址的比较。依次类推 Math、Integer、Double 等这些类都是重写了 equals()方法的，从而进行的是内容的比较。当然，基本类型是进行值的比较。 它的性质有： 自反性（reflexive）。对于任意不为null的引用值 x，x.equals(x)一定是true。 对称性（symmetric）。对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。 传递性（transitive）。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。 一致性（consistent）。对于任意不为null的引用值x和y，如果用于 equals 比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。 对于任意不为null的引用值x，x.equals(null)返回false。 对于Object类来说，equals()方法在对象上实现的是差别可能性最大的等价关系，即，对于任意非null的引用值x和y，当且仅当x和y引用的是同一个对象，该方法才会返回true。 需要注意的是当 equals() 方法被 override 时，hashCode() 也要被 override。按照一般 hashCode() 方法的实现来说，相等的对象，它们的 hash code 一定相等。 1.2. hashcode() 方法详解 hashCode() 方法给对象返回一个 hash code 值。这个方法被用于 hash tables，例如 HashMap。 它的性质是： 在一个 Java 应用的执行期间，如果一个对象提供给 equals 做比较的信息没有被修改的话，该对象多次调用 hashCode() 方法，该方法必须始终如一返回同一个 integer。 如果两个对象根据 equals(Object) 方法是相等的，那么调用二者各自的 hashCode() 方法必须产生同一个 integer 结果。 并不要求根据 equals(java.lang.Object) 方法不相等的两个对象，调用二者各自的 hashCode() 方法必须产生不同的 integer 结果。然而，程序员应该意识到对于不同的对象产生不同的 integer 结果，有可能会提高 hash table 的性能。 大量的实践表明，由 Object 类定义的 hashCode() 方法对于不同的对象返回不同的 integer。 在 object 类中，hashCode 定义如下： public native int hashCode(); 说明是一个本地方法，它的实现是根据本地机器相关的。当然我们可以在自己写的类中覆盖 hashcode() 方法，比String、Integer、Double 等这些类都是覆盖了 hashcode() 方法的。例如在 String 类中定义的 hashcode() 方法如下 public int hashCode() { int h = hash; if (h == 0) { int off = offset; char val[] = value; int len = count; for (int i = 0; i 解释一下这个程序（String 的 API 中写到）：s[0]31^(n-1) + s[1]31^(n-2) + … + s[n-1] ​ 使用 int 算法，这里 s[i] 是字符串的第 i 个字符，n 是字符串的长度，^ 表示求幂（空字符串的哈希码为 0）。 ​ 想要弄明白 hashCode 的作用，必须要先知道 Java 中的集合。　　 ​ 总的来说，Java 中的集合（Collection）有两类，一类是 List，再有一类是 Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。这里就引出一个问题：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ ​ 这就是 Object.equals 方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有 1000 个元素，那么第 1001 个元素加入集合时，它就要调用 1000 次 equals 方法。这显然会大大降低效率。 ​ 于是，Java 采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上，初学者可以简单理解，hashCode 方法实际上返回的就是对象存储的物理地址（实际可能并不是）。 ​ 这样一来，当集合要添加新的元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的 equals 方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用 equals 方法的次数就大大降低了，几乎只需要一两次。 简而言之，在集合查找时，hashcode 能大大降低对象比较次数，提高查找效率 Java 对象的 eqauls 方法和 hashCode 方法是这样规定的： 1、相等（相同）的对象必须具有相等的哈希码（或者散列码）。 2、如果两个对象的 hashCode 相同，它们并不一定相同。 关于第一点，相等（相同）的对象必须具有相等的哈希码（或者散列码），为什么？ 想象一下，假如两个 Java 对象 A 和 B，A 和 B 相等（eqauls 结果为 true），但 A 和 B 的哈希码不同，则 A 和 B 存入 HashMap 时的哈希码计算得到的 HashMap 内部数组位置索引可能不同，那么 A 和 B 很有可能允许同时存入 HashMap，显然相等/相同的元素是不允许同时存入 HashMap，HashMap 不允许存放重复元素。 关于第二点，两个对象的 hashCode 相同，它们并不一定相同 也就是说，不同对象的 hashCode 可能相同；假如两个 Java 对象 A 和 B，A 和 B 不相等（eqauls 结果为 false），但 A 和 B 的哈希码相等，将 A 和 B 都存入 HashMap 时会发生哈希冲突，也就是 A 和 B 存放在 HashMap 内部数组的位置索引相同这时 HashMap 会在该位置建立一个链接表，将 A 和 B 串起来放在该位置，显然，该情况不违反 HashMap 的使用原则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法以避免哈希冲突。 所以，Java 对于 eqauls 方法和 hashCode 方法是这样规定的： 1.如果两个对象相同，那么它们的 hashCode 值一定要相同； 2.如果两个对象的 hashCode 相同，它们并不一定相同（这里说的对象相同指的是用 eqauls 方法比较）， 如不按要求去做了，会发现相同的对象可以出现在 Set 集合中，同时，增加新元素的效率会大大下降。 3.equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的 hashcode()不相等。 换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashcode()不等，一定能推出 equals()也不等；hashcode()相等，equals()可能相等，也可能不等。 在 object 类中，hashcode()方法是本地方法，返回的是对象的地址值，而 object 类中的 equals()方法比较的也是两个对象的地址值，如果 equals()相等，说明两个对象地址值也相等，当然 hashcode()也就相等了；在 String 类中，equals()返回的是两个对象内容的比较，当两个对象内容相等时，Hashcode()方法根据 String 类的重写代码的分析，也可知道 hashcode()返回结果也会相等。以此类推，可以知道 Integer、Double 等封装类中经过重写的 equals()和 hashcode()方法也同样适合于这个原则。当然没有经过重写的类，在继承了 object 类的 equals()和 hashcode()方法后，也会遵守这个原则。 1.3. Hashset、Hashmap、Hashtable 与 hashcode()和 equals()的密切关系 Hashset 是继承 Set 接口，Set 接口又实现 Collection 接口，这是层次关系。那么 Hashset、Hashmap、Hashtable 中的存储操作是根据什么原理来存取对象的呢？ ​ 下面以 HashSet 为例进行分析，我们都知道：在 hashset 中不允许出现重复对象，元素的位置也是不确定的。在 hashset 中又是怎样判定元素是否重复的呢？在 java 的集合中，判断两个对象是否相等的规则是： ​ 1.判断两个对象的 hashCode 是否相等 ​ 如果不相等，认为两个对象也不相等，完毕 ​ 如果相等，转入 2 ​ （这一点只是为了提高存储效率而要求的，其实理论上没有也可以，但如果没有，实际使用时效率会大大降低，所以我们这里将其做为必需的。） ​ 2.判断两个对象用 equals 运算是否相等 ​ 如果不相等，认为两个对象也不相等 ​ 如果相等，认为两个对象相等（equals()是判断两个对象是否相等的关键） ​ 为什么是两条准则，难道用第一条不行吗？不行，因为前面已经说了，hashcode()相等时，equals()方法也可能不等，所以必须用第 2 条准则进行限制，才能保证加入的为非重复元素。 例 1： package com.bijian.study; import java.util.HashSet; import java.util.Iterator; import java.util.Set; public class HashSetTest { public static void main(String args[]) { String s1 = new String(\"aaa\"); String s2 = new String(\"aaa\"); System.out.println(s1 == s2); System.out.println(s1.equals(s2)); System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); Set hashset = new HashSet(); hashset.add(s1); hashset.add(s2); Iterator it = hashset.iterator(); while (it.hasNext()) { System.out.println(it.next()); } } } 运行结果： false true 96321 96321 aaa 这是因为 String 类已经重写了 equals()方法和 hashcode()方法，所以 hashset 认为它们是相等的对象，进行了重复添加。 例 2 package com.bijian.study; import java.util.HashSet; import java.util.Iterator; public class HashSetTest { public static void main(String[] args) { HashSet hs = new HashSet(); hs.add(new Student(1, \"zhangsan\")); hs.add(new Student(2, \"lisi\")); hs.add(new Student(3, \"wangwu\")); hs.add(new Student(1, \"zhangsan\")); Iterator it = hs.iterator(); while (it.hasNext()) { System.out.println(it.next()); } } } class Student { int num; String name; Student(int num, String name) { this.num = num; this.name = name; } public String toString() { return num + \":\" + name; } } 运行结果： 1:zhangsan 3:wangwu 2:lisi 1:zhangsan 为什么 hashset 添加了相等的元素呢，这是不是和 hashset 的原则违背了呢？回答是：没有。因为在根据 hashcode()对两次建立的 new Student(1,“zhangsan”)对象进行比较时，生成的是不同的哈希码值，所以 hashset 把他当作不同的对象对待了，当然此时的 equals()方法返回的值也不等。 ​ 为什么会生成不同的哈希码值呢？上面我们在比较 s1 和 s2 的时候不是生成了同样的哈希码吗？原因就在于我们自己写的 Student 类并没有重新自己的 hashcode()和 equals()方法，所以在比较时，是继承的 object 类中的 hashcode()方法，而 object 类中的 hashcode()方法是一个本地方法，比较的是对象的地址（引用地址），使用 new 方法创建对象，两次生成的当然是不同的对象了，造成的结果就是两个对象的 hashcode()返回的值不一样，所以 Hashset 会把它们当作不同的对象对待。 ​ 怎么解决这个问题呢？答案是：在 Student 类中重新 hashcode() 和 equals() 方法。 class Student { int num; String name; Student(int num, String name) { this.num = num; this.name = name; } public int hashCode() { return num * name.hashCode(); } public boolean equals(Object o) { Student s = (Student) o; return num == s.num && name.equals(s.name); } public String toString() { return num + \":\" + name; } } 运行结果： 1:zhangsan 3:wangwu 2:lisi 可以看到重复元素的问题已经消除，根据重写的方法，即便两次调用了 new Student(1,\"zhangsan\")，我们在获得对象的哈希码时，根据重写的方法 hashcode()，获得的哈希码肯定是一样的，当然根据 equals()方法我们也可判断是相同的，所以在向 hashset 集合中添加时把它们当作重复元素看待了。 重写 equals()和 hashcode()小结： 重点是 equals，重写 hashCode 只是技术要求（为了提高效率） 为什么要重写 equals 呢？因为在 java 的集合框架中，是通过 equals 来判断两个对象是否相等的 在 hibernate 中，经常使用 set 集合来保存相关对象，而 set 集合是不允许重复的。在向 HashSet 集合中添加元素时，其实只要重写 equals()这一条也可以。但当 hashset 中元素比较多时，或者是重写的 equals()方法比较复杂时，我们只用 equals()方法进行比较判断，效率也会非常低，所以引入了 hashCode()这个方法，只是为了提高效率，且这是非常有必要的。比如可以这样写： public int hashCode(){ return 1; //等价于hashcode无效 } 这样做的效果就是在比较哈希码的时候不能进行判断，因为每个对象返回的哈希码都是 1，每次都必须要经过比较 equals()方法后才能进行判断是否重复，这当然会引起效率的大大降低。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/IaaS-PaaS-SaaS的区别.html": {
    "url": "Basic/IaaS-PaaS-SaaS的区别.html",
    "title": "IaaS-PaaS-SaaS 的区别",
    "keywords": "",
    "body": "1. IaaS，PaaS，SaaS 的区别1. IaaS，PaaS，SaaS 的区别 作者： 阮一峰 日期： 2017 年 7 月 23 日 越来越多的软件，开始采用云服务。 云服务只是一个统称，可以分成三大类。 IaaS：基础设施服务，Infrastructure-as-a-service PaaS：平台服务，Platform-as-a-service SaaS：软件服务，Software-as-a-service 它们有什么区别呢？ IBM 的软件架构师 Albert Barron 曾经使用披萨作为比喻，解释这个问题。David Ng 进一步引申，让它变得更准确易懂。 请设想你是一个餐饮业者，打算做披萨生意。 你可以从头到尾，自己生产披萨，但是这样比较麻烦，需要准备的东西多，因此你决定外包一部分工作，采用他人的服务。你有三个方案。 （1）方案一：IaaS 他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。 （2）方案二：PaaS 除了基础设施，他人还提供披萨饼皮。 你只要把自己的配料洒在饼皮上，让他帮你烤出来就行了。也就是说，你要做的就是设计披萨的味道（海鲜披萨或者鸡肉披萨），他人提供平台服务，让你把自己的设计实现。 （3）方案三：SaaS 他人直接做好了披萨，不用你的介入，到手的就是一个成品。你要做的就是把它卖出去，最多再包装一下，印上你自己的 Logo。 上面的三种方案，可以总结成下面这张图。 从左到右，自己承担的工作量（上图蓝色部分）越来越少，IaaS > PaaS > SaaS。 对应软件开发，则是下面这张图。 SaaS 是软件的开发、管理、部署都交给第三方，不需要关心技术问题，可以拿来即用。 普通用户接触到的互联网服务，几乎都是 SaaS，下面是一些例子。 客户管理服务 Salesforce 团队协同服务 Google Apps 储存服务 Box 储存服务 Dropbox 社交服务 Facebook / Twitter / Instagram PaaS 提供软件部署平台（runtime），抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层。 下面这些都属于 PaaS。 Heroku Google App Engine OpenShift IaaS 是云服务的最底层，主要提供一些基础资源。 它与 PaaS 的区别是，用户需要自己控制底层，实现基础设施的使用逻辑。下面这些都属于 IaaS。 Amazon EC2 Digital Ocean RackSpace Cloud Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/nodejs_interview.html": {
    "url": "Basic/nodejs_interview.html",
    "title": "nodejs_interview",
    "keywords": "",
    "body": "1. nodejs interview1.1.1. What is an error-first callback?1.1.2. How can you avoid callback hells?1.1.3. Why Modular programming1.1.4. How can you listen on port 80 with Node?1.1.5. What's the event loop?1.1.6. What tools can be used to assure consistent style?1.1.7. What's the difference between operational and programmer errors?1.1.8. Why npm shrinkwrap is useful?1.1.9. What's a stub? Name a use case.1.1.10. What's a test pyramid? How can you implement it when talking about HTTP APIs?1.1.11. What are Promises?1.1.12. When are background/worker processes useful? How can you handle worker tasks?1.1.13. When to use yarn and npm?1.1.14. How can you secure your HTTP cookies against XSS attacks?1.1.15. How can you make sure your dependencies are safe?1.1.16. What's wrong with the code snippet?1.1.17. What's wrong with the following code snippet?1.1.18. What's the output of following code snippet?1. nodejs interview What is an error-first callback? How can you avoid callback hells? How can you listen on port 80 with Node? What's the event loop? What tools can be used to assure consistent style? What's the difference between operational and programmer errors? Why npm shrinkwrap is useful? What's a stub? Name a use case. What's a test pyramid? How can you implement it when talking about HTTP APIs? What's your favourite HTTP framework and why? What are Promises? When should you npm and when yarn? How can you secure your HTTP cookies against XSS attacks? How can you make sure your dependencies are safe? 1.1.1. What is an error-first callback? Error-first callbacks are used to pass errors and data. The first argument is always an error object that the programmer has to check if something went wrong. Additional arguments are used to pass data. fs.readFile(filePath, function(err, data) { if (err) { //handle the error } // use the data object }); 1.1.2. How can you avoid callback hells? modularization: break callbacks into independent functions use Promises use yield with Generators use a control flow library, like async use async/await (note that it is only available in the latest v7 release and not in the LTS version - you can read our experimental async/await how-to here) 1.1.3. Why Modular programming Avoid naming conflict in global Separation of dependency concerns File concatenation for production //AMD define([module_id][dependencies], function() { 'use strict'; //Put the module definition here }); define(['./UserModel', 'jquery'], function(User, $) { 'use strict'; var service = {}; service.fetchUsers = function() { return $.ajax({ url: '/users', method: 'method', dataType: 'json', converters: { 'text json': function(raw) { var data = JSON.parse(raw); var users = data.map(function(d) { var user = new User(); user.set('name', d.name); user.set('age', d.age); return user; }); return users; }, }, }); }; return service; }); //commonjs var $ = require('jquery'); var service = {}; service.fetchUsers = function() { return $.ajax({ url: '/mock/users.json', method: 'GET', dataType: 'json', converters: { 'text json': function(raw) { var data = JSON.parse(raw); var users = data.map(function(d) { var user = new User(); user.set('name', d.name); user.set('age', d.age); return user; }); return users; }, }, }); }; module.exports = service; //ES2015 import $ from 'jquery'; import User from './UserModel'; var service = {}; service.fetchUsers = function() { return $.ajax({ url: '/mock/users.json', method: 'GET', dataType: 'json', converters: { 'text json': function(raw) { var data = JSON.parse(raw); var users = data.map(function(d) { var user = new User(); user.set('name', d.name); user.set('age', d.age); return user; }); return users; }, }, }); }; export default service; 1.1.4. How can you listen on port 80 with Node? Trick question! You should not try to listen with Node on port 80 (in Unix-like systems) - to do so you would need superuser rights, but it is not a good idea to run your application with it. Still, if you want to have your Node.js application listen on port 80, here is what you can do. Run the application on any port above 1024, then put a reverse proxy like nginx in front of it. 1.1.5. What's the event loop? Node.js runs using a single thread. when you call sync functions, they will be pushed into call stack, and execute on javascript runtime. When calling async functions like setTimeout, it won't be execute on call stack immediately, browser webapi will execute it, and when it finishes, the result will be pushed to task queue. Event loop will check the status of call stack and task queue. When all sync functions on call stack are done, Event loop will send results on task queue to call stack and show results. Every I/O requires a callback - once they are done they are pushed onto the event loop for execution. Under the hood Node.js uses many threads through libuv. 1.1.6. What tools can be used to assure consistent style? ESLint, Standard, JSLint These tools are really helpful when developing code in teams, to enforce a given style guide and to catch common errors using static analysis. 1.1.7. What's the difference between operational and programmer errors? Operation errors are not bugs, but problems with the system, like request timeout or hardware failure. On the other hand programmer errors are actual bugs. 1.1.8. Why npm shrinkwrap is useful? This command locks down the versions of a package's dependencies so that you can control exactly which versions of each dependency will be used when your package is installed. npmjs.com It is useful when you are deploying your Node.js applications - with it you can be sure which versions of your dependencies are going to be deployed. 1.1.9. What's a stub? Name a use case. Stubs are functions/programs that simulate the behaviours of components/modules. Stubs provide canned answers to function calls made during test cases. Also, you can assert on with what these stubs were called. A use-case can be a file read, when you do not want to read an actual file: var fs = require('fs'); var readFileStub = sinon.stub(fs, 'readFile', function(path, cb) { return cb(null, 'filecontent'); }); expect(readFileStub).to.be.called; readFileStub.restore(); 1.1.10. What's a test pyramid? How can you implement it when talking about HTTP APIs? A test pyramid describes that when writings test cases there should be a lot more low-level unit tests than high level end-to-end tests. When talking about HTTP APIs, it may come down to this: lots of low-level unit tests for models *(dependencies are stubbed)*, fewer integration tests, where you check how your models interact with each other *(dependencies are not stubbed)*, less end-to-end tests, where you call your actual endpoints *(dependencies are not stubbed)*. 1.1.11. What are Promises? Promises are a concurrency primitive. Promises can help you better handle async operations instead of callback functions. Also, note the catch, which can be used for error handling. Promises are chainable. new Promise((resolve, reject) => { setTimeout(() => { resolve('result'); }, 100); }) .then(console.log) .catch(console.error); 1.1.12. When are background/worker processes useful? How can you handle worker tasks? Worker processes are extremely useful if you'd like to do data processing in the background, like sending out emails or processing images. Canvas draw pixels. There are lots of options for this like RabbitMQ or Kafka. 1.1.13. When to use yarn and npm? For now I would suggest keep using npm for open source libraries, so if a new update gets pushed, you will get that automatically as well, while for production application deployments yarn seems like a good fit. Ask interviewer How do you use them? 1.1.14. How can you secure your HTTP cookies against XSS attacks? XSS occurs when the attacker injects executable JavaScript code into the HTML response. To mitigate these attacks, you have to set flags on the set-cookie HTTP header: HttpOnly - this attribute is used to help prevent attacks such as cross-site scripting since it does not allow the cookie to be accessed via JavaScript. secure - this attribute tells the browser to only send the cookie if the request is being sent over HTTPS. So it would look something like this: Set-Cookie: sid=; HttpOnly. If you are using Express, with express-cookie session, it is working by default. 1.1.15. How can you make sure your dependencies are safe? When writing Node.js applications, ending up with hundreds or even thousands of dependencies can easily happen. For example, if you depend on Express, you depend on 27 other modules directly, and of course on those dependencies' as well, so manually checking all of them is not an option! The only option is to automate the update / security audit of your dependencies. For that there are free and paid options: npm outdated Trace by RisingStack NSP GreenKeeper Snyk 1.1.16. What's wrong with the code snippet? new Promise((resolve, reject) => { throw new Error('error'); }).then(console.log); As there is no catch after the then. This way the error will be a silent one, there will be no indication of an error thrown. To fix it, you can do the following: new Promise((resolve, reject) => { throw new Error('error') }).then(console.log).catch(console.error) If you have to debug a huge codebase, and you don't know which Promise can potentially hide an issue, you can use the unhandledRejection hook. It will print out all unhandled Promise rejections. process.on('unhandledRejection', (err) => { console.log(err); }); 1.1.17. What's wrong with the following code snippet? function checkApiKey(apiKeyFromDb, apiKeyReceived) { if (apiKeyFromDb === apiKeyReceived) { return true; } return false; } When you compare security credentials it is crucial that you don't leak any information, so you have to make sure that you compare them in fixed time. If you fail to do so, your application will be vulnerable to timing attacks. But why does it work like that? V8, the JavaScript engine used by Node.js, tries to optimize the code you run from a performance point of view. It starts comparing the strings character by character, and once a mismatch is found, it stops the comparison operation. So the longer the attacker has from the password, the more time it takes. To solve this issue, you can use the npm module called cryptiles. function checkApiKey(apiKeyFromDb, apiKeyReceived) { return cryptiles.fixedTimeComparison(apiKeyFromDb, apiKeyReceived); } 1.1.18. What's the output of following code snippet? Promise.resolve(1) .then((x) => x + 1) .then((x) => { throw new Error('My Error'); }) .catch(() => 1) .then((x) => x + 1) .then((x) => console.log(x)) //2 .catch(console.error); A new Promise is created, that will resolve to 1. The resolved value is incremented with 1 (so it is 2 now), and returned instantly. The resolved value is discarded, and an error is thrown. The error is discarded, and a new value (1) is returned. The execution did not stop after the catch, but before the exception was handled, it continued, and a new, incremented value (2) is returned. The value 2 is printed to the standard output. This line won't run, as there was no exception. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/oop.html": {
    "url": "Basic/oop.html",
    "title": "oop",
    "keywords": "",
    "body": "1. OOP1.1. Give me an example you used OOP1.2. SOLID principles1. OOP 1.1. Give me an example you used OOP 封装、继承、多态 OOP: abstraction, Encapsulation, inheritance, polymorphism. In a .net core project, I used repository pattern. So there is an abstract BaseRepository, which includes Add, Remove, Update methods, etc. Any repository that inherits from this baseRepo will have these common methods. And we can also add some new properties or methods for a specific class. Javascript: OOP list, indicator 1.2. SOLID principles Single responsibility Open close: open for extension, but closed for modification Liskov substitution: Can use baseType accepts childType without altering the correctness of that program. (Shape s = new Rectangle();) Interface segregation: many small interfaces rather than a big one, only implement interfaces needed DI: decouple. High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/performance.html": {
    "url": "Basic/performance.html",
    "title": "performance",
    "keywords": "",
    "body": "1. Performance 前端性能测试1. Performance 前端性能测试 Speed: https://tools.pingdom.com Mobile-Friendly: https://search.google.com/test/mobile-friendly Markup validation: http://validator.w3.org/ Css validation: https://jigsaw.w3.org/css-validator/ Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/shift_operator.html": {
    "url": "Basic/shift_operator.html",
    "title": "shift_operator",
    "keywords": "",
    "body": "1. shift operator 位运算1.1. 左移 (1.2. 右移 (>>)1. shift operator 位运算 1.1. 左移 ( 将第一个操作数向左移动第二个操作数指定的位数，空出的位置补 0。左移相当于乘。左移一位相当于乘 2。左移两位相当于乘 4。左移三位相当于乘 8。 x 1.2. 右移 (>>) 将第一个操作数向右移动第二个操作数所指定的位数，空出的位置补 0。右移相当于整除。右移一位相当于除以 2。右移两位相当于除以 4。右移三位相当于除以 8。 x >> 1 === x / 2; x >> 2 === x / 4; x >> 3 === x / 8; x >> 4 === x / 16; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/sql.html": {
    "url": "Basic/sql.html",
    "title": "sql",
    "keywords": "",
    "body": "1. Sql 面试题1.1.1. sql performance1.1.2. Debugging in SQL1. Sql 面试题 1.1.1. sql performance Avoid Multiple Joins in a Single Query Eliminate Cursors from the Query Try to remove cursors from the query and use set-based query; set-based query is more efficient than cursor-based. If there is a need to use cursor than avoid dynamic cursors as it tends to limit the choice of plans available to the query optimizer. For example, dynamic cursor limits the optimizer to using nested loop joins. Use of Indexes Use join instead of subQuery if possible avoid select * avoid count * asterisk normalization denormalization for performance in large app database sharding, partition. Master read/write 1.1.2. Debugging in SQL Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/to learn.html": {
    "url": "Basic/to learn.html",
    "title": "to learn",
    "keywords": "",
    "body": "前端面试 http://www.thatjsdude.com/interview http://www.cnblogs.com/LO-ME/p/3606675.html 移动端混合式 原生 前端动画： DOM 动画，位置变化 svg path 动画 http://www.cnblogs.com/coco1s/p/6225973.html http://isux.tencent.com/svg-animate.html css3 动画 微信开发、小程序 vue 源码 阿里经常问 https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch1.md https://github.com/wwwebman/front-end-interview-questions https://segmentfault.com/a/1190000010880049 http://www.jianshu.com/p/99d9eda110f6 javascript 设计模式与开发实践 曾探著 webgl: https://developer.mozilla.org/zh-CN/docs/learn/WebGL http://www.jianshu.com/p/e3d8a244f3d9 rxjs: http://reactivex.io/rxjs/ https://yq.aliyun.com/articles/65027 https://segmentfault.com/a/1190000008464065 https://github.com/qiu-deqing/google http://www.cnblogs.com/weiqu/p/5860945.html vue react 源码解析 https://segmentfault.com/a/1190000006599500 https://github.com/berwin/Blog/issues/11 http://transcoder.tradaquan.com/from=1012852s/bd_page_type=1/ssid=672ebbab/uid=0/pu=sz%40320_1004%2Cta%40iphone_2_6.0_11_9.0%2Cusm%401/baiduid=87EA91E1A4122F054A2B3E0D40131DEF/w=0_10_/t=iphone/l=3/tc?ref=www_iphone&lid=12732224663698296230&order=5&fm=alhm&h5ad=1&srd=1&dict=32&tj=h5_mobile_5_0_10_title&w_qd=IlPT2AEptyoA_yk5wuwcqxGuClNVj7wpzSQYaxPVzAYtLOe&sec=23364&di=0b8c5341cc7f01c5&bdenc=1&tch=124.339.255.1228.0.0&nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IEQGG_ytK1DK6mlrte4viZQRAXjbxKXXLUoCb9n00sqcHuH7c_GUo6so4g43&eqid=b0b1f2df9834500010000000599982ae&wd=&clk_info=%7B%22srcid%22%3A%221599%22%2C%22tplname%22%3A%22h5_mobile%22%2C%22t%22%3A1503232754687%2C%22sig%22%3A%2286768%22%2C%22xpath%22%3A%22div-a-h3%22%7D https://github.com/cucygh/es6-vue-react-gulp https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651552583&idx=2&sn=00c75778efaf4709d0752bffadeb5285&chksm=8025ac86b75225903e0bcf69a5ecc41d4728183d1b9c567b176115a1ad557500827e68ea267b&mpshare=1&scene=23&srcid=09081I5DeMDZExOU7qxtqRI4#rd Build the layout and interactions of common web applications, such as the Netflix browser site. Implement widgets like a date picker, carousel or e-commerce cart. Write a function similar to debounce or clone an object deeply. Execution context, especially lexical scope and closures. Hoisting, function & block scoping and function expressions & declarations. Binding – specifically call, bind, apply and lexical this. Object prototypes, constructors and mixins. Composition and high order functions. Event delegation and bubbling. Type Coercion using typeof, instanceof and Object.prototype.toString. Handling asynchronous calls with callbacks, promises, await and async. When to use function declarations and expressions. DOM How to traverse and manipulate the DOM is important, and this is where most candidates struggle if they have been depending on jQuery or have been writing a lot of React & Angular type apps recently. You might not do this on a daily basis since most of us are using an abstraction of sorts, but without using a library you should know how to do the following: Selecting or finding nodes using document.querySelector and in older browsers document.getElementsByTagName. Traversal up and down – Node.parentNode, Node.firstChild, Node.lastChild and Node.childNodes. Traversal left and right – Node.previousSibling and Node.nextSibling. Manipulation – add, remove, copy, and create nodes in the DOM tree. You should know operations such as how to change the text content of a node and toggle, remove or add a CSS classname. Performance – touching the DOM can be expensive when you have many nodes, you should at least know about document fragments and node caching. 1、手写 jsonp 的实现 2、手写链表倒数第 K 个查找 3、http 请求头，请求体，cookie 在哪个里面？url 在哪里面？ 4、原型链的解释 5、对闭包的理解，实现一个暴露内部变量，而且外部可以访问修改的函数 6、基本的数据类型 7、基本的两列自适应布局 8、unix 中常用的命令行 9、OSI 模型，HTTP,TCP,UDP 分别在哪些层 10、解释平衡二叉树，以及在数据结构中的应用（红黑树） 11、快排的时间复杂度和空间复杂度 12、手写一个 jQuery 插件 13、在 jquery 方法和原型上面添加方法的区别和实现，以及 jquery 对象的实现 14、手写一个递归函数 15、对前端路由的理解？前后端路由的区别？ 16、介绍一下 webpack 和 gulp，以及项目中具体的使用 17、你对 es6 的了解 18、解释一下 vue 和 react，以及异同点 19、关于平衡二叉树 20、前后端分离的意义以及对前端工程化的理解 21、使用 css 实现一个三角形 22、用 promise 手写 ajax 23、手写一个类的继承，并解释一下 24、解释一下 call 函数和 apply 函数的作用，以及用法 25、你说自己抗压能力强，具体表现在哪里？ 26、对前端前景的展望，以后前端会怎么发展 27、手写第一次面试没有写出来的链表问题，要求用 es6 写 28、平时是怎么学技术的？ 29、平时大学里面时间是怎么规划的？ 30、接下来有什么计划？这个学期和下个学期的计划是？ 31、项目中遇到的难点，或者你学习路上的难点 32、你是通过什么方法和途径来学习前端的 33、手写一个简单遍历算法 34、解释一下 react 和 vue，以及区别 35、你在团队中更倾向于什么角色？ 36、对 java 的理解 37、介绍 node.js，并且介绍你用它做的项目 38、手写一个 js 的深克隆 39、for 函数里面 setTimeout 异步问题 40、手写归并排序 41、介绍自己的项目 42、实现两个数组的排序合并 43、手写一个原生 ajax 44、手写一个 promise 版的 ajax 45、手写实现一个 promise 46、手写实现 requireJS 模块实现 47、手写实现 jquery 里面的 insertAfter 48、react 和 vue 的介绍以及异同 49、AMD 和 CMD，commonJS 的区别 50、介绍一下 backbone 51、了解过 SEO 吗？ 52、低版本浏览器不支持 HTML5 标签怎么解决？ 53、用 js 使低版本浏览器支持 HTML5 标签 底层是怎么实现的？ 54、实现一个布局：左边固定宽度为 200，右边自适应，而且滚动条要自动选择只出现最高的那个 55、画出盒子模型，要使谷歌浏览器的盒子模型显示得跟 IE 浏览器一致（让谷歌跟 ie 一致，不是 ie 跟谷歌一致），该怎么做？ 56、手写 JS 实现类继承，讲原型链原理，并解释 new 一个对象的过程都发生了什么 57、Array 对象自带的方法，一一列举 58、若干个数字，怎么选出最大的五个 59、Array 对象自带的排序函数底层是怎么实现的？ 60、常用的排序算法有哪些，介绍一下选择排序 61、了解 navigator 对象吗？ 62、手写一个正则表达式，验证邮箱 63、link 和@import 引入 CSS 的区别？ 64、刚才说有些浏览器不兼容@import，具体指哪些浏览器？ 65、介绍一下 cookie,localstorage,sessionstorage,session 66、jquery 绑定 click 的方法有几种 67、你的优点/竞争力 68、移动端适配问题 69、react 的难点在哪里 70、做过 css 动画吗 71、如何优化网站 72、以后的规划 73、你做过最困难的事情是啥？ 74、css3 html5 新特性 75、闭包，ES6，跨域 76、问做过啥项目，用到什么技术，遇到什么困难 77、兼容性 78、盒子模型 79、Array 的 unshift() method 的作用是什么？如何连接两个 Array？如何在 Array 里移除一个元素？ 80、用纸笔写一个 Closure，任意形式和内容 81、知不知道 Array-like Object？ 82、如何用 Native JavaScript 来读写 Cookie？ 83、知不知道 CSS Box-model？ 84、如何做一个 AJAX Request？ 85、Cross-domain access 有没有了解？ 86、前端安全方面有没有了解？XSS 和 CSRF 如何攻防？ 87、HTTP Response 的 Header 里面都有些啥？ 88、知不知道 HTTP2？ 89、输入 URL 后发生了什么？ 90、new operator 实际上做了什么？ 91、面向对象的属性有哪些？ 92、做一个两栏布局，左边 fixed width，右边 responsive，用纸笔手写 93、讲一下 AJAX Request 94、讲一下 Cross-domain access 95、介绍一下做过的项目 96、问到了多个服务器怎么弄，架构之类的 97、angular 的渲染流程 98、脏检查 99、nodejs 的架构、优缺点、回调 100、css 盒模型 101、css 布局，左边定宽右边自适应 102、冒泡和捕获，事件流哪三个阶段？ 103、实现事件代理 104、原型链 105、继承的两种方法 106、ajax，原生 ajax 的四个过程 107、闭包，简单说一个闭包的应用，然后闭包的主要作用是什么 108、css:两个块状元素上下的 margin-top 和 margin-bottom 会重叠。啥原因？怎么解决？ 109、js：写一个递归。就是每隔 5 秒调用一个自身，一共 100 次 110、cookie 和 session 有什么区别 111、网络分层结构 112、你的不足是什么？ 113、做了那么多项目，有没有自己的归纳总结 114、工程怎么进行文件管理 115、less 和 sass 掌握程度 116、Cookie 是否会被覆盖，localStorage 是否会被覆盖 117、事件代理 js 实现 118、Css 实现动画效果 119、Animation 还有哪些其他属性 120、Css 实现三列布局 121、Css 实现保持长宽比 1:1 122、Css 实现两个自适应等宽元素中间空 10 个像素 123、requireJS 的原理是什么 124、如何保持登录状态 125、浮动的原理以及如何清除浮动 126、Html 的语义化 127、原生 js 添加 class 怎么添加，如果本身已经有 class 了，会不会覆盖，怎么保留？ 128、Jsonp 的原理。怎么去读取一个 script 里面的数据？ 129、如果页面初始载入的时候把 ajax 请求返回的数据存在 localStorage 里面，然后每次调用的时候去 localStorage 里面取数，是否可行。 130、304 是什么意思？有没有方法不请求不经过服务器直接使用缓存 131、http 请求头有哪些字段 132、数组去除一个函数。用 arr.splice。又问 splice 返回了什么？应该返回的是去除的元素。 133、js 异步的方法（promise，generator，async） 134、Cookie 跨域请求能不能带上 135、最近看什么开源项目？ 136、commonJS 和 AMD 137、平时是怎么学习的？ 138、为什么要用 translate3d？ 139、对象中 key-value 的 value 怎么再放一个对象？ 140、Get 和 post 的区别？ 145、Post 一个 file 的时候 file 放在哪的？ 146、说说你对组件的理解 147、组件的 html 怎么进行管理 148、js 的异步加载，promise 的三种状态，ES7 中的 async 用过么 149、静态属性怎么继承 150、js 原型链的继承 151、jquery 和 zepto 有什么区别 152、angular 的双向绑定原理 153、angular 和 react 的认识 154、MVVM 是什么 155、移动端是指手机浏览器，还是 native，还是 hybrid 156、你用了移动端的什么库类和框架？ 157、移动端要注意哪些？ 158、适配有去考虑么，retina 屏幕啊？ 159、rem 是什么？em 是什么？如果上一层就是根 root 了，em 和 rem 等价么？ 160、怎么测试的？会自动化测试么？ 161、你觉得你什么技术最擅长？ 162、你平时有没有什么技术的沉淀？ 163、单向链表怎么查找有没有环？ 164、怎么得到一个页面的 a 标签？ 165、怎么在页面里放置一个很简单的图标，不能用 img 和 background-img？ 166、正则表达式判断 url 167、怎么去除字符串前后的空格 168、实现页面的局部刷新 169、绝对定位与相对定位的区别 170、js 轮播实现思路 171、使用 js 画一个抛物线，抛物线上有个小球随着抛物线运动，有两个按钮能使小球继续运动停止运动 172、java 五子棋，说下实现思路 173、如何让各种情况下的 div 居中(绝对定位的 div,垂直居中,水平居中)？ 174、display 有哪些值？说明他们的作用 175、css 定义的权重 176、requirejs 实现原理 177、requirejs 怎么防止重复加载 178、ES6 里头的箭头函数的 this 对象与其他的有啥区别 179、tcp/udp 区别 180、tcp 三次握手过程 181、xss 与 csrf 的原理与怎么防范 182、mysql 与 MongoDB 的区别 183、w3c 事件与 IE 事件的区别 184、有没有上传过些什么 npm 模块 185、IE 与 W3C 怎么阻止事件的冒泡 186、gulp 底层实现原理 187、webpack 底层实现原理 188、gulp 与 webpack 区别 189、vuejs 与 angularjs 的区别 190、vuex 是用来做什么的 191、说下你知道的响应状态码 192、ajax 的过程以及 readyState 几个状态的含义 193、你除了前端之外还会些什么？ 194、cookie 与 session 的区别 195、一些关于 php 与 java 的问题 196、你觉得你哪个项目是你做的最好的 197、说说你在项目中遇到了哪些困难,是怎么解决的 198、前端优化你知道哪些 199、webpack 是用来干嘛的 200、webpack 与 gulp 的区别 201、es6 与 es7 了解多少 202、说下你知道的响应状态码 203、看过哪些框架的源码 204、遇到过哪些浏览器兼容性问题 205、清除浮动有哪几种方式,分别说说 206、你知道有哪些跨域方式,分别说说 207、JavaScript 有哪几种类型的值 208、使用 new 操作符时具体是干了些什么 209、学习前端的方法以及途径 210、怎么实现两个大整数的相乘，说下思路 211、你学过数据结构没,说说你都了解些什么 212、你学过计算机操作系统没,说说你都了解些什么 213、你学过计算机组成原理没,说说你都了解些什么 214、你学过算法没,说说你都了解些什么 215、说下选择排序,冒泡排序的实现思路 216、用过哪些框架 217、让你设计一个前端 css 框架你怎么做 218、了解哪些设计模式说说看 219、说下你所了解的设计模式的优点 220、vue 源码结构 221、状态码 222、浏览器缓存的区别 223、304 与 200 读取缓存的区别 224、http 请求头有哪些,说说看你了解哪些 225、js 中 this 的作用 226、js 中上下文是什么 227、js 有哪些函数能改变上下文 228、你所了解的跨域的方法都说说看你了解的？ 229、要是让你自己写一个 js 框架你会用到哪些设计模式 230、平常在项目中用到过哪些设计模式,说说看 231、一来给了张纸要求写 js 自定义事件 232、前端跨域的方法 233、call 与 apply 的区别 234、h5 有个 api 能定位你知道是哪个吗？ 235、vue 与 angularjs 中双向数据绑定是怎样实现的？ 236、webpack 怎样配置？ 237、nodejs 中的文件怎么读写？ 238、link 和@import 有什么区别？ 239、cookies，sessionStorage 和 localStorage 的区别 240、看过哪些前端的书？平时是怎么学习的 241、说下你所理解的 mvc 与 mvvc 242、position 有哪些值,说下各自的作用 243、写个从几个 li 中取下标的闭包代码 244、你的职业规划是怎么样的？ 245、移动端性能优化 246、lazyload 如何实现 247、点透问题 248、前端安全 249、原生 js 模板引擎 250、repaint 和 reflow 区别 251、requirejs 如何避免循环依赖？ 252、实现布局：左边一张图片，右边一段文字（不是环绕） 253、window.onload 和$(document).ready()的区别，浏览器加载转圈结束时哪个时间点？ 254、form 表单当前页面无刷新提交 target iframe 255、setTimeout 和 setInterval 区别，如何互相实现？ 256、如何避免多重回调—promise，promise 简单描述一下，如何在外部进行 resolve() 257、margin 坍塌？水平方向会不会坍塌？ 258、伪类和伪元素区别 259、vue 如何实现父子组件通信，以及非父子组件通信 260、数组去重 261、使用 flex 布局实现三等分，左右两个元素分别贴到左边和右边，垂直居中 262、平时如何学前端的，看了哪些书，关注了哪些公众号 263、实现 bind 函数 264、数组和链表区别，分别适合什么数据结构 265、对 mvc 的理解 266、描述一个印象最深的项目，在其中担任的角色，解决什么问题 267、http 状态码。。。401 和 403 区别？ 268、描述下二分查找 269、为什么选择前端，如何学习的，看了哪些书，《js 高级程序设计》和《你不知道的 js》有什么区别，看书，看博客，看公众号三者的时间是如何分配的？ 270、如何评价 BAT？ 271、描述下在实习中做过的一个项目，解决了什么问题，在其中担任了什么角色？这个过程存在什么问题，有什么值得改进的地方？ 272、如何看待加班，如果有个项目需要连续一个月加班，你怎么看？ 273、遇到的压力最大的一件事是什么？如何解决的？ 274、平时有什么爱好 275、自身有待改进的地方 276、n 长的数组放入 n+1 个数，不能重复，找出那个缺失的数 277、手里有什么 offer 278、你对于第一份工作最看重的三个方面是什么？ 279、如何评价现在的前端？ 280、用原生 js 实现复选框选择以及全选非全选功能 281、用 4 个颜色给一个六面体上色有多少种情况 282、amd 和 cmd 区别 283、为什么选择前端，移动端性能优化 284、vue 的特点？双向数据绑定是如何实现的 285、Object.defineProperty 286、算法题：数组去重，去除重复两次以上的元素，代码题：嵌套的 ul-li 结构，根据 input 中输入的内容，去除相应的 li 节点，且如果某个嵌套的 ul 下面的 li 都被移除，则该 ul 的父 li 节点也要被移除 287、页面加载过程 288、浏览器如何实现图片缓存 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/webpack原理.html": {
    "url": "Basic/webpack原理.html",
    "title": "webpack 原理",
    "keywords": "",
    "body": "1. 细说 webpack 之流程篇1.1.1. 引言1.1.2. 准备工作1.1.3. shell 与 config 解析1.1.4. 编译与构建流程1.1.5. 打包输出1.1.6. 总结1. 细说 webpack 之流程篇 1.1.1. 引言 目前，几乎所有业务的开发构建都会用到 webpack 。的确，作为模块加载和打包神器，只需配置几个文件，加载各种 loader 就可以享受无痛流程化开发。但对于 webpack 这样一个复杂度较高的插件集合，它的整体流程及思想对我们来说还是很透明的。那么接下来我会带你了解 webpack 这样一个构建黑盒，首先来谈谈它的流程。 1.1.2. 准备工作 1. webstorm 中配置 webpack-webstorm-debugger-script 在开始了解之前，必须要能对 webpack 整个流程进行 debug ，配置过程比较简单。 先将 webpack-webstorm-debugger-script 中的 webstorm-debugger.js 置于 webpack.config.js 的同一目录下，搭建好你的脚手架后就可以直接 Debug 这个 webstorm-debugger.js 文件了。 2. webpack.config.js 配置 估计大家对 webpack.config.js 的配置也尝试过不少次了，这里就大致对这个配置文件进行个分析。 var path = require('path'); var node_modules = path.resolve(__dirname, 'node_modules'); var pathToReact = path.resolve(node_modules, 'react/dist/react.min.js'); module.exports = { // 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。 entry: { bundle: [ 'webpack/hot/dev-server', 'webpack-dev-server/client?http://localhost:8080', path.resolve(__dirname, 'app/app.js'), ], }, // 文件路径指向(可加快打包过程)。 resolve: { alias: { react: pathToReact, }, }, // 生成文件，是模块构建的终点，包括输出文件与输出路径。 output: { path: path.resolve(__dirname, 'build'), filename: '[name].js', }, // 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。 module: { loaders: [ { test: /\\.js$/, loader: 'babel', query: { presets: ['es2015', 'react'], }, }, ], noParse: [pathToReact], }, // webpack 各插件对象，在 webpack 的事件流中执行对应的方法。 plugins: [new webpack.HotModuleReplacementPlugin()], }; 除此之外再大致介绍下 webpack 的一些核心概念： loader：能转换各类资源，并处理成对应模块的加载器。loader 间可以串行使用。 chunk：code splitting 后的产物，也就是按需加载的分块，装载了不同的 module。 对于 module 和 chunk 的关系可以参照 webpack 官方的这张图： plugin：webpack 的插件实体，这里以 UglifyJsPlugin 为例。 function UglifyJsPlugin(options) { this.options = options; } module.exports = UglifyJsPlugin; UglifyJsPlugin.prototype.apply = function(compiler) { compiler.plugin('compilation', function(compilation) { compilation.plugin('build-module', function(module) {}); compilation.plugin('optimize-chunk-assets', function(chunks, callback) { // Uglify 逻辑 }); compilation.plugin('normal-module-loader', function(context) {}); }); }; 在 webpack 中你经常可以看到 compilation.plugin(‘xxx’, callback) ，你可以把它当作是一个事件的绑定，这些事件在打包时由 webpack 来触发。 3. 流程总览 在具体流程学习前，可以先通过这幅 webpack 整体流程图 了解一下大致流程（建议保存下来查看）。 1.1.3. shell 与 config 解析 每次在命令行输入 webpack 后，操作系统都会去调用 ./node_modules/.bin/webpack 这个 shell 脚本。这个脚本会去调用 ./node_modules/webpack/bin/webpack.js 并追加输入的参数，如 -p , -w 。(图中 webpack.js 是 webpack 的启动文件，而 $@ 是后缀参数) 在 webpack.js 这个文件中 webpack 通过 optimist 将用户配置的 webpack.config.js 和 shell 脚本传过来的参数整合成 options 对象传到了下一个流程的控制对象中。 1. optimist 和 commander 一样，optimist 实现了 node 命令行的解析，其 API 调用非常方便。 var optimist = require(\"optimist\"); optimist .boolean(\"json\").alias(\"json\", \"j\").describe(\"json\") .boolean(\"colors\").alias(\"colors\", \"c\").describe(\"colors\") .boolean(\"watch\").alias(\"watch\", \"w\").describe(\"watch\") ... 获取到后缀参数后，optimist 分析参数并以键值对的形式把参数对象保存在 optimist.argv 中，来看看 argv 究竟有什么？ // webpack --hot -w { hot: true, profile: false, watch: true, ... } 2. config 合并与插件加载 在加载插件之前，webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置在 webpack.config.js 的 plugins 。接着 optimist.argv 会被传入到 ./node_modules/webpack/bin/convert-argv.js 中，通过判断 argv 中参数的值决定是否去加载对应插件。(至于 webpack 插件运行机制，在之后的运行机制篇会提到) ifBooleanArg(\"hot\", function() { ensureArray(options, \"plugins\"); var HotModuleReplacementPlugin = require(\"../lib/HotModuleReplacementPlugin\"); options.plugins.push(new HotModuleReplacementPlugin()); }); ... return options; options 作为最后返回结果，包含了之后构建阶段所需的重要信息。 { entry: {},//入口配置 output: {}, //输出配置 plugins: [], //插件集合(配置文件 + shell指令) module: { loaders: [ [Object] ] }, //模块配置 context: //工程路径 ... } 这和 webpack.config.js 的配置非常相似，只是多了一些经 shell 传入的插件对象。插件对象一初始化完毕， options 也就传入到了下个流程中。 var webpack = require('../lib/webpack.js'); var compiler = webpack(options); 1.1.4. 编译与构建流程 在加载配置文件和 shell 后缀参数申明的插件，并传入构建信息 options 对象后，开始整个 webpack 打包最漫长的一步。而这个时候，真正的 webpack 对象才刚被初始化，具体的初始化逻辑在 lib/webpack.js 中，如下： function webpack(options) { var compiler = new Compiler(); ...// 检查options,若watch字段为true,则开启watch线程 return compiler; } ... webpack 的实际入口是 Compiler 中的 run 方法，run 一旦执行后，就开始了编译和构建流程 ，其中有几个比较关键的 webpack 事件节点。 compile 开始编译 make 从入口点分析模块及其依赖的模块，创建这些模块对象 build-module 构建模块 after-compile 完成构建 seal 封装构建结果 emit 把各个 chunk 输出到结果文件 after-emit 完成输出 1. 核心对象 Compilation compiler.run 后首先会触发 compile ，这一步会构建出 Compilation 对象： 这个对象有两个作用，一是负责组织整个打包过程，包含了每个构建环节及输出环节所对应的方法，可以从图中看到比较关键的步骤，如 addEntry() , _addModuleChain() ,buildModule() , seal() , createChunkAssets() (在每一个节点都会触发 webpack 事件去调用各插件)。二是该对象内部存放着所有 module ，chunk，生成的 asset 以及用来生成最后打包文件的 template 的信息。 2. 编译与构建主流程 在创建 module 之前，Compiler 会触发 make，并调用 Compilation.addEntry 方法，通过 options 对象的 entry 字段找到我们的入口 js 文件。之后，在 addEntry 中调用私有方法 _addModuleChain ，这个方法主要做了两件事情。一是根据模块的类型获取对应的模块工厂并创建模块，二是构建模块。 而构建模块作为最耗时的一步，又可细化为三步： 调用各 loader 处理模块之间的依赖 webpack 提供的一个很大的便利就是能将所有资源都整合成模块，不仅仅是 js 文件。所以需要一些 loader ，比如 url-loader ， jsx-loader ， css-loader 等等来让我们可以直接在源文件中引用各类资源。webpack 调用 doBuild() ，对每一个 require() 用对应的 loader 进行加工，最后生成一个 js module。 Compilation.prototype._addModuleChain = function process(context, dependency, onModule, callback) { var start = this.profile && +new Date(); ... // 根据模块的类型获取对应的模块工厂并创建模块 var moduleFactory = this.dependencyFactories.get(dependency.constructor); ... moduleFactory.create(context, dependency, function(err, module) { var result = this.addModule(module); ... this.buildModule(module, function(err) { ... // 构建模块，添加依赖模块 }.bind(this)); }.bind(this)); }; 调用 acorn 解析经 loader 处理后的源文件生成抽象语法树 AST Parser.prototype.parse = function parse(source, initialState) { var ast; if (!ast) { // acorn以es6的语法进行解析 ast = acorn.parse(source, { ranges: true, locations: true, ecmaVersion: 6, sourceType: \"module\" }); } ... }; 遍历 AST，构建该模块所依赖的模块 对于当前模块，或许存在着多个依赖模块。当前模块会开辟一个依赖模块的数组，在遍历 AST 时，将 require() 中的模块通过 addDependency() 添加到数组中。当前模块构建完成后，webpack 调用 processModuleDependencies 开始递归处理依赖的 module，接着就会重复之前的构建步骤。 Compilation.prototype.addModuleDependencies = function(module, dependencies, bail, cacheGroup, recursive, callback) { // 根据依赖数组(dependencies)创建依赖模块对象 var factories = []; for (var i = 0; i 3. 构建细节 module 是 webpack 构建的核心实体，也是所有 module 的 父类，它有几种不同子类：NormalModule , MultiModule , ContextModule , DelegatedModule 等。但这些核心实体都是在构建中都会去调用对应方法，也就是 build() 。来看看其中具体做了什么： // 初始化module信息，如context,id,chunks,dependencies等。 NormalModule.prototype.build = function build(options, compilation, resolver, fs, callback) { this.buildTimestamp = new Date().getTime(); // 构建计时 this.built = true; return this.doBuild( options, compilation, resolver, fs, function(err) { // 指定模块引用，不经acorn解析 if (options.module && options.module.noParse) { if (Array.isArray(options.module.noParse)) { if ( options.module.noParse.some(function(regExp) { return typeof regExp === 'string' ? this.request.indexOf(regExp) === 0 : regExp.test(this.request); }, this) ) { return callback(); } } else if ( typeof options.module.noParse === 'string' ? this.request.indexOf(options.module.noParse) === 0 : options.module.noParse.test(this.request) ) { return callback(); } } // 由acorn解析生成ast try { this.parser.parse(this._source.source(), { current: this, module: this, compilation: compilation, options: options, }); } catch (e) { var source = this._source.source(); this._source = null; return callback(new ModuleParseError(this, source, e)); } return callback(); }.bind(this), ); }; 对于每一个 module ，它都会有这样一个构建方法。当然，它还包括了从构建到输出的一系列的有关 module 生命周期的函数，我们通过 module 父类类图其子类类图(这里以 NormalModule 为例)来观察其真实形态： 可以看到无论是构建流程，处理依赖流程，包括后面的封装流程都是与 module 密切相关的。 1.1.5. 打包输出 在所有模块及其依赖模块 build 完成后，webpack 会监听 seal 事件调用各插件对构建后的结果进行封装，要逐次对每个 module 和 chunk 进行整理，生成编译后的源码，合并，拆分，生成 hash 。 同时这是我们在开发时进行代码优化和功能添加的关键环节。 Compilation.prototype.seal = function seal(callback) { this.applyPlugins(\"seal\"); // 触发插件的seal事件 this.preparedChunks.sort(function(a, b) { if (a.name b.name) { return 1; } return 0; }); this.preparedChunks.forEach(function(preparedChunk) { var module = preparedChunk.module; var chunk = this.addChunk(preparedChunk.name, module); chunk.initial = chunk.entry = true; // 整理每个Module和chunk，每个chunk对应一个输出文件。 chunk.addModule(module); module.addChunk(chunk); }, this); this.applyPluginsAsync(\"optimize-tree\", this.chunks, this.modules, function(err) { if (err) { return callback(err); } ... // 触发插件的事件 this.createChunkAssets(); // 生成最终assets ... // 触发插件的事件 }.bind(this)); }; 1. 生成最终 assets 在封装过程中，webpack 会调用 Compilation 中的 createChunkAssets 方法进行打包后代码的生成。 createChunkAssets 流程如下： 不同的 Template 从上图可以看出通过判断是入口 js 还是需要异步加载的 js 来选择不同的模板对象进行封装，入口 js 会采用 webpack 事件流的 render 事件来触发 Template类 中的 renderChunkModules() (异步加载的 js 会调用 chunkTemplate 中的 render 方法)。 if (chunk.entry) { source = this.mainTemplate.render( this.hash, chunk, this.moduleTemplate, this.dependencyTemplates, ); } else { source = this.chunkTemplate.render(chunk, this.moduleTemplate, this.dependencyTemplates); } 在 webpack 中有四个 Template 的子类，分别是 MainTemplate.js ， ChunkTemplate.js ，ModuleTemplate.js ， HotUpdateChunkTemplate.js ，前两者先前已大致有介绍，而 ModuleTemplate 是对所有模块进行一个代码生成，HotUpdateChunkTemplate 是对热替换模块的一个处理。 模块封装 模块在封装的时候和它在构建时一样，都是调用各模块类中的方法。封装通过调用 module.source() 来进行各操作，比如说 require() 的替换。 MainTemplate.prototype.requireFn = \"__webpack_require__\"; MainTemplate.prototype.render = function(hash, chunk, moduleTemplate, dependencyTemplates) { var buf = []; // 每一个module都有一个moduleId,在最后会替换。 buf.push(\"function \" + this.requireFn + \"(moduleId) {\"); buf.push(this.indent(this.applyPluginsWaterfall(\"require\", \"\", chunk, hash))); buf.push(\"}\"); buf.push(\"\"); ... // 其余封装操作 }; 生成 assets 各模块进行 doBlock 后，把 module 的最终代码循环添加到 source 中。一个 source 对应着一个 asset 对象，该对象保存了单个文件的文件名( name )和最终代码( value )。 2. 输出 最后一步，webpack 调用 Compiler 中的 emitAssets() ，按照 output 中的配置项将文件输出到了对应的 path 中，从而 webpack 整个打包过程结束。要注意的是，若想对结果进行处理，则需要在 emit 触发后对自定义插件进行扩展。 1.1.6. 总结 webpack 的整体流程主要还是依赖于 compilation 和 module 这两个对象，但其思想远不止这么简单。最开始也说过，webpack 本质是个插件集合，并且由 tapable 控制各插件在 webpack 事件流上运行，至于具体的思想和细节，将会在后一篇文章中提到。同时，在业务开发中，无论是为了提升构建效率，或是减小打包文件大小，我们都可以通过编写 webpack 插件来进行流程上的控制，这个也会在之后提到。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/代理.html": {
    "url": "Basic/代理.html",
    "title": "代理",
    "keywords": "",
    "body": "1. 代理1.1. 正向代理1.2. 反向代理1. 代理 1.1. 正向代理 A 同学在大众创业、万众创新的大时代背景下开启他的创业之路，目前他遇到的最大的一个问题就是启动资金，于是他决定去找马云爸爸借钱，可想而知，最后碰一鼻子灰回来了，情急之下，他想到一个办法，找关系开后门，经过一番消息打探，原来 A 同学的大学老师王老师是马云的同学，于是 A 同学找到王老师，托王老师帮忙去马云那借 500 万过来，当然最后事成了。不过马云并不知道这钱是 A 同学借的，马云是借给王老师的，最后由王老师转交给 A 同学。这里的王老师在这个过程中扮演了一个非常关键的角色，就是代理，也可以说是正向代理，王老师代替 A 同学办这件事，这个过程中，真正借钱的人是谁，马云是不知道的，这点非常关键。 我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 http://www.google.com 时，被残忍的 block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求 google.com，代理把请求返回的相应结构再返回给我。 1.2. 反向代理 大家都有过这样的经历，拨打 10086 客服电话，可能一个地区的 10086 客服有几个或者几十个，你永远都不需要关心在电话那头的是哪一个，叫什么，男的，还是女的，漂亮的还是帅气的，你都不关心，你关心的是你的问题能不能得到专业的解答，你只需要拨通了 10086 的总机号码，电话那头总会有人会回答你，只是有时慢有时快而已。那么这里的 10086 总机号码就是我们说的反向代理。客户不知道真正提供服务人的是谁。 反向代理隐藏了真实的服务端，当我们请求 www.baidu.com 的时候，就像拨打 10086 一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx 就是性能非常好的反向代理服务器，用来做负载均衡。 两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，反向代理代理的对象是服务端 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/代码优化.html": {
    "url": "Basic/代码优化.html",
    "title": "代码优化",
    "keywords": "",
    "body": "1. 代码优化，和性能优化不一样1. 代码优化，和性能优化不一样 代码优化的目标是： 减小代码的体积 提高代码运行的效率 尽量重用对象 特别是 String 对象的使用，出现字符串连接时应该使用 StringBuilder。连接池、线程池 尽可能使用局部变量 调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中，速度较快。其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。 尽量减少对变量的重复计算 因为 array 其实是个特殊的 object，需要遍历 object 才知道长度： for (var i = 0, length = list.length; i 尽量采用懒加载的策略，即在需要的时候才创建 String str = \"aaa\"; if (i == 1) { 　　list.add(str); } 建议替换为： if (i == 1) { 　　String str = \"aaa\"; 　　list.add(str); } 乘法和除法使用移位操作 for (val = 0; val 用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为： for (val = 0; val > 1; } 移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。 循环内不要不断创建对象引用 for (int i = 1; i 这种做法会导致内存中有 count 份 Object 对象引用存在，count 很大的话，就耗费内存了，建议为改为： Object obj = null; for (int i = 0; i 尽量在合适的场合使用单例 使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： 控制资源的使用，通过线程同步来控制资源的并发访问 控制实例的产生，以达到节约资源的目的 控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 程序运行过程中避免使用反射 使用数据库连接池和线程池 这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程 使用带缓冲的输入输出流进行 IO 操作 带缓冲的输入输出流，即 BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升 IO 效率 顺序插入和随机访问比较多的场景使用 ArrayList，元素删除和中间插入比较多的场景使用 LinkedList Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/": {
    "url": "Basic/大型网站架构/",
    "title": "Basic/大型网站架构",
    "keywords": "",
    "body": "1. TOC1. TOC 1 大型网站架构演化 2 大型网站架构模式 3 大型网站性能优化 4 大型网站架构要素 5 高可用架构 6 可扩展架构 database_scale Web 系统大规模并发——电商秒杀与抢购 亿级 Web 系统搭建——单机到分布式集群 压力性能测试 回答高并发和大型网站设计 多线程 1 多线程 2 大型网站分布式设计 大型网站架构 读写锁分离-封装 ReaderWriterLockSlim 负载均衡方法和分布式缓存 高并发 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Basic/大型网站架构/1大型网站架构演化.html": {
    "url": "Basic/大型网站架构/1大型网站架构演化.html",
    "title": "1 大型网站架构演化",
    "keywords": "",
    "body": "1. 大型网站1.1. 一、大型网站系统特点1.2. 二、大型网站架构演化过程1.3. 本章思维导图1. 大型网站 1.1. 一、大型网站系统特点 高并发、大流量：PV 量巨大 高可用：7*24 小时不间断服务 海量数据：文件数目分分钟 xxTB 用户分布广泛，网络情况复杂：网络运营商 安全环境恶劣：黑客的攻击 需求快速变更，发布频繁：快速适应市场，满足用户需求 渐进式发展：慢慢地运营出大型网站 1.2. 二、大型网站架构演化过程 初始阶段网站架构：一台 Server 就刚需—应用程序、数据库、文件等所有资源都集中在一台 Server 上，典型案例：基于 LAMP 架构的 PHP 网站 应用和数据服务分离：三台 Server 平天下—业务发展，单台不再适应业务的发展，将应用和数据分离后成三台 Sever（应用服务器、文件服务器与数据库服务器）。分离后三台 Server 对硬件资源的需求各不相同：应用服务器需要更快更强大的 CPU，而数据库服务器需要更快的硬盘和更大的内存，文件服务器则需要更大的硬盘； 缓存：3+X 的 Server 模式—减少数据库访问压力，提高网站的数据访问速度。缓存又可以分为：本地缓存和远程缓存（可以是分布式的），本地缓存访问速度快，但数据量有限；远程分布式缓存可以集群，因此容量不受限制； 使用应用服务器集群改善网站并发处理能力：集群—硬件方面解决高并发、海量数据问题的常用手段，实现系统的可伸缩性。通过负载均衡调度器，可将用户访问分发到集群中的某台 Server 上，应用服务器的负载压力不再成为整个网站的瓶颈。 数据库读写分离：使用缓存后绝大部分都可以不通过 DB 就能完成，但仍有一部分（缓存访问不命中、缓存过期）和全部的写操作需要访问 DB，在网站的用户达到一定规模后，DB 因为负载压力过高成为网站的瓶颈。大部分主流 DB 都提供主从热备功能，利用这一功能就可以配置两台 DB 主从关系，一台数据更新同步到另一台 Server 上。网站利用 DB 的这一功能，实现 DB 读写分离，从而改善 DB 负载压力。 使用反向代理和 CDN 加速网站响应：CDN 和反向代理的基本原理都是缓存，区别在于 CDN 部署在网络提供商的机房，而反向代理则部署在网站的中心机房。使用 CDN 和反向代理的目的都是尽早返回数据给用户，一方面加快用户访问速度，另一方面也减轻后端服务器的负载压力。 使用分布式文件系统和分布式数据库系统：随着网站业务的发展，两台 DB 服务器依然不能满足需求，文件系统也一样。 使用 NoSQL 和搜索引擎：NoSQL 和搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。 业务拆分：通过分而治之的手段将整个网站业务分成不同的产品线，如淘宝将首页、商铺、订单、卖家、买家等拆分成不同的产品线，分归不同的业务团队负责。各个应用之间可以通过建立一个超链接建立关系，也可以通过消息队列进行数据分发。 分布式服务：既然每一个应用系统都需要执行许多相通的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。 1.3. 本章思维导图 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/2大型网站架构模式.html": {
    "url": "Basic/大型网站架构/2大型网站架构模式.html",
    "title": "2 大型网站架构模式",
    "keywords": "",
    "body": "1. 一、分层2. 二、分割3. 三、分布式4. 四、集群5. 五、缓存6. 六、异步7. 七、冗余8. 八、自动化9. 九、安全10. 十、总结11. 本章思维导图1. 一、分层 最常见的架构模式，将系统在横向维度上切分成几个部分，每个部分单一职责。网站一般分为三个层次：应用层、服务层和数据层，其具体结构如下图所示： 但是，分层架构也有一些挑战：① 必须合理规划层次边界和接口；② 禁止跨层次的调用及逆向调用。 2. 二、分割 分割是在纵向方面对软件进行切分->将不同的功能和服务分割开来，比如将服务层拆成多个小服务。包装成高内聚低耦合的模块单元，有助于软件开发和维护，还便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力。 3. 三、分布式 分布式应用和服务：应用和服务模块分布式部署，便于业务功能扩展； 分布式静态资源：JS、CSS、LOGO 图片等资源独立部署，采用独立域名->动静分离； 分布式数据和存储：传统 RDBMS 分布式部署和 NoSQL 产品； 分布式计算：Hadoop 及其 MapReduce 分布式计算框架，其特点是移动计算而不是移动数据。 4. 四、集群 多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。当某台服务器发生故障，负载均衡设备或者系统的失效转移机制将请求转发到集群中的其他服务器上，提高系统的可用性，即所谓的HA（高可用性）。 在网站应用中，即使是访问量很小的分布式应用和服务，也至少要部署两台服务器构成一个小集群。 5. 五、缓存 缓存是改善软件性能的第一手段。 CDN：内容分发网络，缓存网站的一些静态资源； 反向代理：部署在网站的前端，最先访问到的就是反向代理服务器； 本地缓存：在应用服务器本地缓存热点数据，无需访问数据库； 分布式缓存：应用程序通过网络通信访问缓存数据； 网站应用中，缓存除了可以加快数据访问速度，还可以减轻后端应用和数据存储的负载压力。 6. 六、异步 业务之间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步执行进行协作。 异步架构是典型的生产者消费者模式，两者不存在直接调用，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站扩展新功能非常便利。 异步消息队列可以提高系统可用性、加快网站响应速度，消除并发访问高峰。 7. 七、冗余 要想保证在服务器宕机的情况下网站依然可以继续服务，不丢失数据，就需要一定程度的服务器冗余运行，数据冗余备份，这样当某台服务器宕机时，可以将其上的服务和数据访问转移到其他机器上。 数据库除了定期备份存档保存实现冷备份之外，为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步实现热备份。 8. 八、自动化 在无人值守的情况下，网站可以正常运行，一切都可以自动化是网站的理想状态。目前大型网站的自动化架构设计主要集中在发布运维方面。 发布部署过程自动化 自动化代码管理 自动化测试 自动化安全监测 9. 九、安全 通过密码和手机校验码进行身份验证 对登录、交易等操作进行加密 使用验证码进行识别 对于常见的 XSS 攻击、SQL 注入、编码转换等进行防范 对垃圾或敏感信息进行过滤 对交易转账等操作进行风险控制 10. 十、总结 好的设计绝对不是模仿，不是生搬硬套某个模式，而是对问题深刻理解之上的创造与创新，即使是“微创新”，也是让人耳目一新的似曾相识。山寨与创新的最大区别不在于是否抄袭，是否模仿，而在于对问题和需求是否真正理解与把握。 11. 本章思维导图 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/3大型网站性能优化.html": {
    "url": "Basic/大型网站架构/3大型网站性能优化.html",
    "title": "3 大型网站性能优化",
    "keywords": "",
    "body": "1. 网站性能测试2. 性能优化2.1.1. web 前端2.1.2. 应用服务器端：服务器本地缓存和分布式缓存2.1.3. 数据库服务器端1. 网站性能测试 性能测试指标：① 响应时间；② 并发数；③ 吞吐量；④ 性能计数器； 性能测试方法：① 性能测试；② 负载测试；③ 压力测试；④ 稳定性测试； 性能优化策略： ① 性能分析：检查请求处理各个环节的日志，分析哪个环节响应时间不合理，检查监控数据分析影响性能的因素； ② 性能优化：Web 前端优化，应用服务器优化，存储服务器优化； 2. 性能优化 2.1.1. web 前端 浏览器缓存：设置 http 头中 Cache-Control 和 Expires 属性 使用页面压缩：可以对 html、css、js 文件启用 Gzip 压缩，可以达到较高的压缩效率，但是压缩会对服务器及浏览器产生一定的压力 PS：Gzip 压缩效率非常高，通常可以达到70%的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右。想要启用 Gzip 压缩，提高浏览速度，可以浏览这篇文章：http://www.chinaz.com/web/2012/1017/278682.shtml 合理布局页面： CSS：把样式表置于顶部，浏览器会在下载完全部 CSS 之后才开始对整个页面进行渲染，因此最好将 CSS 放在页面最上面；避免使用 CSS 表达式（expression_r）；用 link 代替@import；避免使用滤镜； JavaScript：把脚本置于页面底部，浏览器在加载 JS 后会立即执行，有可能会阻塞整个页面，造成页面显示缓慢；使用外部 JavaScript 和 CSS；削减 JavaScript 和 CSS；剔除重复脚本；减少 DOM 访问；开发智能事件处理程序； 减少 Cookie 传输：一方面，太大的 Cookie 会严重影响数据传输；另一方面，对于某些静态资源的访问（如 CSS、JS 等）发送 Cookie 没有意义 减少 http 请求：因为 http 是无状态的，每次请求的开销都比较昂贵（需要建立通信链路、进行数据传输，而服务器端对于每个 http 请求都需要启动独立的线程去处理）；减少 http 的主要手段是合并 CSS、合并 JS、合并图片（CSS 精灵，利用偏移定位 image）； CDN：内容分发网络（Content Delivery Network，简称 CDN） 它将数据缓存在离用户最近的节点，缩短用户查看对象的延迟，提高用户访问网站的响应速度与网站的可用性，解决网络带宽小、用户访问量大、网点分布不均等问题。http://baike.baidu.com/view/8689800.htm?from_id=420951&type=search&fromtitle=CDN&fr=aladdin 反向代理 反向代理服务器位于网站机房，代理网站 Web 服务器接收 Http 请求 反向代理服务器具有以下功能：　　 ① 保护网站安全：任何来自 Internet 的请求都必须先经过代理服务器　　 ② 通过配置缓存功能加速 Web 请求：减轻真实 Web 服务器的负载压力　　 ③ 实现负载均衡：均衡地分发请求，平衡集群中各个服务器的负载压力 2.1.2. 应用服务器端：服务器本地缓存和分布式缓存 分布式缓存： PS：网站性能优化第一定律：优先考虑使用缓存优化性能。缓存是指将数据存储在相对较高访问速度的存储介质中（如内存），以供系统进行快速处理响应用户请求。 ① 缓存本质是一个内存 Hash 表，数据以(Key,Value)形式存储在内存中。 ② 缓存主要用来存放那些读写比很高、很少变化的数据，如商品的类目信息、热门商品信息等。这样，应用程序读取数据时，先到缓存中取，如缓存中没有或失效，再到数据库中取出，重新写入缓存以供下一次访问。因此，可以很好地改善系统性能，提高数据读取速度，降低存储访问压力。 ③ 分布式缓存架构：一方面是以以 JBoss Cache 为代表的互相通信派；另一方面是以 Memcached 为代表的互不通信派； JBoss Cache 需要将缓存信息同步到集群中的所有机器，代价比较大；而 Memcached 采用一种集中式的缓存集群管理，缓存与应用分离部署，应用程序通过一致性 Hash 算法选择缓存服务器远程访问缓存数据，缓存服务器之间互不通信，因而集群规模可以轻易地扩容，具有良好的伸缩性。 Memcached 由两个核心组件组成：服务端（ms）和客户端（mc），在一个 memcached 的查询中，mc 先通过计算 key 的 hash 值来确定 kv 对所处在的 ms 位置。当 ms 确定后，客户端就会发送一个查询请求给对应的 ms，让它来查找确切的数据。因为这之间没有交互以及多播协议，所以 memcached 交互带给网络的影响是最小化的。 异步操作： ① 使用消息队列将调用异步化，可改善网站的扩展性，还可改善网站性能； ② 消息队列具有削峰的作用->将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务； 使用集群： Web服务器集群、数据库服务器集群、分布式缓存服务器集群等等，通过部署多台服务器共同对外提供同类服务，提高整体处理能力。 ①在高并发场景下，使用**负载均衡**技术为一个应用构建多台服务器组成的服务器集群； ![](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261605265029573.jpg) ②可以避免单一服务器因负载压力过大而响应缓慢，使用户请求具有**更好的响应延迟特性**； ③负载均衡可以采用硬件设备，也可以采用软件负载。商用硬件负载设备（例如出名的F5）成本通常较高（一台几十万上百万很正常），所以在条件允许的情况下我们会采用软负载，软负载解决的两个核心问题是：选谁、转发，其中最著名的是**LVS**（Linux Virtual Server）。 > **PS：**LVS是四层负载均衡，也就是说建立在OSI模型的第四层——传输层之上，传输层上有我们熟悉的TCP/UDP，LVS支持TCP/UDP的负载均衡。 LVS 的转发主要通过修改 IP 地址（NAT 模式，分为源地址修改 SNAT 和目标地址修改 DNAT）、修改目标 MAC（DR 模式）来实现。有关 LVS 的详情请参考：http://www.importnew.com/11229.html 代码优化： ① 多线程：使用多线程的原因：一是 IO 阻塞，二是多 CPU，都是为了最大限度地利用 CPU 资源，提高系统吞吐能力，改善系统性能； ② 资源复用：目的是减少开销很大的系统资源的创建和销毁，主要采用两种模式实现：单例（Singleton）和对象池（Object Pool）。例如，在.NET 开发中，经常使用到的线程池，数据库连接池等，本质上都是对象池。 ③ 数据结构：在不同场合合理使用恰当的数据结构，可以极大优化程序的性能。 ④ 垃圾回收：理解垃圾回收机制有助于程序优化和参数调优，以及编写内存安安全的代码。这里主要针对 Java（JVM）和 C#（CLR）一类的具有 GC（垃圾回收机制）的语言。 2.1.3. 数据库服务器端 索引：索引（index）是对数据库表中一个或多个列（例如，employee 表的姓氏 (name) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。 PS：要注意的是，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。 缓存：数据库缓存是介于应用程序和物理数据源之间，其作用是为了降低应用程序对数据库的物理数据源访问的频次，从而提高了应用的运行性能。 SQL 优化：当一个基于数据库的应用程序运行起来很慢时，90%的可能都是由于数据访问程序的问题，要么是没有优化，要么是没有按最佳方法编写代码，因此你需要审查和优化你的数据访问/处理程序。具体可以浏览这篇文章：http://www.cnblogs.com/Shaina/archive/2012/04/22/2464576.html NoSQL：方兴未艾的 NoSQL 数据库通过优化数据模型、存储结构、伸缩性等手段在性能方面的优势日趋明显。 存储性能优化 （1）机械硬盘 还是 固态硬盘？ （2）B+树 vs LSM 树 ① 传统关系型数据库广泛采用 B+树，B+树是对数据排好序后再存储，加快数据检索速度。 PS：目前大多数 DB 多采用两级索引的 B+树，树的层次最多三层。因此可能需要5 次磁盘访问才能更新一条记录（三次磁盘访问获得数据索引及行 ID，一次数据文件读操作，一次数据文件写操作，终于知道数据库操作有多麻烦多耗时了） ②NoSQL（例如：HBase）产品广泛采用 LSM 树： 具体思想是：将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘。不过读取的时候稍微麻烦，需要合并磁盘中历史数据和内存中最近的修改操作，所以写入性能大大提升，读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件。 LSM 树的原理是：把一棵大树拆分成 N 棵小树，它首先写入内存中，随着小树越来越大，内存中的小树会被清除并写入到磁盘中，磁盘中的树定期可以做合并操作，合并成一棵大树，以优化读性能。 LSM 树的优势在于：在 LSM 树上进行一次数据更新不需要磁盘访问，在内存即可完成，速度远快于 B+树。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/4大型网站架构要素.html": {
    "url": "Basic/大型网站架构/4大型网站架构要素.html",
    "title": "4 大型网站架构要素",
    "keywords": "",
    "body": "1. 可用性—你能保证几个 9？2. 伸缩性3. 扩展性4. 安全性5. 本章思维导图1. 可用性—你能保证几个 9？ 如何衡量可用性？全靠 9 来撑腰：几乎所有网站都承诺 7✖️24 小时可用，但事实上都不可能完全实现，总会有一些故障时间。那么，去除这些故障时间就是网站的总可用时间。换算成网站的可用性指标，以此衡量网站的可用性，例如某些知名网站可用性达到99.99%。 哪些手段提高可用性？ ① 核心：冗余-各服务器互相备份保证整体可用； ② 应用服务器端：通过负载均衡设备建立集群，其中一台宕机立即切换到其他服务器继续提供服务，这就保证了高可用性。 ③ 存储服务器端：需要对数据进行实时备份，当某台宕机立即将数据访问请求转换到其他服务器上，并进行数据恢复以保证数据高可用。 2. 伸缩性 衡量标准： ① 是否可以多态服务器构建集群？　　 ② 是否容易向集群中添加新服务器？　　 ③ 加入服务器后是否能提供无差别服务？ 主要手段： ① 应用服务器：使用合适的负载均衡设备（硬件还是软件？F5 还是 LVS+KeepAlived）；　　 ② 缓存服务器：改进缓存路由算法保证缓存数据的可访问性；　　 ③ 数据库服务器：通过路由区分等手段将多服务器组成一个集群； 3. 扩展性 衡量标准：增加新业务时是否可以实现对现有产品透明无影响 主要手段： ① 事件驱动架构：利用消息队列实现；　　 ② 分布式服务：将业务和可复用服务分离； 4. 安全性 何为安全性？保护网站不受恶意访问和攻击，保护网站的重要数据不被窃取； 衡量标准：针对现存和潜在的攻击窃密手段，是否有可靠的应对策略； 5. 本章思维导图 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/5高可用架构.html": {
    "url": "Basic/大型网站架构/5高可用架构.html",
    "title": "5 高可用架构",
    "keywords": "",
    "body": "1. 一、可用性度量与考核2. 二、高可用的架构3. 三、高可用的应用3.1.1. 1. 通过负载均衡进行无状态服务的失效转移3.1.2. 2. ==应用服务器集群的 Session 管理==4. 四、高可用的服务5. 五、高可用的数据6. 六、高可用的 QA7. 七、网站运行监控8. 本章思维导图1. 一、可用性度量与考核 如何度量网站可用性？ 一个神奇的数字—9！你有几个 9，就代表了你的可用性。例如 QQ 可用性达到了 4 个 9：99.99% ①2 个 9=基本可用　　 ②3 个 9=较高可用　　 ③4 个 9=具有自动恢复能力的高可用　　 ④5 个 9=极高可用->理想状态 那么，可用性的 9 又是怎么计算出来的呢： ① 网站不可用时间=故障修复时间点-故障发现时间点 ② 网站年度可用性指标=（1-网站不可用时间/年度总时间）*100% 如何考核网站可用性？ 广泛采用故障分的，它是对网站故障进行分类加权计算故障责任的方法。一般会给每个分类的故障设置一个权重（例如事故级故障权重为 100，A 类为 20 等），其计算公式为：故障分=故障时间（分钟）*故障权重。公司对技术团队的考核一般会参考故障分，例如某团队今年发生了几个事故级故障，那么其绩效考核估计受到很大影响，年终奖什么的就悲剧了。 2. 二、高可用的架构 目前，通常企业级应用系统（特别是政府部门和大企业的应用系统）一般会采用安规的软硬件设备，如 IOE（IBM 的小型机、Oracle 数据、EMC 存储设备）系列。而一般互联网公司更多地采用 PC 级服务器（x86），开源的数据库（MySQL）和操作系统（Linux）组建廉价且高容错（硬件故障是常态）的应用集群。 设计的目的？ 保证服务器硬件故障服务依然可用，数据依然保存并能够被访问。 主要的手段？ ① 冗余备份以及 ② 失效转移： 对于服务而言，一旦某个服务器宕机，就将服务切换到其他可用的服务器上。对于数据而言，如果某个磁盘损坏，就从备份的磁盘（事先就做好了数据的同步复制）读取数据。 3. 三、高可用的应用 3.1.1. 1. 通过负载均衡进行无状态服务的失效转移 3.1.2. 2. ==应用服务器集群的 Session 管理== Session 单机情况下由部署在服务器上得 Web 容器（如 IIS、Tomcat、JBoss 等）管理。在使用了负载均衡的集群环境中，由于请求的分发是随机的，所以保证每次请求依然能够获得正确的 Session 比单机时要复杂得多。 在集群环境中，Session 管理的几种常见手段: Session 复制： 该方案简单易行，集群中的几台服务器之间同步 Session 对象，任何一台服务器宕机都不会导致 Session 对象的丢失，服务器也只需要从本机获取即可。但是，该方案只适合集群规模较小的情况下。当规模较大时，大量的 Session 复制操作会占用服务器和网络的大量资源，系统不堪重负。 Session 绑定： 利用负载均衡的源地址 Hash算法，总是将源于同一 IP 地址的请求分发到同一台服务器上。这样的话，在整个会话期间，用户所有的请求都在同一台服务器上进行处理，即 Session 绑定在某台特定服务器上，保证 Session 总能在这台服务器上获取。（这种方案又叫做会话粘滞）。 但是，这种方案不符合高可用的需求。因为一旦某台服务器宕机，那么该机器上得 Session 也就不复存在了，用户请求切换到其他机器后因为没有 Session 而无法完成业务处理。因此，很少有网站采用此方案进行 Session 管理。 Cookie 记录 Session： 利用浏览器支持的 Cookie 记录 Session 简单易行，可用性高，并且支持服务器的线性伸缩，因此，许多网站都或多或少地使用了 Cookie 来记录 Session。但是 Cookie 记录 Session 有缺点：比如受 Cookie 大小限制、每次请求响应都要传输 Cookie 影响性能、用户关闭了 Cookie 会造成访问不正常等。 ==Session 服务器==：利用独立部署的 Session 服务器（集群）统一管理 Session，应用服务器每次读写 Session 时，都访问 Session 服务器。这种方案实际上是将应用服务器的状态分离，分为无状态的应用服务器和有状态的 Session 服务器。 对于，有状态的 Session 服务器，一种较简单的方法是利用分布式缓存（如 Memcached、Redis 等，有关 Redis 的简单介绍可以阅读我的博文：NoSQL 初探之人人都爱 Redis）、数据库等，在这些产品的基础上进行封装，使其符合 Session 的存储和访问要求。 4. 四、高可用的服务 高可用的服务模块为业务产品提供基础公共服务，在大型站点中这些服务通常都独立分布式部署，被具体应用远程调用。 在具体实践中，有以下几点高可用的服务策略可以参考： ① 分级管理：核心应用和服务具有更高的优先级，比如用户及时付款比能否评价商品更重要； ② 超时设置：设置服务调用的超时时间，一旦超时后，通信框架抛出异常，应用程序则根据服务调度策略选择重试 or 请求转移到其他服务器上； ③ 异步调用：通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。 PS：不是所有服务都可以异步调用，对于获取用户信息这类调用，采用异步方式会延长响应时间，得不偿失。对于那些必须确认服务调用成功后才能继续进行下一步的操作的应用也不适合异步调用。有关具体使用消息队列实现异步调用的案例，请阅读我的博文：《使用 Redis 作为消息队列服务场景的应用案例》。 ④ 服务降级：网站访问高峰期间，为了保证核心应用的正常运行，需要对服务降级。 降级有两种手段：一是拒绝服务，拒绝较低优先级的应用的调用，减少服务调用并发数，确保核心应用的正常运行；二是关闭功能，关闭部分不重要的服务，或者服务内部关闭部分不重要的功能，以节约系统开销，为核心应用服务让出资源； ⑤ 幂等性设计：保证服务重复调用和调用一次产生的结果相同； 5. 五、高可用的数据 对于大多数网站而言，数据是其最宝贵的物质资产。 保证数据高可用的主要手段有两种：一是数据备份，二是失效转移机制； ① 数据备份：又分为冷备份和热备份，冷备份是定期复制，不能保证数据可用性。热备份又分为异步热备和同步热备，异步热备是指多份数据副本的写入操作异步完成，而同步方式则是指多份数据副本的写入操作同时完成。 关系数据库的热备机制就是通常所说的主从同步机制，实践中通常使用读写分离的方法来访问 Master 和 Slave 数据库，也就是说写操作只访问 Master 库，读操作均访问 Slave 库。 PS：在 MS SQL Server 中，可以通过发布订阅功能实现主从分离。关于发布订阅，可以参考 MSDN 的这篇文章：http://technet.microsoft.com/zh-cn/ff806143.aspx ② 失效转移：若数据服务器集群中任何一台服务器宕机，那么应用程序针对这台服务器的所有读写操作都要重新路由到其他服务器，保证数据访问不会失败。 6. 六、高可用的 QA ① 网站发布：在柔性的发布过程中，每次关闭的服务都是集群中的一小部分，并在发布完成后立即可以访问； ② 自动化测试：使用自动测试工具或脚本完成测试； ③ 预发布验证：引入预发布服务器，与正式服务器几乎一致，只是没有配置在负载均衡服务器上，外部用户无法访问； ④ 代码控制：目前大多数网站采用 SVN，分支开发，主干发布模式；另外，目前开源社区广泛采用 Git 作为版本控制工具，正逐步取代 SVN 的地位； 7. 七、网站运行监控 ”不允许没有监控的系统上线“ （1）监控数据采集 ① 用户行为日志收集：服务器端的日志收集和客户端的日志收集；目前许多网站逐步开发基于实时计算框架 Storm 的日志统计与分析工具； ② 服务器性能监控：收集服务器性能指标，如系统 Load、内存占用、磁盘 IO 等，及时判断，防患于未然； ③ 运行数据报告：采集并报告，汇总后统一显示，应用程序需要在代码中处理运行数据采集的逻辑； （2）监控管理 ① 系统报警：配置报警阀值和值守人员联系方式，系统发生报警时，即使工程师在千里之外，也可以被及时通知； ② 失效转移：监控系统在发现故障时，主动通知应用进行失效转移； ③ 自动优雅降级：为了应付网站访问高峰，主动关闭部分功能，释放部分系统资源，保证核心应用服务的正常运行；—>网站柔性架构的理想状态 8. 本章思维导图 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/6可扩展架构.html": {
    "url": "Basic/大型网站架构/6可扩展架构.html",
    "title": "6 可扩展架构",
    "keywords": "",
    "body": "1. 一、可伸缩与可扩展—傻傻分不清楚2. 二、利用分布式消息队列降低系统耦合性2.1. 2.1 事件驱动架构2.2. 2.2 分布式消息队列3. 三、利用分布式服务打造可复用的业务平台3.1. 3.1 巨无霸的应用系统带来的问题3.2. 3.2 拆分，拆分还是拆分4. 四、可扩展的数据结构5. 五、利用开放平台建设网站生态圈6. 本章思维导图1. 一、可伸缩与可扩展—傻傻分不清楚 （1）扩展性（Extensibiltiy） 指对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。我们不禁想到了面向对象中一大原则：开闭原则，对扩展开放，对修改封闭。也就说，当系统新增一个功能时，不需要对现有系统的结构和代码进行修改。 （2）伸缩性（Scalability） 指系统能够通过增加（或减少）自身资源规模的方式增强（或减少）自己计算事务的能力。在网站架构中，通常是指利用集群的方式增加服务器数量，从而提高系统的整体事务吞吐能力。 设计网站可扩展架构的核心思想是：模块化，并在此基础之上降低模块间的耦合，提高模块的复用性。在大型网站中，这些模块通过分布式部署的方式，独立的模块部署在独立的服务器（集群）上，从物理上分离模块之间的耦合关系，进一步降低耦合性从而提高复用性。 2. 二、利用分布式消息队列降低系统耦合性 上面我们提到说要分离模块之间的耦合，如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块的影响最小，这样系统的可扩展性无疑会更好一些。那么，有没有一种架构是基于如此考虑而设计的呢？于是，我们将眼光转向一个名叫“事件驱动”的架构。 2.1. 2.1 事件驱动架构 根据事件驱动架构（Event Driven Architecture）的定义：通过在低耦合的模块之间传输消息，以保持模块的松散耦合，并借助事件消息的通信完成模块间合作。典型的 EDA 架构就是操作系统中常见的生产者消费者模式。在大型网站架构中，具体实现手段有很多，但是最常见的是分布式消息队列。 如上图所示，消息队列利用发布—订阅模式工作，消息发送者发布消息，一个或多个消息接受者订阅消息。消息发送者是消息源，在对消息进行处理后发送至分布式消息队列，消息接收者从分布式消息队列获取该消息后继续进行处理。可以明显看出，发送者与接受者之间没有直接耦合，消息发送者只需将消息发送给分布式消息队列即操作结束，而消息接受者也只需要从分布式消息队列获取消息后进行处理，不需要知道该消息从何而来。因此，对于新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展设计。 2.2. 2.2 分布式消息队列 队列是一种先进先出的数据结构，分布式消息队列则看以看作是将这种数据结构部署到独立服务器上，应用程序看以通过远程访问接口使用分布式消息队列，进行消息存取操作，进而实现分布式的异步调用。 如上图所示，我们可以明确三个步凑： ① 消息生产者应用程序通过远程访问接口将消息推送给消息队列服务器，消息队列服务器将消息写入本地内存队列后马上返回成功响应给消息生产者。 ② 消息队列服务器根据消息订阅列表查找订阅该消息的消费者应用程序，将消息队列中的消息按照先进先出的原则将消息通过远程通信接口发送给消费者应用程序； ③ 消费者应用程序接收到推送过来的消息之后进行相关的一系列处理，过程终止； 有没有这样一种情况：消息队列服务器宕机后导致消息丢失。事实上，这种情况的确存在于实际的运维过程中。那么，我们如何来避免呢？这时，作者给出了一个方案：如果消息队列服务器宕机造成消息丢失，会将消息成功发送到消息队列的消息存储在消息生产者服务器，等消息真正被消息消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中其他的服务器发布消息。 另外，有关于分布式消息队列的实践可以采用 NoSQL 产品来构建，例如 Redis 就提供了队列数据类型，可以方便地构建分布式消息队列，如果你有兴趣，也可以参阅我的另一篇博文：《使用 Redis 作为消息队列服务应用场景案例》 3. 三、利用分布式服务打造可复用的业务平台 如果说分布式消息队列通过消息对象分解系统耦合性，不同子系统处理同一个消息；那么分布式服务则通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用。 3.1. 3.1 巨无霸的应用系统带来的问题 网站由小到大的演化过程中，表现为整个网站是由单一系统逐步膨胀发展变化而来的，随着网站功能的日益复杂，网站应用系统会逐渐成为一个巨无霸，如下图所示。可以看出，一个应用中聚合了大量的应用和服务组件，这个巨无霸给整个网站的开发（编译麻烦、代码分支管理困难）、维护（新增业务困难）和部署（部署困难）都带来了巨大的麻烦。 3.2. 3.2 拆分，拆分还是拆分 解决方案还是我们多次提到的拆分，将模块独立部署，降低系统耦合性。拆分又分为：横向拆分和纵向拆分。这里我们再次回顾一下这两种方式： （1）纵向拆分：将一个大应用拆分为多个小应用，如果新增的业务较为独立，那么就直接将其设计部署为一个独立的 Web 应用系统； （2）横向拆分：将可以复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务即可，不需要依赖于具体的模块代码。如果模块内业务逻辑发生变化时，只要接口保持一致就不会影响业务程序和其他模块。 4. 四、可扩展的数据结构 传统的关系数据库为了保证关系运算（通过 SQL 语句）的正确性，在设计表结构的时候就需要制定表的 Schema—字段名称、数据类型等，还要遵循制定的设计范式（例如：1NF、2NF、3NF 等等）。这些规范带来的一个问题就是僵硬的数据结构难以面对需求变更带来的挑战，有些系统设计者通过预先设计一些冗余字段来应付（在我所实习的一年里，我见过很多次这种设计，虽然可以解决问题，但从设计学来说，真的好 Shit），但这显然是一种糟糕的数据库设计。 那么，有木有办法能够做到可扩展的数据结构设计呢？是否可以不需要修改表结构就可以新增字段呢？答案是肯定的，目前许多 NoSQL 数据库使用的ColumnFamily（列族）设计就是一个解决方案。ColumnFamily 最早在 Google 的 BigTable 中使用，这是一种面向列族的稀疏矩阵存储格式。或许这么说大家还是不明白，但可以通过下图来理解： 这是一个学生基本信息表，不同学生的联系方式不同，选修的课程也不同，而且在将来会有更多的联系方式和课程加入这张表，如果按照传统的数据库设计，无论提前预设多少冗余字段都不够用，捉襟见肘，疲于应付。而是用 ColumnFamily 结构的 NoSQL 数据库，创建表的时候，只需要指定 ColumnFamily 的名字，无需指定字段（Column），可以在数据写入时再指定，通过这种方式，数据表可以包含数百万的字段，使应用程序的数据结构可以随意扩展。 5. 五、利用开放平台建设网站生态圈 网站的价值在于为他的用户创造价值，大型网站为了更好地服务自己的用户，会开发更多的增值服务，会把网站内部的服务封装一些调用接口开放出去，供外部的第三方开发者使用，这个提供开放接口的平台被称作开放平台。第三方开发者利用这些开放的接口开发应用程序（APP）或者网站，为更多的用户提供价值。这样一来，网站、用户、第三方开发者相互依赖，形成一个网站的生态圈，即为用户提供更多的价值，也提高了网站和第三方开发者的竞争能力和盈利能力。 6. 本章思维导图 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/database_scale.html": {
    "url": "Basic/大型网站架构/database_scale.html",
    "title": "database_scale",
    "keywords": "",
    "body": "1. Database Scale1.1. 1. Database Partitioning Options1.1.1. Cluster Computing1.1.2. Table Partitioning1.1.3. Federated Tables1.1.4. Sum of Partitioning Options1.2. 2. Database Sharding, The “Shared-Nothing” Approach1.2.1. Usage1.2.2. Advantage1.2.3. Things to be considered1.3. When Database Sharding is Appropriate1.4. Disadvantages of sharding1. Database Scale 1.1. 1. Database Partitioning Options 1.1.1. Cluster Computing Cluster computing utilizes many servers operating in a group, with shared messaging between the nodes of the cluster. Most often this scenario relies on a centralized shared disk facility, typically a Storage Area Network (SAN). Each node in the cluster runs a single instance of the database server, operating in various modes: For high-availability, many nodes in the cluster can be used for reads, but only one for write (CRUD) operations. This can make reads faster, but write transactions do not see any benefit. If a failure of one node occurs, then another node in the cluster takes over, again continuing to operating against the shared disk facility. This approach has limited scalability due to the single bottleneck for CRUD operations. Even the reads will ultimately hit a performance limit as the centralized shared disk facility can only spread the load so much before diminishing returns are experienced. The read limitations are particularly evident when an application requires complex joins or contains non-optimized SQL statements. More advanced clustering techniques rely on real-time memory replication between nodes, keeping the memory image of nodes in the cluster up to date via a real-time messaging system. This allows each node to operate in both read or write mode, but is ultimately limited by the amount of traffic that can be transmitted between nodes (using a typical network or other high-speed communication mechanism). Therefore, as nodes are added, the communication and memory replication overhead increases geometrically, thus hitting severe scalability limits, often with a relatively small number of nodes. This solution also suffers from the same shared disk limitations of a traditional cluster, given that a growing, single large database has increasingly intensive disk I/O. 1.1.2. Table Partitioning data in a single large table can be split across multiple disks for improved disk I/O utilization. The partitioning is typically done horizontally (separating rows by range across disk partitions), but can be vertical in some systems as well (placing different columns on separate partitions). This approach can help reduce the disk I/O bottleneck for a given table. disadvantage: make joins and other operations slower. since the approach relies on a single server instance of the database management system, all other CPU and memory contention limitations apply 1.1.3. Federated Tables An offshoot of Table Partitioning is the Federated Table approach, where tables can be accessed across multiple servers. disadvantage: complex to administer, and lacks efficiency as the federated tables must be accessed over the network. This approach may work for some reporting or analytical tasks, but for general read/write transactions it is not a very likely choice. 1.1.4. Sum of Partitioning Options The common drawback is reliance on shared facilities and resources. Whether relying on shared memory, centralized disk, or processor capacity they each suffer with scalability limitations, not to mention many other drawbacks, including complex administration, lack of support for critical business requirements, and high availability limitations. 1.2. 2. Database Sharding, The “Shared-Nothing” Approach ==breaking up big database into many smaller databases that share nothing and can be spread across multiple servers.== 1.2.1. Usage customerWest vs customerEast; customerEurope vs customerUS 1.2.2. Advantage improved scalability, growing in a near-linear fashion as more servers are added to the network Smaller databases are easier to manage. Smaller databases are faster. By hosting each shard database on its own server, the ratio between memory and data on disk is greatly improved, thereby reducing disk I/O. This results in less contention for resources, greater join performance, faster index searches, and fewer database locks. Database Sharding can reduce costs. Most Database Sharding implementations take advantage of lower-cost open source databases, or can even take advantage of “workgroup” versions of commercial databases. Additionally, sharding works well with commodity multi-core server hardware, far less expensive than high-end multi-CPU servers and expensive SANs. The overall reduction in cost due to savings in license fees, software maintenance and hardware investment is substantial, in some cases 70% or more when compared to other solutions. 1.2.3. Things to be considered Reliability. Automated backups of individual Database Shards. Database Shard redundancy, ensuring at least 2 “live” copies of each shard are available in the event of an outage or server failure. This requires a high-performance, efficient, and reliable replication mechanism. Cost-effective hardware redundancy, both within and across servers. Automated failover when an outage or server failure occurs. Disaster Recovery site management. Distributed queries. Aggregation of statistics, requiring a broad sweep of data across the entire system. Such an example is the computation of sales by product, which ordinarily requires evaluation of the entire database. Queries that support comprehensive reports, such as listings of all individual customers that purchased a given product in the last day, week or month. Avoidance of cross-shard joins. The primary technique to avoid this is the replication of Global Tables, the relatively static lookup tables that are common utilized when joining to much larger primary tables. Tables containing values as Status Codes, Countries, Types, and even Products fall into this category. What is required is an automated replication mechanism that ensures values for Global Tables are in synch across all shards, minimizing or eliminating the need for cross-shard joins. Auto-increment key management. Typical auto-increment functionality provided by database management systems generate a sequential key for each new row inserted into the database. This is fine for a single database application, but when using Database Sharding, keys must be managed across all shards in a coordinated fashion. The requirement here is to provide a seamless, automated method of key generation to the application, one that operates across all shards, ensuring that keys are unique across the entire system. Support for multiple Shard Schemes. It is important to note that Database Sharding is effective because it offers an application specific technique for massive scalability and performance improvements. In fact it can be said that the degree of effectiveness is directly related to how well the sharding algorithms themselves are tailored to the application problem at hand. What is required is a set of multiple, flexible shard schemes, each designed to address a specific type of application problem. Each scheme has inherent performance and/or application characteristics and advantages when applied to a specific problem domain. In fact, using the wrong shard scheme can actually inhibit performance and the very results you are trying to obtain. It is also not uncommon for a single application to use more than one shard scheme, each applied to a specific portion of the application to achieve optimum results. Here is a list of some common shard schemes: Session-based sharding, where each individual user or process interacts with a specific shard for the duration of the user or process session. This is the simplest technique to implement, and adds virtually zero overhead to overall performance, since the sharding decision is made only once per session. Applications which can benefit from this approach are often customer-centric, where all data for a given customer is contained in a single shard, and that is all the data that the customer requires. Transaction-based sharding determines the shard by examining the first SQL Statement in a given database transaction. This is normally done by evaluating the “shard key” value used in the statement (such as an Order Number), and then directing all other statements in the transaction to the same shard. Statement-based sharding is the most process intensive of all types, evaluating each individual SQL Statement to determine the appropriate shard to direct it to. Again, evaluation of the shard key value is required. This option is often desirable on high-volume, granular transactions, such as recording phone call records. Determine the optimum method for sharding the data. This is another area that is highly variable, change from application to application. It is closely tied with the selection of the Database Shard Scheme described above. There are numerous methods for deciding how to shard your data, and its important to understand your transaction rates, table volumes, key distribution, and other characteristics of your application. This data is required to determine the optimum sharding strategy: Shard by a primary key on a table. This is the most straightforward option, and easiest to map to a given application. However, this is only effective if your data is reasonably well distributed. For example, if you elected to shard by Customer ID (and this is a sequential numeric value), and most of your transactions are for new customers, very little if anything will be gained by sharding your database. On the other hand, if you can select a key that does adequately and naturally distribute your transactions, great benefits can be realized. Shard by the modulus of a key value. This option works in a vast number of cases, by applying the modulus function to the key value, and distributing transactions based on the calculated value. In essence you can predetermine any number of shards, and the modulus function effectively distributes across your shards on a “round-robin” basis, creating a very even distribution of new key values. Maintain a master shard index table. This technique involves using a single master table that maps various values to specific shards. It is very flexible, and meets a wide variety of application situations. However, this option often delivers lower performance as it requires an extra lookup for each sharded SQL Statement. 1.3. When Database Sharding is Appropriate High-transaction database applications Mixed workload database usage Frequent reads, including complex queries and joins Write-intensive transactions (CRUD statements, including INSERT, UPDATE, DELETE) Contention for common tables and/or rows General Business Reporting Typical “repeating segment” report generation Some data analysis (mixed with other workloads) Database Sharding is a method of “horizontal” portioning, meaning that database rows (as opposed to columns) for a single schema table are distributed across multiple shards. To understand the characteristics of how well sharding fits a given situation, here are the important things to determine: Identify all transaction-intensive tables in your schema. Determine the transaction volume your database is currently handling (or is expected to handle). Identify all common SQL statements (SELECT, INSERT, UPDATE, DELETE), and the volumes associated with each. Develop an understanding of your “table hierarchy” contained in your schema; in other words the main parent-child relationships. Determine the “key distribution” for transactions on high-volume tables, to determine if they are evenly spread or are concentrated in narrow ranges. With this information, you can rapidly gain an assessment of the value and applicability of sharding to your application. As an example, here is a simple Bookstore schema showing how the data can be sharded: Figure 3. Example Bookstore schema showing how data is sharded. In the Bookstore example, the Primary Shard Table is the ‘customer’ entity. This is the table that is used to shard the data. The ‘customer’ table is the parent of the shard hierarchy, with the ‘customer_order’ and ‘order_item’ entities as child tables. The data is sharded by the ‘customer.id’ attribute, and all related rows in the child tables associated with a given ‘customer.id’ are sharded as well. The Global Tables are the common lookup tables, which have relatively low activity, and these tables are replicated to all shards to avoid cross-shard joins. 1.4. Disadvantages of sharding Sharding a database table before it has been optimized locally causes premature complexity. Sharding should be used only when all other options for optimization are inadequate. The introduced complexity of database sharding causes the following potential problems: Increased complexity of SQL - Increased bugs because the developers have to write more complicated SQL to handle sharding logic. Sharding introduces complexity - The sharding software that partitions, balances, coordinates, and ensures integrity can fail. Single point of failure - Corruption of one shard due to network/hardware/systems problems causes failure of the entire table. Failover servers more complex - Failover servers must themselves have copies of the fleets of database shards. Backups more complex - Database backups of the individual shards must be coordinated with the backups of the other shards. Operational complexity added - Adding/removing indexes, adding/deleting columns, modifying the schema becomes much more difficult. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/memcache/": {
    "url": "Basic/大型网站架构/memcache/",
    "title": "Basic/大型网站架构/memcache",
    "keywords": "",
    "body": "1. TOC1. TOC consistent_hash Memcached 与 Redis 的对比 memcached 使用 memcached 分布式原理 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Basic/大型网站架构/memcache/consistent_hash.html": {
    "url": "Basic/大型网站架构/memcache/consistent_hash.html",
    "title": "consistent_hash",
    "keywords": "",
    "body": "1. System Design for Big Data1.1. What is Consistent Hashing1.2. When to use Consistent Hashing1.3. Here's how consistent hashing works1.4. Now let's consider the load balance issue1.5. Monotone Keys1. System Design for Big Data Given n cache hosts, an intuitive hash function is key % n. It is simple and commonly used. But it has two major drawbacks: It is NOT horizontally scalable. Every time when adding one new cache host to the system, all existing mappings are broken. It will be a pain point in maintenance if the caching system contains a lot of data. Also, if the caching system is behind a popular service, it is not easy to schedule a downtime to update all caching mappings. It may NOT be load balanced, especially for non-uniformly distributed data. In real world, it is less likely that the data is uniformly distributed. Then for the caching system, it results that some caches are hot and saturated while the others idle and almost empty. In such situations, consistent hashing is a good way to improve the caching system. 1.1. What is Consistent Hashing Consistent Hashing is a hashing strategy such that when the hash table is resized (e.g. a new cache host is added to the system), only k/n keys need to be remapped, where k is the number of keys and n is the number of caches. Recall that in a caching system using the mod as hash function, all keys need to be remapped. Consistent hashing maps an object to the same cache host if possible. If a cache host is removed, the objects on that host will be shared by other hosts; If a new cache is added, it takes its share from other hosts without touching other shares. 1.2. When to use Consistent Hashing Consistent hashing is a very useful strategy for distributed caching system and distributed hash tables. It can reduce the impact of host failures. It can also make the caching system more easier to scale up (and scale down). Example of uses include: Last.fm: memcached client with consistent hashing Amazon: internal scalable key-value store, Dynamo Chord: a distributed hash table by MITHow it works? As a typical hash function, consistent hashing maps a key or a cache host to an integer. Suppose the output of the hash function are in the range of [0, 2^128) (e.g. MD5 hash). Image that the integers in the range are placed on a ring such that the values are wrapped around. 1.3. Here's how consistent hashing works Given a list of cache servers, hash them to integers in the range. To map a key to a server, hash it to a single integer. Move clockwise on the ring until finding the first cache it encounters. That cache is the one that contains the key. See animation below as an example: key1 maps to cache A; key2 maps to cache C. To add a new cache, say D, keys that were originally falling to C will be split and some of them will be moved to D. Other keys don't need to be touched. To remove a cache or if a cache failed, say C, all keys that were originally mapping to C will fall into A and only those keys need to be moved to A. Other keys don't need to be touched. 1.4. Now let's consider the load balance issue As we discussed at the beginning, the real data are essentially randomly distributed and thus may not be uniform. It may cause the keys on caches are unbalanced. To resolve this issue, we add \"virtual replicas\" for caches. For each cache, instead of mapping it to a single point on the ring, we map it to multiple points on the ring, i.e. replicas. By doing this, each cache is associated with multiple segments of the ring. If the hash function \"mixes well\", as the number of replicas increases, the keys will be more balanced. 1.5. Monotone Keys If keys are known to be monotonically increased, binary searching can be used to improve the performance of locating a cache for a given key. Then the locate time can be reduced to O(log(n)). Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/memcache/Memcached与Redis的对比.html": {
    "url": "Basic/大型网站架构/memcache/Memcached与Redis的对比.html",
    "title": "Memcached 与 Redis 的对比",
    "keywords": "",
    "body": "1. Memcached 与 Redis 的对比1. Memcached 与 Redis 的对比 没有必要过多的关心性能，因为二者的性能都已经足够高了。由于Redis 只使用单核，而Memcached 可以使用多核，所以在比较上，平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在100k 以上的数据中，Memcached 性能要高于 Redis，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。说了这么多，结论是，无论你使用哪一个，每秒处理请求的次数都不会成为瓶颈。（比如瓶颈可能会在网卡） 如果要说内存使用效率，使用简单的 key-value 存储的话，Memcached 的内存利用率更高，而如果 Redis 采用 hash 结构来做 key-value 存储，由于其组合式的压缩，其内存利用率会高于 Memcached。当然，这和你的应用场景和数据特性有关。 如果你对数据持久化和数据同步有所要求，那么推荐你选择 Redis，因为这两个特性 Memcached 都不具备。即使你只是希望在升级或者重启系统后缓存数据不会丢失，选择 Redis 也是明智的。 需要慎重考虑的部分: Memcached 单个 key-value 大小有限，一个 value 最大只支持 1MB，而 Redis 最大支持 512MB Memcached 只是个内存缓存，对可靠性无要求；而 Redis 更倾向于内存数据库，因此对对可靠性方面要求比较高 从本质上讲，Memcached 只是一个单一 key-value 内存 Cache；而 Redis 则是一个数据结构内存数据库，支持五种数据类型，因此 Redis 除单纯缓存作用外，还可以处理一些简单的逻辑运算，Redis 不仅可以缓存，而且还可以作为数据库用 新版本（3.0）的 Redis 是指集群分布式，也就是说集群本身均衡客户端请求，各个节点可以交流，可拓展行、可维护性更强大。 MongoDB 不支持事务。 结论：在简单的 Key/Value 应用场景（例如缓存），Memcached 拥有更高的读写性能；而在数据持久化和数据同步场景，Redis 拥有更加强大的功能和更为丰富的数据类型 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/memcache/memcached使用.html": {
    "url": "Basic/大型网站架构/memcache/memcached使用.html",
    "title": "memcached 使用",
    "keywords": "",
    "body": "1. 安装和启动1.1. 先把 memcached 用起来1.1.1. memcached 分布式缓存的设置与应用1.1.2. memcached 的数据压缩机制1.1.3. 使用客户端多个 SocketIO 池1.1.4. 说说 memcached 的故障转移处理1.1.5. 说说 key-value 中的 key 与 value1.2. Memcached 客户端使用封装1.2.1. 抽象出来了一个接口1.2.2. MemcacheHelper.cs1.3. App.config1.3.1. Program.cs1. 安装和启动 install memcached.exe -d install start memcached.exe -d start stop memcached.exe -d stop unInstall memcached.exe -d uninstall 以上的安装和启动都是在默认环境下进行的，在安装时可设置如下参数： Memcached 默认使用端口是 11211 默认最大连接数是 1024 个 默认最大使用内存是 64M 默认每个键值对，值存储空间为 1M -p 监听的端口 -l 连接的 IP 地址, 默认是本机 -d start 启动 memcached 服务 -d restart 重起 memcached 服务 -d stop|shutdown 关闭正在运行的 memcached 服务 -d install 安装 memcached 服务 -d uninstall 卸载 memcached 服务 -u 以身份运行 (仅在以 root 运行的时候有效) -m 最大内存使用，单位 MB。默认 64MB -M 内存耗尽时返回错误，而不是删除项 -c 最大同时连接数，默认是 1024 -f 块大小增长因子，默认是 1.25 -n 最小分配空间，key+value+flags 默认是 48 -h 显示帮助 怎么才知道 Memcached 服务已经安装成功并启动了呢? cmd 命令 services.msc 检测 Memcached 服务是否成功启动： 使用 telnet 命令连接到登录台：telnet 服务器 IP 地址 11211（11211 是默认的 Memcached 服务端口号）打印当前 Memcache 服务器状态：stats 可以看到，通过 stats 命令列出了一系列的 Memcached 服务状态信息 1.1. 先把 memcached 用起来 下载客户端的 4 个 dll，IcSharpCode.SharpZipLib.dll，log4net.dll，Memcached.ClientLibrary.dll，Commons.dll 新建一个简单控制台应用程序 using Memcached.ClientLibrary; using System; namespace Tdf.RedisCacheTest { class AMemcached { public static MemcachedClient cache; static AMemcached() { string[] servers = { \"127.0.0.1:11211\" }; // 初始化池 SockIOPool pool = SockIOPool.GetInstance(); // 设置服务器列表 pool.SetServers(servers); // 各服务器之间负载均衡的设置比例 pool.SetWeights(new int[] { 1 }); // 初始化时创建连接数 pool.InitConnections = 3; // 最小连接数 pool.MinConnections = 3; // 最大连接数 pool.MaxConnections = 5; // 连接的最大空闲时间，下面设置为6个小时（单位ms），超过这个设置时间，连接会被释放掉 pool.MaxIdle = 1000 * 60 * 60 * 6; // socket连接的超时时间，下面设置表示不超时（单位ms），即一直保持链接状态 pool.SocketConnectTimeout = 0; // 通讯的超时时间，下面设置为3秒（单位ms），.Net版本没有实现 pool.SocketTimeout = 1000 * 3; // 维护线程的间隔激活时间，下面设置为30秒（单位s），设置为0时表示不启用维护线程 pool.MaintenanceSleep = 30; // 设置SocktIO池的故障标志 pool.Failover = true; // 是否对TCP/IP通讯使用nalgle算法，.net版本没有实现 pool.Nagle = false; // socket单次任务的最大时间（单位ms），超过这个时间socket会被强行中端掉，当前任务失败。 pool.MaxBusy = 1000 * 10; pool.Initialize(); cache = new MemcachedClient(); // 是否启用压缩数据：如果启用了压缩，数据压缩长于门槛的数据将被储存在压缩的形式 cache.EnableCompression = false; // 压缩设置，超过指定大小的都压缩 cache.CompressionThreshold = 1024 * 1024; } } class Program { static void Main(string[] args) { // 存入key为userName，value为Bobby的一个缓存 AMemcached.cache.Add(\"userName\", \"Bobby\"); // 读出key为a的缓存值 var s = AMemcached.cache.Get(\"userName\"); // 输出 Console.WriteLine(s); Console.Read(); } } } 1.1.1. memcached 分布式缓存的设置与应用 string[] servers = { \"127.0.0.1:11211\", \"192.168.2.100:11211\" }; // 初始化池 SockIOPool pool = SockIOPool.GetInstance(); // 设置服务器列表 pool.SetServers(servers); // 各服务器之间负载均衡的设置比例 pool.SetWeights(new int[] { 1, 10 }); Note： 在 172.18.5.66，与 192.168.10.121 两台机器上装 memcached 服务端。 pool.SetWeights 这里的 1 跟 10 意思是，负载均衡比例，假如 11000 条数据，大致数据分布为：172.18.5.66 分布 1000 条数据左右。另外一台为 10000 条左右。 memcached 服务端并不具备负载均衡的能力，而是memcachedClient 实现的，具体存取数据实现的核心是采用一致性 Hash 算法，把 key-value 分布到某一台服务器中里边。 1.1.2. memcached 的数据压缩机制 // 是否启用压缩数据：如果启用了压缩，数据压缩长于门槛的数据将被储存在压缩的形式 cache.EnableCompression = false; // 压缩设置，超过指定大小的都压缩 cache.CompressionThreshold = 1024 * 1024; Note： 这个处理是在 MemcachedClient 对象中，设置这个 EnableCompression 属性，是否使用压缩的意思，如果启用啦压缩功能 ,则IcSharpCode.SharpZipLib 类库会在数据超过预设大小时，进行数据压缩处理。 CompressionThreshold 这个属性是压缩的阀值，默认是 15K，如果超过设定的阀值则使用 memcached 的通讯协议，存数据时给每个数据项分配一个 16 为的 flag 表示，用作记录是否有压缩，如果有压缩则提取数据是进行解压。如果没有超过阀值则不压缩，直接存储。 1.1.3. 使用客户端多个 SocketIO 池 using Memcached.ClientLibrary; using System; namespace Tdf.RedisCacheTest { class AMemcached { public MemcachedClient cache; public AMemcached(string poolName) { string[] servers = { \"127.0.0.1:11211\", \"192.168.2.100:11211\" }; // 初始化池 SockIOPool pool = SockIOPool.GetInstance(); // 设置服务器列表 pool.SetServers(servers); // 各服务器之间负载均衡的设置比例 pool.SetWeights(new int[] { 1, 10 }); // 初始化时创建连接数 pool.InitConnections = 3; // 最小连接数 pool.MinConnections = 3; // 最大连接数 pool.MaxConnections = 5; // 连接的最大空闲时间，下面设置为6个小时（单位ms），超过这个设置时间，连接会被释放掉 pool.MaxIdle = 1000 * 60 * 60 * 6; // socket连接的超时时间，下面设置表示不超时（单位ms），即一直保持链接状态 pool.SocketConnectTimeout = 0; // 通讯的超时时间，下面设置为3秒（单位ms），.Net版本没有实现 pool.SocketTimeout = 1000 * 3; // 维护线程的间隔激活时间，下面设置为30秒（单位s），设置为0时表示不启用维护线程 pool.MaintenanceSleep = 30; // 设置SocktIO池的故障标志 pool.Failover = true; // 是否对TCP/IP通讯使用nalgle算法，.net版本没有实现 pool.Nagle = false; // socket单次任务的最大时间（单位ms），超过这个时间socket会被强行中端掉，当前任务失败。 pool.MaxBusy = 1000 * 10; pool.Initialize(); cache = new MemcachedClient(); // 是否启用压缩数据：如果启用了压缩，数据压缩长于门槛的数据将被储存在压缩的形式 cache.EnableCompression = false; // 压缩设置，超过指定大小的都压缩 cache.CompressionThreshold = 1024 * 1024; } } class Program { static void Main(string[] args) { // 存入key为userName，value为Bobby的一个缓存 new AMemcached(\"poolName\").cache.Add(\"b\", 123); // AMemcached.cache.Add(\"userName\", \"Bobby\"); // 读出key为a的缓存值 var s = new AMemcached(\"poolName\").cache.Get(\"userName\"); // 输出 Console.WriteLine(s); Console.Read(); } } } 1.1.4. 说说 memcached 的故障转移处理 // 设置 SocketIO 池的故障标志 pool.Failover = true; Note：memcached 的故障转移是一套正常节点发生故障变为死节点时的处理机制。 开启故障转移：如果发生 socket 异常，则该节点被添加到存放死节点属性的 hostDead 中，新请求被映射到 dead server，检测尝试连接死节点的时间间隔属性 hostDeadDuration（默认设置为 100ms），如果没有达到设定的间隔时间则 key 会被映射到可用的 server 处理，如果达到了时间间隔，则尝试重新链接，连接成功将此节点从 hostDead 中去除，连接失败则间隔时间翻倍存放，下次重新连接时间会被拉长。 不开启故障转移：新的请求都会被映射到 dead server 上，尝试重新建立 socket 链接，如果连接失败，返回 null 或者操作失败。 1.1.5. 说说 key-value 中的 key 与 value key 在服务端的长度限制为 250 个字符，建议使用较短的 key 但不要重复。 value 的大小限制为 1mb，如果大拉，可以使用压缩，如果还大，那可能拆分到多个 key 中。 1.2. Memcached 客户端使用封装 1.2.1. 抽象出来了一个接口 using System; namespace Tdf.Memcached { public interface IMemcached { void Add(string key, object value); void Add(string key, object value, DateTime expiredDateTime); void Update(string key, object value); void Update(string key, object value, DateTime expiredDateTime); void Set(string key, object value); void Set(string key, object value, DateTime expiredTime); void Delete(string key); object Get(string key); bool KeyExists(string key); } } 1.2.2. MemcacheHelper.cs using Memcached.ClientLibrary; using System; using System.Configuration; namespace Tdf.Memcached { /// /// 基于Memcached.ClientLibrary 封装使用 Memcached 信息 /// 读取缓存存放在服务器 /// public class MemcacheHelper { /// /// 字段_instance,存放注册的缓存信息 /// private static MemcacheHelper _instance; /// /// 缓存客户端 /// private readonly MemcachedClient _client; /// /// 受保护类型的缓存对象，初始化一个新的缓存对象 /// protected MemcacheHelper() { // 读取app.Config中需要缓存的服务器地址信息，可以传递多个地址，使用\";\"分隔 string[] serverList = ConfigurationManager.AppSettings[\"readWriteHosts\"].Split(new char[] { ';' }); try { // 初始化池 var sockIoPool = SockIOPool.GetInstance(); // 设置服务器列表 sockIoPool.SetServers(serverList); // 各服务器之间负载均衡的设置比例 sockIoPool.SetWeights(new int[] { 1 }); // 初始化时创建连接数 sockIoPool.InitConnections = 3; // 最小连接数 sockIoPool.MinConnections = 3; // 最大连接数 sockIoPool.MaxConnections = 5; // 连接的最大空闲时间，下面设置为6个小时（单位ms），超过这个设置时间，连接会被释放掉 sockIoPool.MaxIdle = 1000 * 60 * 60 * 6; // socket连接的超时时间，下面设置表示不超时（单位ms），即一直保持链接状态 sockIoPool.SocketConnectTimeout = 0; // 通讯的超时时间，下面设置为3秒（单位ms）,.Net版本没有实现 sockIoPool.SocketTimeout = 1000 * 3; // 维护线程的间隔激活时间，下面设置为30秒（单位s），设置为0时表示不启用维护线程 sockIoPool.MaintenanceSleep = 30; // 设置SocktIO池的故障标志 sockIoPool.Failover = true; // 是否对TCP/IP通讯使用nalgle算法，.net版本没有实现 sockIoPool.Nagle = false; // socket单次任务的最大时间（单位ms），超过这个时间socket会被强行中端掉，当前任务失败。 sockIoPool.MaxBusy = 1000 * 10; sockIoPool.Initialize(); // 实例化缓存对象 _client = new MemcachedClient(); // 是否启用压缩数据：如果启用了压缩，数据压缩长于门槛的数据将被储存在压缩的形式 _client.EnableCompression = false; // 压缩设置，超过指定大小的都压缩 _client.CompressionThreshold = 1024 * 1024; } catch (Exception ex) { // 错误信息写入事务日志 throw new Exception(ex.Message); } } /// /// 获取缓存的实例对象，方法调用的时候使用 /// /// public static MemcacheHelper GetInstance() { return _instance; } /// /// 添加缓存信息(如果存在缓存信息则直接重写设置，否则添加) /// 使用：MemcacheHelper.GetInstance().Add(key,value) /// /// 需要缓存的键 /// 需要缓存的值 public void Add(string key, object value) { if (_client.KeyExists(key)) { _client.Set(key, value); } _client.Add(key, value); } /// /// 添加缓存信息 /// 使用：MemcacheHelper.GetInstance().Add(key,value,Datetime.Now()) /// /// 需要缓存的键 /// 需要缓存的值 /// 设置的缓存的过时时间 public void Add(string key, object value, DateTime expiredDateTime) { _client.Add(key, value, expiredDateTime); } /// /// 修改缓存的值 /// 使用：MemcacheHelper.GetInstance().Update(key,value) /// /// 需要修改的键 /// 需要修改的值 public void Update(string key, object value) { _client.Replace(key, value); } /// /// 修改缓存的值 /// 使用：MemcacheHelper.GetInstance().Update(key,value,Datetime.Now()) /// /// 需要修改的键 /// 需要修改的值 /// 设置的缓存的过时时间 public void Update(string key, object value, DateTime expiredDateTime) { _client.Replace(key, value, expiredDateTime); } /// /// 设置缓存 /// 使用：MemcacheHelper.GetInstance().Set(key,value) /// /// 设置缓存的键 /// 设置缓存的值 public void Set(string key, object value) { _client.Set(key, value); } /// /// 设置缓存，并修改过期时间 /// 使用：MemcacheHelper.GetInstance().Set(key,value,Datetime.Now()) /// /// 设置缓存的键 /// 设置缓存的值 /// 设置缓存过期的时间 public void Set(string key, object value, DateTime expiredTime) { _client.Set(key, value, expiredTime); } /// /// 删除缓存 /// 使用：MemcacheHelper.GetInstance().Delete(key) /// /// 需要删除的缓存的键 public void Delete(string key) { _client.Delete(key); } /// /// 获取缓存的值 /// 使用：MemcacheHelper.GetInstance().Get(key) /// /// 传递缓存中的键 /// 返回缓存在缓存中的信息 public object Get(string key) { return _client.Get(key); } /// /// 缓存是否存在 /// 使用：MemcacheHelper.GetInstance().KeyExists(key) /// /// 传递缓存中的键 /// 如果为true，则表示存在此缓存，否则比表示不存在 public bool KeyExists(string key) { return _client.KeyExists(key); } /// /// 注册Memcache缓存(在Global.asax的Application_Start方法中注册) /// 使用：MemcacheHelper.RegisterMemcache(); /// public static void RegisterMemcache() { if (_instance == null) { _instance = new MemcacheHelper(); } } } } 1.3. App.config 1.3.1. Program.cs using System; using Tdf.Memcached; namespace Tdf.MemcachedTest { class Program { static void Main(string[] args) { // 注册Memcache缓存 MemcacheHelper.RegisterMemcache(); // 添加缓存信息(如果存在缓存信息则直接重写设置，否则添加) MemcacheHelper.GetInstance().Add(\"userName\", \"Bobby\"); // 缓存是否存在 var tf = MemcacheHelper.GetInstance().KeyExists(\"userName\"); Console.WriteLine(tf); // 获取缓存的值 var s = MemcacheHelper.GetInstance().Get(\"userName\"); Console.WriteLine(s); Console.Read(); } } } 到此，我们已经完成了一个最小化的 memcached 集群读写测试 Demo。但是，在实际的开发场景中，远不仅仅是存储一个字符串，更多的是存储一个自定义的类的实例对象。这就需要使用到序列化，下面我们来新加一个类 Claim，让其作为可序列化的对象来存储进 Memcached 中。注意：需要为该类加上 [Serializable] 的特性！ using System; using Tdf.Memcached; namespace Tdf.MemcachedTest { [Serializable] public class Claim { public int UserId { get; set; } public string UserName { get; set; } } class Program { static void Main(string[] args) { // 注册Memcache缓存 MemcacheHelper.RegisterMemcache(); // 自定义对象存储 Claim claim = new Claim(); claim.UserId = 694802856; claim.UserName = \"难念的经\"; MemcacheHelper.GetInstance().Add(\"Claim\", claim); Claim newMyObj = MemcacheHelper.GetInstance().Get(\"Claim\") as Claim; Console.WriteLine(\"Hello,My UserId is {0} and UserName is {1}\", newMyObj.UserId, newMyObj.UserName); Console.Read(); } } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/memcache/memcached分布式原理.html": {
    "url": "Basic/大型网站架构/memcache/memcached分布式原理.html",
    "title": "memcached 分布式原理",
    "keywords": "",
    "body": "1. Memcached 分布式原理1.1. Memcached 内存管理机制1.2. Memcached 算法1.2.1. 余数计算分散法1.2.2. Consistent Hashing 算法1.2.3. 优化的 Consistent Hashing 算法1. Memcached 分布式原理 添加新的键值对数据 从图中可以看出，Memcached 虽然称为“分布式”缓存服务器，但服务器端并没有“分布式”功能，而是完全由客户端程序库实现的。服务端之间没有任何联系，数据存取都是通过客户端的算法实现的。当客户端要存取数据时，首先会通过算法查找自己维护的服务器哈希列表，找到对应的服务器后，再将数据存往指定服务器。例如：上图中应用程序要新增一个 的键值对，它通过 set 操作提交给 Memcached 客户端，客户端通过一定的哈希算法（比如：一般的求余函数或者强大的一致性 Hash 算法）从服务器列表中计算出一个要存储的服务器地址，最后将该键值对存储到计算出来的服务器里边。 获取已存在的键值对数据 上图中应用程序想要获取 Key 为 tokyo 的 Value，于是它向 Memcached 客户端提交了一个 Get 请求，Memcached 客户端还是通过算法从服务器列表查询哪台服务器存有 Key 为 tokyo 的 Value（即选择刚刚 Set 到了哪台服务器），如果查到，则向查到的服务器请求返回 Key 为 tokyo 的数据。 1.1. Memcached 内存管理机制 Memcached 通过预分配指定的内存空间来存取数据，所有的数据都保存在 memcached 内置的内存中。利用 Slab Allocation 机制来分配和管理内存。按照预先规定的大小，将分配的内存分割成特定长度的内存块，再把尺寸相同的内存块分成组，这些内存块不会释放，可以重复利用。当存入的数据占满内存空间时，Memcached 使用 LRU 算法自动删除不使用的缓存数据。Memcached 是为缓存系统设计的，因此没有考虑数据的容灾问题，和机器的内存一样，重启机器将会丢失，如果希望服务重启数据依然能保留，那么就需要 sina 网开发的 Memcached 持久性内存缓冲系统，当然还有常见的 NOSQL 服务如 redis。默认监听端口：11211 1.2. Memcached 算法 1.2.1. 余数计算分散法 余数计算分散法是 memcached 标准的分布式方法，算法如下： CRC($key)%N 求得传入键的整数哈希值（ int hashCode ）。 使用计算出的 hashCode 除以服务器台数 (N) 取余数（ C = hashCode % N ） 在 N 台服务器中选择序号为 C 的服务器。 余数计算的方法简单，数据的分散性也相当优秀，但也有其缺点。 那就是当添加或移除服务器时，缓存重组的代价相当巨大。 添加服务器后，余数就会产生巨变，这样就无法获取与保存时相同的服务器， 从而影响缓存的命中率。 1.2.2. Consistent Hashing 算法 首先求出 memcached 服务器节点的哈希值，并将其分配到 0 ～ 2^32 的圆上，这个圆我们可以把它叫做值域，然后用同样的方法求出存储数据键的哈希值，并映射到圆上。然后从数据映射到的位置开始顺时针查找，将数据保存到找到的最近服务器上，如果超过 0~2^32 仍找不到，就会保存在第一台 memcached 服务器上： memcached 基本原理: 再抛出上面的问题，如果新添加或移除一台机器，在 consistent Hashing 算法下会有什么影响。上图中假设有四个节点，我们再添加一个节点叫 node5: 添加了 node 节点之后: node5 被放在了 node4 与 node2 之间，本来映射到 node2 和 node4 之间的区域都会找到 node4，当有 node5 的时候，node5 和 node4 之间的还是找到 node4，而 node5 和 node2 之间的此时会找到 node5，因此当添加一台服务器的时候受影响的仅仅是 node5 和 node2 区间。由于 KEY 总是顺时针查找距离其最近的节点，因此新加入的节点只影响整个环中的一部分 1.2.3. 优化的 Consistent Hashing 算法 上面可以看出使用 consistent Hashing 最大限度的抑制了键的重新分配，且有的 consistent Hashing 的实现方式还采用了虚拟节点的思想。问题起源于使用一般 hash 函数的话，服务器的映射地点的分布非常不均匀，从而导致数据库访问倾斜，大量的 key 被映射到同一台服务器上。为了避免这个问题，引入了虚拟节点的机制，为每台服务器计算出多个 hash 值，每个值对应环上的一个节点位置，这种节点叫虚拟节点。而 key 的映射方式不变，就是多了层从虚拟节点再映射到物理机的过程。这种优化下尽管物理机很少的情况下，只要虚拟节点足够多，也能够使用得 key 分布的相对均匀。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/redis/": {
    "url": "Basic/大型网站架构/redis/",
    "title": "Basic/大型网站架构/redis",
    "keywords": "",
    "body": "1. TOC1. TOC 1Redis 在 Windows 上的安装与配置 2Redis API 与常用数据类型简介 3Redis 作为消息队列服务场景应用案例 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Basic/大型网站架构/redis/1Redis在Windows上的安装与配置.html": {
    "url": "Basic/大型网站架构/redis/1Redis在Windows上的安装与配置.html",
    "title": "1Redis 在 Windows 上的安装与配置",
    "keywords": "",
    "body": "1. Redis1.1. Redis 在 Windows 上的安装与配置1.1.1. 参考文献1.1.2. 附件下载1. Redis Redis 是一个开源的，使用 C 语言编写，面向“键/值”（Key/Value）对类型数据的分布式 NoSQL 数据库系统，特点是高性能、持久存储、适应高并发的应用场景。因此，可以说 Redis 纯粹为应用而产生，它是一个高性能的 key-value 数据库，并且还提供了多种语言的 API。那么，也许我们会问：到底性能如何呢？以下是官方的 bench-mark 数据： 测试完成了50 个并发执行100000 个请求。 设置和获取的值是一个 256 字节字符串。 Linux box 是运行 Linux 2.6,这是 X3320 Xeon 2.5 ghz。 文本执行使用 loopback 接口(127.0.0.1)。 结果:读的速度是 110000 次/s,写的速度是 81000 次/s 。（当然不同的服务器配置性能也有所不同）。 和 Memcached 类似，Redis 支持存储的 value 类型相对更多，包括 string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和 hash（哈希类型）。这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis 支持各种不同方式的排序。与 Memcached 一样，为了保证效率，数据都是缓存在内存中。区别的是Redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave(主从)同步（数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。）。 因此，Redis 的出现，很大程度补偿了 Memcached 这类 key/value 存储的不足，在部分场合可以对关系数据库起到很好的补充作用。 1.1. Redis 在 Windows 上的安装与配置 前面介绍了一大堆，现在开始真刀实干！首先，肯定是安装 Redis，这里我们选择比较熟悉的 Windows 平台来进行安装。既然是 Windows 平台，那么肯定要选择一个 Windows 版本的 Redis 安装包（其实 NoSQL 大部分都是部署在 Linux 服务器上得，什么原因？大家都懂得，开源+免费=成熟的服务器方案）。 （1）进入 GitHub 的 Redis 相关包下载页面：https://github.com/MSOpenTech/redis （2）选择相应版本，我这里选择的是 2.6 的版本，点击 Download ZIP 按钮进行下载； （3）打开压缩包，可以看到我们下载的其实是一个完整的 Redis-2.6 的包，包含了 bin、src 等文件夹，src 是源码，而 bin 则是编译好的执行文件，也是我们主要使用的东东。进入 bin 目录，可以看到里面又有两个目录，一个是 32 位操作系统使用的，另一个则是 64 位操作系统使用的。 （4）我所使用的是 64 位系统，所以我将 redisbin64.zip 拷贝出来，解压后移动至我的 D:/Redis 目录中，可以看到解压后的内容包含以下的一些可执行 exe 文件： 下面来看看这几个可执行 exe 文件都是干嘛用的？ ①redis-server.exe：服务程序，也是最最最核心的一个程序。说到底，Redis 也就是我们服务器系统上一直运行的一个服务甚至就是一个进程而已。 ②redis-check-dump.exe：本地数据库检查 ③redis-check-aof.exe：更新日志检查 ④redis-benchmark.exe：性能测试，用以模拟同时由 N 个客户端发送 M 个 SETs/GETs 查询。上面所提到的测试结果就是使用的该程序来进行的。 ⑤redis-cli.exe： 服务端开启后，我们的客户端就可以输入各种命令测试了，例如 GET、SET 等操作； 另外，将刚刚下载的包里边的redis.conf默认配置文件拷贝到工作目录中（我的是 D:/Redis），redis.conf 主要是一些 Redis 的默认服务配置，包括默认端口号（一般默认 6379）啊之类的配置。 （5）既然我们知道了 redis-server.exe 是最核心的一个程序，那么我们就首先来将它开启。这里需要在 Windows 的命令行界面中来开启，首先在运行窗口输入 cmd 进入命令窗口，使用 cd 命令切换到指定的目录（我是将刚刚解压的文件放在了 D:/Redis 文件夹下） （6）最后就是惊心动魄地开启 Redis 的服务了，输入一句简单的命令：redis-server.exe redis.conf 这里需要注意的是：开启 Redis 服务后，命令行窗口不要关闭，一旦关闭，Redis 服务也会相应关闭。因此，我们一般会将其改为 Windows 服务，并且设置为开机自动启动，就像我们数据库服务器中的 SQL Server 服务和 Web 服务器中的 IIS 服务一样。 （7）究竟我们的 Redis 安装好了没呢？我们可以通过新打开（记得是新打开一个，而不是将原来那个关闭了）一个 cmd 窗口使用 redis-cli.exe 来测试一下：redis-cli.exe -h 服务器 IP –p 端口 （8）既然每次都需要在命令窗口中开启 Redis 服务不爽，那我们就动手将其改为 Windows 服务，让它自动启动。通过在网上查找，我在 CSDN 找到了一个批处理文件和一个 RedisService 的可执行文件，并将这两个文件拷贝到指定的 Redis 目录（我的是 D:/Redis）： 其中，install-service 这个批处理文件的代码如下： @echo off set cur_path=%cd% sc create redis-instance binpath= \"\\\"%cur_path%\\RedisService.exe\\\" %cur_path%\\redis.conf\" start= \"auto\" DisplayName= \"Redis\" 意思是在我们的 Windows 中创建一个 Redis 的服务实例，指定要启动的程序路径与配置文件路径。这里需要注意的是：RedisService 是另外的一个 exe，不是我们刚刚下载下来就有的，这个 RedisService.exe 的下载地址为：http://pan.baidu.com/s/1sjrvmTf。启动模式设置为 auto 代表自动启动，显示的服务名称为 Redis。这样，一个 bat 文件就做好了，点击运行之后，一个 Redis 的 Windows 服务也出现在了我们的 Windows 服务列表中，如下图所示： 1.1.1. 参考文献 （1）传智播客 Redis 公开课，王承伟主讲，http://bbs.itcast.cn/thread-26525-1-1.html （2）NoSQL 百度百科，http://baike.baidu.com/view/2677528.htm （3）孙立，《NoSQL 开篇—为什么使用 NoSQL》，http://www.infoq.com/cn/news/2011/01/nosql-why/ （4）Redis 百度百科，http://baike.baidu.com/view/4595959.htm （5）Ruthless，《Windows 下安装 Redis》，http://www.cnblogs.com/linjiqin/archive/2013/05/27/3101694.html （6）张善友，《在 Windows 上以服务方式运行 Redis》，http://www.cnblogs.com/shanyou/archive/2013/01/17/redis-on-windows.html 1.1.2. 附件下载 （1）Redis-2.6 服务包：http://pan.baidu.com/s/1dDEKojJ （2）Redis 注册 Windows 服务的批处理文件：http://pan.baidu.com/s/1jGJtNXs （3）Redis 注册 Windows 服务的启动程序（RedisServcie.exe）：http://pan.baidu.com/s/1sjrvmTf Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/redis/3Redis作为消息队列服务场景应用案例.html": {
    "url": "Basic/大型网站架构/redis/3Redis作为消息队列服务场景应用案例.html",
    "title": "3Redis 作为消息队列服务场景应用案例",
    "keywords": "",
    "body": "1. 一、消息队列场景简介1.1. 二、使用预置类型实现异常日志队列1.2. 三、使用 Redis 重构异常日志队列1.3. 四、小结1.3.1. 参考文献1.3.2. 附件下载1. 一、消息队列场景简介 在众多的实践当中，除了增加服务器数量配置服务器集群实现伸缩性架构设计之外，异步操作也被广泛采用。而异步操作中最核心的就是使用消息队列，通过消息队列，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务，改善网站系统的性能。在京东之类的电子商务网站促销活动中，合理地使用消息队列，可以有效地抵御促销活动刚开始就开始大量涌入的订单对系统造成的冲击。 消息队列服务器中有一个进程单独对消息队列进行处理，首先判断消息队列中是否有待处理的消息，如果有，则将其取出（出队操作，坚持“先进先出”的顺序，保证事务的准确性）进行相应地处理（比如这里是进行保存数据的操作，将数据插入到数据库服务器中的指定数据库里边，实质还是文件的 IO 操作）。就这样，通过消息队列将高并发用户请求进行异步操作，然后一一对消息队列进行出队的同步操作，也避免了并发控制的难题。 说到这里，大家可能会想到这尼玛不就是生产者消费者模式么？对的，消息队列就是生产者消费者模式的典型场景。简单地说，客户端不同用户发送的操作请求就是生产者，他们将要处理的事务存储到消息队列中，然后消息队列服务器的某个进程不停地将要处理的单个事务从消息队列中一个一个地取出来进行相应地处理，这就是消费者消费的过程。 下面我们将以异常日志为案例，介绍在.Net 中如何采用消息队列的思想解决并发问题。当然，消息队列只是解决并发问题的其中一种方式，在实际中往往需要结合多种不同的技术方式来共同解决，比如负载均衡、反向代理、集群等方案。这里，虽然以异常日志为案例，但是“麻雀虽小五脏俱全”，日志写入文件的高并发操作也同样适用于数据库的高并发，所以，研究这个案例是具有实际意义的。 1.1. 二、使用预置类型实现异常日志队列 在日常的 Web 应用中，异常日志的记录是一个十分重要的要点。因为，人无完人，系统也一样，难免会在什么时候出一个测试阶段未能完全测试到的异常。这时候，不能将异常信息直接显示给客户，那样既不友好也不安全。所以，一般都采用将异常信息记录到日志文件中（比如某个 txt 文件，数据库中某个表等），然后技术支持人员通过查看异常日志，分析异常原因，改进 BUG 重新发布，保障系统正常运行。 在用户的各种操作中，如果出现异常的时间一致，那么记录异常日志的操作就会成为并发操作，而记录异常日志又属于文件的 IO 操作（其实数据库的读写归根结底也是对文件即对磁盘进行的 IO 操作），因此很有可能带来并发控制的一系列问题。在以往的编码实践中，我们可以通过给不同的 IO 请求进行加锁（C#中的 lock），等第一个请求完成写入后释放锁，第二个请求再获得锁，进行 IO 操作，然后释放掉，一直到第 N 个请求释放后结束。这种方式，虽然解决了并发操作带来的问题，但是通过加锁延迟了用户响应请求的时间（比如第一个正在 IO 写入操作时，后面的均处于等待状态），并且加锁也会给服务器带来一定的性能负担，造成服务器性能的下降。 基于以上原因，我们采用消息队列的思想将异常日志的记录操作改为队列版，这里我们先不采用 Redis，直接使用.Net 为我们提供的预置类型-Queue。接下来，就让我们动手开刀，写起来。 新建一个 ASP.NET MVC 4 项目，选择“基本”类型，视图引擎选择“Razor”。 既然是异常日志记录，首先得有异常。这时，我们脑海中想到了那个经典的异常：DividedByZeroException。于是，在 Controllers 文件夹中新建一个 Controller，取名为 Home（这里因为 Global 文件中的默认路由就指向了 Home 控制器中的 Index 这个 Action），在 HomeControlle r 中修改 Index 这个 Action 的代码如下： public ActionResult Index() { int a = 10; int b = 0; int c = a / b; //会抛一个DividedByZero的异常 return View(); } 在 ASP.NET MVC 项目中，我们需要在 Global.asax 中的 Application_Start 这个事件中修改全局过滤器（主要是 App_Start 中的 FilterConfig 类的 RegisterGlobalFilters 这个方法），让系统支持对异常的全局处理操作（我们这里主要是对异常进行记录到指定文件中）。 public class FilterConfig { public static void RegisterGlobalFilters(GlobalFilterCollection filters) { // MyExceptionFilterAttribute 继承自 HandleError，主要作用是将异常信息写入日志文件中 filters.Add(new MyExceptionFilterAttribute()); // 默认的异常记录类 filters.Add(new HandleErrorAttribute()); } } 通过改写过滤器配置，我们向全局过滤器中注册了一个异常处理的过滤器配置，那么这个 MyExceptionFilterAttribute 类又是如何编写的呢？ public class MyExceptionFilterAttribute : HandleErrorAttribute { //版本1：使用预置队列类型存储异常对象 public static Queue ExceptionQueue = new Queue(); public override void OnException(ExceptionContext filterContext) { //将异常信息入队 ExceptionQueue.Enqueue(filterContext.Exception); //跳转到自定义错误页 filterContext.HttpContext.Response.Redirect(\"~/Common/CommonError.html\"); base.OnException(filterContext); } } 通过使该类继承 HandlerErrorAttribute 并使其覆写 OnException 这个事件，代表在异常发生时可以进行的操作。而我们在这儿主要通过一个异常队列将获取的异常写入队列，然后跳转到自定义错误页：~/Common/CommonError.html，这个错误页很简单，就是简单的显示“系统发生错误，5 秒后自动跳转到首页” 错误 .timecss { color: red; font-weight: bold; } function delayJump(url) { var timeValue = parseInt(document.getElementById(\"time\").innerHTML); if (timeValue > 0) { timeValue--; document.getElementById(\"time\").innerHTML = timeValue; } else { window.location.href = url; } setTimeout(\"delayJump('\" + url + \"')\", 1000); } 抱歉，处理您的请求时出错。将会在5秒后自动跳转到首页，请耐心等候。 var destUrl = \"/Home/NoError\"; delayJump(destUrl); 走到这里，生产者消费者模式中生产者的任务已经完成了，接下来消费者就需要开始消费了。也就是说，消息队列已经建好了，我们什么时候从队列中去任务，在哪里执行？怎么样执行？通过上面的介绍，我们知道，在专门的消息队列服务器中有一个进程在始终不停地监视消息队列，如果有需要待办的任务信息，则会立即从队列中取出来执行相应的操作，直到队列为空为止。于是，思路有了，我们马上来实现以下。这个消息监视的操作也是一个全局操作，在系统启动时就会一直运行，于是它也应该写在 Application_Start 这个全局起始事件里边，于是按照标准的配置写法，我们在 Application_Start 中添加了如下代码： protected void Application_Start() { AreaRegistration.RegisterAllAreas(); WebApiConfig.Register(GlobalConfiguration.Configuration); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); //自定义事件注册 MessageQueueConfig.RegisterExceptionLogQueue(); } 那么，这个 MessageQueueConfig.RegisterExceptionLogQueue()又是怎么写的呢？ public class MessageQueueConfig { public static void RegisterExceptionLogQueue() { string logFilePath = HttpContext.Current.Server.MapPath(\"/App_Data/\"); //通过线程池开启线程，不停地从队列中获取异常信息并将其写入日志文件 ThreadPool.QueueUserWorkItem(o => { while (true) { try { if (MyExceptionFilterAttribute.ExceptionQueue.Count > 0) { Exception ex = MyExceptionFilterAttribute.ExceptionQueue.Dequeue(); //从队列中出队，获取异常对象 if (ex != null) { //构建完整的日志文件名 string logFileName = logFilePath + DateTime.Now.ToString(\"yyyy-MM-dd\") + \".txt\"; //获得异常堆栈信息 string exceptionMsg = ex.ToString(); //将异常信息写入日志文件中 File.AppendAllText(logFileName, exceptionMsg, Encoding.Default); } } else { Thread.Sleep(1000); //为避免CPU空转，在队列为空时休息1秒 } } catch (Exception ex) { MyExceptionFilterAttribute.ExceptionQueue.Enqueue(ex); } } }, logFilePath); } } 现在，让我们来看看这段代码： ① 首先定义 Log 文件存放的文件夹目录，这里我们一般放到 App_Data 里边，因为放到这里边外网是无法访问到的，可以防止下载操作； ② 其次通过线程池 ThreadPool 开启一个线程，不停地监听消息队列里边的待办事项个数，如果个数>0，则进行出队（FIFO，先入队的先出队）操作。这里主要是取出具体的异常实例对象，并将异常的具体堆栈信息追加写入到指定命名格式的文件中。 许多应用程序创建的线程都要在休眠状态中消耗大量时间，以等待事件发生。其他线程可能进入休眠状态，只被定期唤醒以轮询更改或更新状态信息。线程池通过为应用程序提供一个由系统管理的辅助线程池使您可以更为有效地使用线程。关于线程池的更多信息请访问：http://msdn.microsoft.com/zh-cn/library/system.threading.threadpool(v=VS.90).aspx.aspx>) ③ 如果该线程检测到消息队列中无待办事项，则使用 Thread.Sleep 使线程“休息”一会，避免了 CPU 空转（从理论上来说，CPU 资源是很珍贵的，应该尽量提高 CPU 的利用率）。 最后，我们来看看效果如何？ ① 首先，高大上的 VS 捕捉到了异常-DividedByZeroException： ② 按照我们的全局异常处理过滤器，会将此异常记入队列中，并返回 HTTP 302 重定向跳转到自定义错误页面 ③ 最后，打开 App_Data 文件夹，查看日志文件： 到这里时，我们已经借助消息队列的思想完成了一个自定义的异常日志队列服务。但也许有朋友会说，这个跟 Redis 有关系么？异常日志不都是用 Log4Net 么？不要着急，后边我们就会使用 Redis+Log4Net 来重构这个异常日志队列服务。 1.2. 三、使用 Redis 重构异常日志队列 开启 Redis 的服务，这里我们使用命令开启 Redis 服务（之前已经将 Redis 注册到了 Windows 系统服务中了嘛，么么嗒）：net start redis-instance，当然，也可以通过在 Windows 服务列表中开启。 在刚刚的版本 1 的 Demo 中新建一个文件夹，命名为 Lib，将 ServiceStack.Redis 的 dll 和 Log4Net 的 dll 都拷贝进去。然后，在引用中添加对 Lib 文件夹中所有 dll 的引用。 重写 MyExceptionFilterAttribute 这个全局异常信息过滤器。这里使用到了 Redis 的客户端连接池，每次连接时都是从池中取，不需要每次都创建，节省了时间和资源，提高了资源利用率。对于，多台 Redis 服务器组成的集群而言，这里需要指定多个形如 IP 地址:端口号 的字符串数组。 public class MyExceptionFilterAttribute : HandleErrorAttribute { //版本2：使用Redis的客户端管理器（对象池） public static IRedisClientsManager redisClientManager = new PooledRedisClientManager(new string[] { //如果是Redis集群则配置多个{IP地址:端口号}即可 //例如: \"10.0.0.1:6379\",\"10.0.0.2:6379\",\"10.0.0.3:6379\" \"127.0.0.1:6379\" }); //从池中获取Redis客户端实例 public static IRedisClient redisClient = redisClientManager.GetClient(); public override void OnException(ExceptionContext filterContext) { //将异常信息入队 redisClient.EnqueueItemOnList(\"ExceptionLog\", filterContext.Exception.ToString()); //跳转到自定义错误页 filterContext.HttpContext.Response.Redirect(\"~/Common/CommonError.html\"); base.OnException(filterContext); } } 在 Web.config 中加入 Log4Net 的详细配置 --> Log4Net 是用来记录日志的一个常用组件（Log4J 的移植版本），可以将程序运行过程中的信息输出到一些地方（文件、数据库、EventLog 等）。由于 Log4Net 不是本篇博文介绍的重点，所以对 Log4Net 不熟悉的朋友，请在博客园首页搜索：Log4Net，浏览其详细的介绍。 其次，在 App_Start 文件夹中添加一个类，取名为 LogConfig，定义一个静态方法：RegisterLog4NetConfigure，具体代码只有一行，实现了 Log4Net 配置的初始化操作。 public class LogConfig { public static void RegisterLog4NetConfigure() { //获取Log4Net配置信息(配置信息定义在Web.config文件中) log4net.Config.XmlConfigurator.Configure(); } } 最后，在 Global.asax 中的 Application_Start 方法中添加一行代码，注册 Log4Net 的配置： protected void Application_Start() { AreaRegistration.RegisterAllAreas(); WebApiConfig.Register(GlobalConfiguration.Configuration); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); //自定义事件注册 MessageQueueConfig.RegisterExceptionLogQueue(); LogConfig.RegisterLog4NetConfigure(); } 改写 MessageQueueConfig 中的 RegisterExceptionLogQueue 方法。这里就不再需要从预置类型 Queue 中取任务了，而是 Redis 中取出任务出队进行相应处理。这里，我们使用了 Log4Net 进行异常日志的记录工作。注意在代码顶部添加对 log4net 的引用：using log4net; public static void RegisterExceptionLogQueue() { //通过线程池开启线程，不停地从队列中获取异常信息并将其写入日志文件 ThreadPool.QueueUserWorkItem(o => { while (true) { try { if (MyExceptionFilterAttribute.redisClient.GetListCount(\"ExceptionLog\") > 0) { //从队列中出队，获取异常对象 string errorMsg = MyExceptionFilterAttribute.redisClient.DequeueItemFromList(\"ExceptionLog\"); if (!string.IsNullOrEmpty(errorMsg)) { //使用Log4Net写入异常日志 ILog logger = LogManager.GetLogger(\"Log\"); logger.Error(errorMsg); } } else { Thread.Sleep(1000); //为避免CPU空转，在队列为空时休息1秒 } } catch (Exception ex) { MyExceptionFilterAttribute.redisClient.EnqueueItemOnList(\"ExceptionLog\", ex.ToString()); } } }); } 调试验证是否能正常写入 App_Data 文件的日志中，发现写入的异常日志如下，格式好看，信息详细，圆满完成了我们的目的。 1.3. 四、小结 使用消息队列将调用异步化，可以改善网站系统的性能：消息队列具有很好的削峰作用，即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。在电商网站的促销活动中，合理使用消息队列，可以有效地抵御促销活动刚开始大量涌入的订单对系统造成的冲击。本文使用消息队列的思想，借助 Redis+Log4Net 完成了一个超简单的异常日志队列的应用案例，可以有效地解决在多线程操作中对日志文件的并发操作带来的一些问题。同样地，借助消息队列的思想，我们也可以完成对数据库的高并发的消息队列方案。所以，麻雀虽小五脏俱全，理解好了这个案例，相信对我们这些菜鸟码农是有所裨益的。同样，也请大牛们一笑而过，多多指教菜鸟们一步一步地提高，谢谢了！后边，我们会探索一下 Redis 的集群、主从复制，以及在 VMWare 中建立几台虚拟机来构建主从结构，并使用 Redis 记录网站中重要的 Session 会话对象，或者是电商项目中常见的商品类目信息等。但是，本人资质尚浅，并且都是一些初探性质的学习，如有错误和不当，还请各位园友多多指教！ 1.3.1. 参考文献 （1）传智播客.Net 学院王承伟，数据优化技术之 Redis 公开课，http://bbs.itcast.cn/thread-26525-1-1.html （2）Sanfilippo/贾隆译，《几点建议，让 Redis 在你的系统中发挥更大作用》，http://database.51cto.com/art/201107/276333.htm （3）NoSQLFan，《Redis 作者谈 Redis 应用场景》，http://blog.nosqlfan.com/html/2235.html （4）善心如水，《C#中使用 Log4Net 记录日志》，http://www.cnblogs.com/wangsaiming/archive/2013/01/11/2856253.html （5）逆心，《ServiceStack.Redis 之 IRedisClient》，http://www.cnblogs.com/kissdodog/p/3572084.html （6）李智慧，《大型网站技术架构-核心原理与案例分析》，http://item.jd.com/11322972.html 1.3.2. 附件下载 （1）版本 1：使用预置类型的异常日志队列 Demo，http://pan.baidu.com/s/1nt5G7Fj （2）版本 2：使用 Redis+Log4Net 的异常日志队列 Demo，http://pan.baidu.com/s/1i3gMnnJ Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/Web系统大规模并发——电商秒杀与抢购.html": {
    "url": "Basic/大型网站架构/Web系统大规模并发——电商秒杀与抢购.html",
    "title": "Web 系统大规模并发——电商秒杀与抢购",
    "keywords": "",
    "body": "1.1. 一、大规模并发带来的挑战1.1.1. 1. 请求接口的合理设计1.1.2. 2. 高并发的挑战：一定要“快”1.1.3. 3. 重启与过载保护1.2. 二、作弊的手段：进攻与防守1.2.1. 1. 同一个账号，一次性发出多个请求1.2.2. 3. 多个账号，不同 IP 发送不同请求1.2.3. 4. 火车票的抢购**1.3. 三、高并发下的数据安全1.3.1. 超发的原因1.3.2. 1. 悲观锁思路1.3.3. 2. FIFO 队列思路1.3.4. 3. ==乐观锁思路==1.1. 一、大规模并发带来的挑战 在过去的工作中，我曾经面对过 5w 每秒的高并发秒杀功能，在这个过程中，整个 Web 系统遇到了很多的问题和挑战。 1.1.1. 1. 请求接口的合理设计 一个秒杀或者抢购页面，通常分为 2 个部分，一个是静态的 HTML 等内容，另一个就是参与秒杀的 Web 后台请求接口。 通常静态 HTML 等内容，是通过 CDN 的部署，一般压力不大，核心瓶颈实际上在后台请求接口上。这个后端接口，必须能够支持高并发请求，同时，非常重要的一点，必须尽可能“快”，在最短的时间里返回用户的请求结果。为了实现尽可能快这一点，接口的后端存储使用内存级别的操作会更好一点。仍然直接面向 MySQL 之类的存储是不合适的，如果有这种复杂业务的需求，都建议采用异步写入。 当然，也有一些秒杀和抢购采用“滞后反馈”，就是说秒杀当下不知道结果，一段时间后才可以从页面中看到用户是否秒杀成功。但是，这种属于“偷懒”行为，同时给用户的体验也不好，容易被用户认为是“暗箱操作”。 1.1.2. 2. 高并发的挑战：一定要“快” 通常衡量一个 Web 系统的吞吐率的指标是 QPS（Query Per Second，每秒处理请求数），解决每秒数万次的高并发场景，这个指标非常关键。举个例子，我们假设处理一个业务请求平均响应时间为 100ms，同时，系统内有 20 台 Apache 的 Web 服务器，配置 MaxClients 为 500 个（表示 Apache 的最大连接数目）。 那么，Web 系统的理论峰值 QPS 为（理想化的计算方式）：20*500/0.1 = 100000 （10 万 QPS） 咦？我们的系统似乎很强大，1 秒钟可以处理完 10 万的请求，5w/s 的秒杀似乎是“纸老虎”哈。实际情况，当然没有这么理想。在高并发的实际场景下，机器都处于高负载的状态，在这个时候平均响应时间会被大大增加。 就 Web 服务器而言，Apache 打开了越多的连接进程，CPU 需要处理的上下文切换也越多，额外增加了 CPU 的消耗，然后就直接导致平均响应时间增加。因此上述的 MaxClient 数目，要根据 CPU、内存等硬件因素综合考虑，绝对不是越多越好。可以通过 Apache 自带的 abench 来测试一下，取一个合适的值。然后，我们选择内存操作级别的存储的 Redis，在高并发的状态下，存储的响应时间至关重要。网络带宽虽然也是一个因素，不过，这种请求数据包一般比较小，一般很少成为请求的瓶颈。负载均衡成为系统瓶颈的情况比较少，在这里不做讨论哈。 那么问题来了，假设我们的系统，在 5w/s 的高并发状态下，平均响应时间从 100ms 变为 250ms（实际情况，甚至更多）： 20*500/0.25 = 40000 （4 万 QPS） 于是，我们的系统剩下了 4w 的 QPS，面对 5w 每秒的请求，中间相差了 1w。 同理，某一个秒内，20*500 个可用连接进程都在满负荷工作中，却仍然有 1 万个新来请求，没有连接进程可用，系统陷入到异常状态也是预期之内。 其实在正常的非高并发的业务场景中，也有类似的情况出现，某个业务请求接口出现问题，响应时间极慢，将整个 Web 请求响应时间拉得很长，逐渐将 Web 服务器的可用连接数占满，其他正常的业务请求，无连接进程可用。 更可怕的问题是，是用户的行为特点，系统越是不可用，用户的点击越频繁，恶性循环最终导致“雪崩”（其中一台 Web 机器挂了，导致流量分散到其他正常工作的机器上，再导致正常的机器也挂，然后恶性循环），将整个 Web 系统拖垮。 1.1.3. 3. 重启与过载保护 如果系统发生“雪崩”，贸然重启服务，是无法解决问题的。最常见的现象是，启动起来后，立刻挂掉。这个时候，最好在入口层将流量拒绝，然后再将重启。如果是redis/memcache 这种服务也挂了，重启的时候需要注意“预热”，并且很可能需要比较长的时间。 秒杀和抢购的场景，流量往往是超乎我们系统的准备和想象的。这个时候，过载保护是必要的。如果检测到系统满负载状态，拒绝请求也是一种保护措施。在前端设置过滤是最简单的方式，但是，这种做法是被用户“千夫所指”的行为。更合适一点的是，将过载保护设置在 CGI 入口层，快速将客户的直接请求返回。 1.2. 二、作弊的手段：进攻与防守 秒杀和抢购收到了“海量”的请求，实际上里面的水分是很大的。不少用户，为了“抢”到商品，会使用“刷票工具”等类型的辅助工具，帮助他们发送尽可能多的请求到服务器。还有一部分高级用户，制作强大的自动请求脚本。这种做法的理由也很简单，就是在参与秒杀和抢购的请求中，自己的请求数目占比越多，成功的概率越高。 这些都是属于“作弊的手段”，不过，有“进攻”就有“防守”，这是一场没有硝烟的战斗哈。 1.2.1. 1. 同一个账号，一次性发出多个请求 部分用户通过浏览器的插件或者其他工具，在秒杀开始的时间里，以自己的账号，一次发送上百甚至更多的请求。实际上，这样的用户破坏了秒杀和抢购的公平性。 这种请求在某些没有做数据安全处理的系统里，也可能造成另外一种破坏，导致某些判断条件被绕过。例如一个简单的领取逻辑，先判断用户是否有参与记录，如果没有则领取成功，最后写入到参与记录中。这是个非常简单的逻辑，但是，在高并发的场景下，存在深深的漏洞。多个并发请求通过负载均衡服务器，分配到内网的多台 Web 服务器，它们首先向存储发送查询请求，然后，在某个请求成功写入参与记录的时间差内，其他的请求获查询到的结果都是“没有参与记录”。这里，就存在逻辑判断被绕过的风险。 应对方案： 在程序入口处，一个账号只允许接受 1 个请求，其他请求过滤。不仅解决了同一个账号，发送 N 个请求的问题，还保证了后续的逻辑流程的安全。实现方案，可以通过 Redis 这种内存缓存服务，写入一个标志位（只允许 1 个请求写成功，结合 watch 的乐观锁的特性），成功写入的则可以继续参加。 或者，自己实现一个服务，将同一个账号的请求放入一个队列中，处理完一个，再处理下一个。 2. 多个账号，一次性发送多个请求 很多公司的账号注册功能，在发展早期几乎是没有限制的，很容易就可以注册很多个账号。因此，也导致了出现了一些特殊的工作室，通过编写自动注册脚本，积累了一大批“僵尸账号”，数量庞大，几万甚至几十万的账号不等，专门做各种刷的行为（这就是微博中的“僵尸粉“的来源）。举个例子，例如微博中有转发抽奖的活动，如果我们使用几万个“僵尸号”去混进去转发，这样就可以大大提升我们中奖的概率。 这种账号，使用在秒杀和抢购里，也是同一个道理。例如，iPhone 官网的抢购，火车票黄牛党。 应对方案： 这种场景，可以通过检测指定机器 IP 请求频率就可以解决，如果发现某个 IP 请求频率很高，可以给它弹出一个验证码或者直接禁止它的请求： 弹出验证码，最核心的追求，就是分辨出真实用户。因此，大家可能经常发现，网站弹出的验证码，有些是“鬼神乱舞”的样子，有时让我们根本无法看清。他们这样做的原因，其实也是为了让验证码的图片不被轻易识别，因为强大的“自动脚本”可以通过图片识别里面的字符，然后让脚本自动填写验证码。实际上，有一些非常创新的验证码，效果会比较好，例如给你一个简单问题让你回答，或者让你完成某些简单操作（例如百度贴吧的验证码）。 直接禁止 IP，实际上是有些粗暴的，因为有些真实用户的网络场景恰好是同一出口 IP 的，可能会有“误伤“。但是这一个做法简单高效，根据实际场景使用可以获得很好的效果。 1.2.2. 3. 多个账号，不同 IP 发送不同请求 所谓道高一尺，魔高一丈。有进攻，就会有防守，永不休止。这些“工作室”，发现你对单机 IP 请求频率有控制之后，他们也针对这种场景，想出了他们的“新进攻方案”，就是不断改变 IP。 有同学会好奇，这些随机 IP 服务怎么来的。有一些是某些机构自己占据一批独立 IP，然后做成一个随机代理 IP 的服务，有偿提供给这些“工作室”使用。还有一些更为黑暗一点的，就是通过木马黑掉普通用户的电脑，这个木马也不破坏用户电脑的正常运作，只做一件事情，就是转发 IP 包，普通用户的电脑被变成了 IP 代理出口。通过这种做法，黑客就拿到了大量的独立 IP，然后搭建为随机 IP 服务，就是为了挣钱。 应对方案： 说实话，这种场景下的请求，和真实用户的行为，已经基本相同了，想做分辨很困难。再做进一步的限制很容易“误伤“真实用户，这个时候，通常只能通过设置业务门槛高来限制这种请求了，或者通过账号行为的”数据挖掘“来提前清理掉它们。 僵尸账号也还是有一些共同特征的，例如账号很可能属于同一个号码段甚至是连号的，活跃度不高，等级低，资料不全等等。根据这些特点，适当设置参与门槛，例如限制参与秒杀的账号等级。通过这些业务手段，也是可以过滤掉一些僵尸号。 1.2.3. 4. 火车票的抢购** 看到这里，同学们是否明白你为什么抢不到火车票？如果你只是老老实实地去抢票，真的很难。通过多账号的方式，火车票的黄牛将很多车票的名额占据，部分强大的黄牛，在处理验证码方面，更是“技高一筹“。 高级的黄牛刷票时，在识别验证码的时候使用真实的人，中间搭建一个展示验证码图片的中转软件服务，真人浏览图片并填写下真实验证码，返回给中转软件。对于这种方式，验证码的保护限制作用被废除了，目前也没有很好的解决方案。 因为火车票是根据身份证实名制的，这里还有一个火车票的转让操作方式。大致的操作方式，是先用买家的身份证开启一个抢票工具，持续发送请求，黄牛账号选择退票，然后黄牛买家成功通过自己的身份证购票成功。当一列车厢没有票了的时候，是没有很多人盯着看的，况且黄牛们的抢票工具也很强大，即使让我们看见有退票，我们也不一定能抢得过他们哈。 最终，黄牛顺利将火车票转移到买家的身份证下。 解决方案： 并没有很好的解决方案，唯一可以动心思的也许是对账号数据进行“数据挖掘”，这些黄牛账号也是有一些共同特征的，例如经常抢票和退票，节假日异常活跃等等。将它们分析出来，再做进一步处理和甄别。 1.3. 三、高并发下的数据安全 我们知道在多线程写入同一个文件的时候，会存现“线程安全”的问题（多个线程同时运行同一段代码，如果每次运行结果和单线程运行的结果是一样的，结果和预期相同，就是线程安全的）。如果是 MySQL 数据库，可以使用它自带的锁机制很好的解决问题，但是，在大规模并发的场景中，是不推荐使用 MySQL 的。秒杀和抢购的场景中，还有另外一个问题，就是“超发”，如果在这方面控制不慎，会产生发送过多的情况。我们也曾经听说过，某些电商搞抢购活动，买家成功拍下后，商家却不承认订单有效，拒绝发货。这里的问题，也许并不一定是商家奸诈，而是系统技术层面存在超发风险导致的。 1.3.1. 超发的原因 假设某个抢购场景中，我们一共只有 100 个商品，在最后一刻，我们已经消耗了 99 个商品，仅剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是 99 个，然后都通过了这一个余量判断，最终导致超发。（同文章前面说的场景） 在上面的这个图中，就导致了并发用户 B 也“抢购成功”，多让一个人获得了商品。这种场景，在高并发的情况下非常容易出现。 1.3.2. 1. 悲观锁思路 解决线程安全的思路很多，可以从“悲观锁”的方向开始讨论。 悲观锁，也就是在修改数据的时候，采用锁定状态，排斥外部请求的修改。遇到加锁的状态，就必须等待。 虽然上述的方案的确解决了线程安全的问题，但是，别忘记，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。 1.3.3. 2. FIFO 队列思路 那好，那么我们稍微修改一下上面的场景，我们直接将请求放入队列中的，采用 FIFO（First Input First Output，先进先出），这样的话，我们就不会导致某些请求永远获取不到锁。看到这里，是不是有点强行将多线程变成单线程的感觉哈。 然后，我们现在解决了锁的问题，全部请求采用“先进先出”的队列方式来处理。那么新的问题来了，高并发的场景下，因为请求很多，很可能一瞬间将队列内存“撑爆”，然后系统又陷入到了异常状态。或者设计一个极大的内存队列，也是一种方案，但是，系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终 Web 系统平均响应时候还是会大幅下降，系统还是陷入异常。 1.3.4. 3. ==乐观锁思路== 这个时候，我们就可以讨论一下“乐观锁”的思路了。乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大 CPU 的计算开销。但是，综合来说，这是一个比较好的解决方案。 有很多软件和服务都“乐观锁”功能的支持，例如 Redis 中的 watch 就是其中之一。通过这个实现，我们保证了数据的安全。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/亿级Web系统搭建——单机到分布式集群.html": {
    "url": "Basic/大型网站架构/亿级Web系统搭建——单机到分布式集群.html",
    "title": "亿级 Web 系统搭建——单机到分布式集群",
    "keywords": "",
    "body": "1. Web 负载均衡1.1. 1. HTTP 重定向1.2. 2. 反向代理负载均衡1.3. 3. IP 负载均衡1.4. 4. DNS 负载均衡1. Web 负载均衡 Web 负载均衡（Load Balancing），简单地说就是给我们的服务器集群分配“工作任务”，而采用恰当的分配方式，对于保护处于后端的 Web 服务器来说，非常重要。 负载均衡的策略有很多，我们从简单的讲起哈。 1.1. 1. HTTP 重定向 当用户发来请求的时候，Web 服务器通过修改 HTTP 响应头中的 Location 标记来返回一个新的 url，然后浏览器再继续请求这个新 url，实际上就是页面重定向。通过重定向，来达到“负载均衡”的目标。例如，我们在下载 PHP 源码包的时候，点击下载链接时，为了解决不同国家和地域下载速度的问题，它会返回一个离我们近的下载地址。重定向的 HTTP 返回码是 302，如下图： 如果使用 PHP 代码来实现这个功能，方式如下： 这个重定向非常容易实现，并且可以自定义各种策略。但是，它在大规模访问量下，性能不佳。而且，给用户的体验也不好，实际请求发生重定向，增加了网络延时。 1.2. 2. 反向代理负载均衡 反向代理服务的核心工作主要是转发 HTTP 请求，扮演了浏览器端和后台 Web 服务器中转的角色。因为它工作在 HTTP 层（应用层），也就是网络七层结构中的第七层，因此也被称为“七层负载均衡”。可以做反向代理的软件很多，比较常见的一种是 Nginx。 Nginx 是一种非常灵活的反向代理软件，可以自由定制化转发策略，分配服务器流量的权重等。反向代理中，常见的一个问题，就是 Web 服务器存储的 session 数据，因为一般负载均衡的策略都是随机分配请求的。同一个登录用户的请求，无法保证一定分配到相同的 Web 机器上，会导致无法找到 session 的问题。 解决方案主要有两种： 配置反向代理的转发规则，让同一个用户的请求一定落到同一台机器上（通过分析 cookie），复杂的转发规则将会消耗更多的 CPU，也增加了代理服务器的负担。 将 session 这类的信息，专门用某个独立服务来存储，例如 redis/memchache，这个方案是比较推荐的。 反向代理服务，也是可以开启缓存的，如果开启了，会增加反向代理的负担，需要谨慎使用。这种负载均衡策略实现和部署非常简单，而且性能表现也比较好。但是，它有“单点故障”的问题，如果挂了，会带来很多的麻烦。而且，到了后期 Web 服务器继续增加，它本身可能成为系统的瓶颈。 1.3. 3. IP 负载均衡 IP 负载均衡服务是工作在网络层（修改 IP）和传输层（修改端口，第四层），比起工作在应用层（第七层）性能要高出非常多。原理是，他是对 IP 层的数据包的 IP 地址和端口信息进行修改，达到负载均衡的目的。这种方式，也被称为“四层负载均衡”。常见的负载均衡方式，是 LVS（Linux Virtual Server，Linux 虚拟服务），通过 IPVS（IP Virtual Server，IP 虚拟服务）来实现。 在负载均衡服务器收到客户端的 IP 包的时候，会修改 IP 包的目标 IP 地址或端口，然后原封不动地投递到内部网络中，数据包会流入到实际 Web 服务器。实际服务器处理完成后，又会将数据包投递回给负载均衡服务器，它再修改目标 IP 地址为用户 IP 地址，最终回到客户端。 上述的方式叫 LVS-NAT，除此之外，还有 LVS-RD（直接路由），LVS-TUN（IP 隧道），三者之间都属于 LVS 的方式，但是有一定的区别，篇幅问题，不赘叙。 IP 负载均衡的性能要高出 Nginx 的反向代理很多，它只处理到传输层为止的数据包，并不做进一步的组包，然后直接转发给实际服务器。不过，它的配置和搭建比较复杂。 1.4. 4. DNS 负载均衡 DNS（Domain Name System）负责域名解析的服务，域名 url 实际上是服务器的别名，实际映射是一个 IP 地址，解析过程，就是 DNS 完成域名到 IP 的映射。而一个域名是可以配置成对应多个 IP 的。因此，DNS 也就可以作为负载均衡服务。 这种负载均衡策略，配置简单，性能极佳。但是，不能自由定义规则，而且，变更被映射的 IP 或者机器故障时很麻烦，还存在 DNS 生效延迟的问题。 5. DNS/GSLB 负载均衡 我们常用的 CDN（Content Delivery Network，内容分发网络）实现方式，其实就是在同一个域名映射为多 IP 的基础上更进一步，通过 GSLB（Global Server Load Balance，全局负载均衡）按照指定规则映射域名的 IP。一般情况下都是按照地理位置，将离用户近的 IP 返回给用户，减少网络传输中的路由节点之间的跳跃消耗。 图中的“向上寻找”，实际过程是 LDNS（Local DNS）先向根域名服务（Root Name Server）获取到顶级根的 Name Server（例如.com 的），然后得到指定域名的授权 DNS，然后再获得实际服务器 IP。 CDN 在 Web 系统中，一般情况下是用来解决大小较大的静态资源（html/Js/Css/图片等）的加载问题，让这些比较依赖网络下载的内容，尽可能离用户更近，提升用户体验。 例如，我访问了一张 imgcache.gtimg.cn 上的图片（腾讯的自建 CDN，不使用 qq.com 域名的原因是防止 http 请求的时候，带上了多余的 cookie 信息），我获得的 IP 是 183.60.217.90。 这种方式，和前面的 DNS 负载均衡一样，不仅性能极佳，而且支持配置多种策略。但是，搭建和维护成本非常高。互联网一线公司，会自建 CDN 服务，中小型公司一般使用第三方提供的 CDN。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/压力性能测试.html": {
    "url": "Basic/大型网站架构/压力性能测试.html",
    "title": "压力性能测试",
    "keywords": "",
    "body": "1. 压力测试以及性能分析1.1. 工具简单设置1.2. 压力测试1. 压力测试以及性能分析 使用 Microsoft Web Application Stress Tool 对 web 进行压力测试，Microsoft Web Application Stress Tool 是由微软的网站测试人员所开发，专门用来进行实际网站压力测试的一套工具。透过这套功能强大的压力测试工具，您可以使用少量的客户端计算机仿真大量用户上线对网站服务所可能造成的影响，在网站实际上线之前先对您所设计的网站进行如同真实环境下的测试 1.1. 工具简单设置 打开 Web Application Stress Tool，很简洁的一个页面，上面是工具栏，左下方是功能选项，右下方是详细设置选项。在对目标 Web 服务器进行压力测试之前，先对它进行一些必要的设置。 在“settings”的功能设置中(如下图)，一个是 Stress level (threads)这里是指定程序在后台用多少线程进行请求，也就是相当于模拟多少个客户机的连接，更加形象的就是说设置多少轰炸的线程数。一般填写 500 ～ 1000，因为这个线程数是根据本机的承受力来设置的，如果你对自己的机器配置有足够信心的话，那么设置的越高，轰炸的效果越好。 在“Test Run Time”中来指定一次压力测试需要持续的时间，分为天、小时、分、秒几个单位级别，你根据实际情况来设置吧!这里面设置测试时间为 1 分钟。 其余的选项大家可以根据自己的情况设置。 1.2. 压力测试 在工具中点右键，选择 Add 命令，增加了一个新的测试项目：memcache，对它进行设置，在主选项中的 server 中填写要测试的服务器的 IP 地址，这里我们是在本机上进行测试，所以填写 localhost。在下方选择测试的 Web 连接方式，这里的方式 Verb 选择 get，path 选择要测试的 Web 页面路径，这里填写/WebMemCache/memcache.aspx,即加入缓存的 memcache.aspx 页面(如下图)。 在“Settings”的功能设置中将 Stress level (threads)线程数设置为 500。完毕后，点工具中的灰色三角按钮即可进行测试(如下图)。 同理，我们在建一个 nomemcach 的项目用来测试 nomemcache.aspx 页面。Memcach 和 nomemcach 测试完毕后，点击工具栏上的 Reports 按钮查看测试报告： Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/回答高并发和大型网站设计.html": {
    "url": "Basic/大型网站架构/回答高并发和大型网站设计.html",
    "title": "回答高并发和大型网站设计",
    "keywords": "",
    "body": "1. 高并发解决，大型网站设计1. 高并发解决，大型网站设计 我想高并发问题解决方案要同时考虑硬件和应用程序优化两方面。硬件方面包括水平架构和垂直架构。 垂直架构是增强服务器硬件配置，这个只能到达一定程度，并有资金限制，一般不可取。 水平架构的话我想从小到大说出演化过程。 一台服务器，包括应用程序、数据库、文件 3 台服务器：应用程序服务器（cpu 给力），数据库服务器（硬盘读写快，内存），文件服务器（硬盘大） 增加 分布式缓存服务器集群（memcached，redis） 负载均衡调度器（http 重定向、DNS 域名解析、反向代理 nginx、IP、数据链路层三角传输） + 应用程序服务器集群 数据库 读写分离（主：写，从：读），主从复制 分布式文件服务器集群 + 数据库集群 CDN 服务器集群 + 反向代理服务器集群 nosql + 搜索引擎服务器 按照业务拆分：用户中心 A、店铺 B、订单 C 划分不同的应用程序服务器集群。之间通信通过 消息队列服务器 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/多线程1.html": {
    "url": "Basic/大型网站架构/多线程1.html",
    "title": "多线程 1",
    "keywords": "",
    "body": "1. C#综合揭秘——细说多线程(上)2. 一、线程的定义2.1.1. 1.1 进程、应用程序域与线程的关系2.1.2. 1.2 多线程3. 二、线程的基础知识3.1.1. 2.1 System.Threading.Thread 类3.1.2. 2.1.1 线程的标识符3.1.3. 2.1.2 线程的优先级别3.1.4. 2.1.3 线程的状态3.1.5. 2.1.4 System.Threading.Thread 的方法3.1.6. 2.1.5 开发实例3.1.7. 2.2 System.Threading 命名空间3.1.8. 2.3 线程的管理方式4. 三、以 ThreadStart 方式实现多线程4.1.1. 3.1 使用 ThreadStart 委托4.1.2. 3.2 使用 ParameterizedThreadStart 委托4.1.3. 3.3 前台线程与后台线程4.1.4. 3.4 挂起线程4.1.5. 3.5 Suspend 与 Resume (慎用)4.1.6. 3.6 终止线程5. 四、CLR 线程池的工作者线程5.1.1. 4.1 关于 CLR 线程池5.1.2. 4.2 工作者线程与 I/O 线程5.1.3. 4.3 通过 QueueUserWorkItem 启动工作者线程5.1.4. 4.4 委托类5.1.5. 4.5 利用 BeginInvoke 与 EndInvoke 完成异步委托方法5.1.6. 4.6 善用 IAsyncResult5.1.7. 4.7 回调函数1. C#综合揭秘——细说多线程(上) 2. 一、线程的定义 2.1.1. 1.1 进程、应用程序域与线程的关系 进程(Process)是 Windows 系统中的一个基本概念，它包含着一个运行程序所需要的资源。进程之间是相对独立的，一个进程无法访问另一个进程的数据(除非利用分布式计算方式)，一个进程运行的失败也不会影响其他进程的运行，Windows 系统就是利用进程把工作划分为多个独立的区域的。进程可以理解为一个程序的基本边界。 应用程序域(AppDomain)是一个程序运行的逻辑区域，它可以视为一个轻量级的进程，.NET 的程序集正是在应用程序域中运行的，一个进程可以包含有多个应用程序域，一个应用程序域也可以包含多个程序集。在一个应用程序域中包含了一个或多个上下文 context，使用上下文 CLR 就能够把某些特殊对象的状态放置在不同容器当中。 线程(Thread)是进程中的基本执行单元，在进程入口执行的第一个线程被视为这个进程的主线程。在.NET 应用程序中，都是以 Main()方法作为入口的，当调用此方法时系统就会自动创建一个主线程。线程主要是由 CPU 寄存器、调用栈和线程本地存储器(Thread Local Storage，TLS)组成的。CPU 寄存器主要记录当前所执行线程的状态，调用栈主要用于维护线程所调用到的内存与数据，TLS 主要用于存放线程的状态信息。 进程、应用程序域、线程的关系如下图，一个进程内可以包括多个应用程序域，也有包括多个线程，线程也可以穿梭于多个应用程序域当中。但在同一个时刻，线程只会处于一个应用程序域内。 由于本文是以介绍多线程技术为主题，对进程、应用程序域的介绍就到此为止。关于进程、线程、应用程序域的技术，在“C#综合揭秘——细说进程、应用程序域与上下文”会有详细介绍。 2.1.2. 1.2 多线程 在单 CPU 系统的一个单位时间(time slice)内，CPU 只能运行单个线程，运行顺序取决于线程的优先级别。如果在单位时间内线程未能完成执行，系统就会把线程的状态信息保存到线程的本地存储器(TLS) 中，以便下次执行时恢复执行。而多线程只是系统带来的一个假像，它在多个单位时间内进行多个线程的切换。因为切换频密而且单位时间非常短暂，所以多线程可被视作同时运行。 适当使用多线程能提高系统的性能，比如：在系统请求大容量的数据时使用多线程，把数据输出工作交给异步线程，使主线程保持其稳定性去处理其他问题。但需要注意一点，因为 CPU 需要花费不少的时间在线程的切换上，所以过多地使用多线程反而会导致性能的下降。 3. 二、线程的基础知识 3.1.1. 2.1 System.Threading.Thread 类 System.Threading.Thread 是用于控制线程的基础类，通过 Thread 可以控制当前应用程序域中线程的创建、挂起、停止、销毁。 它包括以下常用公共属性： 属性名称 说明 CurrentContext 获取线程正在其中执行的当前上下文。 CurrentThread 获取当前正在运行的线程。 ExecutionContext 获取一个 ExecutionContext 对象，该对象包含有关当前线程的各种上下文的信息。 IsAlive 获取一个值，该值指示当前线程的执行状态。 IsBackground 获取或设置一个值，该值指示某个线程是否为后台线程。 IsThreadPoolThread 获取一个值，该值指示线程是否属于托管线程池。 ManagedThreadId 获取当前托管线程的唯一标识符。 Name 获取或设置线程的名称。 Priority 获取或设置一个值，该值指示线程的调度优先级。 ThreadState 获取一个值，该值包含当前线程的状态。 3.1.2. 2.1.1 线程的标识符 ManagedThreadId 是确认线程的唯一标识符，程序在大部分情况下都是通过 Thread.ManagedThreadId 来辨别线程的。而 Name 是一个可变值，在默认时候，Name 为一个空值 Null，开发人员可以通过程序设置线程的名称，但这只是一个辅助功能。 3.1.3. 2.1.2 线程的优先级别 .NET 为线程设置了 Priority 属性来定义线程执行的优先级别，里面包含 5 个选项，其中 Normal 是默认值。除非系统有特殊要求，否则不应该随便设置线程的优先级别。 成员名称 说明 Lowest 可以将 Thread 安排在具有任何其他优先级的线程之后。 BelowNormal 可以将 Thread 安排在具有 Normal 优先级的线程之后，在具有 Lowest 优先级的线程之前。 Normal 默认选择。可以将 Thread 安排在具有 AboveNormal 优先级的线程之后，在具有 BelowNormal 优先级的线程之前。 AboveNormal 可以将 Thread 安排在具有 Highest 优先级的线程之后，在具有 Normal 优先级的线程之前。 Highest 可以将 Thread 安排在具有任何其他优先级的线程之前。 3.1.4. 2.1.3 线程的状态 通过 ThreadState 可以检测线程是处于 Unstarted、Sleeping、Running 等等状态，它比 IsAlive 属性能提供更多的特定信息。 前面说过，一个应用程序域中可能包括多个上下文，而通过 CurrentContext 可以获取线程当前的上下文。 CurrentThread 是最常用的一个属性，它是用于获取当前运行的线程。 3.1.5. 2.1.4 System.Threading.Thread 的方法 Thread 中包括了多个方法来控制线程的创建、挂起、停止、销毁，以后来的例子中会经常使用。 方法名称 说明 Abort() 终止本线程。 GetDomain() 返回当前线程正在其中运行的当前域。 GetDomainId() 返回当前线程正在其中运行的当前域 Id。 Interrupt() 中断处于 WaitSleepJoin 线程状态的线程。 Join() 已重载。 阻塞调用线程，直到某个线程终止时为止。 Resume() 继续运行已挂起的线程。 Start() 执行本线程。 Suspend() 挂起当前线程，如果当前线程已属于挂起状态则此不起作用 Sleep() 把正在运行的线程挂起一段时间。 3.1.6. 2.1.5 开发实例 以下这个例子，就是通过 Thread 显示当前线程信息 static void Main(string[] args) { Thread thread = Thread.CurrentThread; thread.Name = \"Main Thread\"; string threadMessage = string.Format(\"Thread ID:{0}\\n Current AppDomainId:{1}\\n \" + \"Current ContextId:{2}\\n Thread Name:{3}\\n \" + \"Thread State:{4}\\n Thread Priority:{5}\\n\", thread.ManagedThreadId, Thread.GetDomainID(), Thread.CurrentContext.ContextID, thread.Name, thread.ThreadState, thread.Priority); Console.WriteLine(threadMessage); Console.ReadKey(); } 运行结果 3.1.7. 2.2 System.Threading 命名空间 在 System.Threading 命名空间内提供多个方法来构建多线程应用程序,其中 ThreadPool 与 Thread 是多线程开发中最常用到的，在.NET 中专门设定了一个 CLR 线程池专门用于管理线程的运行，这个 CLR 线程池正是通过 ThreadPool 类来管理。而 Thread 是管理线程的最直接方式，下面几节将详细介绍有关内容。 类　　　　 说明 AutoResetEvent 通知正在等待的线程已发生事件。无法继承此类。 ExecutionContext 管理当前线程的执行上下文。无法继承此类。 Interlocked 为多个线程共享的变量提供原子操作。 Monitor 提供同步对对象的访问的机制。 Mutex 一个同步基元，也可用于进程间同步。 Thread 创建并控制线程，设置其优先级并获取其状态。 ThreadAbortException 在对 Abort 方法进行调用时引发的异常。无法继承此类。 ThreadPool 提供一个线程池，该线程池可用于发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。 Timeout 包含用于指定无限长的时间的常数。无法继承此类。 Timer 提供以指定的时间间隔执行方法的机制。无法继承此类。 WaitHandle 封装等待对共享资源的独占访问的操作系统特定的对象。 在 System.Threading 中的包含了下表中的多个常用委托，其中 ==ThreadStart、ParameterizedThreadStart 是最常用到的委托。== 由 ThreadStart 生成的线程是最直接的方式，但由 ThreadStart所生成并不受线程池管理。而 ParameterizedThreadStart 是为异步触发带参数的方法而设的，在下一节将为大家逐一细说。 委托 说明 ContextCallback 表示要在新上下文中调用的方法。 ParameterizedThreadStart 表示在 Thread 上执行的方法。 ThreadExceptionEventHandler 表示将要处理 Application 的 ThreadException 事件的方法。 ThreadStart 表示在 Thread 上执行的方法。 TimerCallback 表示处理来自 Timer 的调用的方法。 WaitCallback 表示线程池线程要执行的回调方法。 WaitOrTimerCallback 表示当 WaitHandle 超时或终止时要调用的方法。 3.1.8. 2.3 线程的管理方式 ==通过 ThreadStart 来创建一个新线程是最直接的方法，但这样创建出来的线程比较难管理，如果创建过多的线程反而会让系统的性能下载。== 有见及此，.NET 为线程管理专门设置了一个 CLR 线程池，使用 CLR 线程池系统可以更合理地管理线程的使用。所有请求的服务都能运行于线程池中，当运行结束时线程便会回归到线程池。通过设置，能控制线程池的最大线程数量，在请求超出线程最大值时，线程池能按照操作的优先级别来执行，让部分操作处于等待状态，待有线程回归时再执行操作。 4. 三、以 ThreadStart 方式实现多线程 4.1.1. 3.1 使用 ThreadStart 委托 这里先以一个例子体现一下多线程带来的好处，首先在 Message 类中建立一个方法 ShowMessage()，里面显示了当前运行线程的 Id，并使用 Thread.Sleep 方法模拟部分工作。在 main() 中通过 ThreadStart 委托绑定 Message 对象的 ShowMessage 方法，然后通过 Thread.Start 执行异步方法。 public class Message { public void ShowMessage() { string message = string.Format(\"Async threadId is :{0}\", Thread.CurrentThread.ManagedThreadId); Console.WriteLine(message); for (int n = 0; n 请注意运行结果，在调用 Thread.Start()方法后，系统以异步方式运行 Message.ShowMessage()，而主线程的操作是继续执行的，在 Message.ShowMessage()完成前，主线程已完成所有的操作。 4.1.2. 3.2 使用 ParameterizedThreadStart 委托 ParameterizedThreadStart 委托与 ThreadStart 委托非常相似，但 ParameterizedThreadStart 委托是面向带参数方法的。注意 ParameterizedThreadStart 对应方法的参数为 object，此参数可以为一个值对象，也可以为一个自定义对象。 public class Person { public string Name { get; set; } public int Age { get; set; } } public class Message { public void ShowMessage(object person) { if (person != null) { Person _person = (Person) person; string message = string.Format(\"\\n{0}'s age is {1}!\\nAsync threadId is:{2}\", _person.Name, _person.Age, Thread.CurrentThread.ManagedThreadId); Console.WriteLine(message); } for (int n = 0; n 运行结果： 4.1.3. 3.3 前台线程与后台线程 注意以上两个例子都没有使用 Console.ReadKey(),但系统依然会等待异步线程完成后才会结束。这是因为使用 Thread.Start()启动的线程默认为前台线程，而系统必须等待所有前台线程运行结束后，应用程序域才会自动卸载。 在第二节曾经介绍过线程 Thread 有一个属性 IsBackground，通过把此属性设置为 true，就可以把线程设置为后台线程！这时应用程序域将在主线程完成时就被卸载，而不会等待异步线程的运行。 4.1.4. 3.4 挂起线程 为了等待其他后台线程完成后再结束主线程，就可以使用 Thread.Sleep()方法。 public class Message { public void ShowMessage() { string message = string.Format(\"\\nAsync threadId is:{0}\", Thread.CurrentThread.ManagedThreadId); Console.WriteLine(message); for (int n = 0; n 运行结果如下，此时应用程序域将在主线程运行 5 秒后自动结束 但系统无法预知异步线程需要运行的时间，所以用通过 Thread.Sleep(int)阻塞主线程并不是一个好的解决方法。有见及此，.NET 专门为等待异步线程完成开发了另一个方法 thread.Join()。把上面例子中的最后一行 Thread.Sleep(5000)修改为 thread.Join() 就能保证主线程在异步线程 thread 运行结束后才会终止。 4.1.5. 3.5 Suspend 与 Resume (慎用) Thread.Suspend()与 Thread.Resume()是在 Framework1.0 就已经存在的老方法了，它们分别可以挂起、恢复线程。但在 Framework2.0 中就已经明确排斥这两个方法。这是因为一旦某个线程占用了已有的资源，再使用 Suspend()使线程长期处于挂起状态，当在其他线程调用这些资源的时候就会引起死锁！所以在没有必要的情况下应该避免使用这两个方法。 4.1.6. 3.6 终止线程 若想终止正在运行的线程，可以使用 Abort()方法。在使用 Abort()的时候，将引发一个特殊异常 ThreadAbortException 。若想在线程终止前恢复线程的执行，可以在捕获异常后 ,在 catch(ThreadAbortException ex){...} 中调用 Thread.ResetAbort()取消终止。而使用 Thread.Join()可以保证应用程序域等待异步线程结束后才终止运行。 static void Main(string[] args) { Console.WriteLine(\"Main threadId is:\" + Thread.CurrentThread.ManagedThreadId); Thread thread = new Thread(new ThreadStart(AsyncThread)); thread.IsBackground = true; thread.Start(); thread.Join(); } //以异步方式调用 static void AsyncThread() { try { string message = string.Format(\"\\nAsync threadId is:{0}\", Thread.CurrentThread.ManagedThreadId); Console.WriteLine(message); for (int n = 0; n = 4) { Thread.CurrentThread.Abort(n); } Thread.Sleep(300); Console.WriteLine(\"The number is:\" + n.ToString()); } } catch (ThreadAbortException ex) { //输出终止线程时n的值 if (ex.ExceptionState != null) Console.WriteLine(string.Format(\"Thread abort when the number is: {0}!\", ex.ExceptionState.ToString())); //取消终止，继续执行线程 Thread.ResetAbort(); Console.WriteLine(\"Thread ResetAbort!\"); } //线程结束 Console.WriteLine(\"Thread Close!\"); } 运行结果如下 5. 四、CLR 线程池的工作者线程 5.1.1. 4.1 关于 CLR 线程池 ==使用 ThreadStart 与 ParameterizedThreadStart 建立新线程非常简单，但通过此方法建立的线程难于管理，若建立过多的线程反而会影响系统的性能。== 有见及此，.NET 引入 CLR 线程池这个概念。CLR 线程池并不会在 CLR 初始化的时候立刻建立线程，而是在应用程序要创建线程来执行任务时，线程池才初始化一个线程。线程的初始化与其他的线程一样。在完成任务以后，该线程不会自行销毁，而是以挂起的状态返回到线程池。直到应用程序再次向线程池发出请求时，线程池里挂起的线程就会再度激活执行任务。这样既节省了建立线程所造成的性能损耗，也可以让多个任务反复重用同一线程，从而在应用程序生存期内节约大量开销。 注意：通过 CLR 线程池所建立的线程总是默认为后台线程，优先级数为 ThreadPriority.Normal。 5.1.2. 4.2 工作者线程与 I/O 线程 CLR 线程池分为工作者线程(workerThreads)与 I/O 线程 (completionPortThreads) 两种，工作者线程是主要用作管理 CLR 内部对象的运作，I/O(Input/Output) 线程顾名思义是用于与外部系统交换信息，IO 线程的细节将在下一节详细说明。 通过 ThreadPool.GetMax(out int workerThreads,out int completionPortThreads )和 ThreadPool.SetMax( int workerThreads, int completionPortThreads)两个方法可以分别读取和设置 CLR 线程池中工作者线程与 I/O 线程的最大线程数。在 Framework2.0 中最大线程默认为 25CPU 数，在 Framewok3.0、4.0 中最大线程数默认为 250CPU 数，在近年 I3,I5,I7 CPU 出现后，线程池的最大值一般默认为 1000、2000。若想测试线程池中有多少的线程正在投入使用，可以通过 ThreadPool.GetAvailableThreads( out int workerThreads,out int completionPortThreads ) 方法。 使用 CLR 线程池的工作者线程一般有两种方式，一是直接通过 ThreadPool.QueueUserWorkItem() 方法，二是通过委托，下面将逐一细说。 5.1.3. 4.3 通过 QueueUserWorkItem 启动工作者线程 ThreadPool 线程池中包含有两个静态方法可以直接启动工作者线程：一为 ThreadPool.QueueUserWorkItem(WaitCallback) 二为 ThreadPool.QueueUserWorkItem(WaitCallback, Object) 先把 WaitCallback 委托指向一个带有 Object 参数的无返回值方法，再使用 ThreadPool.QueueUserWorkItem(WaitCallback) 就可以异步启动此方法，此时异步方法的参数被视为 null 。 class Program { static void Main(string[] args) { //把CLR线程池的最大值设置为1000 ThreadPool.SetMaxThreads(1000, 1000); //显示主线程启动时线程池信息 ThreadMessage(\"Start\"); //启动工作者线程 ThreadPool.QueueUserWorkItem(new WaitCallback(AsyncCallback)); Console.ReadKey(); } static void AsyncCallback(object state) { Thread.Sleep(200); ThreadMessage(\"AsyncCallback\"); Console.WriteLine(\"Async thread do work!\"); } //显示线程现状 static void ThreadMessage(string data) { string message = string.Format(\"{0}\\n CurrentThreadId is {1}\", data, Thread.CurrentThread.ManagedThreadId); Console.WriteLine(message); } } 运行结果 使用 ThreadPool.QueueUserWorkItem(WaitCallback, Object) 方法可以把 object 对象作为参数传送到回调函数中。下面例子中就是把一个 string 对象作为参数发送到回调函数当中。 class Program { static void Main(string[] args) { //把线程池的最大值设置为1000 ThreadPool.SetMaxThreads(1000, 1000); ThreadMessage(\"Start\"); ThreadPool.QueueUserWorkItem(new WaitCallback(AsyncCallback), \"Hello Elva\"); Console.ReadKey(); } static void AsyncCallback(object state) { Thread.Sleep(200); ThreadMessage(\"AsyncCallback\"); string data = (string) state; Console.WriteLine(\"Async thread do work!\\n\" + data); } //显示线程现状 static void ThreadMessage(string data) { string message = string.Format(\"{0}\\n CurrentThreadId is {1}\", data, Thread.CurrentThread.ManagedThreadId); Console.WriteLine(message); } } 运行结果 ==通过 ThreadPool.QueueUserWorkItem 启动工作者线程虽然是方便，但 WaitCallback 委托指向的必须是一个带有 Object 参数的无返回值方法，这无疑是一种限制。== 若方法需要有返回值，或者带有多个参数，这将多费周折。有见及此，.NET 提供了另一种方式去建立工作者线程，那就是委托。 5.1.4. 4.4 委托类 使用 CLR 线程池中的工作者线程，最灵活最常用的方式就是使用委托的异步方法，在此先简单介绍一下委托类。 当定义委托后，.NET 就会自动创建一个代表该委托的类，下面可以用反射方式显示委托类的方法成员(对反射有兴趣的朋友可以先参考一下“.NET 基础篇——反射的奥妙”) class Program { delegate void MyDelegate(); static void Main(string[] args) { MyDelegate delegate1 = new MyDelegate(AsyncThread); //显示委托类的几个方法成员 var methods = delegate1.GetType().GetMethods(); if (methods != null) foreach(MethodInfo info in methods) Console.WriteLine(info.Name); Console.ReadKey(); } } 委托类包括以下几个重要方法 public class MyDelegate: MulticastDelegate { public MyDelegate(object target, int methodPtr); //调用委托方法 public virtual void Invoke(); //异步委托 public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object state); public virtual void EndInvoke(IAsyncResult result); } 当调用 Invoke() 方法时，对应此委托的所有方法都会被执行。而 BeginInvoke 与 EndInvoke 则支持委托方法的异步调用，由 BeginInvoke 启动的线程都属于 CLR 线程池中的工作者线程，在下面将详细说明。 5.1.5. 4.5 利用 BeginInvoke 与 EndInvoke 完成异步委托方法 首先建立一个委托对象，通过 IAsyncResult BeginInvoke(string name,AsyncCallback callback,object state) 异步调用委托方法，BeginInvoke 方法除最后的两个参数外，其它参数都是与方法参数相对应的。通过 BeginInvoke 方法将返回一个实现了 System.IAsyncResult 接口的对象，之后就可以利用 EndInvoke(IAsyncResult) 方法就可以结束异步操作，获取委托的运行结果。 class Program { delegate string MyDelegate(string name); static void Main(string[] args) { ThreadMessage(\"Main Thread\"); //建立委托 MyDelegate myDelegate = new MyDelegate(Hello); //异步调用委托，获取计算结果 IAsyncResult result = myDelegate.BeginInvoke(\"Leslie\", null, null); //完成主线程其他工作 ............. //等待异步方法完成，调用EndInvoke(IAsyncResult)获取运行结果 string data = myDelegate.EndInvoke(result); Console.WriteLine(data); Console.ReadKey(); } static string Hello(string name) { ThreadMessage(\"Async Thread\"); Thread.Sleep(2000); //虚拟异步工作 return \"Hello \" + name; } //显示当前线程 static void ThreadMessage(string data) { string message = string.Format(\"{0}\\n ThreadId is:{1}\", data, Thread.CurrentThread.ManagedThreadId); Console.WriteLine(message); } } 运行结果 5.1.6. 4.6 善用 IAsyncResult 在以上例子中可以看见，如果在使用 myDelegate.BeginInvoke 后立即调用 myDelegate.EndInvoke，那在异步线程未完成工作以前主线程将处于阻塞状态，等到异步线程结束获取计算结果后，主线程才能继续工作，这明显无法展示出多线程的优势。此时可以好好利用 IAsyncResult 提高主线程的工作性能，IAsyncResult 有以下成员： public interface IAsyncResult { object AsyncState { get; } //获取用户定义的对象，它限定或包含关于异步操作的信息。 WailHandle AsyncWaitHandle { get; } //获取用于等待异步操作完成的 WaitHandle。 bool CompletedSynchronously { get; } //获取异步操作是否同步完成的指示。 bool IsCompleted { get; } //获取异步操作是否已完成的指示。 } 通过轮询方式，使用 IsCompleted 属性判断异步操作是否完成，这样在异步操作未完成前就可以让主线程执行另外的工作。 class Program { delegate string MyDelegate(string name); static void Main(string[] args) { ThreadMessage(\"Main Thread\"); //建立委托 MyDelegate myDelegate = new MyDelegate(Hello); //异步调用委托，获取计算结果 IAsyncResult result = myDelegate.BeginInvoke(\"Leslie\", null, null); //在异步线程未完成前执行其他工作 while (!result.IsCompleted) { Thread.Sleep(200); //虚拟操作 Console.WriteLine(\"Main thead do work!\"); } string data = myDelegate.EndInvoke(result); Console.WriteLine(data); Console.ReadKey(); } static string Hello(string name) { ThreadMessage(\"Async Thread\"); Thread.Sleep(2000); return \"Hello \" + name; } static void ThreadMessage(string data) { string message = string.Format(\"{0}\\n ThreadId is:{1}\", data, Thread.CurrentThread.ManagedThreadId); Console.WriteLine(message); } } 运行结果： 除此以外，也可以使用 WailHandle 完成同样的工作，WaitHandle 里面包含有一个方法 WaitOne(int timeout)，它可以判断委托是否完成工作，在工作未完成前主线程可以继续其他工作。运行下面代码可得到与使用 IAsyncResult.IsCompleted 同样的结果，而且更简单方便 。 namespace Test { class Program { delegate string MyDelegate(string name); static void Main(string[] args) { ThreadMessage(\"Main Thread\"); //建立委托 MyDelegate myDelegate = new MyDelegate(Hello); //异步调用委托，获取计算结果 IAsyncResult result = myDelegate.BeginInvoke(\"Leslie\", null, null); while (!result.AsyncWaitHandle.WaitOne(200)) { Console.WriteLine(\"Main thead do work!\"); } string data = myDelegate.EndInvoke(result); Console.WriteLine(data); Console.ReadKey(); } static string Hello(string name) { ThreadMessage(\"Async Thread\"); Thread.Sleep(2000); return \"Hello \" + name; } static void ThreadMessage(string data) { string message = string.Format(\"{0}\\n ThreadId is:{1}\", data, Thread.CurrentThread.ManagedThreadId); Console.WriteLine(message); } } } 当要监视多个运行对象的时候，使用 IAsyncResult.WaitHandle.WaitOne 可就派不上用场了。 幸好.NET 为 WaitHandle 准备了另外两个静态方法：WaitAny(waitHandle[], int)与 WaitAll (waitHandle[] , int)。其中 WaitAll 在等待所有 waitHandle 完成后再返回一个 bool 值。而 WaitAny 是等待其中一个 waitHandle 完成后就返回一个 int，这个 int 是代表已完成 waitHandle 在 waitHandle[]中的数组索引。下面就是使用 WaitAll 的例子，运行结果与使用 IAsyncResult.IsCompleted 相同。 class Program { delegate string MyDelegate(string name); static void Main(string[] args) { ThreadMessage(\"Main Thread\"); //建立委托 MyDelegate myDelegate = new MyDelegate(Hello); //异步调用委托，获取计算结果 IAsyncResult result = myDelegate.BeginInvoke(\"Leslie\", null, null); //此处可加入多个检测对象 WaitHandle[] waitHandleList = new WaitHandle[] { result.AsyncWaitHandle,........ }; while (!WaitHandle.WaitAll(waitHandleList, 200)) { Console.WriteLine(\"Main thead do work!\"); } string data = myDelegate.EndInvoke(result); Console.WriteLine(data); Console.ReadKey(); } static string Hello(string name) { ThreadMessage(\"Async Thread\"); Thread.Sleep(2000); return \"Hello \" + name; } static void ThreadMessage(string data) { string message = string.Format(\"{0}\\n ThreadId is:{1}\", data, Thread.CurrentThread.ManagedThreadId); Console.WriteLine(message); } } 5.1.7. 4.7 回调函数 使用轮询方式来检测异步方法的状态非常麻烦，而且效率不高，有见及此，.NET 为 IAsyncResult BeginInvoke(AsyncCallback , object)准备了一个回调函数。使用 AsyncCallback 就可以绑定一个方法作为回调函数，回调函数必须是带参数 IAsyncResult 且无返回值的方法： void AsycnCallbackMethod(IAsyncResult result) 。在 BeginInvoke 方法完成后，系统就会调用 AsyncCallback 所绑定的回调函数,最后回调函数中调用 XXX EndInvoke(IAsyncResult result) 就可以结束异步方法，它的返回值类型与委托的返回值一致。 class Program { delegate string MyDelegate(string name); static void Main(string[] args) { ThreadMessage(\"Main Thread\"); //建立委托 MyDelegate myDelegate = new MyDelegate(Hello); //异步调用委托，获取计算结果 myDelegate.BeginInvoke(\"Leslie\", new AsyncCallback(Completed), null); //在启动异步线程后，主线程可以继续工作而不需要等待 for (int n = 0; n 可以看到，主线在调用 BeginInvoke 方法可以继续执行其他命令，而无需再等待了，这无疑比使用轮询方式判断异步方法是否完成更有优势。在异步方法执行完成后将会调用 AsyncCallback 所绑定的回调函数，注意一点，回调函数依然是在异步线程中执行，这样就不会影响主线程的运行，这也使用回调函数最值得青昧的地方。在回调函数中有一个既定的参数 IAsyncResult,把 IAsyncResult 强制转换为 AsyncResult 后，就可以通过 AsyncResult.AsyncDelegate 获取原委托，再使用 EndInvoke 方法获取计算结果。运行结果如下： 如果想为回调函数传送一些外部信息，就可以利用 BeginInvoke(AsyncCallback,object)的最后一个参数 object,它允许外部向回调函数输入任何类型的参数。只需要在回调函数中利用 AsyncResult.AsyncState 就可以获取 object 对象。 class Program { public class Person { public string Name; public int Age; } delegate string MyDelegate(string name); static void Main(string[] args) { ThreadMessage(\"Main Thread\"); //建立委托 MyDelegate myDelegate = new MyDelegate(Hello); //建立Person对象 Person person = new Person(); person.Name = \"Elva\"; person.Age = 27; //异步调用委托，输入参数对象person, 获取计算结果 myDelegate.BeginInvoke(\"Leslie\", new AsyncCallback(Completed), person); //在启动异步线程后，主线程可以继续工作而不需要等待 for (int n = 0; n 运行结果: Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/多线程2.html": {
    "url": "Basic/大型网站架构/多线程2.html",
    "title": "多线程 2",
    "keywords": "",
    "body": "1. 五、CLR 线程池的 I/O 线程1.1.1. 5.1 异步读写 FileStream1.1.2. 5.1.1 异步写入1.1.3. 5.2 异步操作 TCP/IP 套接字1.1.4. 5.3 异步 WebRequest1.1.5. 5.4 异步调用 WebService2. 六、异步 SqlCommand3. 七、并行编程与 PLINQ3.1.1. 7.1 泛型委托3.1.2. 7.2 任务并行库（TPL）3.1.3. 7.2.1 数据并行3.1.4. 7.2.2 任务并行3.1.5. 7.3 Task 简介3.1.6. 7.4 并行查询（PLINQ）3.1.7. 7.4.1 AsParallel3.1.8. 7.4.2 AsOrdered3.1.9. 7.4.3 WithDegreeOfParallelism3.1.10. 7.4.4 ForAll3.1.11. 7.4.5 WithCancellation3.1.12. 8.1 定时器3.1.13. 8.2 锁3.1.14. 8.2.1 lock3.1.15. 8.2.2 Montior3.1.16. 8.2.3 Interlocked1. 五、CLR 线程池的 I/O 线程 在前一节所介绍的线程都属于 CLR 线程池的工作者线程，这一节开始为大家介绍一下 CLR 线程池的 I/O 线程 I/O 线程是.NET 专为访问外部资源所设置的一种线程，因为访问外部资源常常要受到外界因素的影响，为了防止让主线程受影响而长期处于阻塞状态，.NET 为多个 I/O 操作都建立起了异步方法，例如：FileStream、TCP/IP、WebRequest、WebService 等等，而且每个异步方法的使用方式都非常类似，都是以 BeginXXX 为开始，以 EndXXX 结束，下面为大家一一解说。 1.1.1. 5.1 异步读写 FileStream 需要在 FileStream 异步调用 I/O 线程，必须使用以下构造函数建立 FileStream 对象，并把 useAsync 设置为 true。 FileStream stream = new FileStream ( string path, FileMode mode, FileAccess access, FileShare share, int bufferSize,bool useAsync ) ; 其中 path 是文件的相对路径或绝对路径; mode 确定如何打开或创建文件; access 确定访问文件的方式; share 确定文件如何进程共享; bufferSize 是代表缓冲区大小,一般默认最小值为 8，在启动异步读取或写入时，文件大小一般大于缓冲大小; userAsync 代表是否启动异步 I/O 线程。 注意：当使用 BeginRead 和 BeginWrite 方法在执行大量读或写时效果更好，但对于少量的读/写，这些方法速度可能比同步读取还要慢，因为进行线程间的切换需要大量时间。 1.1.2. 5.1.1 异步写入 FileStream 中包含 BeginWrite、EndWrite 方法可以启动 I/O 线程进行异步写入。 public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, Object stateObject) public override void EndWrite (IAsyncResult asyncResult) BeginWrite 返回值为 IAsyncResult, 使用方式与委托的 BeginInvoke 方法相似，最好就是使用回调函数，避免线程阻塞。在最后两个参数中，参数 AsyncCallback 用于绑定回调函数; 参数 Object 用于传递外部数据。要注意一点：AsyncCallback 所绑定的回调函数必须是带单个 IAsyncResult 参数的无返回值方法。 在例子中，把 FileStream 作为外部数据传递到回调函数当中，然后在回调函数中利用 IAsyncResult.AsyncState 获取 FileStream 对象，最后通过 FileStream.EndWrite（IAsyncResult）结束写入。 class Program { static void Main(string[] args) { //把线程池的最大值设置为1000 ThreadPool.SetMaxThreads(1000, 1000); ThreadPoolMessage(\"Start\"); //新立文件File.sour FileStream stream = new FileStream(\"File.sour\", FileMode.OpenOrCreate, FileAccess.ReadWrite,FileShare.ReadWrite,1024,true); byte[] bytes = new byte[16384]; string message = \"An operating-system ThreadId has no fixed relationship........\"; bytes = Encoding.Unicode.GetBytes(message); //启动异步写入 stream.BeginWrite(bytes, 0, (int)bytes.Length,new AsyncCallback(Callback),stream); stream.Flush(); Console.ReadKey(); } static void Callback(IAsyncResult result) { //显示线程池现状 Thread.Sleep(200); ThreadPoolMessage(\"AsyncCallback\"); //结束异步写入 FileStream stream = (FileStream)result.AsyncState; stream.EndWrite(result); stream.Close(); } //显示线程池现状 static void ThreadPoolMessage(string data) { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"{0}\\n CurrentThreadId is {1}\\n \"+ \"WorkerThreads is:{2} CompletionPortThreads is :{3}\", data, Thread.CurrentThread.ManagedThreadId, a.ToString(), b.ToString()); Console.WriteLine(message); } } 由输出结果可以看到，在使用 FileStream.BeginWrite 方法后，系统将自动启动 CLR 线程池中 I/O 线程。 5.1.2 异步读取 FileStream 中包含 BeginRead 与 EndRead 可以异步调用 I/O 线程进行读取。 public override IAsyncResult BeginRead (byte[] array,int offset,int numBytes, AsyncCallback userCallback,Object stateObject) public override int EndRead(IAsyncResult asyncResult) 其使用方式与 BeginWrite 和 EndWrite 相似，AsyncCallback 用于绑定回调函数; Object 用于传递外部数据。在回调函数只需要使用 IAsyncResut.AsyncState 就可获取外部数据。EndWrite 方法会返回从流读取到的字节数量。 首先定义 FileData 类，里面包含 FileStream 对象，byte[] 数组和长度。然后把 FileData 对象作为外部数据传到回调函数，在回调函数中，把 IAsyncResult.AsyncState 强制转换为 FileData，然后通过 FileStream.EndRead（IAsyncResult）结束读取。最后比较一下长度，若读取到的长度与输入的数据长度不一至，则抛出异常。 class Program { public class FileData { public FileStream Stream; public int Length; public byte[] ByteData; } static void Main(string[] args) { //把线程池的最大值设置为1000 ThreadPool.SetMaxThreads(1000, 1000); ThreadPoolMessage(\"Start\"); ReadFile(); Console.ReadKey(); } static void ReadFile() { byte[] byteData=new byte[80961024]; FileStream stream = new FileStream(\"File1.sour\", FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite, 1024, true); //把FileStream对象,byte[]对象，长度等有关数据绑定到FileData对象中，以附带属性方式送到回调函数 FileData fileData = new FileData(); fileData.Stream = stream; fileData.Length = (int)stream.Length; fileData.ByteData = byteData; //启动异步读取 stream.BeginRead(byteData, 0, fileData.Length, new AsyncCallback(Completed), fileData); } static void Completed(IAsyncResult result) { ThreadPoolMessage(\"Completed\"); //把AsyncResult.AsyncState转换为FileData对象，以FileStream.EndRead完成异步读取 FileData fileData = (FileData)result.AsyncState; int length=fileData.Stream.EndRead(result); fileData.Stream.Close(); //如果读取到的长度与输入长度不一致，则抛出异常 if (length != fileData.Length) throw new Exception(\"Stream is not complete!\"); string data=Encoding.ASCII.GetString(fileData.ByteData, 0, fileData.Length); Console.WriteLine(data.Substring(2,22)); } //显示线程池现状 static void ThreadPoolMessage(string data) { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"{0}\\n CurrentThreadId is {1}\\n \"+ \"WorkerThreads is:{2} CompletionPortThreads is :{3}\", data, Thread.CurrentThread.ManagedThreadId, a.ToString(), b.ToString()); Console.WriteLine(message); } } 由输出结果可以看到，在使用 FileStream.BeginRead 方法后，系统将自动启动 CLR 线程池中 I/O 线程。 注意：如果你看到的测试结果正好相反：工作者线程为 999，I/O 线程为 1000，这是因为 FileStream 的文件容量小于缓冲值 1024 所致的。此时文件将会一次性读取或写入，而系统将启动工作者线程而非 I/O 线程来处理回调函数。** 1.1.3. 5.2 异步操作 TCP/IP 套接字 在介绍 TCP/IP 套接字前先简单介绍一下 NetworkStream 类，它是用于网络访问的基础数据流。 NetworkStream 提供了好几个方法控制套接字数据的发送与接收, 其中 BeginRead、EndRead、BeginWrite、EndWrite 能够实现异步操作，而且异步线程是来自于 CLR 线程池的 I/O 线程。 public override int ReadByte () public override int Read (byte[] buffer,int offset, int size) public override void WriteByte (byte value) public override void Write (byte[] buffer,int offset, int size) public override IAsyncResult BeginRead (byte [] buffer, int offset, int size, AsyncCallback callback, Object state ) public override int EndRead(IAsyncResult result) public override IAsyncResult BeginWrite (byte [] buffer, int offset, int size, AsyncCallback callback, Object state ) public override void EndWrite(IAsyncResult result) 若要创建 NetworkStream，必须提供已连接的 Socket。而在.NET 中使用 TCP/IP 套接字不需要直接与 Socket 打交道，因为.NET 把 Socket 的大部分操作都放在 System.Net.TcpListener 和 System.Net.Sockets.TcpClient 里面，这两个类大大地简化了 Socket 的操作。一般套接字对象 Socket 包含一个 Accept（）方法，此方法能产生阻塞来等待客户端的请求，而在 TcpListener 类里也包含了一个相似的方法 public TcpClient AcceptTcpClient（）用于等待客户端的请求。此方法将会返回一个 TcpClient 对象，通过 TcpClient 的 public NetworkStream GetStream（）方法就能获取 NetworkStream 对象，控制套接字数据的发送与接收。 下面以一个例子说明异步调用 TCP/IP 套接字收发数据的过程。 首先在服务器端建立默认地址 127.0.0.1 用于收发信息，使用此地址与端口 500 新建 TcpListener 对象，调用 TcpListener.Start 侦听传入的连接请求，再使用一个死循环来监听信息。 在 ChatClient 类包括有接收信息与发送信息两个功能：当接收到客户端请求时，它会利用 NetworkStream.BeginRead 读取客户端信息，并在回调函数 ReceiveAsyncCallback 中输出信息内容，若接收到的信息的大小小于 1 时，它将会抛出一个异常。当信息成功接收后，再使用 NetworkStream.BeginWrite 方法回馈信息到客户端 class Program { static void Main(string[] args) { //设置CLR线程池最大线程数 ThreadPool.SetMaxThreads(1000, 1000); //默认地址为127.0.0.1 IPAddress ipAddress = IPAddress.Parse(\"127.0.0.1\"); TcpListener tcpListener = new TcpListener(ipAddress, 500); tcpListener.Start(); //以一个死循环来实现监听 while (true) { //调用一个ChatClient对象来实现监听 ChatClient chatClient = new ChatClient(tcpListener.AcceptTcpClient()); } } } public class ChatClient { static TcpClient tcpClient; static byte[] byteMessage; static string clientEndPoint; public ChatClient(TcpClient tcpClient1) { tcpClient = tcpClient1; byteMessage = new byte[tcpClient.ReceiveBufferSize]; //显示客户端信息 clientEndPoint = tcpClient.Client.RemoteEndPoint.ToString(); Console.WriteLine(\"Client's endpoint is \" + clientEndPoint); //使用NetworkStream.BeginRead异步读取信息 NetworkStream networkStream = tcpClient.GetStream(); networkStream.BeginRead(byteMessage, 0, tcpClient.ReceiveBufferSize, new AsyncCallback(ReceiveAsyncCallback), null); } public void ReceiveAsyncCallback(IAsyncResult iAsyncResult) { //显示CLR线程池状态 Thread.Sleep(100); ThreadPoolMessage(\"\\nMessage is receiving\"); //使用NetworkStream.EndRead结束异步读取 NetworkStream networkStreamRead = tcpClient.GetStream(); int length=networkStreamRead.EndRead(iAsyncResult); //如果接收到的数据长度少于1则抛出异常 if (length 而在客户端只是使用简单的开发方式，利用 TcpClient 连接到服务器端，然后调用 NetworkStream.Write 方法发送信息，最后调用 NetworkStream.Read 方法读取回馈信息 static void Main(string[] args) { //连接服务端 TcpClient tcpClient = new TcpClient(\"127.0.0.1\", 500); //发送信息 NetworkStream networkStream = tcpClient.GetStream(); byte[] sendMessage = Encoding.UTF8.GetBytes(\"Client request connection!\"); networkStream.Write(sendMessage, 0, sendMessage.Length); networkStream.Flush(); //接收信息 byte[] receiveMessage=new byte[1024]; int count=networkStream.Read(receiveMessage, 0,1024); Console.WriteLine(Encoding.UTF8.GetString(receiveMessage)); Console.ReadKey(); } 注意观察运行结果，服务器端的异步操作线程都是来自于 CLR 线程池的 I/O 线程 1.1.4. 5.3 异步 WebRequest System.Net.WebRequest 是 .NET 为实现访问 Internet 的 “请求/响应模型” 而开发的一个 abstract 基类， 它主要有三个子类：FtpWebRequest、HttpWebRequest、FileWebRequest。当使用 WebRequest.Create（string uri）创建对象时，应用程序就可以根据请求协议判断实现类来进行操作。FileWebRequest、FtpWebRequest、HttpWebRequest 各有其作用：FileWebRequest 使用 “file://路径” 的 URI 方式实现对本地资源和内部文件的请求/响应、FtpWebRequest 使用 FTP 文件传输协议实现文件请求/响应、HttpWebRequest 用于处理 HTTP 的页面请求/响应。由于使用方法相类似，下面就以常用的 HttpWebRequest 为例子介绍一下异步 WebRequest 的使用方法。 在使用 ASP.NET 开发网站的时候，往往会忽略了 HttpWebRequest 的使用，因为开发都假设客户端是使用浏览器等工具去阅读页面的。但如果你对 REST 开发方式有所了解，那对 HttpWebRequest 就应该非常熟悉。它可以在路径参数、头文件、页面主体、Cookie 等多处地方加入请求条件，然后对回复数据进行适当处理。HttpWebRequest 包含有以下几个常用方法用于处理请求/响应： public override Stream GetRequestStream () public override WebResponse GetResponse () public override IAsyncResult BeginGetRequestStream ( AsyncCallback callback, Object state ) public override Stream EndGetRequestStream ( IAsyncResult asyncResult ) public override IAsyncResult BeginGetResponse ( AsyncCallback callback, Object state ) public override WebResponse EndGetResponse ( IAsyncResult asyncResult ) 其中 BeginGetRequestStream、EndGetRequestStream 用于异步向 HttpWebRequest 对象写入请求信息; BeginGetResponse、EndGetResponse 用于异步发送页面请求并获取返回信息。使用异步方式操作 Internet 的“请求/响应”，避免主线程长期处于等待状态，而操作期间异步线程是来自 CLR 线程池的 I/O 线程。 请求与响应不能使用同步与异步混合开发模式，即当请求写入使用 GetRequestStream 同步模式，即使响应使用 BeginGetResponse 异步方法，操作也与 GetRequestStream 方法在于同一线程内。 下面以简单的例子介绍一下异步请求的用法。 首先为 Person 类加上可序列化特性，在服务器端建立 Hanlder.ashx，通过 Request.InputStream 获取到请求数据并把数据转化为 String 对象，此实例中数据是以 “Id：1” 的形式实现传送的。然后根据 Id 查找对应的 Person 对象，并把 Person 对象写入 Response.OutStream 中返还到客户端。 在客户端先把 HttpWebRequird.Method 设置为 \"post\"，使用异步方式通过 BeginGetRequireStream 获取请求数据流，然后写入请求数据 “Id:1”。再使用异步方法 BeginGetResponse 获取回复数据，最后把数据反序列化为 Person 对象显示出来。 HttpWebRequire.Method 默认为 get，在写入请求前必须把 HttpWebRequire.Method 设置为 post,否则在使用 BeginGetRequireStream 获取请求数据流的时候，系统就会发出 “无法发送具有此谓词类型的内容正文\" 的异常。 Model namespace Model { [Serializable] public class Person { public int ID { get; set; } public string Name { get; set; } public int Age { get; set; } } } 服务器端 public class Handler : IHttpHandler { public void ProcessRequest(HttpContext context) { //把信息转换为String，找出输入条件Id byte[] bytes=new byte[1024]; int length=context.Request.InputStream.Read(bytes,0,1024); string condition = Encoding.Default.GetString(bytes); int id = int.Parse(condition.Split(new string[] { \":\" }, StringSplitOptions.RemoveEmptyEntries)[1]); //根据Id查找对应Person对象 var person = GetPersonList().Where(x => x.ID == id).First(); //所Person格式化为二进制数据写入OutputStream BinaryFormatter formatter = new BinaryFormatter(); formatter.Serialize(context.Response.OutputStream, person); } //模拟源数据 private IList GetPersonList() { var personList = new List(); var person1 = new Person(); person1.ID = 1; person1.Name = \"Leslie\"; person1.Age = 30; personList.Add(person1); ........... return personList; } public bool IsReusable { get { return true;} } } 客户端 class Program { static void Main(string[] args) { ThreadPool.SetMaxThreads(1000, 1000); Request(); Console.ReadKey(); } static void Request() { ThreadPoolMessage(\"Start\"); //使用WebRequest.Create方法建立HttpWebRequest对象 HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create( \"http://localhost:5700/Handler.ashx\"); webRequest.Method = \"post\"; //对写入数据的RequestStream对象进行异步请求 IAsyncResult result=webRequest.BeginGetRequestStream( new AsyncCallback(EndGetRequestStream),webRequest); } static void EndGetRequestStream(IAsyncResult result) { ThreadPoolMessage(\"RequestStream Complete\"); //获取RequestStream HttpWebRequest webRequest = (HttpWebRequest)result.AsyncState; Stream stream=webRequest.EndGetRequestStream(result); //写入请求条件 byte[] condition = Encoding.Default.GetBytes(\"Id:1\"); stream.Write(condition, 0, condition.Length); //异步接收回传信息 IAsyncResult responseResult = webRequest.BeginGetResponse( new AsyncCallback(EndGetResponse), webRequest); } static void EndGetResponse(IAsyncResult result) { //显出线程池现状 ThreadPoolMessage(\"GetResponse Complete\"); //结束异步请求，获取结果 HttpWebRequest webRequest = (HttpWebRequest)result.AsyncState; WebResponse webResponse = webRequest.EndGetResponse(result); //把输出结果转化为Person对象 Stream stream = webResponse.GetResponseStream(); BinaryFormatter formatter = new BinaryFormatter(); var person=(Person)formatter.Deserialize(stream); Console.WriteLine(string.Format(\"Person Id:{0} Name:{1} Age:{2}\", person.ID, person.Name, person.Age)); } //显示线程池现状 static void ThreadPoolMessage(string data) { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"{0}\\n CurrentThreadId is {1}\\n \" + \"WorkerThreads is:{2} CompletionPortThreads is :{3}\\n\", data, Thread.CurrentThread.ManagedThreadId, a.ToString(), b.ToString()); Console.WriteLine(message); } } 从运行结果可以看到，BeginGetRequireStream、BeginGetResponse 方法是使用 CLR 线程池的 I/O 线程。 1.1.5. 5.4 异步调用 WebService 相比 TCP/IP 套接字，在使用 WebService 的时候，服务器端需要更复杂的操作处理，使用时间往往会更长。为了避免客户端长期处于等待状态，在配置服务引用时选择 “生成异步操作”，系统可以自动建立异步调用的方式。 以.NET 2.0 以前，系统都是使用 ASMX 来设计 WebService，而近年来 WCF 可说是火热登场，下面就以 WCF 为例子简单介绍一下异步调用 WebService 的例子。 由于系统可以自动生成异步方法，使用起来非常简单，首先在服务器端建立服务 ExampleService，里面包含方法 Method。客户端引用此服务时，选择 “生成异步操作”。然后使用 BeginMethod 启动异步方法， 在回调函数中调用 EndMethod 结束异步调用。 服务端 [ServiceContract] public interface IExampleService { [OperationContract] string Method(string name); } public class ExampleService : IExampleService { public string Method(string name) { return \"Hello \" + name; } } class Program { static void Main(string[] args) { ServiceHost host = new ServiceHost(typeof(ExampleService)); host.Open(); Console.ReadKey(); host.Close(); } } 客户端 class Program { static void Main(string[] args) { //设置最大线程数 ThreadPool.SetMaxThreads(1000, 1000); ThreadPoolMessage(\"Start\"); //建立服务对象，异步调用服务方法 ExampleServiceReference.ExampleServiceClient exampleService = new ExampleServiceReference.ExampleServiceClient(); exampleService.BeginMethod(\"Leslie\",new AsyncCallback(AsyncCallbackMethod), exampleService); Console.ReadKey(); } static void AsyncCallbackMethod(IAsyncResult result) { Thread.Sleep(1000); ThreadPoolMessage(\"Complete\"); ExampleServiceReference.ExampleServiceClient example = (ExampleServiceReference.ExampleServiceClient)result.AsyncState; string data=example.EndMethod(result); Console.WriteLine(data); } //显示线程池现状 static void ThreadPoolMessage(string data) { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"{0}\\n CurrentThreadId is {1}\\n \" + \"WorkerThreads is:{2} CompletionPortThreads is :{3}\\n\", data, Thread.CurrentThread.ManagedThreadId, a.ToString(), b.ToString()); Console.WriteLine(message); } } 注意观察运行结果，异步调用服务时，回调函数都是运行于 CLR 线程池的 I/O 线程当中。 2. 六、异步 SqlCommand 从 ADO.NET 2.0 开始，SqlCommand 就新增了几个异步方法执行 SQL 命令。相对于同步执行方式，它使主线程不需要等待数据库的返回结果，在使用复杂性查询或批量插入时将有效提高主线程的效率。使用异步 SqlCommand 的时候，请注意把 ConnectionString 的 Asynchronous Processing 设置为 true 。 SqlCommand 异步操作的特别之处在于线程并不依赖于 CLR 线程池，而是由 Windows 内部提供，这比使用异步委托更有效率。但如果需要使用回调函数的时候，回调函数的线程依然是来自于 CLR 线程池的工作者线程。 SqlCommand 有以下几个方法支持异步操作： public IAsyncResult BeginExecuteNonQuery (......) public int EndExecuteNonQuery(IAsyncResult) public IAsyncResult BeginExecuteReader(......) public SqlDataReader EndExecuteReader(IAsyncResult) public IAsyncResult BeginExecuteXmlReader (......) public XmlReader EndExecuteXmlReader(IAsyncResult） 由于使用方式相似，此处就以 BeginExecuteNonQuery 为例子，介绍一下异步 SqlCommand 的使用。首先建立 connectionString,注意把 Asynchronous Processing 设置为 true 来启动异步命令，然后把 SqlCommand.CommandText 设置为 WAITFOR DELAY \"0:0:3\" 来虚拟数据库操作。再通过 BeginExecuteNonQuery 启动异步操作，利用轮询方式监测操作情况。最后在操作完成后使用 EndExecuteNonQuery 完成异步操作。 class Program { //把Asynchronous Processing设置为true static string connectionString = \"Data Source=LESLIE-PC;Initial Catalog=Business;\"+ \"Integrated Security=True;Asynchronous Processing=true\"; static void Main(string[] args) { //把CLR线程池最大线程数设置为1000 ThreadPool.SetMaxThreads(1000, 1000); ThreadPoolMessage(\"Start\"); //使用WAITFOR DELAY命令来虚拟操作 SqlConnection connection = new SqlConnection(connectionString); SqlCommand command = new SqlCommand(\"WAITFOR DELAY '0:0:3';\", connection); connection.Open(); //启动异步SqlCommand操作，利用轮询方式监测操作 IAsyncResult result = command.BeginExecuteNonQuery(); ThreadPoolMessage(\"BeginRead\"); while (!result.AsyncWaitHandle.WaitOne(500)) Console.WriteLine(\"Main thread do work........\"); //结束异步SqlCommand int count= command.EndExecuteNonQuery(result); ThreadPoolMessage(\"\\nCompleted\"); Console.ReadKey(); } //显示线程池现状 static void ThreadPoolMessage(string data) { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"{0}\\n CurrentThreadId is {1}\\n \"+ \"WorkerThreads is:{2} CompletionPortThreads is :{3}\\n\", data, Thread.CurrentThread.ManagedThreadId, a.ToString(), b.ToString()); Console.WriteLine(message); } } 注意运行结果，SqlCommand 的异步执行线程并不属于 CLR 线程池。 如果觉得使用轮询方式过于麻烦，可以使用回调函数，但要注意当调用回调函数时，线程是来自于 CLR 线程池的工作者线程。 class Program { //把Asynchronous Processing设置为true static string connectionString = \"Data Source=LESLIE-PC;Initial Catalog=Business;\"+ \"Integrated Security=True;Asynchronous Processing=true\"; static void Main(string[] args) { //把CLR线程池最大线程数设置为1000 ThreadPool.SetMaxThreads(1000, 1000); ThreadPoolMessage(\"Start\"); //使用WAITFOR DELAY命令来虚拟操作 SqlConnection connection = new SqlConnection(connectionString); SqlCommand command = new SqlCommand(\"WAITFOR DELAY '0:0:3';\", connection); connection.Open(); //启动异步SqlCommand操作，并把SqlCommand对象传递到回调函数 IAsyncResult result = command.BeginExecuteNonQuery( new AsyncCallback(AsyncCallbackMethod),command); Console.ReadKey(); } static void AsyncCallbackMethod(IAsyncResult result) { Thread.Sleep(200); ThreadPoolMessage(\"AsyncCallback\"); SqlCommand command = (SqlCommand)result.AsyncState; int count=command.EndExecuteNonQuery(result); command.Connection.Close(); } //显示线程池现状 static void ThreadPoolMessage(string data) { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"{0}\\n CurrentThreadId is {1}\\n \"+ \"WorkerThreads is:{2} CompletionPortThreads is :{3}\\n\", data, Thread.CurrentThread.ManagedThreadId, a.ToString(), b.ToString()); Console.WriteLine(message); } } 运行结果： 3. 七、并行编程与 PLINQ 要使用多线程开发，必须非常熟悉 Thread 的使用，而且在开发过程中可能会面对很多未知的问题。为了简化开发，.NET 4.0 特别提供一个并行编程库 System.Threading.Tasks，它可以简化并行开发，你无需直接跟线程或线程池打交道，就可以简单建立多线程应用程序。此外，.NET 还提供了新的一组扩展方法 PLINQ，它具有自动分析查询功能，如果并行查询能提高系统效率，则同时运行，如果查询未能从并行查询中受益，则按原顺序查询。下面将详细介绍并行操作的方式。 3.1.1. 7.1 泛型委托 使用并行编程可以同时操作多个委托,在介绍并行编程前先简单介绍一下两个泛型委托 System.Func<>与 System.Action<>。 Func<>是一个能接受多个参数和一个返回值的泛型委托，它能接受 0 个到 16 个输入参数, 其中 T1,T2,T3,T4......T16 代表自定的输入类型，TResult 为自定义的返回值。 public delegate TResult Func（） public delegate TResult Func（T1 arg1） public delegate TResult Func（T1 arg1,T2 arg2） public delegate TResult Func（T1 arg1,T2 arg2,T3 arg3） public delegate TResult Func（T1 arg1,T2 arg2,T3 arg3,T4 arg4） .............. public delegate TResult Func（T1 arg1,T2 arg2,T3 arg3,T4 arg4，...... ,T16 arg16） Action<>与Func<>十分相似，不同在于Action<>的返回值为void，Action能接受0~16个参数 public delegate void Action（） public delegate void Action（T1 arg1,T2 arg2） public delegate void Action（T1 arg1,T2 arg2, T3 arg3） ............. public delegate void Action（T1 arg1,T2 arg2,T3 arg3,T4 arg4，...... ,T16 arg16） 3.1.2. 7.2 任务并行库（TPL） System.Threading.Tasks 中的类被统称为任务并行库（Task Parallel Library，TPL），TPL 使用 CLR 线程池把工作分配到 CPU，并能自动处理工作分区、线程调度、取消支持、状态管理以及其他低级别的细节操作，极大地简化了多线程的开发。 TPL 比 Thread 更具智能性，当它判断任务集并没有从并行运行中受益，就会选择按顺序运行。但并非所有的项目都适合使用并行开发，创建过多并行任务可能会损害程序的性能，降低运行效率。 TPL 包括常用的数据并行与任务并行两种执行方式： 3.1.3. 7.2.1 数据并行 数据并行的核心类就是 System.Threading.Tasks.Parallel，它包含两个静态方法 Parallel.For 与 Parallel.ForEach, 使用方式与 for、foreach 相仿。通过这两个方法可以并行处理 System.Func<>、System.Action<>委托。 以下一个例子就是利用 public static ParallelLoopResult For( int from, int max, Action) 方法对 List进行并行查询。假设使用单线程方式查询 3 个 Person 对象，需要用时大约 6 秒，在使用并行方式，只需使用 2 秒就能完成查询，而且能够避开 Thread 的繁琐处理。 class Program { static void Main(string[] args) { //设置最大线程数 ThreadPool.SetMaxThreads(1000, 1000); //并行查询 Parallel.For(0, 3,n => { Thread.Sleep(2000); //模拟查询 ThreadPoolMessage(GetPersonList()[n]); }); Console.ReadKey(); } //模拟源数据 static IList GetPersonList() { var personList = new List(); var person1 = new Person(); person1.ID = 1; person1.Name = \"Leslie\"; person1.Age = 30; personList.Add(person1); ........... return personList; } //显示线程池现状 static void ThreadPoolMessage(Person person) { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"Person ID:{0} Name:{1} Age:{2}\\n\" + \" CurrentThreadId is {3}\\n WorkerThreads is:{4}\" + \" CompletionPortThreads is :{5}\\n\", person.ID, person.Name, person.Age, Thread.CurrentThread.ManagedThreadId, a.ToString(), b.ToString()); Console.WriteLine(message); } } 观察运行结果，对象并非按照原排列顺序进行查询，而是使用并行方式查询。 若想停止操作，可以利用 ParallelLoopState 参数，下面以 ForEach 作为例子。 public static ParallelLoopResult ForEach( IEnumerable source, Action action) 其中 source 为数据集，在 Action委托的 ParallelLoopState 参数当中包含有 Break（）和 Stop（）两个方法都可以使迭代停止。Break 的使用跟传统 for 里面的使用方式相似，但因为处于并行处理当中，使用 Break 并不能保证所有运行能立即停止，在当前迭代之前的迭代会继续执行。若想立即停止操作，可以使用 Stop 方法，它能保证立即终止所有的操作，无论它们是处于当前迭代的之前还是之后。 class Program { static void Main(string[] args) { //设置最大线程数 ThreadPool.SetMaxThreads(1000, 1000); //并行查询 Parallel.ForEach(GetPersonList(), (person, state) => { if (person.ID == 2) state.Stop(); ThreadPoolMessage(person); }); Console.ReadKey(); } //模拟源数据 static IList GetPersonList() { var personList = new List(); var person1 = new Person(); person1.ID = 1; person1.Name = \"Leslie\"; person1.Age = 30; personList.Add(person1); .......... return personList; } //显示线程池现状 static void ThreadPoolMessage(Person person) { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"Person ID:{0} Name:{1} Age:{2}\\n\" + \" CurrentThreadId is {3}\\n WorkerThreads is:{4}\" + \" CompletionPortThreads is :{5}\\n\", person.ID, person.Name, person.Age, Thread.CurrentThread.ManagedThreadId, a.ToString(), b.ToString()); Console.WriteLine(message); } } 观察运行结果，当 Person 的 ID 等于 2 时，运行将会停止。 当要在多个线程中调用本地变量，可以使用以下方法： public static ParallelLoopResult ForEach(IEnumerable, Func, Func, Action) 其中第一个参数为数据集; 第二个参数是一个 Func 委托，用于在每个线程执行前进行初始化; 第 三个参数是委托 Func,它能对数据集的每个成员进行迭代，当中 T1 是数据集的成员，T2 是一个 ParallelLoopState 对 象，它可以控制迭代的状态，T3 是线程中的本地变量; 第四个参数是一个 Action 委托，用于对每个线程的最终状态进行最终操作。 在以下例子中，使用 ForEach 计算多个 Order 的总体价格。在 ForEach 方法中，首先把参数初始化为 0f，然后用把同一个 Order 的多个 OrderItem 价格进行累加，计算出 Order 的价格，最后把多个 Order 的价格进行累加，计算出多个 Order 的总体价格。 public class Order { public int ID; public float Price; } public class OrderItem { public int ID; public string Goods; public int OrderID; public float Price; public int Count; } class Program { static void Main(string[] args) { //设置最大线程数 ThreadPool.SetMaxThreads(1000, 1000); float totalPrice = 0f; //并行查询 var parallelResult = Parallel.ForEach(GetOrderList(), () => 0f, //把参数初始值设为0 (order, state, orderPrice) => { //计算单个Order的价格 orderPrice = GetOrderItem().Where(item => item.OrderID == order.ID) .Sum(item => item.Price * item.Count); order.Price = orderPrice; ThreadPoolMessage(order); return orderPrice; }, (finallyPrice) => { totalPrice += finallyPrice;//计算多个Order的总体价格 } ); while (!parallelResult.IsCompleted) Console.WriteLine(\"Doing Work!\"); Console.WriteLine(\"Total Price is:\" + totalPrice); Console.ReadKey(); } //虚拟数据 static IList GetOrderList() { IList orderList = new List(); Order order1 = new Order(); order1.ID = 1; orderList.Add(order1); ............ return orderList; } //虚拟数据 static IList GetOrderItem() { IList itemList = new List(); OrderItem orderItem1 = new OrderItem(); orderItem1.ID = 1; orderItem1.Goods = \"iPhone 4S\"; orderItem1.Price = 6700; orderItem1.Count = 2; orderItem1.OrderID = 1; itemList.Add(orderItem1); ........... return itemList; } //显示线程池现状 static void ThreadPoolMessage(Order order) { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"OrderID:{0} OrderPrice:{1}\\n\" + \" CurrentThreadId is {2}\\n WorkerThreads is:{3}\" + \" CompletionPortThreads is:{4}\\n\", order.ID, order.Price, Thread.CurrentThread.ManagedThreadId, a.ToString(), b.ToString()); Console.WriteLine(message); } } 运行结果 3.1.4. 7.2.2 任务并行 在 TPL 当中还可以使用 Parallel.Invoke 方法触发多个异步任务,其中 actions 中可以包含多个方法或者委托，parallelOptions 用于配置 Parallel 类的操作。 public static void Invoke(Action[] actions ) public static void Invoke(ParallelOptions parallelOptions, Action[] actions ) 下面例子中利用了 Parallet.Invoke 并行查询多个 Person，actions 当中可以绑定方法、lambda 表达式或者委托，注意绑定方法时必须是返回值为 void 的无参数方法。 class Program { static void Main(string[] args) { //设置最大线程数 ThreadPool.SetMaxThreads(1000, 1000); //任务并行 Parallel.Invoke(option, PersonMessage, ()=>ThreadPoolMessage(GetPersonList()[1]), delegate(){ ThreadPoolMessage(GetPersonList()[2]); }); Console.ReadKey(); } static void PersonMessage() { ThreadPoolMessage(GetPersonList()[0]); } //显示线程池现状 static void ThreadPoolMessage(Person person) { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"Person ID:{0} Name:{1} Age:{2}\\n\" + \" CurrentThreadId is {3}\\n WorkerThreads is:{4}\" + \" CompletionPortThreads is :{5}\\n\", person.ID, person.Name, person.Age, Thread.CurrentThread.ManagedThreadId, a.ToString(), b.ToString()); Console.WriteLine(message); } //模拟源数据 static IList GetPersonList() { var personList = new List(); var person1 = new Person(); person1.ID = 1; person1.Name = \"Leslie\"; person1.Age = 30; personList.Add(person1); .......... return personList; } } 运行结果 3.1.5. 7.3 Task 简介 以 Thread 创建的线程被默认为前台线程，当然你可以把线程 IsBackground 属性设置为 true，但 TPL 为此提供了一个更简单的类 Task。 Task 存在于 System.Threading.Tasks 命名空间当中，它可以作为异步委托的简单替代品。通过 Task 的 Factory 属性将返回 TaskFactory 类，以 TaskFactory.StartNew（Action）方法可以创建一个新线程，所创建的线程默认为后台线程。 class Program { static void Main(string[] args) { ThreadPool.SetMaxThreads(1000, 1000); Task.Factory.StartNew(() => ThreadPoolMessage()); Console.ReadKey(); } //显示线程池现状 static void ThreadPoolMessage() { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"CurrentThreadId is:{0}\\n\" + \"CurrentThread IsBackground:{1}\\n\" + \"WorkerThreads is:{2}\\nCompletionPortThreads is:{3}\\n\", Thread.CurrentThread.ManagedThreadId, Thread.CurrentThread.IsBackground.ToString(), a.ToString(), b.ToString()); Console.WriteLine(message); } } 运行结果 若要取消处理，可以利用 CancellationTakenSource 对象，在 TaskFactory 中包含有方法 public Task StartNew( Action action, CancellationToken cancellationToken ) 在方法中加入 CancellationTakenSource 对象的 CancellationToken 属性，可以控制任务的运行，调用 CancellationTakenSource.Cancel 时任务就会自动停止。下面以图片下载为例子介绍一下 TaskFactory 的使用。 服务器端页面 private static List url=new List(); protected void Page_Load(object sender, EventArgs e) { if (!Page.IsPostBack) { url.Clear(); Application[\"Url\"] = null; } } protected void CheckBox_CheckedChanged(object sender, EventArgs e) { CheckBox checkBox = (CheckBox)sender; if (checkBox.Checked) url.Add(checkBox.Text); else url.Remove(checkBox.Text); Application[\"Url\"]= url; } 首先在服务器页面中显示多个*.jpg 图片，每个图片都有对应的 CheckBox 检测其选择情况。所选择图片的路径会记录在 Application[\"Url\"]当中传递到 Handler.ashx 当中。 Application 是一个全局变量，此处只是为了显示 Task 的使用方式，在 ASP.NET 开发应该慎用 Application。 Handler.ashx 处理图片的下载，它从 Application[\"Url\"] 当中获取所选择图片的路径，并把图片转化成 byte[]二进制数据。再把图片的数量，每副图片的二进制数据的长度记录在 OutputStream 的头部。最后把图片的二进制数据记入 OutputStream 一并输出。 public class Handler : IHttpHandler { public void ProcessRequest(HttpContext context) { //获取图片名，把图片数量写OutputStream List urlList = (List)context.Application[\"Url\"]; context.Response.OutputStream.Write(BitConverter.GetBytes(urlList.Count), 0, 4); //把图片转换成二进制数据 List imageList = GetImages(urlList); //把每副图片长度写入OutputStream foreach (string image in imageList) { byte[] imageByte=Convert.FromBase64String(image); context.Response.OutputStream.Write(BitConverter.GetBytes(imageByte.Length),0,4); } //把图片写入OutputStream foreach (string image in imageList) { byte[] imageByte = Convert.FromBase64String(image); context.Response.OutputStream.Write(imageByte,0,imageByte.Length); } } //获取多个图片的二进制数据 private List GetImages(List urlList) { List imageList = new List(); foreach (string url in urlList) imageList.Add(GetImage(url)); return imageList; } //获取单副图片的二进制数据 private string GetImage(string url) { string path = \"E:/My Projects/Example/WebSite/Images/\"+url; FileStream stream = new FileStream(path, FileMode.Open, FileAccess.Read); byte[] imgBytes = new byte[10240]; int imgLength = stream.Read(imgBytes, 0, 10240); return Convert.ToBase64String(imgBytes,0,imgLength); } public bool IsReusable { get{ return false;} } } 客户端 建立一个 WinForm 窗口，里面加入一个 WebBrowser 连接到服务器端的 Default.aspx 页面。当按下 Download 按键时，系统就会利用 TaskFactory.StartNew 的方法建立异步线程，使用 WebRequest 方法向 Handler.ashx 发送请求。接收到回传流时，就会根据头文件的内容判断图片的数量与每副图片的长度，把二进制数据转化为*.jpg 文件保存。 系统利用 TaskFactory.StartNew(action,cancellationToken) 方式异步调用 GetImages 方法进行图片下载。当用户按下 Cancel 按钮时，异步任务就会停止。值得注意的是，在图片下载时调用了 CancellationToken.ThrowIfCancellationRequested 方法，目的在检查并行任务的运行情况，在并行任务被停止时释放出 OperationCanceledException 异常，确保用户按下 Cancel 按钮时，停止所有并行任务。 public partial class Form1 : Form { private CancellationTokenSource tokenSource = new CancellationTokenSource(); public Form1() { InitializeComponent(); ThreadPool.SetMaxThreads(1000, 1000); } private void downloadToolStripMenuItem_Click(object sender, EventArgs e) { Task.Factory.StartNew(GetImages,tokenSource.Token); } private void cancelToolStripMenuItem_Click(object sender, EventArgs e) { tokenSource.Cancel(); } private void GetImages() { //发送请求，获取输出流 WebRequest webRequest = HttpWebRequest.Create(\"Http://localhost:5800/Handler.ashx\"); Stream responseStream=webRequest.GetResponse().GetResponseStream(); byte[] responseByte = new byte[81960]; IAsyncResult result=responseStream.BeginRead(responseByte,0,81960,null,null); int responseLength = responseStream.EndRead(result); //获取图片数量 int imageCount = BitConverter.ToInt32(responseByte, 0); //获取每副图片的长度 int[] lengths = new int[imageCount]; for (int n = 0; n 3.1.6. 7.4 并行查询（PLINQ） 并行 LINQ (PLINQ) 是 LINQ 模式的并行实现，主要区别在于 PLINQ 尝试充分利用系统中的所有处理器。 它利用所有处理器的方法，把数据源分成片段，然后在多个处理器上对单独工作线程上的每个片段并行执行查询， 在许多情况下，并行执行意味着查询运行速度显著提高。但这并不说明所有 PLINQ 都会使用并行方式，当系统测试要并行查询会对系统性能造成损害时，那将自动化地使用同步执行。在 System.Linq.ParallelEnumerable 类中，包含了并行查询的大部分方法。 方法成员　 说明 AsParallel PLINQ 的入口点。 指定如果可能，应并行化查询的其余部分。 AsSequential(Of TSource) 指定查询的其余部分应像非并行 LINQ 查询一样按顺序运行。 AsOrdered 指定 PLINQ 应保留查询的其余部分的源序列排序，直到例如通过使用 orderby（在 Visual Basic 中为 Order By）子句更改排序为止。 AsUnordered(Of TSource) 指定查询的其余部分的 PLINQ 不需要保留源序列的排序。 WithCancellation(Of TSource) 指定 PLINQ 应定期监视请求取消时提供的取消标记和取消执行的状态。 WithDegreeOfParallelism(Of TSource) 指定 PLINQ 应当用来并行化查询的处理器的最大数目。 WithMergeOptions(Of TSource) 提供有关 PLINQ 应当如何（如果可能）将并行结果合并回到使用线程上的一个序列的提示。 WithExecutionMode(Of TSource) 指定 PLINQ 应当如何并行化查询（即使默认行为是按顺序运行查询）。 ForAll(Of TSource) 多线程枚举方法，与循环访问查询结果不同，它允许在不首先合并回到使用者线程的情况下并行处理结果。 Aggregate 重载 对于 PLINQ 唯一的重载，它启用对线程本地分区的中间聚合以及一个用于合并所有分区结果的最终聚合函数。 3.1.7. 7.4.1 AsParallel 通常想要实现并行查询，只需向数据源添加 AsParallel 查询操作即可。 class Program { static void Main(string[] args) { var personList=GetPersonList().AsParallel() .Where(x=>x.Age>30); Console.ReadKey(); } //模拟源数据 static IList GetPersonList() { var personList = new List(); var person1 = new Person(); person1.ID = 1; person1.Name = \"Leslie\"; person1.Age = 30; personList.Add(person1); ........... return personList; } } 3.1.8. 7.4.2 AsOrdered 若要使查询结果必须保留源序列排序方式，可以使用 AsOrdered 方法。 AsOrdered 依然使用并行方式，只是在查询过程加入额外信息，在并行结束后把查询结果再次进行排列。 class Program { static void Main(string[] args) { var personList=GetPersonList().AsParallel().AsOrdered() .Where(x=>x.Age GetPersonList() {......} } 3.1.9. 7.4.3 WithDegreeOfParallelism 默认情况下，PLINQ 使用主机上的所有处理器，这些处理器的数量最多可达 64 个。通过使用 WithDegreeOfParallelism(Of TSource) 方法，可以指示 PLINQ 使用不多于指定数量的处理器。 class Program { static void Main(string[] args) { var personList=GetPersonList().AsParallel().WithDegreeOfParallelism(2) .Where(x=>x.Age GetPersonList() {.........} } 3.1.10. 7.4.4 ForAll 如果要对并行查询结果进行操作，一般会在 for 或 foreach 中执行，执行枚举操作时会使用同步方式。有见及此，PLINQ 中包含了 ForAll 方法，它可以使用并行方式对数据集进行操作。 class Program { static void Main(string[] args) { ThreadPool.SetMaxThreads(1000, 1000); GetPersonList().AsParallel().ForAll(person =>{ ThreadPoolMessage(person); }); Console.ReadKey(); } static IList GetPersonList() {.......} //显示线程池现状 static void ThreadPoolMessage(Person person) { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"Person ID:{0} Name:{1} Age:{2}\\n\" + \" CurrentThreadId is {3}\\n WorkerThreads is:{4}\" + \" CompletionPortThreads is :{5}\\n\", person.ID, person.Name, person.Age, Thread.CurrentThread.ManagedThreadId, a.ToString(), b.ToString()); Console.WriteLine(message); } } 运行结果 3.1.11. 7.4.5 WithCancellation 如果需要停止查询，可以使用 WithCancellation(Of TSource) 运算符并提供 CancellationToken 实例作为参数。与第三节 Task 的例子相似，如果标记上的 IsCancellationRequested 属性设置为 true，则 PLINQ 将会注意到它，并停止所有线程上的处理，然后引发 OperationCanceledException。这可以保证并行查询能够立即停止。 class Program { static CancellationTokenSource tokenSource = new CancellationTokenSource(); static void Main(string[] args) { Task.Factory.StartNew(Cancel); try { GetPersonList().AsParallel().WithCancellation(tokenSource.Token) .ForAll(person => { ThreadPoolMessage(person); }); } catch (OperationCanceledException ex) { } Console.ReadKey(); } //在10~50毫秒内发出停止信号 static void Cancel() { Random random = new Random(); Thread.Sleep(random.Next(10,50)); tokenSource.Cancel(); } static IList GetPersonList() {......} //显示线程池现状 static void ThreadPoolMessage(Person person) { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"Person ID:{0} Name:{1} Age:{2}\\n\" + \" CurrentThreadId is {3}\\n WorkerThreads is:{4}\" + \" CompletionPortThreads is :{5}\\n\", person.ID, person.Name, person.Age, Thread.CurrentThread.ManagedThreadId, a.ToString(), b.ToString()); Console.WriteLine(message); } } 八、定时器与锁 3.1.12. 8.1 定时器 若要长期定时进行一些工作，比如像邮箱更新，实时收听信息等等，可以利用定时器 Timer 进行操作。在 System.Threading 命名空间中存在 Timer 类与对应的 TimerCallback 委托，它可以在后台线程中执行一些长期的定时操作，使主线程不受干扰。 Timer 类中最常用的构造函数为 public Timer( timerCallback , object , int , int ) timerCallback 委托可以绑定执行方法，执行方法必须返回 void，它可以是无参数方法，也可以带一个 object 参数的方法。第二个参数是为 timerCallback 委托输入的参数对象。第三个参数是开始执行前等待的时间。第四个参数是每次执行之间的等待时间。 开发实例 class Program { static void Main(string[] args) { ThreadPool.SetMaxThreads(1000, 1000); TimerCallback callback = new TimerCallback(ThreadPoolMessage); Timer t = new Timer(callback,\"Hello Jack! \", 0, 1000); Console.ReadKey(); } //显示线程池现状 static void ThreadPoolMessage(object data) { int a, b; ThreadPool.GetAvailableThreads(out a, out b); string message = string.Format(\"{0}\\n CurrentThreadId is:{1}\\n\" + \" CurrentThread IsBackground:{2}\\n\" + \" WorkerThreads is:{3}\\n CompletionPortThreads is:{4}\\n\", data + \"Time now is \" + DateTime.Now.ToLongTimeString(), Thread.CurrentThread.ManagedThreadId, Thread.CurrentThread.IsBackground.ToString(), a.ToString(), b.ToString()); Console.WriteLine(message); } } 注意观察运行结果，每次调用 Timer 绑定的方法时不一定是使用同一线程，但线程都会是来自工作者线程的后台线程。 3.1.13. 8.2 锁 在使用多线程开发时，存在一定的共用数据，为了避免多线程同时操作同一数据，.NET 提供了 lock、Monitor、Interlocked 等多个锁定数据的方式。 3.1.14. 8.2.1 lock lock 的使用比较简单，如果需要锁定某个对象时，可以直接使用 lock(this)的方式。 private void Method() { lock(this) { //在此进行的操作能保证在同一时间内只有一个线程对此对象操作 } } 如果操作只锁定某段代码，可以事先建立一个 object 对象，并对此对象进行操作锁定，这也是.net 提倡的锁定用法。 class Control { private object obj=new object(); public void Method() { lock(obj) {.......} } } 3.1.15. 8.2.2 Montior Montior 存在于 System.Thread 命名空间内，相比 lock，Montior 使用更灵活。它存在 Enter, Exit 两个方法，它可以对对象进行锁定与解锁，比 lock 使用更灵活。 class Control { private object obj=new object(); public void Method() { Monitor.Enter(obj); try {......} catch(Excetion ex) {......} finally { Monitor.Exit(obj); } } } 使用 try 的方式，能确保程序不会因死锁而释放出异常！而且在 finally 中释放 obj 对象能够确保无论是否出现死锁状态，系统都会释放 obj 对象。而且 Monitor 中还存在 Wait 方法可以让线程等待一段时间，然后在完成时使用 Pulse、PulseAll 等方法通知等待线程。 3.1.16. 8.2.3 Interlocked Interlocked 存在于 System.Thread 命名空间内，它的操作比 Monitor 使用更简单。它存在 CompareExchange、Decrement、Exchange、Increment 等常用方法让参数在安全的情况进行数据交换。 Increment、Decrement 可以使参数安全地加 1 或减 1 并返回递增后的新值。 class Example { private int a=1; public void AddOne() { int newA=Interlocked.Increment(ref a); } } Exchange 可以安全地变量赋值。 public void SetData() { Interlocked.Exchange(ref a,100); } CompareExchange 使用特别方便，它相当于 if 的用法，当 a 等于 1 时，则把 100 赋值给 a。 public void CompareAndExchange() { Interlocked.CompareExchange(ref a,100,1); } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/大型网站分布式设计.html": {
    "url": "Basic/大型网站架构/大型网站分布式设计.html",
    "title": "大型网站分布式设计",
    "keywords": "",
    "body": "1. 大型网站分布式设计1.1. Web 分布式系统设计准则1.2. 基本原理1.2.1. 举例：图片托管应用1.2.2. 读写分离1.2.3. 分区处理1.2.4. 冗余1.2.5. 扩容之水平扩展分区和垂直扩展1.3. 建立大型 web1.3.1. 缓存1.3.2. 代理1.3.3. 索引1.3.4. 负载均衡1.3.5. 队列1. 大型网站分布式设计 http://blog.jobbole.com/58551/ 1.1. Web 分布式系统设计准则 可用性 大型在线零售网站，甚至是几分钟的不可用都会导致数以千万计美元的收入损失，所以将他们的系统设计成 不间断可用和能够弹性恢复 既是一项基础业务也是一个技术需求。分布式系统的高可用性需要仔细考虑关键组件冗余，快速恢复部分有问题的系统，并且当出现问题时能够做到优雅降级。 性能 性能已成为大多数网站一个很重要的考量指标。一个网站的速度会影响到使用和用户满意度，同样也会影响到搜索引擎排名，将直接关系到网站收入和用户保持力（黏性）。因此，关键之处就在于创建一个为 快速响应、低延迟 的系统。 可靠性 一个系统需要做到可靠，这样才能使得对于 固定数据的请求始终会返回同样的数据。如果数据发生变化或者更新，那相同的请求应该返回新的数据。 用户需要知道，一旦一些数据被写入、存储到系统中，那么系统就会持久化（这些数据）并且能够让人信赖随时能够检索。 可伸缩性 对于任何大型分布式系统，系统规模只是可伸缩性需要考虑的一个方面。同样重要的是， 增加容量能够处理更大量的负载所需的工作 ，通常在系统可伸缩性方面被提及到。可伸缩性会涉及到系统的很多不同的因素：系统额外还能够处理多少流量，是否能够轻易增加存储容量，还能多处理多少事务。 可管理性 设计一个易于运维的系统是另一个重要考量点。系统的可管理型等同于操作的可伸缩性：维护和变更。可管理性需要考虑的有：当 问题发生时能够便于诊断和理解 ，便于进行变更和修改，并且系统易于操作。（比如系统是否能够进行例行操作而不带来失败或者异常？） 成本 包括硬件和软件成本，但同样还要考虑到一些其他方面来 部署、运维系统，比如构建系统所需的开发时间，运行系统所需的运维工作量，甚至所需的培训都要被考虑在内 。 小节 这些准则中的每一条都提供了在设计一个分布式 web 系统架构时作决定的基本原则。但是，他们也可能互相矛盾，比如达到某一目标是以牺牲另一个为代价的。一个典型的例子：专注于系统容量时，选择通过简单增加更多机器（可伸缩性）的代价是（增加了）可管理性（你需要运维更多的服务器）和成本（更多服务器价格）。当设计任何 web 应用时，这些关键准则都是需要考量的，即使不得不承认，一个设计可能会牺牲它们中的一个或更多。 1.2. 基本原理 对于系统架构来说，有一些事情需要考虑：什么是正确的组件，这些组件如何协作，需要做哪些正确的权衡。 大型 Web 应用都非常核心的因素：服务，冗余，分期和失败处理。每个因素均包含有选择和妥协。 1.2.1. 举例：图片托管应用 设想一个这样的系统：用户可以将他们的图片上传到一个中央服务器，并且图片可以通过一个 web 链接或者 API（应用程序接口）进行请求，就像 Flickr 或者 Picasa 一样。为了简单起见，我们假定这个应用有两个关键部分：能够上传（写入）一张图片到服务器，能够查询一张图片。虽然我们希望上传能够更快速，但我们最关心的是系统能够快速分发用户请求的图片（比如图片可以被请求用于一张网页或是其他应用）。这些跟一个 web 服务器或者 CDN（内容分发网络） edge server（CDN 所使用的服务器，用于在很多位置存放内容，这样内容在地理/物理上更接近用户，起到更高性能的作用）所提供的功能非常类似。 系统其他重要的方面 对于存储的图片数量没有设限，所以就图片数量而言，需要考虑存储的可伸缩性。 对于图片的下载/请求需要做到低延迟。 如果一个用户上传了一张图片，那该图片应该总是存在的。（图片的数据可靠性） 系统需要易于管理（可管理型）。 由于图片托管不会带来很高的利润，所以系统需要做到有成本效益的。 图片 1.1：图片托管应用的简化架构图 服务 可伸缩系统的设计有助于各功能解耦并且通过一个清晰定义的接口思考系统的每个部分。在实践中，这种方式的系统拥有一个面向服务的架构 SOA。对于这些类型的系统，每个服务都有它们各自确切的功能上下文，并且和该上下文以外的任何交互均是与一个抽象的接口进行的，特别是另一个服务的公有接口。 将一个系统拆解为一个互补的服务集合解耦了那些相互间的操作。这种抽象有助于建立服务间明确的关系、潜在的运行环境、服务的消费者。通过这些清晰的描绘有助于隔离问题，并且允许每个部分能够相互独立地进行扩展。这种面向服务的系统设计有点类似与面向对象编程。 在我们的例子中，所有上传和获取图片的请求都是在同一服务器上处理，但是，如果系统想要达到可伸缩，那么将这两个功能拆分成各自的服务是非常明智的。 1.2.2. 读写分离 假设这些服务被大量使用，这样的场景将非常易于看到写操作会如何影响读取图片的时间（因为这两个功能会竞争共享资源）。即使上传和下载速度是一样的（对于大多数 IP 网络来说不一定是，因为大多数都是设计成下载速度与上传速度 3:1 的比例），文件通常直接从缓存中读取，而写入则最终必须到达磁盘（在最终一致的场景中可能会被写入多次）。即使所有东西都是从内存或者磁盘（比如 SSD 固态硬盘）读取，数据库的写入操作总还是比读取要慢。 另一个潜在的设计问题是，一个像 Apache 或者 lighttpd 的 web 服务器，通常有一个它可以维持并发连接数的上线（默认大约在 500 左右，但可以调得更高），并且在高流量下，写操作将很快消耗完所有连接资源。由于读操作可以异步进行，或者利用其它性能调优如 gzip 压缩或者 chunked transfer encoding，web 服务器可以转换为更快服务读操作、更快切换客户端，从而比最大连接数每秒服务更多的请求（Apache 最大连接数设置为 500，但一般都能每秒服务数千个请求）。写操作，在另一方面，倾向于在上传过程中维护一个打开状态的连接，所有上传一个 1M 大小的文件在大多数家庭网络上将花费超过 1 秒的视角，所以 web 服务器只能同时处理 500 个写操作。 图 1.2: 读写分离 将图片的读、写操作拆分成各自的服务是一个应对这种瓶颈很好的解决方案，如图 1.2。这样允许我们能够独立的扩展它们（通常读大于写）。这样可以分离未来的担心，可以更简单地解决像读操作缓慢的问题，并做到可伸缩。 这种方法的好处在于我们能够独立解决问题——不用担心在同一上下文中写入、读取新的图片。这两种服务仍然影响着全部的图片，但均能通过 service-appropriate 方法优化它们的性能，比如让请求排队，或者缓存受欢迎的图片。从一个维护和成本的视角出发，每个服务均能独立、按需伸缩是非常好的，因为如果它们被组合、混合在一起，在上面讨论的场景下，可能某一服务不经意间就会影响到其他服务的性能。 当然，当你考虑着两个不同点时，上面的例子能够工作得很好（事实上，这跟一些云存储提供商的实现方案和 CDN 很类似）。尽管还有很多方法来处理这些类型的瓶颈，但每个都有不同方面的权衡。 1.2.3. 分区处理 例如， Flickr 通过将用户分布在不同区域的方法来解决读/写问题，比如每个分区只处理一定数量的用户，随着用户的增加，集群会更多的分区 。在第一个例子中，基于实际使用（整个系统的读写操作数量）可以更容易地伸缩硬件，然而 Flickr 是基于它的用户（但强制假设用户的使用率均等，所以仍有额外的容量）。对于前者来说，停电或者一个服务的问题就会降低整个系统的功能性（比如没人可以写入文件），然而 Flickr 的一个分区停电仅会影响到这个分区相应的用户。第一个例子易于操作整个数据集，比如升级写入服务来包含新的元数据或者搜索所有的图片元数据，然而在 Flickr 的架构下，每个分区均需要被更新或搜索（或者一个搜索服务需要能够整理相关元数据——事实上他们确实这么做）。 对于这些系统来说没有孰对孰错，而是帮助我们回到本章开头所说的准则，判断系统需求（读多还是写多还是两者都多，并发程度，跨数据集查询，搜索，排序等），检测不同的取舍，理解系统为什么会失败并且有可靠的计划来应对失败的发生。 1.2.4. 冗余 为了能够优雅地处理失败问题，Web 架构必须做到服务和数据的冗余。比如，如果在单台服务器上仅有一份文件，那么失去那台服务器就意味着丢失那份文件。通常的解决方案是创建多个、冗余的备份。 该准则同样适用于服务。如果应用有一个核心功能，那么通过确保多个拷贝（多个同类服务实例）或者版本同时运行能够免于单点失败的情况。 在一个系统中创建冗余能够去除单点失败，并提供一个备份或在必要的紧急时刻替换功能。例如，如果在生产环境有同一服务的两个实例在运行，其中一个失败或者降级了，系统可以（启动）failover 到那个健康状态的服务。Failover 可以自动发生或者需要人工干预。 服务冗余的另一个关键点在于创建一个非共享的架构。通过这种架构，每个节点都能够独立操作，并且没有中央“大脑”来管理状态或者协调其他节点的活动。这对于可伸缩性非常有帮助，因为新的节点不需要特殊的条件或知识就能加入到集群。但是，最重要的是在这些系统中不会存在单点失败问题，所以它们能够更加弹性地面对失败。 例如，在我们的图片服务应用，所有的图片会在另一个地方的硬件中有冗余的备份，理想情况是在一个不同的地理位置，以防地震或者数据中心火灾这类的灾难发生，而访问图片的服务同样是冗余的，见图 1.3（负载均衡器可以将其变为现实，详情请见下文） 图 1.3：图片托管应用，带有冗余特性 1.2.5. 扩容之水平扩展分区和垂直扩展 单台服务器可能没法放下海量数据集。也可能是一个操作需要太多计算资源，消耗性能，使得有必要增加系统容量。无论是哪种情况，你都有两种选择：垂直扩展（scale vertically）或者水平扩展（scale horizontally）。 垂直扩展意味着在单台服务器上增加更多的资源。所以对于大数据来说，这意味着增加更多更大容量的硬盘以便让单台服务器能够容纳整个数据集。对于计算操作的场景，这意味着将计算任务交给一台拥有更快 CPU 或者更多内存的大型服务器。对于每种场景，垂直扩展是通过自身能够处理更多的方式来达到目标的。 垂直扩展对于应用来说无需修改，通常升级机器即可达到目的 水平扩展，就是增加更多的节点。对于大数据集，可能是用另一台服务器来存储部分数据集；而对于计算资源来说，则意味着将操作进行分解或者加载在一些额外的节点上。水平扩展要求应用架构能够支持这种方式的扩展，因为数据、服务都是分布式的，需要从软件层面来支持这一特性，从而做到数据、服务的水平可扩展。水平扩展应该被天然地包含在系统架构设计准则里，否则想要通过修改、隔离上下文来达到这一点将会相当麻烦。 对于水平扩展来说，通常方法之一就是 将你的服务打散、分区。分区可以是分布式的，这样每个逻辑功能集都是分离的；分区可通过地理边界来划分，或者其他标准如付费/未付费用户 。这些设计的好处在于它们能够使得服务或数据存储易于增加容量。 在我们的图片服务器例子中，可以将单台存储图片的服务器替换为多台文件服务器，每台保存各自单独的图片集。（见图 1.4）这样的架构使得系统能够往各台文件服务器中存入图片，当磁盘快满时再增加额外的服务器。这种设计将需要一种命名机制，将图片的文件名与所在服务器关联起来。一个图片的名字可以通过服务器间一致性 Hash 机制来生成。或者另一种选择是，可以分配给每张图片一个增量 ID，当一个客户端请求一张图片时，图片检索服务只需要维护每台服务器对应的 ID 区间即可（类似索引）。 图 1.4：图片托管应用，加入冗余和分区特性 当然，将数据或功能分布在多台服务器上会带来很多挑战。关键问题之一是数据局部性（data locality）。在分布式系统里，数据离操作或者计算点越近，系统性能就越高。因此将数据分布在多台服务器可能是有问题的，任何需要数据的时候都可能不在本地，使得服务器必须通过网络来获取所需的信息。 1.3. 建立大型 web 大多数简单的 web 应用随着它们的成长，会有两个主要的挑战：访问应用服务器和数据库的可伸缩性。在一个高可伸缩的应用设计中，web 服务器通常会最小化并通常表现为一个非共享（无状态）架构。这样使得系统的应用服务层能够很好地进行伸缩。这样数据的结果是， 压力被向下推到了数据库服务器和相关（底层）支持服务；真正的伸缩和性能挑战就在这一层起到作用 。 假设你有数以 TB 计的数据并且希望能让用户随机访问这些数据的一小部分。由于很难将 TB 级的数据加载到内存，所以这会使得事情变得非常有挑战性。这种访问将直接变为磁盘 IO 操作。从磁盘读取会比从内存要慢得多。顺序访问内存的速度是访问磁盘的 6 倍，而在随机读方面，前者是后者的十万倍。而且，即使有唯一 ID，从哪里能够找到这样一小块数据仍然是一项艰巨的任务。 幸运的是，可以通过 缓存、代理、索引、负载均衡 来解决。 1.3.1. 缓存 缓存几乎被用在计算机运行的各层：硬件，操作系统，web 浏览器，web 应用等等。缓存就像短期的内存：有着限定大小的空间，但通常比访问原始数据源更快，并且包含有最近最多被访问过的（数据）项。缓存可以存在于架构的各个层次，但会发现到经常更靠近前端（非 web 前端界面，架构上层），这样就可尽快返回数据而不用经过繁重的下层处理了。 图 1.5：在请求层节点中插入缓存 每次对于一个服务的请求，节点将立即返回存在的本地、缓存的数据。如果对应的缓存不存在，请求节点将会从磁盘中查询数据。请求层节点的缓存既可以放置在内存（更快）也可以在节点本地磁盘（比通过网络快）上。 图 1.6：多个缓存 当你扩展到多个节点时，会发生什么呢？正如你看到的图 1.6，如果请求曾扩展到多个节点，那么每个节点都可以拥有它自身的缓存。但是，如果你的负载均衡器将请求随机分发到这些节点上，同样的请求会到达不同的节点，就会提高缓存 miss 率。两种克服这种困难的方法是：全局缓存和分布式缓存。 全局缓存 所有节点使用同一缓存空间。这包括增加一台服务器或是某种类型的文件存储，并且所有请求层的节点均可以访问全局缓存。这种类型的缓存机制可能会变得比较复杂，因为随着客户端和请求数量的增加，单个缓存服务器很容易被压垮，但是在一些架构中非常有效（特别是有专门定制的硬件使得访问全局缓存非常快速，或者需要缓存的数据集是固定的）。 通常有两种形式的全局缓存。 如果缓存中找不到对应的响应，那缓存自身会去从下层存储中获取丢失的数据。 当缓存中找不到相应数据时，需要请求节点自己去获取数据。 第一种方式相当于是全局缓存将查询缓存、底层获取数据、填充缓存这些操作一并做掉，理想情况下对于上层应用应该只需要提供一个获取数据的 API，上层应用无需关心所请求的数据是已存在于缓存中的还是从底层存储中获取的，能够更专注于上层业务逻辑，但这就可能需要这种全局缓存设计成能够根据传入 API 接口的参数去获取底层存储的数据，接口签名可以简化为 Object getData(String uniqueId, DataRetrieveCallback callback)，第一个参数代表与缓存约定的唯一标示一个数据的 ID，第二个是一个获取数据回调接口，具体实现由调用该接口的业务端来实现，即当全局缓存中未找到 uniqueId 对应的缓存数据时，那就会以该 callback 去获取数据，并以 uniqueId 为 key、callback 获取数据为 value 放入全局缓存中。 图 1.7：全局缓存自身负责存取 第二种方式相对来说自由一些。请求节点自行根据业务场景需求来决定查询数据的方式，以及查数据后的处理（比如缓存回收策略），全局缓存只作为一个基础组件让请求节点能够在其中存取数据。 图 1.8 全局缓存，请求节点负责存取 大多数应用倾向于通过第一种方式使用全局缓存，由缓存自身来管理回收、获取数据，来应对从客户端发起的对同一数据的众多请求。但是，对于一些场景来说，第二种实现就比较有意义。比如，如果是用来缓存大型文件，那缓存低命中率将会导致缓存缓冲区被缓存 miss 给压垮；在这种情况下，缓存中缓存大部分数据集（或热门数据）将会有助解决这个问题。另一个例子是，一个架构中缓存的文件是静态、不应回收的。（这可能跟应用对于数据延迟的需求有关——对于大数据集来说，某些数据段需要被快速访问——这时应用的业务逻辑会比缓存更懂得回收策略或热点处理。） 分布式缓存 在一个分布式缓存中，每个节点拥有部分缓存的数据，如果将杂货店里的冰箱比作一个缓存，那么一个分布式缓存好比是将你的食物放在几个不同的地方——你的冰箱、食物柜、午餐饭盒里——非常便于取到快餐的地方而无需跑一趟商店。通常这类缓存使用 一致性 Hash 算法进行切分，这样一个请求节点在查询指定数据时，可以很快知道去哪里查询 ，并通过分布式缓存来判断数据可用性。这种场景下，每个节点都会拥有一部分缓存，并且会将请求传递到其他节点来获取数据，最后才到原始地方查询数据。因此，分布式缓存的一个优势就是通过往请求池里增加节点来扩大缓存空间。 分布式缓存的一个缺点在于节点丢失纠正问题。一些分布式缓存通过将复制数据多份存放在不同的节点来解决这个问题；但是，你可以想象到这样做会让逻辑迅速变得复杂，特别是当你向请求层增加或减少节点的时候。虽然一个节点丢失并且缓存失效，但请求仍然可以从源头来获取（数据）——所以这不一定是最悲剧的。 图 1.8 分布式缓存 缓存是以需要维护更多存储空间为代价的，特别是昂贵的内存方式；天下没有免费的午餐。缓存让事情变得更快，同时还保证了高负载条件下系统的功能，否则系统服务可能早已降级。 一个非常受欢迎的开源缓存叫做Memcached（既可以是本地又可以是分布式缓存）。它简单来说就是一个内存 key-value 存储，对任意数据存储和快速查找做了优化（时间复杂度 O(1)）。 Facebook 使用了若干种不同类型的缓存以达到他们网站的性能要求（Facebook caching and performance）。他们在语言层面使用$GLOBALS 和 APC 缓存（在 PHP 中提供的函数调用）使得中间功能调用和结果更快。Facebook 使用一种全局缓存，分布在多台服务器上（Scaling memcached at Facebook），这样一个访问缓存的函数调用就会产生很多并行请求来从 Memcached 服务器集群获取数据。这使得他们能够在用户概况数据上获得更高的性能和吞吐量，并且有一个集中的地方去更新数据。 现在让我们来聊聊当数据不存在于缓存的时候应该做什么。 1.3.2. 代理 从基本层面来看，代理服务器是硬件/软件的一个中间层，用于接收从客户端发起的请求并传递到后端服务器。通常来说，代理是用来 过滤请求、记录请求日志或者有时对请求进行转换（增加/去除头文件，加密/解密或者进行压缩） 。 代理同样能够极大帮助协调多个服务器的请求，有机会从系统的角度来优化请求流量。使用代理来加快数据访问速度的方式之一是 将多个同种请求集中放到一个请求中，然后将单个结果返回到请求客户端。这就叫做压缩转发(collapsed forwarding) 假设在几个节点上存在对同样数据的请求（我们叫它 littleB），并且这份数据不在缓存里。如果请求通过代理路由，那么这些请求可以被压缩为一个，就意味着我们只需要从磁盘读取一次 littleB 即可。这种设计是会带来一定的开销，因为跟不用代理相比每个请求都会产生更高的延迟，并且一些请求会因为要与相同请求合并而产生一些延迟。但这种做法在高负载的情况下提高系统性能，特别是当相同的数据重复被请求。这很像缓存，但不用像缓存那样存储数据/文件，而是优化了对那些文件的请求或调用，并且充当那些客户端的代理。 例如，在局域网（LAN）代理中，客户端不需有自己的 IP 来连接互联网，而局域网会将对同样内容的客户端请求进行压缩。这里可能很容易产生困惑，因为许多代理同样也是缓存（因为在这里放一个缓存很合理），但不是所有缓存都能充当代理。 图 1.14：使用一个代理服务器来压缩请求 另一个使用代理的好方法是，可以用来压缩对那些在原始存储中空间上紧密联系的数据（磁盘连续块）的请求。例如，我们假设一群节点请求 B 的部分数据：B1、B2。我们可以对代理进行设置使其能够识别出不同请求的空间局部性，将它们压缩为单个请求并且只返回 bigB，最小化对原始数据的读取操作。当你随机访问 TB 级的数据时，这样会大幅降低请求时间。在高负载情况下或者当你只有有限的缓存，代理是非常有帮助的，因为代理可以从根本上将若干个请求合并为一个。 图 1.11：使用代理压缩空间上邻近的数据请求 你完全可以一并使用代理和缓存，但通常 最好将缓存放在代理之前使用 。这是因为缓存通过内存来提供数据非常快速，并且它也不关心多个对同样结果的请求。但如果缓存被放在代理服务器的后面，那在每个请求访问缓存前就会有额外的延迟，这会阻碍系统性能。 如果你在寻找一款代理想要加入到你的系统中，那有很多选择可供考虑；Squid 和 Varnish 都是经过路演并广泛应用于很多网站的生产环境中。这些代理方案做了很多优化来充分使用客户端与服务端的通信。安装其中之一并在 web 服务器层将其作为一个反向代理（将在下面的负载均衡小节解释）可以提高 web 服务器性能，降低处理来自客户端的请求所消耗的工作量。 1.3.3. 索引 使用索引来加快访问数据已经是优化数据访问性能众所周知的策略。索引是以增加存储开销和减慢写入速度（因为你必须同时写入数据并更新索引）的代价来得到更快读取的好处。 就像对于传统的关系数据库，你同样可以将这种概念应用到大数据集上。索引的诀窍在于你必须仔细考虑你的用户会如何使用你的数据。对于 TB 级但单项数据比较小比如 1KB 的数据集，索引是优化数据访问非常必要的方式。在一个大数据集中寻找一个小单元是非常困难的，因为你不可能在一个可接受的时间里遍历这么大的数据。并且，像这么一个大数据集很有可能是分布在几个物理设备上——这就意味着你需要有方法能够找到所要数据正确的物理位置。索引是达到这个的最好方法。 图 1.12：索引 假设你在寻找 B 的 part2 数据——你将如何知道到哪去找到它？如果你有一个按照数据类型（如 A,B,C）排序好的索引，它会告诉你数据 B 在哪里。然后你查找到位置，然后读取你所要的部分。 这些索引通常存放在内存中，或者在更靠近客户端请求的地方。伯克利数据库（BDBs）和树形数据结构经常用来有序地存储数据，非常适合通过索引来访问。 索引经常会有很多层，类似一个 map，将你从一个地方引导至另一个，以此类推，直到你获取到你所要的那份数据。 图 1.13：多层索引 索引也可以用来对同样的数据创建出一些不同的视图。对于大数据集来说，通过定义不同的过滤器和排序是一个很好的方式，而不需要创建很多额外数据拷贝。 在大型可伸缩的系统中，即使索引已被压缩但仍会变得很大，不易存储。在这个系统里，我们假设世界上有很多书——100,000,000 本——并且每本书仅有 10 页（为了便于计算），每页有 250 个单词，这就意味着一共有 2500 亿个单词。如果我们假设平均每个单词有 5 个字符，每个字符占用 8 个比特，每个单词 5 个字节，那么对于仅包含每个单词的索引的大小就达到 TB 级。所以你会发现创建像一些如词组、数据位置、出现次数之类的其他信息的索引将会增长得更快。 创建这些中间索引并且以更小的方式表达数据，将大数据的问题变得易于处理。数据可以分布在多台服务器但仍可以快速访问。索引是信息获取的基石，也是当今现代搜索引擎的基础。 1.3.4. 负载均衡 用于将负载分摊在一些列负责服务请求的节点上。这使得一个系统的多个节点能够为相同功能提供服务。它们主要目的是处理许多同时进行的连接并将这些连接路由到其中的一个请求节点上，使得系统能够可伸缩地通过增加节点来服务更多请求。 图 1.14 负载均衡器 有很多不同的用于服务请求的算法，包括随机挑选一个节点、循环或给予某些标准如内存/CPU 使用率选取节点。一个广泛使用的开源软件级负载均衡器是 HAProxy。 在一个分布式系统中，负责均衡器通常是放置在系统很前端的地方，这样就能路由所有进入系统的请求。在一个复杂的分布式系统中，一个请求被多个负载均衡器路由也是可能的。 图 1.15：多重负责均衡器 如同代理一般，一些负载均衡器也能根据不同类型的请求进行路由。（从技术上来说，就是所谓的反向代理。） 负载均衡器的挑战之一在于如何管理用户 session 数据。在一个电子商务网站，当你只有一个客户端时很容易让用户把东西放到他们的购物车并且在不同的访问间保存（这是很重要的，因为当用户回来时很有可能买放在购物车里的产品）。但是，如果一个用户先被路由到一个 session 节点，然后在他们下次访问时路由到另一个不同的节点，那将会因为新节点可能丢失用户购物车里的东西而产生不一致。解决办法之一通过粘性 session机制总是将用户路由到同一节点，但这样既很难享受到一些像自动 failover 的可靠机制了。 上段中提到的用户 session 问题，实际上在很多大型网站如淘宝、支付宝，都是通过一个分布式 session 的中间件来解决的。原理其实很简单，比如用户登录了支付宝，那么系统会给当前用户分配一个全局唯一的 sessionId 并写入到浏览器的 cookie 中，在后台服务端也会有专门的一个分布式存储以 sessionId 为 key 开辟一个空间存放该用户 session 数据。虽然应用都是集群部署方式，但每个无状态应用节点都会统一连接到该分布式存储。由于用户 session 数据是统一保存在分布式存储上，即对 session 数据的存取都是发生在同一个地方，而非各个节点内部，所以不会因为不同的请求路由到不同的应用节点上导致 session 数据不一致的情况。同时，这一方法不会像 sticky session 机制那样限制了系统的可伸缩性。如果出现 session 存取的性能问题，那只需通过扩展后端分布式存储即可解决。 如果系统只是由少数节点构成的，那么像 Round Robin DNS 那样的系统就更加明智，因为负责均衡器很贵而且增加了一层不必要的复杂度。当然在大型系统里有各种各样的调度和负载均衡算法，包括简单的像随机选择或循环方式，还有更加复杂的机制如考虑系统使用率和容量的。所有这些算法都分布化了流量和请求，并且提供像自动 failover 或者自动去除坏节点，这类对可靠性非常有帮助的工具。但是，这些先进特性也会使得问题诊断变得复杂化。比如，在一个高负载情况下，负载均衡器会去除掉那些变慢或者超时（由于请求过多）的节点，但这样反而加重了其他节点的恶劣处境。在这些情况下，全面监控变得很重要，因为从全局来看系统的流量和吞吐量正在下降（由于各节点服务请求越来越少），但从节点个体来看正在达到极限。 负载均衡器是一个非常简单能让你提高系统容量的方法，还能用来判断一个节点的健康度，这样当一个节点失去响应或者过载时，得益于系统不同节点的冗余性，可以将其从请求处理池中去除。 1.3.5. 队列 另一个扩展数据层的重要部分是有效管理写入操作。当系统比较简单，系统处理负载很低，数据库也很小，可以预见写入操作是很快的；但是，在更加复杂的系统中，写入操作的时间可能无法确定。例如，数据需要被写入到不同服务器或索引的多个地方，或者系统负载很高。这些情况下，写操作或者任何任务都会花费很长的时间，这时需要异步化系统才能提高系统的性能和可靠性；通常的方法之一是使用队列。 在小型系统中，一台服务器可以尽快地处理客户端请求。但是，当服务器接收到超过其处理能力的请求时，那每个客户端都只能被迫等待其他客户端请求完成才能得到响应。这种同步的方式将会严重降低客户端性能，客户端被强制等待。增加额外的服务器并不能解决这个问题；即使通过有效的负载均衡，依然难以保证最大化客户端性能所需做的公平分配的工作。 图 1.16：同步化请求 使用队列，当前有能力处理任务的 worker 去取下一个任务来做。这些任务可以是对数据库的写入操作，或是复杂一些的如生成文件的小型预览图。当一个客户端将任务的请求提交到队列后，它们不再需要被迫等待结果；取而代之的是，它们只需要确认请求被得到正确接收。 图 1.17：使用队列来管理请求 队列使得客户端能够以异步的方式进行工作。另一方面，一个同步化系统不会区分请求和响应，因此就无法分开管理。在一个异步化系统里，客户端提交任务请求，后端服务反馈一个收到任务的确认信息，并且客户端可以定期地查看任务的状态，一旦完成即可取得任务结果。在客户端等待一个异步请求完成时，它可以自由地处理其他的工作，即使是发起对其他服务的异步请求。 队列还能提供对服务断供/失败的保护措施。比如，很容易创建一个健壮的队列来重试那些由于服务器短暂失败的服务请求。更好的是通过使用队列来确保服务品质，而非将客户端直接面对断断续续的服务，因为那样会需要客户端复杂且经常不一致的错误处理。 队列是管理大型可伸缩分布式应用不同部分间通信的基础，可以通过很多方式来实现。有一些开源的队列如RabbitMQ, ActiveMQ, BeanstalkD，也有一些使用像 Zookeeper 的服务，还有像 Redis 那样的数据存储。 正如大家所知的双十一、双十二，这两天用户的请求可谓超级海量。拿支付宝来说，核心系统如支付、账务，即使使用了很多技术方案来确保高性能、高可用，但面对数倍于平时的请求量依然捉急。在开发了一套分布式队列基础中间件后，网站的吞吐量、可用性得到了很大的提高。同时，对于队列来说，除了将客户端请求与服务端处理分离外，通过对队列加上额外的一些特性，能够起到非常大的作用。比如，在队列上加入限流特性，当请求量大大超过后端服务处理能力时，可以采取丢弃请求的方式来保证系统、队列不至于被海量请求压垮；当请求量回到一定水平，再将限流放开。这种做法，正好满足了系统对可用性、性能、可伸缩性、可管理性的要求。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/大型网站架构.html": {
    "url": "Basic/大型网站架构/大型网站架构.html",
    "title": "大型网站架构",
    "keywords": "",
    "body": "1. 大型分布式网站架构技术总结1.1.1. 一、特点1.1.2. 二、架构目标1.1.3. 三、架构模式1.1.4. 四、高性能架构1.1.5. 五、高可用架构1.1.6. 六、可伸缩架构1.1.7. 七、可扩展架构1.1.8. 八、安全架构1.1.9. 九、敏捷性1.1.10. 十、大型架构举例1. 大型分布式网站架构技术总结 http://www.10tiao.com/html/357/201701/2247484785/1.html 1.1.1. 一、特点 用户多，分布广泛 大流量，高并发 海量数据，服务高可用 安全环境恶劣，易受网络攻击 功能多，变更快，频繁发布 从小到大，渐进发展 以用户为中心 免费服务，付费体验 1.1.2. 二、架构目标 高性能：提供快速的访问体验。 高可用：网站服务一直可以正常访问。 可伸缩：通过硬件增加/减少，提高/降低处理能力。 安全性：提供网站安全访问和数据加密，安全存储等策略。 扩展性：方便的通过新增/移除方式，增加/减少新的功能/模块。 敏捷性：随需应变，快速响应 1.1.3. 三、架构模式 分层：一般可分为，应用层，服务层，数据层，管理层，分析层； 分割：一般按照业务/模块/功能特点进行划分，比如应用层分为首页，用户中心。 分布式：将应用分开部署（比如多台物理机），通过远程调用协同工作。 集群：一个应用/模块/功能部署多份（如：多台物理机），通过负载均衡共同提供对外访问。 缓存：将数据放在距离应用或用户最近的位置，加快访问速度。 异步：将同步的操作异步化。客户端发出请求，不等待服务端响应，等服务端处理完毕后，使用通知或轮询的方式告知请求方。一般指：请求——响应——通知 模式。 冗余：增加副本，提高可用性，安全性，性能。 安全：对已知问题有有效的解决方案，对未知/潜在问题建立发现和防御机制。 自动化：将重复的，不需要人工参与的事情，通过工具的方式，使用机器完成。 敏捷性：积极接受需求变更，快速响应业务发展需求。 1.1.4. 四、高性能架构 以用户为中心，提供快速的网页访问体验。主要参数有较短的响应时间，较大的并发处理能力，较高的吞吐量，稳定的性能参数。 可分为前端优化，应用层优化，代码层优化，存储层优化。 前端优化：网站业务逻辑之前的部分； 浏览器优化：减少 Http 请求数，使用浏览器缓存，启用压缩，Css Js 位置，Js 异步，减少 Cookie 传输； CDN 加速，反向代理； 应用层优化：处理网站业务的服务器。使用缓存，异步，集群 代码优化：合理的架构，多线程，资源复用（对象池，线程池等），良好的数据结构，JVM 调优，单例，Cache 等； 存储优化：缓存，固态硬盘，光纤传输，优化读写，磁盘冗余，分布式存储（HDFS），NOSQL 等； 1.1.5. 五、高可用架构 大型网站应该在任何时候都可以正常访问。正常提供对外服务。因为大型网站的复杂性，分布式，廉价服务器，开源数据库，操作系统等特点。要保证高可用是很困难的，也就是说网站的故障是不可避免的。 如何提高可用性，就是需要迫切解决的问题。首先，需要从架构级别，在规划的时候，就考虑可用性。行业内一般用几个 9 表示可用性指标。比如四个 9（99.99），一年内允许的不可用时间是 53 分钟。 不同层级使用的策略不同，一般采用冗余备份和失效转移解决高可用问题。 应用层：一般设计为无状态的，对于每次请求，使用哪一台服务器处理是没有影响的。一般使用负载均衡技术（需要解决 Session 同步问题），实现高可用。 服务层：负载均衡，分级管理，快速失败（超时设置），异步调用，服务降级，幂等设计等。 数据层：冗余备份（冷，热备[同步，异步]，温备），失效转移（确认，转移，恢复）。数据高可用方面著名的理论基础是 CAP 理论（持久性，可用性，数据一致性[强一致，用户一致，最终一致]） 1.1.6. 六、可伸缩架构 伸缩性是指在不改变原有架构设计的基础上，通过添加/减少硬件（服务器）的方式，提高/降低系统的处理能力。 应用层：对应用进行垂直或水平切分。然后针对单一功能进行负载均衡（DNS,HTTP[反向代理],IP,链路层）。 服务层：与应用层类似； 数据层：分库，分表，NOSQL 等；常用算法 Hash，一致性 Hash。 1.1.7. 七、可扩展架构 可以方便的进行功能模块的新增/移除，提供代码/模块级别良好的可扩展性。 模块化，组件化：高内聚，内耦合，提高复用性，扩展性。 稳定接口：定义稳定的接口，在接口不变的情况下，内部结构可以“随意”变化。 设计模式：应用面向对象思想，原则，使用设计模式，进行代码层面的设计。 消息队列：模块化的系统，通过消息队列进行交互，使模块之间的依赖解耦。 分布式服务：公用模块服务化，提供其他系统使用，提高可重用性，扩展性。 1.1.8. 八、安全架构 对已知问题有有效的解决方案，对未知/潜在问题建立发现和防御机制。对于安全问题，首先要提高安全意识，建立一个安全的有效机制，从政策层面，组织层面进行保障。比如服务器密码不能泄露，密码每月更新，并且三次内不能重复；每周安全扫描等。以制度化的方式，加强安全体系的建设。同时，需要注意与安全有关的各个环节。安全问题不容忽视。包括基础设施安全，应用系统安全，数据保密安全等。 基础设施安全：硬件采购，操作系统，网络环境方面的安全。一般采用，正规渠道购买高质量的产品，选择安全的操作系统，及时修补漏洞，安装杀毒软件防火墙。防范病毒，后门。设置防火墙策略，建立 DDOS 防御系统，使用攻击检测系统，进行子网隔离等手段。 应用系统安全：在程序开发时，对已知常用问题，使用正确的方式，在代码层面解决掉。防止跨站脚本攻击（XSS），注入攻击，跨站请求伪造（CSRF），错误信息，HTML 注释，文件上传，路径遍历等。还可以使用 Web 应用防火墙（比如：ModSecurity），进行安全漏洞扫描等措施，加强应用级别的安全。 数据保密安全：存储安全（存在在可靠的设备，实时，定时备份），保存安全（重要的信息加密保存，选择合适的人员复杂保存和检测等），传输安全（防止数据窃取和数据篡改）； 常用的加解密算法（单项散列加密[MD5,SHA]，对称加密[DES,3DES,RC]），非对称加密[RSA]等。 1.1.9. 九、敏捷性 网站的架构设计，运维管理要适应变化，提供高伸缩性，高扩展性。方便的应对快速的业务发展，突增高流量访问等要求。 除上面介绍的架构要素外，还需要引入敏捷管理，敏捷开发的思想。使业务，产品，技术，运维统一起来，随需应变，快速响应。 1.1.10. 十、大型架构举例 以上采用七层逻辑架构，第一层客户层，第二层前端优化层，第三层应用层，第四层服务层，第五层数据存储层，第六层大数据存储层，第七层大数据处理层。 客户层：支持 PC 浏览器和手机 APP。差别是手机 APP 可以直接访问通过 IP 访问，反向代理服务器。 前端层：使用 DNS 负载均衡，CDN 本地加速以及反向代理服务； 应用层：网站应用集群；按照业务进行垂直拆分，比如商品应用，会员中心等； 服务层：提供公用服务，比如用户服务，订单服务，支付服务等； 数据层：支持关系型数据库集群（支持读写分离），NOSQL 集群，分布式文件系统集群；以及分布式 Cache； 大数据存储层：支持应用层和服务层的日志数据收集，关系数据库和 NOSQL 数据库的结构化和半结构化数据收集； 大数据处理层：通过 Mapreduce 进行离线数据分析或 Storm 实时数据分析，并将处理后的数据存入关系型数据库。（实际使用中，离线数据和实时数据会按照业务要求进行分类处理，并存入不同的数据库中，供应用层或服务层使用）。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/读写锁分离-封装ReaderWriterLockSlim.html": {
    "url": "Basic/大型网站架构/读写锁分离-封装ReaderWriterLockSlim.html",
    "title": "读写锁分离-封装 ReaderWriterLockSlim",
    "keywords": "",
    "body": "1. 读写锁分离－－封装 ReaderWriterLockSlim1.1. ReaderWriterLockSlim 类1.2. 主要属性,方法1.3. 应用1.4. 封装1.5. 使用场合1.6. 使用详细说明1.7. 对比无 lock1.8. 对比原始单一 lock1.9. Code 平台下载1. 读写锁分离－－封装 ReaderWriterLockSlim 1.1. ReaderWriterLockSlim 类 表示用于管理资源访问的锁定状态，可实现多线程读取或进行独占式写入访问。 使用 ReaderWriterLockSlim 来保护由多个线程读取但每次只采用一个线程写入的资源。 ReaderWriterLockSlim 允许多个线程均处于读取模式，允许一个线程处于写入模式并独占锁定状态，同时还允许一个具有读取权限的线程处于可升级的读取模式，在此模式下线程无需放弃对资源的读取权限即可升级为写入模式。 注意 ReaderWriterLockSlim 类似于 ReaderWriterLock，只是简化了递归、升级和降级锁定状态的规则。 ReaderWriterLockSlim 可避免多种潜在的死锁情况。 此外，ReaderWriterLockSlim 的性能明显优于 ReaderWriterLock。 建议在所有新的开发工作中使用 ReaderWriterLockSlim。 1.2. 主要属性,方法 属性: IsReadLockHeld 　　获取一个值，该值指示当前线程是否已进入读取模式的锁定状态。 IsWriteLockHeld 　 获取一个值，该值指示当前线程是否已进入写入模式的锁定状态。 方法: EnterReadLock 尝试进入读取模式锁定状态。 ExitReadLock 减少读取模式的递归计数，并在生成的计数为 0（零）时退出读取模式。 EnterWriteLock 尝试进入写入模式锁定状态。 ExitWriteLock 减少写入模式的递归计数，并在生成的计数为 0（零）时退出写入模式。 当然还有其他很多方法,比如EnterUpgradeableReadLock.aspx>)进入可以升级到写入模式的读取模式.. 1.3. 应用 来对比一个老式的 lock 写法 private object _Lock = new object(); private void Read() { lock (_Lock) { //具体方法实现 } } 读写锁分离 private ReaderWriterLockSlim _LockSlim = new ReaderWriterLockSlim(); private void Read() { try { _LockSlim.EnterReadLock(); //具体方法实现 } finally { _LockSlim.ExitReadLock(); } } private void Write() { try { _LockSlim.EnterWriteLock(); //具体方法实现 } finally { _LockSlim.ExitWriteLock(); } } 看上下 2 种写法: 从性能的角度来说,肯定是读写锁分离更好了，特别是大多数场合(读取操作远远多余写入操作) 从可读性和代码美观度来说，就是上面的 lock 要简洁的多了，维护起来也更清晰 所以我希望重新封装 ReaderWriterLockSlim，当然我第一想到的就是利用 using 语法糖的特性封装一个新的对象 1.4. 封装 Code 平台: UsingLock 由于是利用的 using 的语法,所以我直接取名叫 UsingLock，简单好记 using System; using System.Threading; namespace blqw { /// 使用using代替lock操作的对象,可指定写入和读取锁定模式 /// public class UsingLock { #region 内部类 /// 利用IDisposable的using语法糖方便的释放锁定操作 /// 内部类 /// private struct Lock : IDisposable { /// 读写锁对象 /// private ReaderWriterLockSlim _Lock; /// 是否为写入模式 /// private bool _IsWrite; /// 利用IDisposable的using语法糖方便的释放锁定操作 /// 构造函数 /// /// 读写锁 /// 写入模式为true,读取模式为false public Lock(ReaderWriterLockSlim rwl, bool isWrite) { _Lock = rwl; _IsWrite = isWrite; } /// 释放对象时退出指定锁定模式 /// public void Dispose() { if (_IsWrite) { if (_Lock.IsWriteLockHeld) { _Lock.ExitWriteLock(); } } else { if (_Lock.IsReadLockHeld) { _Lock.ExitReadLock(); } } } } /// 空的可释放对象,免去了调用时需要判断是否为null的问题 /// 内部类 /// private class Disposable : IDisposable { /// 空的可释放对象 /// public static readonly Disposable Empty = new Disposable(); /// 空的释放方法 /// public void Dispose() { } } #endregion /// 读写锁 /// private ReaderWriterLockSlim _LockSlim = new ReaderWriterLockSlim(); /// 保存数据 /// private T _Data; /// 使用using代替lock操作的对象,可指定写入和读取锁定模式 /// 构造函数 /// public UsingLock() { Enabled = true; } /// 使用using代替lock操作的对象,可指定写入和读取锁定模式 /// 构造函数 /// 为Data属性设置初始值 public UsingLock(T data) { Enabled = true; _Data = data; } /// 获取或设置当前对象中保存数据的值 /// /// 获取数据时未进入读取或写入锁定模式 /// 设置数据时未进入写入锁定模式 public T Data { get { if (_LockSlim.IsReadLockHeld || _LockSlim.IsWriteLockHeld) { return _Data; } throw new MemberAccessException(\"请先进入读取或写入锁定模式再进行操作\"); } set { if (_LockSlim.IsWriteLockHeld == false) { throw new MemberAccessException(\"只有写入模式中才能改变Data的值\"); } _Data = value; } } /// 是否启用,当该值为false时,Read()和Write()方法将返回 Disposable.Empty /// public bool Enabled { get; set; } /// 进入读取锁定模式,该模式下允许多个读操作同时进行 /// 退出读锁请将返回对象释放,建议使用using语块 /// Enabled为false时,返回Disposable.Empty; /// 在读取或写入锁定模式下重复执行,返回Disposable.Empty; /// public IDisposable Read() { if (Enabled == false || _LockSlim.IsReadLockHeld || _LockSlim.IsWriteLockHeld) { return Disposable.Empty; } else { _LockSlim.EnterReadLock(); return new Lock(_LockSlim, false); } } /// 进入写入锁定模式,该模式下只允许同时执行一个读操作 /// 退出读锁请将返回对象释放,建议使用using语块 /// Enabled为false时,返回Disposable.Empty; /// 在写入锁定模式下重复执行,返回Disposable.Empty; /// /// 读取模式下不能进入写入锁定状态 public IDisposable Write() { if (Enabled == false || _LockSlim.IsWriteLockHeld) { return Disposable.Empty; } else if (_LockSlim.IsReadLockHeld) { throw new NotImplementedException(\"读取模式下不能进入写入锁定状态\"); } else { _LockSlim.EnterWriteLock(); return new Lock(_LockSlim, true); } } } } 方法: Read() 进入读取锁定模式 Write() 进入写入锁定模式 属性： Data UsingLock 中可以保存一个数据，由当前线程中的环境判断是否可以读取或设置该对象 Enabled 是否启用当前组件..这个有妙用，下面介绍 1.5. 使用场合 /// 假设有这样一个队列系统 /// class MyQueue:IEnumerable { List _List; UsingLock _Lock; public MyQueue(IEnumerable strings) { _List = new List(strings); _Lock = new UsingLock(); } /// 获取第一个元素.并且从集合中删除 /// public string LootFirst() { using (_Lock.Write()) { if (_List.Count == 0) { _Lock.Enabled = false; return null; } var s = _List[0]; _List.RemoveAt(0); return s; } } public int Count { get { return _List.Count; } } /// 枚举当前集合的元素 /// public IEnumerator GetEnumerator() { using (_Lock.Read()) { foreach (var item in _List) { yield return item; } } } System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return GetEnumerator(); } } 我这里假设了一个队列系统，把最容易出现问题的修改集合和枚举集合 2 个操作公开出来，方便在多线程中测试效果 以下为测试代码: static void Main(string[] args) { //建立一个字符串集合,总数为1000 List list = new List(1000); for (int i = 0; i { Console.WriteLine(mq.LootFirst()); }); } //在主线程中不停调用mq的遍历方法,这样的操作是很容易出现线程争抢资源的,如果没有锁定访问机制,就会出现异常 while (mq.Count > 0) { foreach (var item in mq) { //如果最后一个值还在,就输出 \"还在\" if (item == last) { Console.WriteLine(\"还在\"); } } } } 测试结果 Release 模式下也是很轻松就跑完了,证明访问的同步控制部分是可以正常工作的 1.6. 使用详细说明 语法上是不是跟 lock 比较类似了?Enabled 属性的作用在这里就可见一斑了 这部分比较简单,就不多说了..... 1.7. 对比无 lock 当然写完可以用,还需要和原始的方式比较一下,不然不知道优劣 对比无 lock 模式 将 using 代码注释,果然出现了异常 1.8. 对比原始单一 lock 对比原始 lock 模式,这次需要加上时间 UsingLock VS 单一 lock 1.9. Code 平台下载 https://code.csdn.net/snippets/112634 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/负载均衡方法和分布式缓存.html": {
    "url": "Basic/大型网站架构/负载均衡方法和分布式缓存.html",
    "title": "负载均衡方法和分布式缓存",
    "keywords": "",
    "body": "1. 一、网站架构的伸缩性设计1.1. 1.1 不同功能进行物理分离实现伸缩1.2. 1.2 单一功通过集群规模实现伸缩2. 二、应用服务器集群的伸缩性设计2.1. 2.1 应用服务器2.2. 2.2 负载均衡技术—网站必不可少的基础技术手段2.3. 2.3 负载均衡算法—负载均衡技术赖以生存的核心3. 三、分布式缓存集群的伸缩性设计4. 四、数据存储服务器集群的伸缩性设计5. 本章思维导图1. 一、网站架构的伸缩性设计 首先，所谓网站的伸缩性，指不需要改变网站的软硬件设计，仅仅通过改变部署的服务器数量就可以扩大或者缩小网站的服务处理能力。在整个互联网行业的发展渐进演化中，最重要的技术就是服务器集群，通过不断地向集群中添加服务器来增强整个集群的处理能力。 1.1. 1.1 不同功能进行物理分离实现伸缩 （1）纵向分离：将业务处理流程上得不同部分分离部署，实现系统的伸缩性； （2）横向分离：将不同的业务模块分离部署，实现系统的伸缩性； 1.2. 1.2 单一功通过集群规模实现伸缩 使用服务器集群，即将相同服务部署在多台服务器上构成一个集群整体对外提供服务。具体来说，集群伸缩性又分为应用服务器集群伸缩性和数据服务器集群伸缩性。这两种集群对于数据状态管理的不同，技术实现也有很大的区别。 2. 二、应用服务器集群的伸缩性设计 2.1. 2.1 应用服务器 （1）应用服务器应该被设计成无状态的，即应用服务器不存储请求上下文信息；构建集群后，每次用户的请求都可以发到集群中任意一台服务器上处理，任何一台服务器的处理结果都是相同的； （2）HTTP 本身是一个无状态的连接协议，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是 Cookie 和 Session 了。 （3）HTTP 请求的分发是应用服务器集群实现伸缩性的核心问题，而负载均衡服务器就是 HTTP 请求的分发装置，它是网站必不可少的基础手段，也被称为网站的杀手锏之一。 2.2. 2.2 负载均衡技术—网站必不可少的基础技术手段 负载均衡的实现方式多种多样，从硬件到软件，从商业产品到开源产品，应有尽有。但是，实现负载均衡的基础技术不外乎以下几种： （1）HTTP 重定向负载均衡　　评价：★★ 此方案的优点是简单易行，通过检测离用户较近的服务器，重定向到该服务器，缺点是： ① 浏览器需要两次请求才能完成一次访问，性能较差； ② 重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限； ③ 使用 HTTP 302 重定向有可能使搜索引擎判断为SEO 作弊，降低搜索排名； （2）DNS 域名解析负载均衡　　评价：★★★ 此方案要求在 DNS 服务器中配置多个 A 记录，例如： www.mysite.com IN A 114.100.80.1 www.mysite.com IN A 114.100.80.2 www.mysite.com IN A 114.100.80.3 此方案的优点是将负载均衡的工作转交给了 DNS，省掉了网站管理维护负载均衡服务器的麻烦。而缺点是： ① 目前的 DNS 是多级解析，每一级 DNS 都可能缓存 A 记录，当某台服务器下线后，即使修改了 DNS 的 A 记录，要使其生效仍然需要较长时间。这段期间，会导致用户访问已经下线的服务器造成访问失败。 ②DNS 负载均衡的控制权在域名服务商那里，网站无法对其做更多改善和管理； TIPS：事实上，大型网站总是部分使用 DNS 域名解析，利用域名解析作为第一级负载均衡手段，即域名解析得到的一组服务器不是实际的 Web 服务器，而是同样提供负载均衡的内部服务器，这组内部服务器再进行负载均衡，请求分发到真实的 Web 服务器上。 （3）反向代理负载均衡　　评价：★★★★ Web 服务器不需要使用外部 IP 地址，而反向代理服务器则需要配置双网卡和内外部两套 IP 地址。 此方案的优点是和反向代理服务器功能集成在一起，部署简单。缺点是反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。 （4）IP 负载均衡　　评价：★★★★ 此方案优点在于在内核进程完成数据分发，较反向代理负载均衡（在应用程序中分发数据）有更好的处理性能。缺点是由于所有请求响应都需要经过负载均衡服务器，集群的最大响应数据吞吐量不得不受制于负载均衡服务器网卡带宽。需要 ip 转换 （5）数据链路层负载均衡　　评价：★★★★★ 此种方式又称作三角传输模式，负载均衡数据分发过程中不修改 IP 地址，只修改 mac 地址，由于实际处理请求的真实物理 IP 地址和数据请求目的 IP 地址一致，所以不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载均衡方式又称作直接路由方式（DR）。 使用三角传输模式的链路层负载均衡是目前大型网站使用最广泛的一种负载均衡手段。在 Linux 平台上最好的链路层负载均衡开源产品是 LVS（Linux Virutal Server）。 2.3. 2.3 负载均衡算法—负载均衡技术赖以生存的核心 前面的方法解决了负载均衡通过何种方式实现，而更为重要的则是如何从 Web 服务器列表中计算得到一台 Web 服务器的地址，而这正是负载均衡的核心—算法。这里简单介绍一下通常的集中负载均衡计算的算法，如果需要深入了解请自行百度。 （1）轮询 所有请求被以此分发到每台应用服务器上，即每台服务器需要处理的请求数目都相同，适合于所有服务器硬件都相同的场景。 （2）加权轮询 根据应用服务器的配置性能的情况，在轮询的基础上，按照配置的权重将请求分发到每个服务器，高性能的服务器能分配更多的请求。 （3）随机 此算法比较简单实用，请求被随机分配到各个应用服务器，因为好的随机数本身就很均衡。 （4）最少连接 记录每个应用服务器正在处理的连接数（请求数），将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。 （5）源地址散列 根据请求来源的 IP 地址进行 Hash 计算得到应用服务器，这样来自同一个 IP 地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，从而实现会话粘滞。 3. 三、分布式缓存集群的伸缩性设计 不同于应用服务器集群的伸缩性设计，分布式缓存集群的伸缩性不能使用简单的负载均衡手段来实现。因为：分布式缓存服务器集群中缓存的数据各不相同，缓存访问请求不可以在缓存服务器集群中的任意一台处理，必须先找到缓存有需要的数据的服务器，然后才能访问。 分布式缓存集群伸缩性设计的目标：让新上线的缓存服务器对整个分布式缓存集群影响最小，也就是说新加入缓存服务器后应使整个缓存服务器集群中已经缓存的数据尽可能还被访问到。 （1）以 Memcached 为代表的分布式缓存集群的访问模型 以上图片展示了一个典型的缓存写操作，应用程序需要写缓存数据，API 将 KEY（'CHENGDU'）输入路由算法模块，路由算法根据 KEY 和 Memcached 服务器集群列表计算得到一台服务器编号（如 Node1），进而得到该机器的 IP 地址和端口（10.0.0.1:91000）。然后，API 调用通信模块和编号为 Node1 的 Memcached 服务器进行通信，将数据写入该服务器，至此便完成了一次分布式缓存的写操作。 而读操作和写操作一样，使用同样的路由算法和服务器列表，只要提供相同的 KEY（如上面提到的'CHENGDU'），Memcached 客户端总是访问相通的服务器（如上面计算得到的 Node1）去读取数据。 （2）以 Memcached 为代表的分布式缓存集群的伸缩性挑战 简单的路由算法（通过使用余数 Hash）无法满足业务发展时服务器扩容的需要：缓存命中率下降。例如：当 3 台服务器扩容至 4 台时，采用普通的余数 Hash 算法会导致大约 75%（3/4）被缓存了的数据无法正确命中，随着服务器集群规模的增大，这个比例会线性地上升。那么，可以想象，当 100 台服务器的急群众加入一台服务器，不能命中的概率大概是 99%（N/N+1），这个结果显然是无法接受的。 那么，能否通过改进路由算法，使得新加入的服务器不影响大部分缓存数据的正确性呢？请看下面的一致性 Hash 算法。 （3）分布式缓存的一致性 Hash 算法 说明：一致性 Hash 算法是分布式缓存的核心理论，这里只是简单介绍一下，后续有空我会单独写一篇文章来详细介绍一致性 Hash 算法，以及用 C#实现一致性 Hash 算法。 具体算法过程是： ① 先构造一个长度为 0~2^32 （2 的 32 次幂）个的整数环（又称：一致性 Hash 环），根据节点名称的 Hash 值将缓存服务器节点防置在这个 Hash 环中，如上图中的 node1，node2 等； ② 根据需要缓存的数据的 KEY 值计算得到其 Hash 值，如上图中右半部分的“键”，计算其 Hash 值后离 node2 很近； ③ 在 Hash 环上顺时针查找距离这个 KEY 的 Hash 值最近的缓存服务器节点，完成 KEY 到服务器的 Hash 映射查找，如上图中离右边这个键的 Hash 值最近的顺时针方向的服务器节点是 node2，因此这个 KEY 会到 node2 中读取数据； 当缓存服务器集群需要扩容的时候，只需要将新加入的节点名称（如 node5）的 Hash 值放入一致性 Hash 环中，由于 KEY 总是顺时针查找距离其最近的节点，因此新加入的节点只影响整个环中的一部分。如下图中所示，添加 node5 后，只影响右边逆时针方向的三个 Key/Value 对数据，只占整个 Hash 环中的一小部分。 因此，我们可以与之前的普通余数 Hash 作对比：采用一直性 Hash 算法时，当 3 台服务器扩容到 4 台时，可以继续命中原有缓存数据的概率为 75%，远高于普通余数 Hash 的 25%，而且随着集群规模越大，继续命中原有缓存数据的概率也会随之增大。当 100 台服务器增加 1 台时，继续命中的概率是 99%。虽然，仍有小部分数据缓存在服务器中无法被读取到，但是这个比例足够小，通过访问数据库也不会对数据库造成致命的负载压力。 4. 四、数据存储服务器集群的伸缩性设计 首先，数据存储服务器必须保证数据的可靠存储，任何情况下都必须保证数据的可用性和正确性。因此，缓存服务器集群的伸缩性架构方案不能直接适用于数据库等存储服务器。 （1）关系数据库集群的伸缩性设计 ① 市场上主要的关系数据库都支持数据复制功能，使用这个功能可以对数据库进行简单伸缩。下图显示了使用数据复制的 MySQL 集群伸缩性方案：多台 MySQL 的角色有主从之分，写操作都在主服务器上，由主服务器将数据同步到集群中其他从服务器。而读操作及数据分析等离线操作都会在从服务器上完成。 ② 前面提到的业务分割模式也可以用在数据库，不同业务数据表部署在不同的数据库集群上，这就是所谓的“数据分库”；但是其有一个制约条件：跨库的表无法进行 Join 操作； ③ 在实际运维中，对一些单表数据仍然很大的表，例如 Facebook 的用户数据库、淘宝的商品数据库等，还需要进行分片，将一张表拆分开分别存储在多个数据库中，这就是所谓的“数据分片”； （2）NoSQL 数据库的伸缩性设计 首先，NoSQL 主要指非关系的、分布式的数据库设计模式。也有许多专家将 NoSQL 解读为Not Only SQL，表示 NoSQL 是关系数据库的补充，而不是替代方案。一般而言，NoSQL 数据库产品都放弃了关系数据库的两大重要基础：① 以关系代数为基础的结构化查询语言（SQL）② 事务的一致性保证（ACID）；与之对应的是强化一些大型网站更关注的特性：高可用性和可伸缩性； 开源社区的 NoSQL 产品不尽其数，其支持的数据结构和伸缩性特性也各不相同。目前看来，应用最广泛的是 Apache HBase。HBase 的伸缩性主要依赖于其可分裂的 HRegion及可伸缩的分布式文件系统 HDFS（如果您不知道 HDFS 又对 HDFS 有兴趣，可以阅读我的另一篇博文《不怕故障的海量存储—HDFS 基础入门》）实现。 上图是 HBase 的整体架构图： ①HBase 中数据以 HRegion 为单位进行管理，也就是说应用程序如果想要访问一个数据，必须先找到 HRegion，然后将数据读写操作提交给 HRegion，由 HRegion 完成存储层面的数据操作。 ② 每个 HRegion 中存储一段 Key 区间（例如：[Key1,Key2)）的数据，HRegionServer 是物理服务器，每个 HRegionServer 上可以启动多个 HRegion 实例。当一个 HRegion 中写入的数据太多，达到配置的阀值时，HRegion 会分裂成两个 HRegion，并将 HRegion 在整个集群中进行迁移，以使 HRegionServer 的负载均衡。 ③ 所有的HRegion 的信息都（例如：存储的 Key 值区间、所在 HRegionServer 的 IP 地址和端口号等）记录在 HMaster 服务器上。同时为了保证高可用，HBase 启动了多个 HMaster，并通过 ZooKeeper（一个支持分布式一致性的数据管理服务）选举出一个主服务器，通过这个主 HMaster 服务器获得 Key 值所在的 HRegionServer，最后请求该 HRegionServer 上的 HRegion 实例，获得需要的数据。其具体的数据寻址访问流程如下图所示： 5. 本章思维导图 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/大型网站架构/高并发.html": {
    "url": "Basic/大型网站架构/高并发.html",
    "title": "高并发",
    "keywords": "",
    "body": "1. 如何处理并发和同步1.1. 悲观锁(Pessimistic Locking)1.2. 乐观锁(Optimistic Locking)1.3. 常见并发同步案例分析1.3.1. 案例一：订票系统案例，某航班只有一张机票，假定有 1w 个人打开你的网站来订票，问你如何解决并发问题(可扩展到任何高并发网站要考虑的并发读写问题)1.3.2. 案例二、股票交易系统、银行系统，大数据量你是如何考虑的1.4. 常见的提高高并发下访问的效率的手段1.5. 总结1.6. 参考1.7. .net 高并发1. 如何处理并发和同步 一种我觉得有点老的方式是通过锁机制。 锁机制有两个层面。一种是代码层次上的，如 java 中的同步锁，典型的就是同步关键字 synchronized。.net lock 另外一种是数据库层次上的，比较典型的就是悲观锁和乐观锁。 1.1. 悲观锁(Pessimistic Locking) 对数据被外界（包括本系统当前的其他事务，以及来自 外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能 真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。 一个典型的倚赖数据库的悲观锁调用： select * from account where name=\"Erica\" for update 这条 sql 语句锁定了 account 表中所有符合检索条件（ name=\"Erica\" ）的记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。 Hibernate 的悲观锁，也是基于数据库的锁机制实现。 下面的代码实现了对查询记录的加锁： String hqlStr = \"from TUser as user where user.name='Erica'\"; Query query = session.createQuery(hqlStr); query.setLockMode(\"user\", LockMode.UPGRADE); // 加锁 List userList = query.list();// 执行查询，获取数据 query.setLockMode 对查询语句中，特定别名所对应的记录进行加锁（我们为 TUser 类指定了一个别名 “user\" ），这里也就是对返回的所有 user 记录进行加锁。 Hibernate 的加锁模式有： LockMode.NONE ： 无锁机制。 LockMode.WRITE ： Hibernate 在 Insert 和 Update 记录的时候会自动获取 LockMode.READ ： Hibernate 在读取记录的时候会自动获取。 以上这三种锁机制一般由 Hibernate 内部使用，如 Hibernate 为了保证 Update 过程中对象不会被外界修改，会在 save 方法实现中自动为目标对象加上 WRITE 锁。 LockMode.UPGRADE ：利用数据库的 for update 子句加锁。 LockMode. UPGRADE_NOWAIT ： Oracle 的特定实现，利用 Oracle 的 for update nowait 子句实现加锁。 上面这两种锁机制是我们在应用层较为常用的，加锁一般通过以下方法实现： Criteria.setLockMode Query.setLockMode Session.lock 只有在查询开始之前（也就是 Hibernate 生成 SQL 之前）设定加锁，才会真正通过数据库的锁机制进行加锁处理，否则，数据已经通过不包含 for update 子句的 Select SQL 加载进来，所谓数据库加锁也就无从谈起。 1.2. 乐观锁(Optimistic Locking) 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依 靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库 性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。 如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进 行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对几百上千个并发，这样的情况将导致怎样的后果。 乐观锁机制在一定程度上解决了这个问题。 乐观锁，大多是基于数据版本 Version 记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version\" 字段来实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。 对于上面修改用户帐户信息的例子而言，假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。 在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。 操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣 除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。 操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数 据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的 数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 提交版本必须大于记录当前版本才能执行更新 的乐观锁策略，因此，操作员 B 的提交被驳回。 这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。 从上面的例子可以看出，乐观锁机制避免了长事务中的数据库加锁开销（操作员 A 和操作员 B 操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系 统整体性能表现。 乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户余额更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整（如 将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开）。 Hibernate 在其数据访问引擎中内置了乐观锁实现。如果不用考虑外部系统对数据库的更新操作，利用 Hibernate 提供的透明化乐观锁实现，将大大提升我们的生产力。Hibernate 中可以通过 class 描述符的 optimistic-lock 属性结合 version 描述符指定。 1.3. 常见并发同步案例分析 1.3.1. 案例一：订票系统案例，某航班只有一张机票，假定有 1w 个人打开你的网站来订票，问你如何解决并发问题(可扩展到任何高并发网站要考虑的并发读写问题) 首先，1w 个人来访问，票没出去前要保证大家都能看到有票，不可能一个人在看到票的时候别人就不能看了。到底谁能抢到，那得看这个人的“运气\"（网络快慢等）。其次考虑的问题，并发，1w 个人同时点击购买，到底谁能成交？总共只有一张票。 我们容易想到和并发相关的几个方案 ： 锁同步同步更多指的是应用程序的层面，多个线程进来，只能一个一个的访问，java 中指的是 synchronized 关键字。锁也有 2 个层面，一个是 java 中谈到的对象锁，用于线程同步；另外一个层面是数据库的锁；如果是分布式的系统，显然只能利用数据库端的锁来实现。 假定我们采用了同步机制或者数据库物理锁机制，如何保证 1w 个人还能同时看到有票，显然会牺牲性能，在高并发网站中是不可取的。使用 hibernate 后我们提出了另外一个概念：乐观锁、悲观锁（即传统的物理锁）； 采用乐观锁即可解决此问题。乐观锁意思是不锁定表的情况下，利用业务的控制来解决并发问题，这样即保证数据的并发可读性又保证保存数据的排他性，保证性能的同时解决了并发带来的脏数据问题。 hibernate 中如何实现乐观锁： 前提：在现有表当中增加一个冗余字段，version 版本号, long 类型 原理： 只有当前版本号》=数据库表版本号，才能提交 提交成功后，版本号 version ++ 实现很简单：在 ormapping 增加一属性 optimistic-lock=\"version\" 即可，以下是样例片段 1.3.2. 案例二、股票交易系统、银行系统，大数据量你是如何考虑的 首先，股票交易系统的行情表，每几秒钟就有一个行情记录产生，一天下来就有（假定行情 3 秒一个） 股票数量 ×20×60*6 条记录，一月下来这个表记录数量多大？ oracle 中一张表的记录数超过 100w 后 查询性能就很差了，如何保证系统性能？再比如，中国移动有上亿的用户量，表如何设计？把所有用于存在于一个表么？ 所以，大数量的系统，必须考虑表拆分（表名字不一样，但是结构完全一样），通用的几种方式： 按业务分，比如 手机号的表，我们可以考虑 130 开头的作为一个表，131 开头的另外一张表 以此类推 利用 oracle 的表拆分机制做分表 如果是交易系统，我们可以考虑按时间轴拆分，当日数据一个表，历史数据弄到其它表。这里历史数据的报表和查询不会影响当日交易。 当然，表拆分后我们的应用得做相应的适配。单纯的 ORM Mapping 也许就得改动了。比如部分业务得通过存储过程等 此外，我们还得考虑缓存。这里的缓存，指的不仅仅是 hibernate，hibernate 本身提供了一级二级缓存。这里的缓存独立于应用，依然是内存的读取，假如我们能减少数据库频繁的访问，那对系统肯定大大有利的。比如一个电子商务系统的商品搜索，如果某个关键字的商品经常被搜，那就可以考虑这部分商品列表存放到缓存（内存中去），这样不用每次访问数据库，性能大大增加。 简单的缓存大家可以理解为自己做一个 hashmap，把常访问的数据做一个 key，value 是第一次从数据库搜索出来的值，下次访问就可以从 map 里读取，而不读数据库；专业些的目前有独立的缓存框架比如 memcached 等，可独立部署成一个缓存服务器。 1.4. 常见的提高高并发下访问的效率的手段 首先要了解高并发的的瓶颈在哪里？ 可能是服务器网络带宽不够 可能 web 线程连接数不够 可能数据库连接查询上不去。 根据不同的情况，解决思路也不同。 第一种情况可以增加网络带宽，DNS 域名解析分发多台服务器。第二种情况：负载均衡，前置代理服务器 nginx、apache 等等第三种：数据库查询优化，读写分离，分表等等 1.5. 总结 尽量使用缓存，包括用户缓存，信息缓存等，多花点内存来做缓存，可以大量减少与数据库的交互，提高性能。 用 jprofiler 等工具找出性能瓶颈，减少额外的开销。 优化数据库查询语句，减少直接使用 hibernate 等工具的直接生成语句（仅耗时较长的查询做优化）。 优化数据库结构，多做索引，提高查询效率。 统计的功能尽量做缓存，或按每天一统计或定时统计相关报表，避免需要时进行统计的功能。 能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态 html 来显示）。 解决以上问题后，使用服务器集群来解决单台的瓶颈问题。 1.6. 参考 http://betakoli.iteye.com/blog/2257095 1.7. .net 高并发 先还原一下 nuget 包，需要改一下 redis 的配置，rabbitmq 的配置以及 Ef 的连接字符串。另外使用的是 CodeFirst，先 update-database 生成数据库后再进行操作。 大量的请求，如果仅仅只有一台服务器肯定是吃不消的，通常一些公司都是一台服务器上部署了很多个网站也充当了数据库服务器、redis 服务器。如果要应用高并发没有足够的硬件支持是不行的。我们需要进行 分布式集群 以及 负载均衡 这时我们还需要提高网站的吞吐量，怎么提高呢？首先我们需要针对 IO 密集型做异步化操作,抢单的页面不只是有抢单按钮，还有商品的介绍，图片，文字描述等。对于这些数据我们要进行缓存，一万个用户一万次请求都从数据库中取数据与只取一次剩下 9999 次从缓存中取效率自然是不一样的 上面说的都是为了解决一个 高 字，而并发才是我们真正需要准备的，假如两个用户同时请求，这时库存还有 1，程序里先判断库存是不是 1，现在都符合条件，然后进行生成订单等操作。就发生了资源共享的问题，明明只有一个订单，但是两个用户都完成了订单，那么这个商品应该给谁呢？假设现在是一个电商网站，今天要举办活动，有 10 个商品低价销售，但是会来抢购的人会特别多，最后只有十个人可以成功的买到商品。 假设的逻辑，我们用户进行了请求，我们把他们的信息放到库里，但是只有前十个人是可以购买商品的，因为库存只有 10 个也许我们可以用锁来解决并发的问题，但是锁无疑带来的是效率的低下，用户体验也极低。我们想要的是快速返回，但是后面那一堆的逻辑怎么办呢？我们可以使用 RabbitMq 队列，用户的请求到达了抢单接口，我们只向队列中丢一条数据后就立即返回 这时又来了一个问题，会有同一个用户多次进行请求的情况，如果像之前的逻辑，前 10 条信息有二条是属于一个人的呢，（这里假设每个人只可以购买一次）我们就需要进行判断了，同一个账户发送的多次请求，我们只认为第一次请求是有效的，剩下的都请都直接返回。因为是并发，我们又怎么做到第一次请求有效呢？这时我们可以使用 Redis incr 存储用户的标识，Redis 是单线程的，不存在并发的问题。incr 返回为 1 那么是第一次请求，为 N 则是第 N 请求那么它就是无效的。这是请求标识。请求标识我们可以在抢单接口就进行判断，也就是先拿用户的标识去 Incr，返回为 1 则丢到队列，不为 1 则不丢到队列。也可以在 rabbitmq 的消费端进行处理，从 rabbitmq 消息队列中拿到用户信息后，进行 incr。再进行下一步操作。丢到了消息队列中，我们还需要去处理，consumer 我们肯定是要有多个的，我们可以使用平分分发与手动交付。在这里我们把用户的信息进行入库，当然入库后我们再向 Redis 中存入一条入库标识上面都是在后端，客户端这里点击了抢单按钮后可以立即导向排队界面（是不是很熟悉，某米。。。）在这个界面进行轮询五秒一次，判断当前用户在库中的位置，如果是前十，那么就进行订单操作，不是。。。那就再等，看看会不会有其他用户放弃购买资格。其实讲到这里，已经差不多了，成功的把并行变成了串行。剩下的就是业务处理，怎么做都可以。 其实对于并发还可以有其它的处理方式，比如乐观锁也可以有效的控制并发 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/面经/": {
    "url": "Basic/面经/",
    "title": "Basic/面经",
    "keywords": "",
    "body": "1. TOC1. TOC vmware Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Basic/面经/vmware.html": {
    "url": "Basic/面经/vmware.html",
    "title": "vmware",
    "keywords": "",
    "body": "1. vmware shanghai 2017-3-8 Jack (Ke Zhang)1.1. prepare Henry Chen interview1. vmware shanghai 2017-3-8 Jack (Ke Zhang) cookie, localStorage, when to use, when don't want to send to server? CORS how to set cookie expire time? (document.cookie = 'name=qiu; max-age=9999; path=/; domain=domain; secure';, max-age=0 删除) angular directives usage server rendering, client rendering real-time chat array [1,2,3,4,2], find values that appears more than once website optimization cross domain, jsonp why use oop, what is oop, benefit (encapsulation, abstraction, inheritance, polymorphism. reuse) modularization, commonjs, requirejs, es2015 will make commonjs or require away? how angular module? angular service, factory, provider, why use service? css priority, red, blue, green. bootstrap uses important? some js needs to put in front, resulting loading DOM slow, how to solve? async, defer less, sass pack tools, grunt testing: mocha, should.js, supertest, PhantomJS why not global variable, use closure benefit h5 advantage 1.1. prepare Henry Chen interview distributed systems 接口和抽象类有何区别？ 反射 单例模式吗？请实现之，并说说用在哪些情况中。 锁:有关锁的问题，读写锁的优化 多线程实现 写一个 Singleton 的例子 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/面经/阿里云后端/": {
    "url": "Basic/面经/阿里云后端/",
    "title": "Basic/面经/阿里云后端",
    "keywords": "",
    "body": "1. TOC1. TOC 三大音频网络协议 视频协议 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Basic/面经/阿里云后端/三大音频网络协议.html": {
    "url": "Basic/面经/阿里云后端/三大音频网络协议.html",
    "title": "三大音频网络协议",
    "keywords": "",
    "body": "1. 三大音频网络协议1. 三大音频网络协议 目前业内实用化音频网络协议有 CobraNet、Dante、Ethernet AVB。 CobraNet 网络 CobraNet 是一种在以太网上传输专业非压缩音频信号的技术，工作在数据链路层（OSI 二层）的低层传输协议，但无法穿过路由器，只能在局域网中传递，音频流不能大于 8 个数据包 Bundle。 它可以在 100M 以太网下单向可以传输 64 个 48kHz、20bit 的音频信号通道（48kHz、24bit 信号为 56 路）；除音频信号外，还可以传输 RS485 串口通信数据及其它非同步 IP 数据；开放的 MIB 文件，支持 SNMP。一般使用星型（或连星型）网络结构。 目前，国内使用 CobraNet 技术搭建大规模音响传输及控制系统的工程还是凤毛麟角。 网络音视频实时传输技术—Ethernet AVB 以太网音视频桥接技术是一项新的 IEEE 802 标准，其在传统以太网络的基础上，通过保障带宽，限制延迟和精确时钟同步，提供完美的服务质量，以支持各种基于音频、视频的网络多媒体应用。 Ethernet AVB 致力于提供一套基于标准的方案来为演播室、影剧院、音乐会现场及娱乐系统等提供稳定可靠的音视频服务，以及提供低延时、供家庭及企业使用的同步音视频网络。 Ethernet AVB 关注于增强传统以太网的实时音视频性能，同时又保持了 100%向后兼容传统以太网，是极具发展潜力的下一代网络音视频实时传输技术。 Ethernet AVB 是一种架构在以太网三层网络基础上传输专业非压缩 Audio、video 信号的协议技术，它能够支持目前大多数的专业视频信号格式，支持多达 512 通道无压缩或多路压缩数据格式音频信号，支持在以太网上传输压缩的 1080i/p 高清视频信号，而它的带宽占用率只有 130Mbit/s。 Ethernet AVB 建立的 AVB 网络，称之为 AVB“云”（Cloud），解决了在以太网上提供同步化低延迟的实时流媒体服务。在 AVB“云”内，由于延迟和服务质量得到保障，能够高质量地提供实时的流媒体服务。 同时，AVB 网络保持与传统以太网的兼容，能够连接到传统的交换机、集线器和终端设备。告别直接与硬件对话的“云计算”支持用户在任意位置、使用各种终端获取应用服务，所请求的资源来自“云”，而不是固定的有形的实体。 Dante 数字音频传输技术 Dante 协议是一个在标准的 IP 网络上运行的现代化高性能数字媒体传输系统，是 Audinate 公司在 2003 年研发的，和传统的 CobraNet 技术一样，也是一个集硬件、软件和通信协议为一体的产品。 Dante 数字音频传输技术是基于 3 层的 IP 网络技术，采用 Zeroconf 协议，简化了网络的运行模式。它可以通过一根普通的网线同时发送和接收许多的音频通道，完全替代一堆的多芯线缆，而且音频可以发送到所有带 Dante 的音频设备，并且更改路由只需要通过简单易用的软件即可完成。另外，Dante 能提供 1-1024 个通道的音频传输，以及在其网络路由可以有无限数量的通道。 Dante 技术具备自身独特的优势： 1、更小的延时、采用了 IEEE1588 精密时钟协议进行时钟同步、采用了 zeroconf（Zero Configuration Networking）[6][7]协议、网络的高兼容特性、自愈系统、音频通道的传输模式可以是单播或是多播，这些独特的优势，成为 Dante 技术在专业音频领域及其他工程领域的奠基石，可广泛应用于专业音响行业、广播系统、电话会议系统、楼宇智能音频系统、大型运动会等行业。 2、Dante 提供一个简化的，自配置，真正的即插即用的使用标准的互联网协议超过 100 MB 和/或千兆以太网的数字音频网络。 3、Dante 是建立在全球网络标准，包括互联网协议-不只是以太网。借助真正的 IP 路由，Dante 技术可以在网络上能够任由传输专业质量的音频和高清晰度的视频。 Dante 技术可以在以太网（100M 或者 1000M）上传送高精度时钟信号以及专业音频信号并可以进行复杂的路由。与以往传统的音频传输技术相比，它继承了 CobraNet 与 EtherSound 所有的优点，网络中的音频信号，都以“标签”的形式进行标注等。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/面经/阿里云后端/视频协议.html": {
    "url": "Basic/面经/阿里云后端/视频协议.html",
    "title": "视频协议",
    "keywords": "",
    "body": "1. 视频协议1.1. 1. RTSP/RTP/RTCP 协议族1.2. 2. HTTP 协议1.3. 3. RTMP1. 视频协议 1.1. 1. RTSP/RTP/RTCP 协议族 本协议族是最早的视频传输协议。其中 RTSP 协议用于视频点播的会话控制，例如发起点播请求的 SETUP 请求，进行具体播放操作的 PLAY、PAUSE 请求，视频的跳转也是通过 PLAY 请求的参数支持的。而 RTP 协议用于具体的视频数据流的传输。RTCP 协议中的 C 是控制的意思，用于在视频流数据之外，丢包或者码率之类的控制。 该协议族 RTSP 是建立在 TCP 之上的，RTP、RTCP 建立在 UDP 之上。不过也可以通过 interleave 的方式，将 RTP 和 RTSP 一起在同一个 TCP 连接上传输。 RTSP 协议族，是最早被提出来的，因此很多考虑的地方，都还带有早期的特征。比如使用 UDP，是考虑到传输的效率，以及视频协议本身对丢包就有一定的容忍度。但是 UDP 协议，显然不能用于更大规模的网络，而且复杂网络下路由器的穿透也是问题。从视频角度而言，RTSP 协议族的优势，在于可以控制到视频帧，因此可以承载实时性很高的应用。这个优点是相对于 HTTP 方式的最大优点。H.323 视频会议协议，底层一般采用 RTSP 协议。RTSP 协议族的复杂度主要集中在服务器端，因为服务器端需要 parse 视频文件，seek 到具体的视频帧，而且可能还需要进行倍速播放（就是老旧的 DVD 带的那种 2 倍速，4 倍速播放的功能），倍速播放功能是 RTSP 协议独有的，其他视频协议都无法支持。缺点，就是服务器端的复杂度也比较高，实现起来也比较复杂。 1.2. 2. HTTP 协议 HTTP 的视频协议，主要是在互联网普及之后。在互联网上看视频的需求下形成的。 2.1 最初的 HTTP 视频协议，没有任何特别之处，就是通用的 HTTP 文件渐进式下载。本质就是下载视频文件，而利用视频文件本身的特点，就是存在头部信息，和部分视频帧数据，就完全可以解码播放了。显然这种方式需要将视频文件的头部信息放在文件的前面。有些例如 faststart 工具，就是专门做这个功能的。但是最为原始的状态下，视频无法进行快进或者跳转播放到文件尚未被下载到的部分。这个时候对 HTTP 协议提出了range-request的要求。这个目前几乎所有 HTTP 的服务器都支持了。range-request，是请求文件的部分数据，指定偏移字节数。在视频客户端解析出视频文件的头部后，就可以判断后续视频相应的帧的位置了。或者根据码率等信息，计算相应的为位置。 2.2 支持 HTTP range-request 的服务器，目前就可以支持我们一般网络看视频的要求了。但是，这种方式，无法支持实时视频流，或者准实时视频流。因为视频流，是不存在一个视频文件的概念的。HTTP 协议播放视频的好处，就是简单。采取通用的 HTTP 服务器，就可以提供服务，不需要专门类型的服务器，也不需要特别的网络端口，穿过路由器防火墙一点都没有问题。而且还可以利用通用的 CDN 来简化视频的部署分发的工作，减少带宽的使用。这个是目前用于PC 端或者网页端，视频点播业务，最常见的解决方案。客户端的实现，一般采用 flash 完成，flash 本是的 videoplayer 或者 videodisplay 控件就可以完成。资源一般采用 flv 格式，也可以使用 mp4 格式。在此基础上，多家公司推出了自己的解决方法。 2.3 HLS HDS MSS DASH 苹果推出的 HTTP Live Streaming，就是随着苹果设备的普及得以广泛应用的一种。从名词就可以判断出来，HLS 支持 Live 直播式的视频传输。HTTP 采用 m3u8 作为索引文件，视频为 MPEG2-TS 格式的片段文件。如果为直播视频流，则采取更新 m3u8 文件，从而更新视频索引列表，达到视频直播的目的。但是这种方法，因为最终视频是片段文件，所以必然存在片段视频长度的延迟。因此只可以用于对实时性要求没有那么高的准实时视频流。但是 HLS 方式，因为采用了较早的 MPEG2-TS 格式，这种格式的 overhead，也就是头部信息占据总文件的比例比较大，也就是效率不够高。之所以没有使用其他格式，主要是商业竞争和版权的问题。相应的，adobe 公司，推出相似的 HTTP dynamic streaming。这种方式本质和 HLS 的策略是类似的，就是通过索引文件+视频片段的方式。但是显然采用的索引格式和视频片段格式都不一样的。HDS 采用的是视频格式是 flv 或者 f4v，索引格式记不清楚了。类似的，微软也推出了 Microsoft Smooth Streaming，也即是 mss 的视频播出方式，采用的视频格式是分段 mp4 格式。 MPEG 标准组则推出了 Dynamic Adaptive Streaming over HTTP, DASH.采用的视频格式为 3GPP 吧。显然，这个目前是百花齐放的状态，虽然最常用的的是 HLS，谁叫苹果这么霸气呢。而安卓和苹果上面对于 flash 都有限制，而 HDS 是 adobe 推出在 adobe 平台上面的。mss，只有在少数几个地方见到过。dash，目前仅仅是论文里面的产物。以上的协议，主要是解决一个问题，就是自适应码率切换，上面的 dynamic，adaptive 都是类似的意思。主要是利用索引文件中同时给出不同码率的视频文件的地址，这样播放器端，可以根据带宽情况，自适应选择不同码率的视频文件。同时在视频直播方面，在安卓和 iOS 平台以外，还有很多视频服务器提供厂商，自己开发协议，一般采用方式为固定时间片段的 flv 文件的方式（采用 flv，是因为 flash 上方便播放） 2.4 HTML5 同时 HTML 制定厂商也不寂寞，推出 HTML5 这种方式，这种方式本质上，和前面的 HTTP 视频协议没有任何区别。但是播放器端，不再依赖于特定的插件如 flash，或者其他播放软件，而是可以支持浏览器的直接视频播放。采用的是 html 中嵌入 video 标签，同时直接指明视频的 url。不过，不同的浏览器，对于音视频的格式支持不完全相同。比较通用的是视频 H。264 格式，音频 AAC 格式，封装格式 MP4。 2.5 其他 在 HTTP 协议的基础上，各家公司，针对自己的业务特性，也可能开发自己的专有的数据格式，或者协议。但是都是在上述的基本上做出一些细微的修改而已。毕竟国内的技术体系，还完全无法提出一个新的技术的程度。（google，就提出新的编码格式替换 H.264,SPDY 协议，这个国内做不到的）。一般只会做到例如 HTTP 特殊字段或者特殊参数，传递到 flash 中做出一定的解释。或者在原有的视频文件格式基础上添加一些特殊意义的头部等等。 1.3. 3. RTMP 这个是 adobe 公司自己推出的视频播放协议。需要专用的服务器，如 FMS，开源的有 red5.这种协议也是 flash 默认支持的。 总体来看，视频相关的协议发展，是从专用的协议、服务器，逐渐向 HTTP 过渡的过程。而且逐渐适应网络的发展和需求，复杂多变的网络环境，才催生了 http 的视频协议。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/面试必看/": {
    "url": "Basic/面试必看/",
    "title": "Basic/面试必看",
    "keywords": "",
    "body": "1. TOC1. TOC ask_question behavior-question me Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Basic/面试必看/ask_question.html": {
    "url": "Basic/面试必看/ask_question.html",
    "title": "ask_question",
    "keywords": "",
    "body": "1. Questions that I can ask1. Questions that I can ask 我未来期望做项目经理，带领团队做出优秀的产品，您觉得如何才能成为一名出色的项目经理？需要掌握什么技能？ 技术总监／项目经理很忙，新技术更新很快，在没时间没精力学习这些技术的情况下如何管理和指导团队 经过这次面试，您觉得我还有什么地方要提高？ What is the ratio of testers to developers to program managers? What is the interaction like? How does project planning happen on the team? 这个职位需要做什么？你希望我未来三个月能够帮公司做什么？ 公司如何帮助新员工尽快适应职位？除此之外您建议我如何尽快适应该职位？并且很快在该职位上作出成绩？ 公司现在都用到哪些核心技术？未来考虑使用哪些新技术进行改进？ 您能介绍下你们团队规模以及如何分配任务的吗？ 公司未来三年最重要的新产品线、新策略、新市场有哪些？ 公司如何帮助我们多了解每个部门的业务（好让我们更能做出贡献）？ What are the necessary skills to do this job? What makes a successful candidate? What would make an unsuccessful candidate? Why have people left this position previously? What is the most difficult part of this job? What brought you to this company? What has been most challenging for you? I'm very interested in scalability, and I'd love to learn more about it. What opportunities are there at this company to learn about this? I'm not familiar with technology X, but it sounds like a very interesting solution. Could you tell me a bit more about how it works? 问 HR 福利 你最棒的团队成员有什么共通特质？ 同事们闲暇时间都做什么消遣？ 你们平常用英文还是中文？ 贵公司业绩成长的最关键因素是什么？ 面对即将来临的不景气，你们有什么应对的计划？ (或者该产业特有的状况) 公司创办的过程，有哪些关键的决定把公司带到今天的地位？ 最近的主管异动/人事改组/签下新客户，对公司有什么影响？ Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/面试必看/behavior-question.html": {
    "url": "Basic/面试必看/behavior-question.html",
    "title": "behavior-question",
    "keywords": "",
    "body": "1. behavior question1. behavior question What two or three things are most important to you in your job? 环境很重要：我喜欢交朋友，喜欢和志同道合的朋友交流、成长。大家彼此尊重、互相帮助提升：我能学到很多，个人发展空间贡献：在适合我的位置上贡献自己的力量。 I want to be happy. I want to work in a job that I am passionate about, and for a company that respects and rewards my contributions. I want to have co-workers whom I like and respect. I think these things all work together for a positive work environment — which increases productivity — resulting in happy employees and a happy employer. I also seek fulfillment. I don’t want to work in a job that I feel is below what I am capable of doing. I seek a job that will challenge me to perform at the highest levels and seek ongoing professional development so that I can be even better at my job, making an even stronger contribution to my employer. From everything I’ve researched and seen, this job that I’m interviewing for meets all my criteria. Opportunities, show my value, make me grow。个人发展空间 Respect from colleague, friendly, corporation salary, salary is flexible. Sometimes you cannot get the high expected one, it won't let you miss some good opportunities, but I have a bottom line, and i feel a great company like to find a very great employee and pay more salary to him, rather than find a normal person with low salary. Salary is a way to show your value Give me a specific Negative experience example of a time when a co-worker criticized your work in front of others. How did you respond? How has that event shaped the way you communicate with others? (SNH) I seldom get criticized since I'm usually productive and deliver satisfying solutions, but this happened once when I worked on the real-time chat functionality in SNH. One today, my scrum master, my director and I sat together, and scrum master asked why the task has not been finished. Scrum master is not good at techniques. So I have to say something that all of us can understand easily. I say, First, No one has real-time chat development experience, since I love to try some new things I pick up this difficult task by myself. I want to be responsible for company, and deliver great products. I try to think if I were the customer, what do I really want to see in the product? If I just want to stay at comfortable zone, I don't pick this task and maybe we never have this meeting. Second, It took me 3 days to filly understand the requirement since the requirement is not clear at beginning. Third, I did research and found SignalR is the best solution in .net Platform. It needs both client side and server side work. To achieve point to point chat is not hard, but it's a little difficult to achieve one to group and group to one. Fourth, the most difficult part is about database design. We want to keep chat history. If one deletes history from his side, the other one should still be able to view history. In addition, how does a online person send a message to offline person? And when that offline person gets online, he can receive the message immediately? Then I showed them the paper that lists my thoughts, drafts about database design, system design, and pseudo code etc. Finally they understand how hard it is and after I presented all these functionalities, all in the team are quite satisfied with it! So after this event, my scrum master attitude became warmer, he would talk with me to understand everything before any judgement. He think I'm responsible and capable. We respect each other. Don't you talk with other developers or scrum master everyday? We have standing up meetings every day, but probably because I talked about the same thing for several days, he thought I didn't make progress for days. Tell me about a time where you sought out perspectives other than your own to make a product/service/project better? (use other peoples' thought) ActionMenu json or web.config Ub tahoe project there is a actionMenu dropdown list, it has icons and anchors. Based on systemId (bankerConsole, teller), the list is different. The data is dynamic so we cannot just write plain html because it's not extendable if we add a new system. So for some reasons, my manager doesn't want to load that dropdown from database. (maybe creating a table just for a dropdownList is too much) My solution is to create a json file, \"systemId\":1,\"url\":\"a-dev.com\". So I load the json and bind data to dropdownList. Whenever there is any change, I can directly work on json file. It's a good solution for many cases, but in our case, the dropdown anchor url varies like \"a-dev\", \"a-test\" based on the environment. My manager suggests we use web.config and transform the url based on environment. I feel this solution works better in this case. Later instead of web.config, it's actionMenu.config and third-party lib to do transform. 也可以在前端根据环境变量进行不同 json 文件的读取，但我们不是前后端分离的项目。前端人员写好了后交给后端。当然我前后端都做。 Tell me about a time when you had to analyze facts quickly, define key issues, and respond immediately to a situation. What was the outcome? UnitOfWork, when transactions are more, slow Give me an example of a time you used customer feedback to drive improvement or innovation. What was the situation and what action did you take? UPMC mapQuest: map shows different offices, under the map there are names of offices. mouse hover on the office icon in map, name will pop up. The customer feedback is is there anyway that we know the all offices' names without hovering mouse to each, or if we want to find a office named \"A\", where is it in map without trying to hover every icon? since some offices name are long, i cannot display names along with the icon in map. What I did was to set identity number 1 2 3 4 for each of office under map, and on the map, the icon has corresponding number. Customer is very glad to have this solution. Tell me about a goal that you set that took a long time to achieve or that you are still working towards. How do you keep focused on the goal given the other priorities you have? a long-term goal: be a technical leader in 5 years. I seldom set big goal without smaller short-term goals because it may take too long to get there, and there're some uncertain things before going that far. If I don't get there I may lose confidence. I tend to set small goals and once I finish one, I encourage myself and am excited to set next one. But to be a leader is a target I'm pretty sure I will be there. To achieve that, I dig into techniques everyday, review technical news, blogs, books, videos, etc. Also I learn from my manager and teammates. Talk with friends, mentor. Learn from books. The tasks my leader assigned have first priorities, I like to finish these tasks efficiently with high quality. And then I use some spare time to work on my goals. I'm curious. When I see an app working in a different way, I will think how it is working like this under the hood (frontend animation i.e.). When I wait bus in station, I will check how the advertise designed. What if I design it? Tell me about a time when you linked two or more problems together and identified an underlying issue? Were you able to find a solution? mPower: worked on error log using log4net. But when multiple threads throw error together, lock will decrease performance because other threads have to wait. I thought that I worked on message queue before, so I use both log4net and queue to improve the performance. And finally use redis. What three things you are you working on to improve your overall effectiveness? newest techniques, recently ES2015. Read blogs, news, videos, etc. Talk with mentors create helper functions, like AjaxHelper, CacheHelper, build my code library (frontend plugins), write notes, blogs to share to deepen my skills read books to build emotional intelligence learn from mistake treat people right Give me an example of when you took an unpopular stance in a meeting with peers and your leader and you were the outlier. What was it, why did you feel strongly about it, and what did you do? This only happened to me in the first few weeks when I joined a new company. I'm new, I'm not familiar with everything. I feel it's quite normal. What I did is listen to what they say carefully and try my best to understand how things are going, how I can get used to this new environment quickly? And after meeting I also ask my manager and peers for help. But after 2 or 3 month, I usually take a popular stance. Tell me about a time you wouldn’t compromise on achieving a great outcome when others felt something was good enough. What was the situation? log4net + queue, can use log4net + redis Tell me about a time you made a hard decision to sacrifice short term gain for a longer term goal. Before working with UnionBank, I received another offer from a small company, they give more salary, more vacations. But I feel my capability is beyond their need. I stay at my comfort zone and won't make big progress. My long-term goal is to be a technical lead, working in this company, I will get more salary, but it makes me hard to become an excellent leader. I give up that offer and go with UnionBank. How do you drive adoption for your vision/ideas? How do you know how well your idea or vision has been adopted by other teams or partners? Give a specific example highlighting one of your ideas. ES2015, coding style, name convention. Everyone started to follow rules. Tell me about a time when you realized you needed to have a deeper level of subject matter expertise to do your job well? When I started to work on Avendas in SNH, I just knew basics of angular. Although I mainly worked on backend, knowing how angular send ajax call to server is better for me to understand how frontend and backend work together. I felt I need to learn more about angular. Now I'm at middle level of angular 1, and I haven't studied angular 2. I know I need to work on angular 2 or 4 so if next project uses them, I will be more confident. Leadership skills? （✔️，我在领导时注重的点） give others opportunities to shine think big 宏观思维 assign tasks accordingly motivate team listen from different opinions and make best decision considering long-term goal understand what is most important I am a leader who likes to give the people I am leading the ability to shine. I think it is important to take everyone’s opinion into consideration and be willing to listen to what they have to say. I think my job as a leader is to organize things and keep them in order. Being the leader does not mean I know everything there is to know because I cannot possibly know more than everyone else about every topic. It is just not plausible. creativity or efficiency, Which is more important? I think that the key is a balance between the two, with efficiency being the most important. You could have an extremely creative piece, but if the message of the piece is not clear then it is not efficient and a waste of resources. How has college changed you as a person? I have grown up during my college years. I am able to communicate better, think strategically, and multitask more than ever before. I can handle an appropriate level of stress and still get things done. Some people work best as part of a group — others prefer the role of individual contributor. How would you describe yourself? I like a mix of both. I like to work in a group and get group input. I think a lot of good ideas come from talking things out with other people. I also like to work by myself on some projects because I think there are some projects that are just done better if one person is working on them. When given an important assignment, how do you approach it? I like to make a todo list, a timeline of how and by when things need to be done. I really like to get started on the assignment immediately because I’ve found that once I get started on a project I tend to get gradually more excited about it and involved in it, and I want to expand the project more and more as I go on. By getting started earlier, I can get the most out of the project and maximize it as much as possible while providing time to give it that extra review. a shortcoming/weakness As a engineer, I'm not strong at history, politics, art, music, etc. Sometimes when I talk with friends, they know a lot of stuff which doesn't relate to work. I feel kind of guilty. They can use very proper words, poetry to express things, but my words are just plain words. I think I might focus more on work sometimes, and forget how to balance work and life. I realized this, and I'm working on it. A excellent person should not just do well in work, but should have a broad knowledge, work for a happy life rather than just for work itself. And from a long run, it's also good for the company. 团队合作意见分歧： 处理很多问题的方式很大程度上取决于你的职位、环境等因素。如果我是管理者，每个人在团队中都应该可以自由坦诚地发表意见，我会非常认真的聆听，分析；但对于自己的意见我不会没有原则的轻易放弃。民主过后还需要集中。我的理念是：Meeting 不等于 Voting，完全不需要少数服从多数；我是负责人，我相信自己有能力采取最佳方案；假如失败了，我也会承担主要责任。而如果我是团队的普通一员，我会保留自己的意见，但还是认真执行管理者已经做出的决策。只要遵循“对事不对人”的原则，目的是合理高效解决问题。反问面试官你是如何处理意见分歧的呢？ 在人际沟通上是否曾经有过不和谐？ 有，生活中遇到过，工作暂时没遇到。其实我这个人很容易和别人相处，因为我会换位思考，以此来理解他人。但是！如果遇到价值观和我有抵触的人，我会无法容忍，可能会不能进行有效沟通。有几类人不太欣赏：说话言而无信；做事虎头蛇尾；妄想不劳而获。这种人已经触犯到我的原则底线。当然，我不会拂袖而去，但实在不愿敷衍。也许这就是还不够世故圆滑吧。我很矛盾，不知道该做怎样的拿捏与平衡。 为什么回国发展？ 情。人在一些快乐的时候很容易迷失自己，忘记自己曾经最真实的、发自内心的想法。我会这样问自己，当所有的职业工资水平一样多，职位不分高低，我会选择什么职业？ Give me a specific example of a time when you sold your supervisor or professor on an idea or concept. How did you proceed? What was the result? (assertiveness) When I worked in UnionBank tahoe project, I saw many javascript files include global variable. Naming convention, coding style varies. So I talked with my manager about it. Global variable may raise conflicts and give an example it will increase the development efficiency and easier to maintain if we have a unique naming convention and coding style To make this happen, I gave several solutions, like modularization, self-closure, ESLint, ES2015. And then I told the benefits for each of these techniques. My manger loves my thoughts, and in a meeting I introduced how to make code better. Describe the system you use for keeping track of multiple projects. How do you track your progress so that you can meet deadlines? How do you stay focused? (commitment to task) I used TFS. TFS has my work, workItems. So in workItems, I can see how many tasks are pending. Each task has start day and release day, task description, etc. So by using TFS, I can keep track of my tasks. In addition, to finish a task, I probably needs to do it step by step, so I will write a todo list in my editor Atom, sublime. It includes the start day, end day, priority. I will mark it solved foreach small task. Tell me about a time when you came up with an innovative solution to a challenge your company or class was facing. What was the challenge? What role did others play? (creativity and imagination) UnionBank Unity T4 Describe a time when you got co-workers or classmates who dislike each other to work together. How did you accomplish this? What was the outcome? (teamwork) Raya kept asking Sathish questions every day. Rajini complaint this to me because their discussion always interrupts her thoughts. One friday I invites them to have lunch together. One of my friend in another company had the same problem before the lunch. we talked about many interesting things at first, at last I said, my friend in another company feels their development is not efficient because they sometimes talk a lot of funny things during work. The environment is comfortable but sometimes they didn't finish tasks within deadline. What do you think to solve this kind of issue? Rajini said maybe they can work hard in the morning, and talk something funny during lunch or a small break. Maybe we can do the same, during standup meetings in the morning, we told any block we had. Then we work relatively independently unless there is a big issue one doesn't have any idea. If there are some small issues, we can talk between 2-3 pm everyday. So every one in the team thinks how to solve their tasks and did some research online before asking questions. There is less interruption and everyone tries their best to solve before asking for help. Tell me about a time when you failed to meet a deadline. What things did you fail to do? What were the repercussions? What did you learn? (time management) union bank layout SPA change. Describe a time when you put your needs aside to help a co-worker or classmate understand a task. How did you assist them? What was the result? (flexibility) Sathish, css layout, arrow navigation bar, div:after/before. My task is not urgent, offer help actively Describe two specific goals you set for yourself and how successful you were in meeting them. What factors led to your success in meeting your goals? (goal setting) one goal was I should at least be middle level of angular 1 in June 2016. I set this goal in December 2015. I tend to make smaller goals which can be easily achieved. I feel very glad to finish one and it makes me very excited to set another goal. I'd say I did finish this goal at that time. To get there, I tried to solve every task every efficiently. Once there is a new task, I immediately understand the requirement and start to work on it. I don't like to work close to the deadline. Once I finishes the task earlier, I use this spare time to learn new techniques. I love to learn new things. Another goal is too finishing a chinese history book. I want to be a leader in future, and I feel an excellent leader should not just focus on the techniques. I prefer one should have a very strong knowledge in one and a few fields, but one should also have a broad view, have interest in many different things. So when a new issue comes up, you can have many different ways to solve it. History may not directly help me about coding, but it indirectly gives me an idea that if there is any other way I can communicate with others. How to make the team work more efficiently, etc. factors: passion, motivation, aspiration, I want to be successful. I want to have a wonderful life. I want to share my knowledge and contribute. How do you ensure that someone understands what you are saying? meeting, ES2015, naming convention, code style, ppt lists demo with picture. Code review and double check. From listener eye, expression Tell me about a time when you had to present complex information. Real-time chat history Tell me about a time in which you had to use your written communication skills in order to get across an important point. Jay ui-controller and func-controller Give me an example of a time you had to make a difficult decision. Smaller company with high salary, before UnionBank, because of long-term goal--technical leader Give me an example of when taking your time to make a decision paid off. Unity xml, Unity pragmatically, Unity xml with T4 Give me an example of a situation that could not have happened successfully without you being there. Unity xml with T4, Log4net queue How do you determine priorities in scheduling your time? Give me an example. I have a sense. And ask manager what is important. List all steps to finish that task and find which is most important and what may block me. Tell me about a time when you influenced the outcome of a project by taking a leadership role. ES2015, naming convention, code style; Log4net queue Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Basic/面试必看/me.html": {
    "url": "Basic/面试必看/me.html",
    "title": "me",
    "keywords": "",
    "body": "1. Self Introduction1.1.1. my projects1. Self Introduction I have involved in system development life cycle for 7 years, especially web development. I'm working as CTO in a startup company. Before I was a technical lead in UnionBank, US. College: I'm interested in designing web application for a long time, but I don't choose computer science as my major because I don't want exams, classes ruin my interest, and I learnt computer science class by myself in Dalian University of Technology. I did part-time job to learn and strengthen my programming skills during college life. Post College & Onwards: After college, I worked in several companies in US. Most of my work is about how to build web application. my skill sets include frontend(html,css,js and latest frameworks and libraries like angular, React + redux, jquery), backend(.net latest MVC core, WebForm, MVC, nodejs), database(mongodb, MSSQL). Current Role [Details]: Now I'm leading both frontend and backend teams. I designed system architecture, do some coding, code review and some managements. I give free time every to team so everybody can share and learn what they want if they finish tasks very efficiently. Everyday I go over some blogs and technical websites to learn new techniques, and understand what is popular, what will be popular in future. And I also like to learn these new stuff from video tutorials(youtube, codeSchool) and buy books online. Anyway, I'm self-motivated, and I love what I'm doing. I used to stand on the top in college life, now I want to an excellent leader. I'm making a progress everyday to make it happen! 我有 7 年软件开发经验，包括 windows application 和 web application。我更倾向于 web 开发。 我很早就对网站开发产生兴趣，但是我在大学时代并没选择相关专业，因为我不想找考试、强制性的课程毁掉我的兴趣。我在大连理工通过自学和兼职工作去提高自己的编程水平。 在迈阿密大学结束后我在美国 3 家公司工作过，大部分工作内容都是网站开发，包括前端、后端和数据库开发。前端方面主要是 html css js 和一些框架 angular jquery，后端.net mvc, nodejs，数据库主要 MSSQL 和 mongodb。 现在在一家中小型公司做技术经理，主要负责前端，搭建框架（yeoman）、封装公共组件、最近开始负责重量级模块--图形化创建。对 react 比较熟悉。曾经用过 angularjs, angular2，最近学习了 vue。我对前沿技术很感兴趣，如 web components, custom elements, shadow dom, css variables 等。我是中途接手一个项目，发现了很多问题，我负责帮助团队不断改进推动项目。还有重新设计系统架构、code review、还有管理方面的工作。每周我都会给团队一些自由时间，大家可以互相分享和学习他们想学的内容。 每天我会查看浏览一些技术博客、网站去了解最新技术以及未来发展趋势。我也通过一些视频教程 youtube, pluralsight 和看书去提高自己的水平。总之，我是个主动性很强、对这个行业充满热情的人。我期望以后能够带领团队创造出优秀的产品，为此我每天都在努力，去实现自己的价值！若干年后问心无愧 1.1.1. my projects 对公司现有的系统的优化和重构: react 状态管理混乱，早起项目只用 react State，大家觉得一层一层传递 state 麻烦。我接手后发现 redux 和 react state 混用导致不清晰，帮助大家从 react state 过度到 redux，完成路由模块、首页等公共模块 80% react 不可变性理解不到位，有些人在 setState 里面修改了状态。还有得 deepClone 后赋值。我推荐 immutability-helper 提取相似组件，封装成公共组件，提高复用性 改进 Modal, Select 等组件 图形化创建的撘建，老师学生端。canvas，fabrics，svg 制作的网页版 sketch、ps。介绍下功能 加入测试、mock-server、持续集成 项目没有 lint 工具导致大家代码不统一，使用 ESLint and editorConfig。 每个 component 都是用 class 的方式去定义。我推荐了 functional/stateless component。 改进： css 模块化 webpack tree-shaking 和 bundle splitting。 Modal、select 组件库的优化和扩展 HighChart 配置统一、可拖拽配置。 Stylus 缩进不方便。 难点： 需要增加图形化创建，数据保存，团队多人协作。 redux 源码 applyMiddleware 等觉得难。 common questions Ub tahoe, MPower SNH Avendas UPMC panelAccess challenges Optimization: SPA, unitOfWork, Cache, Thread; Unity: T4; MPower: log4net+redis real-time chat mapQuest, chart.js, pdf Mistake A link click error after SPA NA NA Leadership ESLint, naming convention, coding style Conflicts not mine: Raya asks too much; opinion conflicts: Jay ui-controller/func-controller scrum master real-time chat task slow What do you do differently high-level architecture refactor, cacheHelper(memcache,regular) real-time chat mapQuest, chart.js, pdf What was the toughest challenge you’ve ever faced? 挑战每隔一段时间就出现，但当前觉得困难的挑战，现在回头看可能好多也不困难了，毕竟经验有增长。 上海踏瑞、创狐：简创和 PGC 项目 -- graphics editor, a very important module in project. It includes Tools, Canvas and Properties Area. You can think it as a online Photoshop. Syncing between areas, Grouping, Data Saving format, 创建复合组件。老师分配群组，组长演示的时候其他组员能实时看到组长的操作。多人协同。 SNH: To design a basic chat application like skype/qq. That was the first time that I made a real-time application. First, I did a research about what techniques should be used and SignalR is the one I want. Second, how to design the one to one, one to many chat mode? I researched and used group, room these concepts to implement both client and server side code. Third, what if one is online and the other one is offline. And online person sends a message to offline person. Then when offline person gets online, how can he receive the message? Fourth, how can I retrieve chat histories? Fifth, if one deletes history from his side, the other person should still be able to have the history, how to manage the history? This is more complicated for one to many. I put all possible situations into consideration and design the database. It's a tough task, when I finish this, all colleagues and manager spoke highly of me! Describe a specific problem you solved for your employer or professor. How did you approach the problem? What role did others play? What was the outcome? (decision making) UnionBank MPower project log4net + redis Initially, tahoe project uses ExceptionFilter to write errors/exceptions into database. When there is an error in test, developers have to look up the error in test db, but some developers don't have access to test db. And it's not convenient to find errors, because you have to open sql client, find that table, and query errors. So I suggest, why not record errors in txt file? Another developer implemented this feature. One day, I wanted to check the error log, but when I see that log file, it's about 100 megabyte, I don't dare to open it... I immediately talked with team and pointed out that we cannot record all errors in only one file. We need to control the biggest size of one file, maybe 10mb. My manager decided to let me do it. Then I used Log4net the solve the problem since it can log errors in several files in a reasonable size. One day, I was pretty sure that an exception was not recorded in our log file. I found the reason is when errors happen in different threads, there will be a problem for multiple threads to access one file. So I added \"lock\" to solve this issue. Then I tested my code by generating multiple errors in multiple threads. The bad thing happens, when a thread writes error to file, the other threads have to wait, the performance is so bad. Then I used put all errors into queue, and start a new thread, which is responsible to get errors and write them into file. Finally, I used redis instead of traditional queue, so errors are push into redis queues. 多线程操作同一个文件时会出现并发问题。解决的一个办法就是给文件加锁(lock)，但是这样的话，一个线程操作文件时，其它的都得等待，这样的话性能非常差。另外一个解决方案，就是先将数据放在队列中，然后开启一个线程，负责从队列中取出数据，再写到文件中。 UnionBank challenges 1: Performance, UnitOfWork, CacheHelper with memcache As the application get larger and we have more and more data, the system response time increased. My goal/challenge is to find the bottleneck and speed up the whole system. You know, there're too many things that need to be considered when we talk about performance (frontend, application, and database). For frontend part, we already used CDN, and js minification/compress, and some other techniques before. But to improve user experience, instead of redirecting from one page to another, I discussed with my manager and suggested to make our application a SPA. I found backend c# code makes system run slow, especially when there are multiple transactions. One reason is that the system doesn't use UnitOfWork, so this means when we are operating multiple tables, we may created dbContext many times, connect to db many times and generate multiple sql queries. So I added UnitOfWork to application and one big advantage is that the CRUD logic can be executed in the business logic layer rather than database layer. Business layer has more control about the data flow. Second, I wrote a CacheHelper and use it whenever it is possible. The CacheHelper can uses both traditional Cache and Memcache (amazon: dynamo). There're some time-costly functions. I created a new thread for them, and made them work asynchronously. As a result, the response is faster. 新奇点，迁移能力 Ub challenge 2: Unity mappings, xml --> programmatically --> T4 xml We used Unity to decouple layers. Our team had a hard time about the unity object mappings. Initially we used xml files to store the mappings. But there is not any intelligence and developers can spell wrong. They cannot see it wrong until running the solution. So I suggest, why don't we give up the xml and create mappings programmatically? We are quite happy at first. But as we have more controllers, we get tired of creating mappings because every time when you creates a new controller, you have to create a mapping between this controller and the service. And sometimes developers forget to add this mapping, resulting in more debugging time. So instead of creating mapping programmatically, I wrote a T4 code template. It can generate a xml file based on the database, new controller file, and its dependent services. Thus, when developers create a new controller, they don't need to take care of the mappings, when they build the solution, the generator will refresh the mappings. Ub mistake I redesigned the layout page and make it as a SPA. I thought I checked everywhere, but there is a link in a very latent place. The link clicking will raise an error. It's dangerous because it's really bad if users see this error. The bad thing is that the production day was tomorrow. I immediately talked with my manager about this and told him this change can be done within 5 minutes. But We don't have enough time to push this fix to test or production. So we delayed our deployment. Thanks god, it doesn't have a serious affect since it is an early release. I took the responsibility and said sorry to my manger. He said it's no a big issue since I found it before deployment and he likes my attitude. Indeed, that link is too easy to be ignored. Ub conflicts I seldom have behavior conflicts with others since I'm always nice to others. But I have some opinion conflicts. These conflicts I feel, most of time they are good because by pointing out different opinions, we can come up with better solutions, and it can improve our creativity. One conflict with my manager is that he wants to separate controllers by ui and functions while I feel controllers should be separated by modules. His thought is, any controller related to UI, which render a view should be placed into UI-controller folder, and any controller which involves many logic and data retrieving functions should be under func folder. I wrote an email and explained my ideas. First, some controllers have both UI an logic functions, so they are not clear where to be placed. Second, these changes will have to change RoutingConfig, and many ajax calls will be affected since the url changed. Third, I estimated the time how long it will take if we really want to do this. And how many files need to be changed. At last, I said something like, if you still want to implement this way, I will definitely do it within the estimated time. Please let me know. So in this conflict, I pointed out the disadvantages that it will generate. If we really do this, how things will go, what to be predicted. These results made my manager clear at this issue. He agreed on me and he was very glad that I could point it out before making that decision. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CheatSheet/": {
    "url": "CheatSheet/",
    "title": "CheatSheet",
    "keywords": "",
    "body": "1. TOC1. TOC Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "CSS/": {
    "url": "CSS/",
    "title": "CSS",
    "keywords": "",
    "body": "1. TOC1. TOC animation code_reset code_清除浮动 css_selector css3 各种图形 interview_BFC interview_css 动画硬件加速 interview_css 变量 interview_css 模块化 interview_flex interview_requestAnimationFrame interview_retina 屏幕 css interview_元素显示隐藏的几种方案 interview_垂直水平居中 interview_布局 media_query sass transform transition Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "CSS/animation.html": {
    "url": "CSS/animation.html",
    "title": "animation",
    "keywords": "",
    "body": "1. 动画1.1. 定义关键帧1.2. 施加动画1.3. 动画调速1.4. 延迟、重复、方向、结束状态1.5. 速记写法1.6. 暂停动画1. 动画 与 Transition 不同，CSS3 动画不需要触发就能开始。虽然仍可以向 :hover 状态添加一个动画，在鼠标移上时播放。但也可以让动画在页面加载后就开始。 动画的基础是一组关键帧。可以认为 Transition 只支持两个关键帧，而动画支持多个关键帧。 1.1. 定义关键帧 @keyframes animationName { from { /* list CSS properties here */ } to { /* list CSS properties here */ } } @keyframes 不是一个 CSS 属性，它是一个规则（rule）。(其他 CSS 规则如 @import @media。) 至少得有两个关键帧。可以使用关键字 from 和 to 创建开始帧的结束帧。例如，让元素渐现的动画： @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } 可以使用百分比创建多个帧。关键字 from 和 to 可以用 0% 和 100% 代替。 @keyframes backgroundGlow { from { background-color: yellow; } 50% { background-color: blue; } to { background-color: red; } } 每个帧内可以放多个属性： @keyframes growAndGlow { from { background-color: yellow; } 50% { transform: scale(1.5); background-color: blue; } to { transform: scale(3); background-color: red; } } 若多个百分比使用同一组属性（帧）则可以造成暂停的效果。例如下面的例子，从 25% 到 75%（即一半的时间）一直停在蓝色上： @keyframes glow { from { background-color: yellow; } 25%, 75% { background-color: blue; } to { background-color: red; } } 如果多个时刻的关键帧相同，可以将它们列在一起。例如，20% 的时候蓝色，40% 的时候橙色，60% 的时候再回到蓝色…… @keyframes glow { from { background-color: yellow; } 20%, 60% { background-color: blue; } 40%, 80% { background-color: orange; } to { background-color: red; } } 1.2. 施加动画 对元素施加动画，在页面加载后立即指定动画。利用这点可以实现介绍性的动画。 还可以对伪类施加（:hover、:active、:target、:focus）。或者施加到一个 CSS 类上，然后通过 Javascript 动态的将 CSS 类应用到某个元素上。 CSS3 提供了一些动画相关的属性，控制动画播放的方式和时间。最少需要指定动画名和持续时间： @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } .announcement { animation-name: fadeIn; animation-duration: 1s; } 将动画名放在引号内，不是必须的，但可以防止与 CSS 关键字冲突。 可以同时施加多个动画，如 fadeIn 和 blink；指定不同的持续时间： animation-name: fadeIn, blink; animation-duration: 1s, 3s; 与 transitions 一样，时间单位可以是秒（s）或毫秒（ms）。 1.3. 动画调速 通过 animation-timing-function 控制动画速度。可以使用 cubic-Bezier 曲线，或内建的关键字（linear, ease, ease-in, ease-out, ease-in-out）。 调速函数可以控制整个动画或特定帧。 .announcement { animation-name: fadeIn; animation-duration: 1s; animation-timing-function: ease-out; } 控制帧速度： @keyframes growAndGlow { from { background-color: yellow; animation-timing-function: cubic-bezier(1, 0.03, 1, 0.115); } 50% { transform: scale(1.5); background-color: blue; animation-timing-function: linear; } to { transform: scale(3); background-color: red; } } 1.4. 延迟、重复、方向、结束状态 利用 animation-delay 延迟动画开始： .announcement { animation-name: fadeIn; animation-duration: 1s; animation-delay: 1s; } 控制动画播放次数： animation-iteration-count: 10; animation-iteration-count: infinite 会导致动画持续播放。 若动画播放超过一次，默认下一次动画开始时会重头播放。如果想让动画正一次，反一次，利用 animation-direction: alternate。（默认是 normal） 动画完成后（如果动画持续多次，指多次重复都结束后，即“最后的最后”），默认元素回到动画开始前的状态。例如若动画放大按钮，动画结束后，按钮默认缩小的原来的状态。如果要让元素停在动画结束的状态，设置属性 animation-fill-mode: forwards。 1.5. 速记写法 animation 属性组合了以下属性：animation-name, animation-duration, animation-timing-function, animation-iteration-count, animation-direction, animation-delay, animation-fill-mode。 .fade { animation-name: fadeOut; animation-duration: 2s; animation-timing-function: ease-in-out; animation-iteration-count: 2; animation-direction: alternate; animation-delay: 5s; animation-fill-mode: forwards; } 可以简写成： .fade { animation: fadeOut 2s ease-in-out 2 alternate 5s forwards; } 若要对元素施加多个动画，只需要逗号分隔多个列表。如施加 fadeOut 和 glow： .fade { animation: fadeOut 2s ease-in-out 2 alternate 5s forwards, glow 5s; } 1.6. 暂停动画 属性 animation-play-state 控制动画的重放。它接收两个关键字 running 或 paused。后者暂停动画。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/code_reset.html": {
    "url": "CSS/code_reset.html",
    "title": "code_reset",
    "keywords": "",
    "body": "1. css reset 重置1.1. 如何修改 chrome 记住密码后自动填充表单的黄色背景 ？1.2. 让页面里的字体变清晰，变细用 CSS 怎么做？1. css reset 重置 见移动端 scss.md 1.1. 如何修改 chrome 记住密码后自动填充表单的黄色背景 ？ input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill { background-color: rgb(250, 255, 189); /* #FAFFBD; */ background-image: none; color: rgb(0, 0, 0); } 1.2. 让页面里的字体变清晰，变细用 CSS 怎么做？ -webkit-font-smoothing: antialiased; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/code_清除浮动.html": {
    "url": "CSS/code_清除浮动.html",
    "title": "code_清除浮动",
    "keywords": "",
    "body": "1. 清除浮动，触发 BFC1. 清除浮动，触发 BFC .clear { zoom: 1; } .clear:after { content: ''; display: block; clear: both; } /*给浮动元素的父级加 */ /* other methods 1.给父级也加浮动 2.给父级加display:inline-block 3.在浮动元素下加 .clear{ height:0px;font-size:0;clear:both;} 4.在浮动元素下加 5.给浮动元素的父级overflow:hidden 并且zoom:1; */ Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/css_selector.html": {
    "url": "CSS/css_selector.html",
    "title": "css_selector",
    "keywords": "",
    "body": "1. CSS 选择器1.1. 属性选择器1.2. 获取标签的值1.3. 改变下载标签的 icon1.4. Details1.5. Event selector1. CSS 选择器 1.1. 属性选择器 如果你想选择包含 title 属性的 div： div[title] 选择包含 title 属性的子元素，只需要加个空格： div [title] 选择 title 内容是 dna 的元素： div[title=\"dna\"] 选择 title 属性包含 dna 单词的元素： 注意 dna 需要是单词，也就是用空格分割，比如 “my beautiful dna” 或 “mutating dna is fun!” div[title~=\"dna\"] 和正则类似，选择 title 属性中，以 dna 结尾的元素： div[title$=\"dna\"] 以 dna 开头： div[title^=\"dna\"] 如果希望选择 dna 或 dna-zh，但不希望匹配 dnaer，可以： 这种场景一般用在国际化，比如 en en-us 就可以用 |=\"en\" div[title|=\"dna\"] 只要包含 dna 这三个字符就选中： div[title*=\"dna\"] 真的很像正则，你可以用 i 标识匹配时大小写不敏感： div[title*=\"dna\" i] 如果你想找到一个 a 标签，拥有 title 属性并且 className 以 genes 结尾，可以这样： a[title][class$=\"genes\"] 1.2. 获取标签的值 p[title]:hover::after { content: '::after content and display title: ' attr(title); display: block; color: rebeccapurple; } Hover in this p tag and see its title attr at the end(:after). 1.3. 改变下载标签的 icon a[download][href$='jpg']::before { content: url(assets/edit-tools.svg); width: 24px; height: 24px; display: inline-block; margin-right: 10px; vertical-align: middle; } href 必须同源且服务器下 host 才能 download。Add icon by css ::before 1.4. Details details[open] { background-color: hotpink; } List of Genes Roddenberry Hackman 1.5. Event selector /* 为 JS 事件着色，比如触发的鼠标事件可以作为选择器： */ [OnMouseOver] { color: burlywood; } [OnMouseOver]::after { content: 'JS function to be called: ' attr(OnMouseOver); } mouseover will be selected in css by [OnMouseOver]. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/css3各种图形.html": {
    "url": "CSS/css3各种图形.html",
    "title": "css3 各种图形",
    "keywords": "",
    "body": "1. css3 实现的各种常用图形1. css3 实现的各种常用图形 http://www.jqhtml.com/8045.html Square Rectangle Circle oval Triangle Up Triangle Down Triangle Left Triangle Right Triangle Top Left Triangle Top Right Triangle Bottom Left Triangle Bottom Right Curved Tail Arrow Trapezoid Parallelogram Star (6-points) Star (5-points) Pentagon Hexagon Octagon Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/helpers/": {
    "url": "CSS/helpers/",
    "title": "CSS/helpers",
    "keywords": "",
    "body": "1. TOC1. TOC shadow Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "CSS/helpers/shadow.html": {
    "url": "CSS/helpers/shadow.html",
    "title": "shadow",
    "keywords": "",
    "body": "1. scss shadow helper1. scss shadow helper Material card Sass mixin amet consectetur adipisicing elit. amet consectetur adipisicing elit. amet consectetur adipisicing elit. :root { --spacing: 1rem; --imgWidth: 100px; --imgHeight: 100px; } @mixin shadow($level: 1, $background: black) { @if $level == 1 { box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba($background, 0.24); } @else if $level == 2 { box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba($background, 0.23); } @else if $level == 3 { box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba($background, 0.23); } @else if $level == 4 { box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba($background, 0.22); } @else if $level == 5 { box-shadow: 0 19px 38px rgba(0, 0, 0, 0.3), 0 15px 12px rgba($background, 0.22); } } .card { @include shadow(1); // focus isn't going to be visible unless it has an href or a tabindex &:hover, &:focus { @include shadow(3); transform: translateY(-5px); } &:active { @include shadow(2); transform: translateY(-2px); } } // Vanity styles body { background: #f9f9f9; margin: 3rem 2rem; font-family: 'Roboto', sans-serif; } .card-grid { display: grid; grid-gap: calc(var(--spacing) * 3.75); grid-template-columns: repeat(3, 140px); grid-auto-rows: var(--imgHeight); grid-auto-flow: dense; } .card { display: block; width: 8rem; min-height: 8rem; background: white; padding: 1rem; transition: all 250ms; font-size: 0.9rem; .title { font-size: 1.1rem; font-weight: 500; margin: 0 0 0.5rem; } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/interview_BFC.html": {
    "url": "CSS/interview_BFC.html",
    "title": "interview_BFC",
    "keywords": "",
    "body": "1. 边距重叠解决方案(BFC -- block format context 块级格式化上下文)1.1. 原理，渲染规则1.2. 如何创建 BFC1.3. 使用场景1. 边距重叠解决方案(BFC -- block format context 块级格式化上下文) 边距重叠包含父子、兄弟 \b 父子关系，子元素高度 100px，margin-top 10px，这时容器高度也是 100px，如果想让容器高度也是 110px，需要创建 BFC，常见是给容器加上 overflow hidden 1.1. 原理，渲染规则 BFC 内部的盒会在垂直方向一个接一个排列（可以看作 BFC 中有一个的常规流），他们相互影响，可能会发生 margin collapse BFC 在页面上是一个独立的容器，外面元素和里面的元素不会相互影响。 BFC 的区域不会与浮动元素重叠 计算 BFC 高度时浮动元素也会参与计算（清除浮动原理） 1.2. 如何创建 BFC 想象以下方法都是在父级元素实现的，如果内部有浮动元素，计算父级高度时内部浮动元素参与计算。 float 不为 none position 不为 relative or static display 设为 inline-block, table-cell, table overflow hidden/auto (不是 visible 就行) 1.3. 使用场景 可以包含浮动元素，清除浮动用 不被浮动元素覆盖 阻止元素的 margin 垂直方向重叠 清除浮动，其背后原理就是浮动元素也参与计算 CSS盒模型 html * { margin: 0; padding: 0; } #sec { background: #f00; /* overflow: hidden; */ } .child { height: 100px; margin-top: 10px; background: yellow } #margin { background: pink; overflow: hidden; } #margin>p { margin: 5px auto 25px; background: red; } 如果是3个p并列，他们margin重叠。解决办法，在其中一个 p 套上 div，让他BFC，此时margin会相加 2 2 3 #layout .left { float: left; width: 100px; height: 100px; background: pink; } #layout .right { height: 110px; background: #ccc; overflow: auto; } #float { background: red; overflow: auto; /*float: left;*/ } #float .float { float: left; font-size: 30px; } 我是浮动元素 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/interview_css动画硬件加速.html": {
    "url": "CSS/interview_css动画硬件加速.html",
    "title": "interview_css 动画硬件加速",
    "keywords": "",
    "body": "1. 用 CSS 开启硬件加速来提高网站性能1.1. 硬件加速是非规范的1.1.1. GPU 合成代价1.1.2. 创建复合层1.1.3. 硬件加速的优缺点1.1.4. 性能优化技巧1.2. 使用硬件加速的注意事项1.3. 总结1.3.1. reference1. 用 CSS 开启硬件加速来提高网站性能 只允许改变 transform、opacity，其它属性不要动，避免重新计算布局(reflow) 对动画元素应用 transform: translate3d(0, 0, 0)、will-change: transform 等，开启硬件加速 动画元素尽量用 fixed、absolute 定位方式，避免 reflow 对动画元素应用高一点的 z-index，减少复合层数量 1.1. 硬件加速是非规范的 很多情况下，开启硬件加速确实能带来明显的性能提升，但是，这部分内容是非规范的，W3C 并没有相关规范说明其中细节，所以通过一些技巧（例如 transform: translate3d(0, 0, 0)）开启硬件加速是规范之外的行为，可能得到性能提升，也可能带来严重的性能问题。 1.1.1. GPU 合成代价 GPU 是独立的一部分，有自己的处理器、内存核数据处理模型，那么意味着通过 CPU 在内存里创建的图像数据无法直接与 GPU 共享，需要打包发送给 GPU，GPU 收到后才能执行我们期望的一系列操作，这个过程需要时间，而打包数据需要内存。 需要的内存取决于： 复合层的数量 复合层的大小 如果复合层太多太大，内存会被迅速消耗，然后掉帧（卡顿、闪烁）现象，甚至浏览器/应用崩溃也就很合理了。 1.1.2. 创建复合层 浏览器在一些情况下会创建复合层，例如： 显示复合层： 3D transforms: translate3d, translateZ and so on; , and elements; animation of transform and opacity via Element.animate(); animation of transform and opacity via СSS transitions and animations; position: fixed; will-change; 隐式复合层： 位于复合层之上的元素会被创建复合层（B 的 z-index 大于 A，对 A 做动画，B 也会被塞进独立的复合层） 很容易理解，A 在动画过程中可能会与 B 产生重叠，被 B 遮住，那么 GPU 需要每帧对 A 图层做动画，然后再与 B 图层合成，才能得到正确结果，所以 B 无论如何都要被塞进复合层，连同 A 一起交给 GPU 隐式创建复合层主要出于重叠考虑，如果浏览器不确定会不会发生重叠，那么就要把不确定的东西都塞进复合层，所以，从这个角度看，高 z-index 原则是有道理的 1.1.3. 硬件加速的优缺点 优点： 动画非常流畅，能达到 60fps 动画执行过程在独立线程里，不受计算密集的 JS 任务影响 缺点： 把元素塞进复合层时需要额外重绘，有时很慢（可能需要整页重绘） 复合层数据传递给 GPU 有额外时耗，取决于复合层的数量和大小，这在中低端设备可能会导致闪烁 每个复合层都要消耗一部分内存，移动设备上内存很贵，过多占用会导致浏览器/应用崩溃 存在隐式复合层的问题，不注意的话内存飙升 文字模糊，元素有时会变形 1.1.4. 性能优化技巧 尽量避免隐式复合层 复合层直接影响 repaint、内存消耗：动画开始时创建复合层、结束时删除复合层，都会引起 repaint，而动画开始时必须把图层数据发送给 GPU，内存消耗集中在这里。两条建议： 给动画元素应用高 z-index，最好直接作为 body 的子元素，对于嵌套很深的动画元素，可以复制一个到 body 下，仅用于实现动画效果 给动画元素应用 will-change，浏览器会提前把这些元素塞进复合层，可以让动画开始/结束时更流畅些，但不能滥用，在不需要的时候赶紧去掉，减少内存消耗 只改变 transform 和 opacity 减少复合层的大小：减小 width、height，减少传递给 GPU 的数据，由 GPU 做 scale 放大展示，视觉效果无差异（多用于纯色背景元素，对不太重要的图片也可以进行 5%到 10%的宽高压缩），例如： #a, #b { will-change: transform; background-color: #f00; } #a { width: 100px; height: 100px; } #b { width: 10px; height: 10px; transform: scale(10); } 最终显示的两个红色块在视觉上没有差异，但减小了 90%的内存消耗 考虑对子元素动画与容器动画 容器动画可能存在不必要的内存消耗，比如子元素之间的空隙，也会被当做有效数据发送给 GPU，如果对各个子元素分别应用动画，就能避免这部分的内存消耗 例如 12 道太阳光线旋转，转容器就把容器整张图都发送给 GPU，单独转 12 道光线就去掉了光线之间的 11 条空隙，能够节省一半内存 早早关注复合层的数量和大小 从一开始就关注复合层，尤其是隐式创建的复合层，避免后期优化影响布局 复合层的大小比数量影响更大，但浏览器会做一些优化操作，把几个复合层整合成一个，叫 Layer Squashing，但有时一个大复合层比几个小复合层消耗的内存更多，有必要的话可以手动去掉这种优化： 不要滥用硬件加速 没事不要乱加 transform: translateZ(0)、will-change: transform 等强制开启硬件加速的属性，GPU 合成存在缺点和不足，而且是非标准的行为，最好情况能带来显著性能提升，最坏情况可能会让浏览器崩溃 CSS animations, transforms 以及 transitions 不会自动开启 GPU 加速，而是由浏览器的缓慢的软件渲染引擎来执行。当浏览器检测到页面中某个 DOM 元素应用了某些 CSS 规则时就会开启，最显著的特征的元素的 3D 变换。 虽然我们可能不想对元素应用 3D 变换，可我们一样可以开启 3D 引擎。例如我们可以用 transform: translateZ(0); 来开启硬件加速 。 .cube { transform: translateZ(0); /* Or */ transform: rotateZ(360deg); /* Other transform properties here */ } 在 Chrome and Safari 中，当我们使用 CSS transform 或者 animation 时可能会有页面闪烁的效果，下面的代码可以修复此情况： .cube { backface-visibility: hidden; perspective: 1000; /* Other transform properties here */ } 在 webkit 内核的浏览器中，另一个行之有效的方法是 cube { transform: translate3d(0, 0, 0); /* Other transform properties here */ } 原生的移动端应用(Native mobile applications)总是可以很好的运用 GPU，这是为什么它比网页应用(Web apps)表现更好的原因。硬件加速在移动端尤其有用，因为它可以有效的减少资源的利用。 在使用动画的时候不要用 top, left, 应使用 transform: translate. Render tree 的元素被分到图层中，图层被 GPU 形成渲染文理。transform 属性不会触发浏览器的 repaint，而 left 和 top 则会一直触发 repaint. 1.2. 使用硬件加速的注意事项 不能让每个元素都启用硬件加速，这样会暂用很大的内存，使页面会有很强的卡顿感。 GPU 渲染会影响字体的抗锯齿效果。这是因为 GPU 和 CPU 具有不同的渲染机制，即使最终硬件加速停止了，文本还是会在动画期间显示得很模糊。 1.3. 总结 使用 GPU 可以优化动画效果 GPU 渲染动会达到 60fps 使用对 GPU 友好的 CSS 属性 理解强制触发硬件加速的 transform 技巧 如果仅仅为了开启硬件加速而随便乱用，那是不明智的。小心使用这些方法，如果通过你的测试，结果确是提高了性能，你才可以使用这些方法。使用 GPU 可能会导致严重的性能问题，因为它增加了内存的使用，而且它会减少移动端设备的电池寿命。 1.3.1. reference http://www.ayqy.net/blog/css%E5%8A%A8%E7%94%BB%E4%B8%8Egpu/ Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/interview_css变量.html": {
    "url": "CSS/interview_css变量.html",
    "title": "interview_css 变量",
    "keywords": "",
    "body": "1. CSS 变量教程1.1. 一、变量的声明1.2. 二、var() 函数1.3. 三、变量值的类型1.4. 四、作用域1.5. 五、响应式布局1.6. 六、兼容性处理1.7. 七、JavaScript 操作1. CSS 变量教程 1.1. 一、变量的声明 声明变量的时候，变量名前面要加两根连词线（--）。 body { --foo: #7f583f; --bar: #f7efd2; } 上面代码中，body 选择器里面声明了两个变量：--foo 和 --bar。 它们与 color、font-size 等正式属性没有什么不同，只是没有默认含义。所以 CSS 变量（CSS variable）又叫做\"CSS 自定义属性\"（CSS custom properties）。因为变量与自定义的 CSS 属性其实是一回事。 你可能会问，为什么选择两根连词线（--）表示变量？因为$foo被 Sass 用掉了，@foo被 Less 用掉了。为了不产生冲突，官方的 CSS 变量就改用两根连词线了。 各种值都可以放入 CSS 变量。 :root { --main-color: #4d4e53; --main-bg: rgb(255, 255, 255); --logo-border-color: rebeccapurple; --header-height: 68px; --content-padding: 10px 20px; --base-line-height: 1.428571429; --transition-duration: 0.35s; --external-link: 'external link'; --margin-top: calc(2vh + 20px); } 变量名大小写敏感，--header-color和--Header-Color是两个不同变量。 1.2. 二、var() 函数 var() 函数用于读取变量。 a { color: var(--foo); text-decoration-color: var(--bar); } var() 函数还可以使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。 color: var(--foo, #7f583f); 第二个参数不处理内部的逗号或空格，都视作参数的一部分。 var(--font-stack, \"Roboto\", \"Helvetica\"); var(--pad, 10px 15px 20px); var() 函数还可以用在变量的声明。 :root { --primary-color: red; --logo-text: var(--primary-color); } 注意，变量值只能用作属性值，不能用作属性名。 .foo { --side: margin-top; /* 无效 */ var(--side): 20px; } 上面代码中，变量 --side 用作属性名，这是无效的。 1.3. 三、变量值的类型 如果变量值是一个字符串，可以与其他字符串拼接。 --bar: 'hello'; --foo: var(--bar) ' world'; 利用这一点，可以 debug（例子）。 body:after { content: '--screen-category : ' var(--screen-category); } 如果变量值是数值，不能与数值单位直接连用。 .foo { --gap: 20; /* 无效 */ margin-top: var(--gap) px; } 上面代码中，数值与单位直接写在一起，这是无效的。必须使用calc()函数，将它们连接。 .foo { --gap: 20; margin-top: calc(var(--gap) * 1px); } 如果变量值带有单位，就不能写成字符串。 /* 无效 */ .foo { --foo: '20px'; font-size: var(--foo); } /* 有效 */ .foo { --foo: 20px; font-size: var(--foo); } 1.4. 四、作用域 同一个 CSS 变量，可以在多个选择器内声明。读取的时候，优先级最高的声明生效。这与 CSS 的\"层叠\"（cascade）规则是一致的。 下面是一个例子。 :root { --color: blue; } div { --color: green; } #alert { --color: red; } * { color: var(--color); } 蓝色 绿色 红色 上面代码中，三个选择器都声明了--color变量。不同元素读取这个变量的时候，会采用优先级最高的规则，因此三段文字的颜色是不一样的。 这就是说，变量的作用域就是它所在的选择器的有效范围。 body { --foo: #7f583f; } .content { --bar: #f7efd2; } 上面代码中，变量--foo的作用域是body选择器的生效范围，--bar的作用域是.content选择器的生效范围。 由于这个原因，全局的变量通常放在根元素:root里面，确保任何选择器都可以读取它们。 :root { --main-color: #06c; } 1.5. 五、响应式布局 CSS 是动态的，页面的任何变化，都会导致采用的规则变化。 利用这个特点，可以在响应式布局的media命令里面声明变量，使得不同的屏幕宽度有不同的变量值。 body { --primary: #7f583f; --secondary: #f7efd2; } a { color: var(--primary); text-decoration-color: var(--secondary); } @media screen and (min-width: 768px) { body { --primary: #f7efd2; --secondary: #7f583f; } } 1.6. 六、兼容性处理 对于不支持 CSS 变量的浏览器，可以采用下面的写法。 a { color: #7f583f; color: var(--primary); } 也可以使用@support命令进行检测。 @supports ((--a: 0)) { /* supported */ } @supports (not (--a: 0)) { /* not supported */ } 1.7. 七、JavaScript 操作 JavaScript 也可以检测浏览器是否支持 CSS 变量。 const isSupported = window.CSS && window.CSS.supports && window.CSS.supports('--a', 0); if (isSupported) { /* supported */ } else { /* not supported */ } JavaScript 操作 CSS 变量的写法如下。 // 设置变量 document.body.style.setProperty('--primary', '#7F583F'); // 读取变量 document.body.style.getPropertyValue('--primary').trim(); // '#7F583F' // 删除变量 document.body.style.removeProperty('--primary'); 这意味着，JavaScript 可以将任意值存入样式表。下面是一个监听事件的例子，事件信息被存入 CSS 变量。 const docStyle = document.documentElement.style; document.addEventListener('mousemove', (e) => { docStyle.setProperty('--mouse-x', e.clientX); docStyle.setProperty('--mouse-y', e.clientY); }); 那些对 CSS 无用的信息，也可以放入 CSS 变量。 --foo: if(x > 5) this.width = 10; 上面代码中，--foo 的值在 CSS 里面是无效语句，但是可以被 JavaScript 读取。这意味着，可以把样式设置写在 CSS 变量中，让 JavaScript 读取。 所以，CSS 变量提供了 JavaScript 与 CSS 通信的一种途径。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/interview_css模块化.html": {
    "url": "CSS/interview_css模块化.html",
    "title": "interview_css 模块化",
    "keywords": "",
    "body": "1. css 模块化1.1. style 标签位置，由于 scoped 不再被支持，淘汰1.2. css @import 语法，和 scss less @import 一个思路，模块化思想第一步1.2.1. link 与 @import 的区别1.3. 实际项目解决方法，模块化思路 ✅1.3.1. CSS Modules1.3.2. 在生产环境中使用1.3.3. 多个 class1.4. reference1. css 模块化 ​ 下面说的是多页面非 SPA，在模块化开发的过程中，每一个模块都是一个独立的小系统，有自己的 html, js, css。js 模块化很方便移植。但是 css 的引入却是个问题。问题在于一个页面要使用这个模块，要么在头部用 link 标签引入对应的 css 文件，要么直接把模块的 css 放在全局 css 进行打包；前者属于有的放矢，有效的保证了资源的利用，但是需要人工引入，不方便；后者直接放在全局，虽然实现了方便性，但也对于不需要此模块的页面增加了负担，也增加了 css 样式相互影响的风险。 几种 css 模块化实践: 1.1. style 标签位置，由于 scoped 不再被支持，淘汰 html 页面样式文件的引入主要有三种方式： 直接通过 style 属性写在 html 标签内，也就是行内样式 引入外部 css 文件的形式，也即外联样式 通过 标签嵌入到 标签内，就是嵌入式 另一种方案：==就是在 标签中放置 标签，隔离其他区域的样式==。然而现在连 firefox 55 版本后默认都不支持了，虽然可以开启。 W3C 关于 style 标签放置位置的规范，html5 中 块元素都可以包裹 style 标签。 scoped: style 加入此属性后，这些属性只会在当前包裹它的元素及其子元素内生效，如果没有此属性，则会在全局生效。 如此一来，我们不仅实现了模块的移植便利，还很好的控制了模块的 css 作用范围，再也不用担心选择器冲突导致的各种样式混乱啦。 1.2. css @import 语法，和 scss less @import 一个思路，模块化思想第一步 首先我们知道 @import 很少用，有些缺点： @import 的文件是额外请求的，所以页面加载的时候会有一小会儿的裸体（FOUC flash of unstyled content, 样式没加载进来），要等这些模块一个一个加载 请求数太多，页面性能不佳，对服务器压力也会相对大一些。 不同的浏览器以及不同的书写形式可能会有不同的加载顺序。 1.2.1. link 与 @import 的区别 link 是 HTML 方式， @import 是 CSS 方式 link 最大限度支持并行下载，@import 过多嵌套导致串行下载，出现 FOUC @import 必须在样式规则之前，可以在 css 文件中引用其他文件 总体来说：link 优于 @import /*xxx 页面入口样式文件 style.css*/ @import './css/base.css'; /*页面基础样式*/ @import './css/index.css'; @import './css/header.css'; @import './css/footer.css'; 这样模块化避免大家修改一个或者几个大的 css。未来想换个 footer，把原先的 comment 掉，添加新的就好。还方面后续再换回来。删除某个模块也方便。 最好的办法就是把模块打包！这和 js 模块化一样的，模块化开发，然后上线之前打包，线上完美使用。 CSS Combo：CSS 模块打包利器 首先安装 css combo：npm install -g css-combo 进入你所在的入口文件（本例为 style.css）目录，输入：csscombo style.css style.combo.css 这样就会把 style.css 文件打包成 style.combo.css 文件 把所有的模块 import 都放在入口文件的最开始，方便管理。 less, scss 和 css combo 解决的不是一类问题，less 更多的是把 css 编程化，css combo 只专注 css 模块打包。 不管用上面 css @import 还是 sass、less 通过 @import ，只能部分解决的 css 模块化的问题。 由于 css 是全局的，在被引入的文件和当前文件出现重名的情况下，前者样式就会被后者覆盖。在引入一些公用组件，或者多人协作开发同一页面的时候，就需要考虑样式会不会被覆盖，这很麻烦。 // file A .name { color: red; } // file B @import 'A.scss'; .name { color: green; } css 全局样式的特点，导致 css 难以维护，所以需要一种 css \"局部\"样式的解决方案。也就是彻底的 css 模块化，@import 进来的 css 模块不能影响覆盖其他模块。 1.3. 实际项目解决方法，模块化思路 ✅ 所有模块都有一个唯一的 id，模块内的所有样式的选择器前都会加上所在模块的 id，这样就避免了模块间的 css 样式到处跑了。或者通过在每个 class 名后带一个独一无二 hash 值，这样就不有存在全局命名冲突的问题了。这样就相当于伪造了\"局部\"样式。 // 原始样式 styles.css .title { color: red; } // 原始模板 demo.html import styles from 'styles.css'; Hello World // 编译后的 styles.css .title_3zyde { color: red; } // 编译后的 demo.html Hello World 1.3.1. CSS Modules 实现上面的效果需要借助 Webpack, Browserify 等 CSS Modules 允许使用 :global(.className) 的语法，声明一个全局规则。凡是这样声明的 class，都不会被编译成哈希字符串。 /* App.css 加入一个全局 class */ .title { color: red; } :global(.title) { color: green; } 限制： You have to use camelCase CSS class names. You have to use styles object whenever constructing a className. Mixing CSS Modules and global CSS classes is cumbersome. Reference to an undefined CSS Module resolves to undefined without a warning. webpack 1.x 与 CSS Modules webpack 自带的 css-loader 组件，自带了 CSS Modules，通过简单的配置即可使用。 { test: /\\.css$/, loader: \"css?modules&localIdentName=[name]__[local]--[hash:base64:5]\" } 命名规范是从 BEM 扩展而来。 Block: 对应模块名 [name] Element: 对应节点名 [local] Modifier: 对应节点状态 [hash:base64:5] 使用 和 -- 是为了区块内单词的分割节点区分开来。最终 class 名为 `stylestitle--3zyde`。 1.3.2. 在生产环境中使用 在实际生产中，结合 sass 使用会更加便利。以下是结合 sass 使用的 webpack 的配置文件。 { test: /\\.scss$/, loader: \"style!css?modules&importLoaders=1&localIdentName=[name]__[local]--[hash:base64:5]!sass?sourceMap=true&sourceMapContents=true\" } 通常除了局部样式，还需要全局样式，比如 base.scss 等基础文件。将公用样式文件和组件样式文件分别放入到两个不同的目标下: . ├── app │ ├── styles # 公用样式 │ │ ├── app.scss │ │ └── base.scss │ │ │ └── components # 组件 ├── Component.jsx # 组件模板 └── Component.scss # 组件样式 然后通过 webpack 配置，将在 app/styles 文件夹的外的(exclude) scss 文件\"局部\"化。 { test: /\\.scss$/, exclude: path.resolve(__dirname, 'app/styles'), loader: \"style!css?modules&importLoaders=1&localIdentName=[name]__[local]--[hash:base64:5]!sass?sourceMap=true&sourceMapContents=true\" }, { test: /\\.scss$/, include: path.resolve(__dirname, 'app/styles'), loader: \"style!css?sass?sourceMap=true&sourceMapContents=true\" } 1.3.3. 多个 class 有时候，一个元素有多个 class 名，可以通过 join(\" \") 或字符串模版的方式来给元素添加多个 class 名。 // join-react.jsx Hello World // stringTemp-react.jsx Hello World 如果只写一个 class 就能把样式定义好，那么最好把所有样式写在一个 class 中。如果我们使用了多个 class 定义样式，通常会带一些一些逻辑判断。这个时候写起来就会麻烦不少。 引入 classnames 即可以解决给元素写多个 class 名的问题，也可以解决写逻辑判断的麻烦问题。 classNames('foo', 'bar'); // => 'foo bar' classNames('foo', { bar: true }); // => 'foo bar' classNames({ 'foo-bar': true }); // => 'foo-bar' classNames({ 'foo-bar': false }); // => '' classNames({ foo: true }, { bar: true }); // => 'foo bar' classNames({ foo: true, bar: true }); // => 'foo bar' // lots of arguments of various types classNames('foo', { bar: true, duck: false }, 'baz', { quux: true }); // => 'foo bar baz quux' // other falsy values are just ignored classNames(null, false, 'bar', undefined, 0, 1, { baz: null }, ''); // => 'bar 1' 引入 CSS Modules 的样式模块，每个 class 每次都要写 styles.xxx 也是很麻烦，在《深入 React 技术栈》提到了 react-css-modules 的库，来减少代码的书写，感兴趣的同学可以研究下。 1.4. reference https://github.com/css-modules/css-modules https://github.com/ruanyf/css-modules-demos https://github.com/gajus/react-css-modules (css-modules 限制) https://github.com/gajus/babel-plugin-react-css-modules Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/interview_flex.html": {
    "url": "CSS/interview_flex.html",
    "title": "interview_flex",
    "keywords": "",
    "body": "1. Flex box1.1. flex 多列1.2. 居中1.3. flex container1.3.1. justify-content1.3.2. align-items1.3.3. align-content (多行才起作用，即 flex-wrap: wrap/wrap-reverse 配合使用)1.3.4. flex-direction1.3.5. flex-wrap1.4. flex items1.4.1. flex1.4.2. align-self1.4.3. order1.4.4. flex-grow1.4.5. flex-basis1.4.6. flex-shrink1.5. reference1. Flex box 学习：http://flexboxfroggy.com/#zh-cn 1.1. flex 多列 .container { display: flex; } .initial { flex: initial; width: 200px; min-width: 100px; } .none { flex: none; width: 200px; } .flex1 { flex: 1; } .flex2 { flex: 2; } 1.2. 居中 .vertical-container { height: 300px; display: flex; align-items: center; justify-content: center; } 1.3. flex container .container { display: flex; /* or inline-flex */ flex-direction: row | row-reverse | column | column-reverse; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow: || ; justify-content: flex-start | flex-end | 'center' | 'space-between' | space-around | 'space-evenly'; align-items: flex-start | flex-end | center | baseline | stretch; align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 1.3.1. justify-content justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly; justify-content 中使用多的有 center, space-between, space-evenly flex-start (default): items are packed toward the start line flex-end: items are packed toward to end line center: items are centered along the line space-between: items are evenly distributed in the line; first item is on the start line, last item on the end line `space-around: items are evenly distributed in the line with equal space around them. Note that visually the spaces aren't equal, since all the items have equal space on both sides. The first item will have one unit of space against the container edge, but two units of space between the next item because that next item has its own spacing that applies. space-evenly: items are distributed so that the spacing between any two items (and the space to the edges) is equal. 1.3.2. align-items This defines the default behavior for how flex items are laid out along the cross axis on the current line. .container { align-items: flex-start | flex-end | center | baseline | stretch; } flex-start: cross-start margin edge of the items is placed on the cross-start line flex-end: cross-end margin edge of the items is placed on the cross-end line center: items are centered in the cross-axis baseline: items are aligned such as their baselines align stretch (default): stretch to fill the container (still respect min-width/max-width) 1.3.3. align-content (多行才起作用，即 flex-wrap: wrap/wrap-reverse 配合使用) 多行之间的间隔、分配方式 This aligns a flex container's lines within when there is extra space in the cross-axis, similar to how justify-content aligns individual items within the main-axis. Note: this property has no effect when there is only one line of flex items. .container { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } flex-start: lines packed to the start of the container flex-end: lines packed to the end of the container center: lines packed to the center of the container space-between: lines evenly distributed; the first line is at the start of the container while the last one is at the end space-around: lines evenly distributed with equal space around each line stretch (default): lines stretch to take up the remaining space 1.3.4. flex-direction 1.3.5. flex-wrap 1.4. flex items 1.4.1. flex This is the shorthand for flex-grow, flex-shrink and flex-basis combined. The second and third parameters (flex-shrink and flex-basis) are optional. Default is 0 1 auto. 只设置一个参数是 \b 比例 flex-grow .item { flex: none | [ ? || ]; } 1.4.2. align-self This allows the default alignment (or the one specified by align-items) to be overridden for individual flex items. Please see the align-items explanation to understand the available values. .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } Note that float, clear and vertical-align have no effect on a flex item. 1.4.3. order .item { order: ; } 1.4.4. flex-grow 每个 item 占用比例 .item { flex-grow: ; /* default 0 */ } 1.4.5. flex-basis This defines the default size of an element before the remaining space is distributed. It can be a length (e.g. 20%, 5rem, etc.) or a keyword. The auto keyword means \"look at my width or height property\" (which was temporarily done by the main-size keyword until deprecated). The content keyword means \"size it based on the item's content\" - this keyword isn't well supported yet, so it's hard to test and harder to know what its brethren max-content, min-content, and fit-content do. .item { flex-basis: | auto; /* default auto */ } If set to 0, the extra space around content isn't factored in. If set to auto, the extra space is distributed based on its flex-grow value. 1.4.6. flex-shrink This defines the ability for a flex item to shrink if necessary. .item { flex-shrink: ; /* default 1 */ } Negative numbers are invalid. 1.5. reference http://www.jqhtml.com/6319.html Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/interview_requestAnimationFrame.html": {
    "url": "CSS/interview_requestAnimationFrame.html",
    "title": "interview_requestAnimationFrame",
    "keywords": "",
    "body": "1. requestAnimationFrame 为何性能好？为何不用 setTimeout1.1. 内部原理1.2. requestAnimationFrame 优于 setTimeout/setInterval 的地方1. requestAnimationFrame 为何性能好？为何不用 setTimeout 国庆北京高速，最多每 16.7s 通过一辆车，结果，突然插入一批 setTimeout 的军车，强行要 10s 通过。显然，这是超负荷的，要想顺利进行，只能让第三辆车直接消失（正如显示绘制第三帧的丢失）。然，这是不现实的，于是就有了会堵车！ 同样的，显示器 16.7ms 刷新间隔之前发生了其他绘制请求(setTimeout)，导致所有第三帧丢失，继而导致动画断续显示（堵车的感觉），这就是过度绘制带来的问题。不仅如此，这种计时器频率的降低也会对电池使用寿命造成负面影响，并会降低其他应用的性能。 这也是为何 setTimeout 的定时器值推荐最小使用 16.7ms 的原因（16.7 = 1000 / 60, 即每秒 60 帧）。 而 requestAnimationFrame 就是为了这个而出现的。我所做的事情很简单，跟着浏览器的绘制走，如果浏览设备绘制间隔是 16.7ms，那我就这个间隔绘制；如果浏览设备绘制间隔是 10ms, 我就 10ms 绘制。这样就不会存在过度绘制的问题，动画不会掉帧。 1.1. 内部原理 浏览器每次要重绘，就会通知 requestAnimationFrame，在同样的时间间隔里进行动画。 如果有多个 requestAnimationFrame 动画，浏览器只要通知一次就可以了。而 setTimeout 貌似是多个独立绘制 页面最小化了，或者被 Tab 切换关灯了。页面是不会重绘的，自然，requestAnimationFrame 动画不会执行。页面绘制全部停止，资源高效利用。 1.2. requestAnimationFrame 优于 setTimeout/setInterval 的地方 在于它是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销。 requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒 60 帧。 在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。 (function() { var lastTime = 0; var vendors = ['webkit', 'moz']; for (var x = 0; x Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/interview_retina屏幕css.html": {
    "url": "CSS/interview_retina屏幕css.html",
    "title": "interview_retina 屏幕 css",
    "keywords": "",
    "body": "1. Have you ever worked with retina graphics? If so, when and what techniques did you use?1. Have you ever worked with retina graphics? If so, when and what techniques did you use? On retina devices the websites are not broken. They just look vague and pixels start appearing as low resolution images. So the only way to correct is to resize the images by following one of the techniques below: Using alternate high resolution pixels (图片是 css 宽高的 2 倍) Suppose we have an image of 200px by 400px (CSS pixels) and we want to display it properly in a retina display, we can upload an alternate image of size 400px by 800px in our server and render them whenever the webpage is opened in a retina device. #element { background-image: url('hires.png'); } @media only screen and (min-device-pixel-ratio: 2) { #element { background-image: url('hires@2x.png'); } } @media only screen and (min-device-pixel-ratio: 3) { #element { background-image: url('hires@3x.png'); } } Using JavaScript to replace all the images with double sized image. 弊端是 retina 屏幕会把 1 倍图片、2 倍图片都下载，速度慢。 // 检测屏幕像素比 $(document).ready(function() { if (window.devicePixelRatio > 1) { var lowResolutionImages = $('img'); images.each(function(i) { var lowResolution = $(this).attr('src'); var highResolution = lowResolution.replace('.', '@2x.'); $(this).attr('src', highResolution); }); } }); Using @face-fonts instead of images icon(✅) Image fonts will automatically resize themselves on the high resolution devices just like normal fonts do. Using SVG images instead of Bitmap images(✅) Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/interview_元素显示隐藏的几种方案.html": {
    "url": "CSS/interview_元素显示隐藏的几种方案.html",
    "title": "interview_元素显示隐藏的几种方案",
    "keywords": "",
    "body": "1. 元素显示与隐藏的方案1. 元素显示与隐藏的方案 /* 首选 */ .hidden { position: absolute; top: -9999em; } .hidden { position: absolute; visibility: hidden; } .hidden { display: none; } 对于 position，如果元素之前没有过 position 属性那就没问题，如果之前就是 absolute、relative 尽量不用 对于 display，需要判断之前元素是 inline-block or block 要想让屏幕阅读器等辅助设备也能明白显示和隐藏，只能用 position top 方法 （可用性隐藏）。但如果被隐藏元素是 a, input，这样的隐藏方式会在用户点击 tab 时产生扰乱，&#x1F41F; 和 &#x1F43B; 不可得兼。 使用 absolute 隐藏是会产生重绘 repaint 而不会产生强烈的回流 reflow。而使用 display:none 不仅会重绘，还会产生回流（DOM 节点删除增加），DOM 影响范围越广，回流越强烈。所以，就 JavaScript 交互的呈现性能上来讲，使用 absolute 隐藏是要优于 display 相关隐藏的。(reflow --> repaint) 方案 1 对应的 js dom.style.position = 'static'; // or dom.classList.remove('hidden'); //better 方案 2 对应的 js dom.style.position = 'static'; dom.style.visibility = 'visible'; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/interview_垂直水平居中.html": {
    "url": "CSS/interview_垂直水平居中.html",
    "title": "interview_垂直水平居中",
    "keywords": "",
    "body": "1. 盒子垂直水平居中1.1. 水平居中1. 盒子垂直水平居中 /* 方法一 absolute transform/margin */ div { position: absolute; width: 500px; height: 300px; top: 50%; left: 50%; transform: translate(-50%, -50%); /* 外边距为自身宽高的一半 margin: -150px 0 0 -250px; */ background-color: pink; } /** 方法二 flex **/ .container { display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ } .container div { width: 100px; height: 100px; background-color: pink; } /** 方法三 absolute top right bottom left = 0 **/ div { position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; } 对于文字使用 line-height === height 方式 span 和 文字 垂直对齐，vertical-align: middle 1.1. 水平居中 http://blog.jobbole.com/46574/ 给 div 设置一个宽度，然后添加 margin: 0 auto 属性 div { width: 200px; margin: 0 auto; } 面试说：对于文字，span 等 inline 元素，使用 text-align center，块级如果已知容器和孩子宽高，也可以通过 padding 挤出空间 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/interview_布局.html": {
    "url": "CSS/interview_布局.html",
    "title": "interview_布局",
    "keywords": "",
    "body": "1. 常见网站布局1.1. 已知高度的三列布局，左右宽度固定，中间自适应。(float, absolute, flex, table, grid)1.2. 三栏垂直分布，上下固定，移动端常见1.3. 两行，头固定，下面自适应高度1.4. 两列，左侧固定宽，右侧自适应宽度1. 常见网站布局 1.1. 已知高度的三列布局，左右宽度固定，中间自适应。(float, absolute, flex, table, grid) Layout html * { padding: 0; margin: 0; } .layout article div { min-height: 100px; } 高度如果未知，flex 和 table 可以继续用。不改变代码情况下grid内容超出 .layout.float .left { float: left; width: 300px; background: red; } .layout.float .center { background: yellow; } .layout.float .right { float: right; width: 300px; background: blue; } 三栏布局 浮动解决方案 兼容性比较好，但脱离了文档流，需要清除浮动 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； .layout.absolute .left-center-right>div { position: absolute; } .layout.absolute .left { left: 0; width: 300px; background: red; } .layout.absolute .center { left: 300px; right: 300px; background: yellow; } .layout.absolute .right { right: 0; width: 300px; background: blue; } 三栏布局 绝对定位解决方案 快捷，但也脱离了文档流，导致里面的布局也会脱离文档流，整个布局并不实用。 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； .layout.flexbox { margin-top: 110px; } .layout.flexbox .left-center-right { display: flex; } .layout.flexbox .left { width: 300px; background: red; } .layout.flexbox .center { flex: 1; background: yellow; } .layout.flexbox .right { width: 300px; background: blue; } 三栏布局 flexbox解决方案 解决float and absolute shortcomings 当中间文字过多时，两侧高度会同中间div高度保持一致 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； .layout.table .left-center-right { width: 100%; height: 100px; display: table; } .layout.table .left-center-right>div { display: table-cell; } .layout.table .left { width: 300px; background: red; } .layout.table .center { background: yellow; } .layout.table .right { width: 300px; background: blue; } 三栏布局 表格布局解决方案 历史上评价不高，兼容性好 当中间文字过多时，两侧高度会同中间div高度保持一致 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； .layout.grid .left-center-right { width: 100%; display: grid; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; } .layout.grid .left-center-right>div {} .layout.grid .left { width: 300px; background: red; } .layout.grid .center { background: yellow; } .layout.grid .right { background: blue; } 三栏布局 网格布局解决方案 可以做复杂事情，新解决方案，兼容性不好 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； 1.2. 三栏垂直分布，上下固定，移动端常见 Document html * { margin: 0; padding: 0; } html, body { height: 100%; } /* position fixed header, footer { height: 100px; width: 100%; background: #ccc; position: fixed; } header { top: 0 } footer { bottom: 0 } section { height: calc(100% - 200px); background: yellow; padding: 100px 0; } */ /*flex 布局*/ body { display: flex; justify-content: flex-start; flex-direction: column; } header, footer { background: #ccc; height: 100px; } section { background: yellow; flex: 1; } 移动端常见，我是导航 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 我是页面底部 1.3. 两行，头固定，下面自适应高度 Document html, body { height: 100%; } body { display: flex; flex-direction: column; } header { /* height: 100px; */ flex-basis: 100px; background: #ccc; } section{ flex: 1; background: #312; } 移动端常见，我是导航 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 中间部分，自适应高度 1.4. 两列，左侧固定宽，右侧自适应宽度 Document html, body { height: 100%; } body { display: flex; } aside { flex-basis: 100px; background: #ccc; } section { flex: 1; } 侧边栏固定 自适应宽度 自适应宽度 自适应宽度 自适应宽度 自适应宽度 自适应宽度 自适应宽度 自适应宽度 自适应宽度 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/media_query.html": {
    "url": "CSS/media_query.html",
    "title": "media_query",
    "keywords": "",
    "body": "1. Media Query1. Media Query Css reset/normalize (not in MQ) small screen (not in MQ due to mobile first, default rules) medium screen: @media screen and (min-width: 500px) { } large screen: @media screen and (min-width: 1140px) { } So most styles are in small.scss, a little in both medium.scss and large.scss Basic: p { font-size: 16px; } @media (min-width: 768px) and (max-width: 1023px) { p { font-size: 18px; } } @media (min-width: 1024px) { p { font-size: 20px; } } Second: $tablet: '(min-width: 768px) and (max-width: 1023px)'; $desktop: '(min-width: 1024px)'; p { font-size: 16px; } @media #{$tablet} { p { font-size: 18px; } } @media #{$desktop} { p { font-size: 20px; } } Write query for a specific element: $tablet: '(min-width: 768px) and (max-width: 1023px)'; $desktop: '(min-width: 1024px)'; p { font-size: 16px; @media #{$tablet} { font-size: 18px; } @media #{$desktop} { font-size: 20px; } } Mixin: $tablet-width: 768px; $desktop-width: 1024px; @mixin tablet { @media (min-width: #{$tablet-width}) and (max-width: #{$desktop-width - 1px}) { @content; } } @mixin desktop { @media (min-width: #{$desktop-width}) { @content; } } @mixin retina { @media only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx) { @content; } } @mixin print { @media print { @content; } } p { font-size: 16px; @include tablet { font-size: 18px; } @include desktop { font-size: 20px; } } @import 'compass/css3'; /** * Conditional Media Query Mixin * by @sheiko (http://dsheiko.com) * * The problem this mixin solves is explained there * https://css-tricks.com/conditional-media-query-mixins/ * * https://github.com/dsheiko * MIT license: https://www.opensource.org/licenses/mit-license.php */ // Predefined Break-points $mediaMaxWidth: 1260px; $mediaBp1Width: 960px; $mediaMinWidth: 480px; @function translate-media-condition($c) { $condMap: ( 'screen': 'only screen', 'print': 'only print', 'retina': '(-webkit-min-device-pixel-ratio: 1.5), (min--moz-device-pixel-ratio: 1.5), (-o-min-device-pixel-ratio: 3/2), (min-device-pixel-ratio: 1.5), (min-resolution: 120dpi)', '>maxWidth': '(min-width: #{$mediaMaxWidth + 1})', 'bp1Width': '(min-width: #{$mediaBp1Width + 1})', 'minWidth': '(min-width: #{$mediaMinWidth + 1})', 'bp1Width', 'minWidth', ' Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/sass.html": {
    "url": "CSS/sass.html",
    "title": "sass",
    "keywords": "",
    "body": "1. scss vs sass1.1. 编译1.1.1. 编译方法1.1.2. 编译结果1.2. 常用基本语法1.3. 1. 变量1.4. 2. 嵌套1.4.1. 2.1 选择器嵌套1.4.2. 2.2 属性嵌套1.5. 3. 代码重用之继承1.6. 4. 代码重用之 Mixin 混合器1.7. 5. 颜色函数1.8. 6. @import 引入1.8.1. 原生的 CSS 导入1.8.2. 一. Sass/Scss、Less 是什么?1.8.3. 二. Sass/Scss 与 Less 区别1.8.4. 三. 总结1. scss vs sass Sass 有两种后缀名文件：.sass和.scss。在同一个项目中，两种格式文件可以共存（不建议，最好统一为一种格式），但二者有各自的特点： sass 后缀的文件：使用类 Ruby 的语法，格式为空格缩进式，没有花括号，靠换行区分不同属性，格式要求比较严格。 scss 后缀的文件：是 Sass3 引入的新语法，基本写法与 CSS 大致相同，所以对于专门做前端的同学来说，.scss后缀的文件是不二选择。 1.1. 编译 1.1.1. 编译方法 Sass 编译方式大概有三种：通过命令行编译（基础方法）、GUI 可视化图形同居编译及自动化编译。 命令行编译 单文件转换命令： sass style.scss style.css #把名为 style 的 Sass 文件转换为 CSS文件。 单文件监听命令（添加--watch命令）： sass --watch style.scss:style.css #`--watch`参数加上之后，可以监测style这个文件的变化，更新保存之后自动编译。 多文件（文件夹）监听命令 sass --watch sass/main:dist/css #监视 sass 目录下 main 文件夹中的所有 Sass文件，并自动编译为CSS文件之后，放到dist/css目录下。 逆向操作，css 文件转换为 sass/scs s 文件 sass-convert style.css style.sass sass-convert style.css style.scss GUI 编译工具推荐国人自己开发的 Koala 工具，有中文版，上手也很简单。戳这里看教程 自动化编译这里有很多途径实现。可以通过 webstorm、Sublime 等编辑器的相关插件实现，也可以借助 Gulp 等自动化构建工具来配置。 Sass 其他命令 sass -h 运行命令行帮助文档，可以获得所有的配置选项 sass –style 指定编译后的 css 代码格式，后面可跟 4 种参数：nested，expanded，compact，compressed sass –sourcemap 表示开启 sourcemap 调试。开启之后，会生成一个后缀名为.css.map 的文件。不过现在基本都会默认生成此文件。 1.1.2. 编译结果 像上面提到的，通过给命令--style后面添加不同的参数，会生成不同样式的 css 代码，这其实没有太多好说，但大家有没有想过一个问题，Sass 文件中的注释会被编译到 CSS 文件中么？这就要看--style命令后面是什么参数了，默认是nested（嵌套式），而expanded（展开式）是 CSS 代码常见的格式。 --Sass 中的注释有 3 种：-- //我是单行注释 不会出现在编译之后任何格式的 CSS 文件中。 /-我是多行注释-/ 只会出现在编译之后代码格式为 expanded 的 CSS 文件中。 /-!我是强制注释-/ 会出现在任何代码格式的 CSS 文件中。 1.2. 常用基本语法 1.3. 1. 变量 变量是 Sass 中最基本的语法。凡是 css 属性的标准值（比如说 1px 或者 bold）可存在的地方，都可以替换为变量。之后，如果你需要一个不同的值，只需要改变这个变量的值，则所有引用此变量的地方生成的值都会随之改变。通过 --$-* 符号来定义，通过变量名称实现多处重复引用。 $box-color: red; //定义变量 ul { color: $box-color; //引用 } li { background-color: $box-color; //引用 } //编译后 ul { color: red; } li { background-color: red; } 另外，变量的值也可以引用其他变量： $highlight-color: #f90; $highlight-border: 1px solid $highlight-color; .selected { border: $highlight-border; } //编译后 .selected { border: 1px solid #f90; } 1.4. 2. 嵌套 Sass 支持选择器及属性嵌套，可以避免代码的重复书写。 1.4.1. 2.1 选择器嵌套 div { h1 { color: #333; } p { margin-bottom: 1.4px; a { color: #999; } } } /* 编译后 -/ div h1 { color: #333; } div p { margin-bottom: 1.4px; } div p a { color: #999; } 大多数情况下上面那种简单的嵌套都没问题。但如果你想要在嵌套的选择器里边应用一个类似于：hover 的伪类，就需要用到 --&-* 这个连接父选择器的标识符。 div { p { margin-bottom: 1.4px; &:hover { color: #999; } } } //编译后： div p { margin-bottom: 1.4px; } div p:hover { color: #999; } 1.4.2. 2.2 属性嵌套 示例 1： div { border: { style: solid; width: 1px; color: #ccc; } } //编译后 div { border-style: solid; border-width: 1px; border-color: #ccc; } 示例 2： div { border: 1px solid #ccc { left: 0px; right: 0px; } } //编译后 div { border: 1px solid #ccc; border-left: 0px; border-right: 0px; } 1.5. 3. 代码重用之继承 使用选择器的继承，要使用关键词@extend，后面紧跟需要继承的选择器。 .class1 { border: 1px solid #333; } .class2 { @extend .class1; background-color: #999; } //编译后 .class1, .class2 { border: 1px solid #333; } .class2 { background-color: #999; } 如上示例，.class2不仅会继承.class1自身的所有样式，也会继承任何跟.class1有关的组合选择器样式，如下： .class1 { border: 1px solid #333; } .class1 a { color: red; } .class2 { @extend .class1; } //编译后： .class1, .class2 { border: 1px solid #333; } .class1 a, .class2 a { color: red; } 1.6. 4. 代码重用之 Mixin 混合器 sass 中使用@mixin 声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的@mixin 通过@include + mixin 名称来调用。 无参数 mixin 声明及调用： @mixin mixName { float: left; margin-left: 10px; } div { @include mixName; } //编译后： div { float: left; margin-left: 10px; } 带参数 mixin 声明及调用可以不给参数值直接写参数，如果给了值的话，就是参数的默认值，在调用的时候传入其他值就会把默认值覆盖掉。 @mixin left($value: 10px) { float: left; margin-left: $value; } div { @include left(66px); } //编译后： div { float: left; margin-left: 66px; } 带多组数值参数的 mixin 声明及调用如果一个参数可以有多组值，如 box-shadow、transition 等，那么参数则需要在变量后加三个点表示，如$variables…。 @mixin mixName($shadow...) { box-shadow: $shadow; } .box { @include mixName( 0 2px 2px rgba(0, 0, 0, 0.3), 0 3px 3px rgba(0, 0, 0, 0.3), 0 4px 4px rgba(0, 0, 0, 0.3) ); } //编译后： .box { box-shadow: 0 2px 2px rgba(0, 0, 0, 0.3), 0 3px 3px rgba(0, 0, 0, 0.3), 0 4px 4px rgba(0, 0, 0, 0.3); } 下面是一个实际应用中关于 CSS3 浏览器兼容的 mixin 使用示例： @mixin transition($transition) { -webkit-transition: $transition; -moz-transition: $transition; -ms-transition: $transition; -o-transition: $transition; transition: $transition; } @mixin opacity($opacity) { opacity: $opacity; filter: alpha(opacity = $opacity * 100); } div { width: 100px; height: 100px; @include transition(all 0.5s); @include opacity(0.5); } ul { width: 50px; height: 50px; @include transition(all 1s); @include opacity(1); } //编译后 div { width: 100px; height: 100px; -webkit-transition: all 0.5s; -moz-transition: all 0.5s; -ms-transition: all 0.5s; -o-transition: all 0.5s; transition: all 0.5s; opacity: 0.5; filter: alpha(opacity=50); } ul { width: 50px; height: 50px; -webkit-transition: all 1s; -moz-transition: all 1s; -ms-transition: all 1s; -o-transition: all 1s; transition: all 1s; opacity: 1; filter: alpha(opacity=100); } 1.7. 5. 颜色函数 Sass 中集成了大量的颜色函数，让变换颜色更加简单直接。 $box-color: red; ul { color: $box-color; } li { background-color: darken($box-color, 30%); } //编译后： ul { color: red; } li { background-color: #660000; } 其他颜色函数 lighten(#cc3, 10%) // #d6d65c grayscale(#cc3) // #808080 complement(#cc3) // #33c 1.8. 6. @import 引入 CSS 中原本就有不常用的@import语法，但是有两个弊端： 引入语句一定要卸载代码最前面才会生效； 影响性能。如果 A 文件要引入 B 文件，当浏览器读到 A 文件时会再去下载 B，阻塞进程。 而 Sass 中的@import会在生成 CSS 文件时就把引入的所有文件先导入进来，也就是所有相关的样式会被编译到同一个 CSS 文件中，无需发起额外的请求。当然，Sass 的@import也支持导入远程的 CSS 文件。那效果跟普通 CSS 导入样式文件一样，导入的 css 文件不会合并到编译后的文件中，而是以@import 方式存在。一般来说基础的文件命名需要以’_’ 开头，如 _partial.scss。这种文件在导入的时候可以不写下划线及后缀，可写成@import “partial”。但是倒入 CSS 文件的话，就需要“文件名+后缀”了。 @import 'partial'; //导入名为“_partial.scss”的文件 @import 'toolbar.css'; //导入名toolbar.css”的文件 { margin: 0; padding: 0; } 1.8.1. 原生的 CSS 导入 下列三种情况下会生成原生的 CSS@import： 被导入文件的名字以. css 结尾； 被导入文件的名字是一个 URL 地址（例如http://www.sass.hk/css/css.css ），由此可用谷歌字体 API 提供的相应服务； 被导入文件的名字是 CSS 的 url() 值。 也就是说，你不能用 Sass 的 @import 直接导入一个原始的 CSS 文件，因为 sass 会认为你想用 CSS 原生的 @import。但是，因为 sass 的语法完全兼容 css，所以你可以把原始的 css 文件改名为.scss 后缀，即可直接导入了。 1.8.2. 一. Sass/Scss、Less 是什么? 参考网站：http://www.sasschina.com/guide Sass (Syntactically Awesome Stylesheets)是一种动态样式语言，Sass 语法属于缩排语法，比 css 比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。 Sass 与 Scss 是什么关系? Sass 的缩排语法，对于写惯 css 前端的 web 开发者来说很不直观，也不能将 css 代码加入到 Sass 里面，因此 sass 语法进行了改良，Sass 3 就变成了 Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。 Less 也是一种动态样式语言。对 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数. Less 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可在服务端运行 (借助 Node.js)。 1.8.3. 二. Sass/Scss 与 Less 区别 编译环境不一样 Sass 的安装需要 Ruby 环境，是在服务端处理的，而 Less 是需要引入 less.js 来处理 Less 代码输出 css 到浏览器，也可以在开发环节使用 Less，然后编译成 css 文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app 这样的工具，也有在线编译地址。 变量符不一样，Less 是@，而 Scss 是$ 变量插值方式不同 在两种语言中，变量都可以以一定的方式插入到字符串中去，这个特性极为有用，但两种语言的插入方式不同，具体请看下例： //sass 中 $direction: left; .myPadding { padding-#{$direction}: 20px; } //less中 @direction: left; .myPadding { padding-@{direction}: 20px; } //编译后的css代码是相同的，如下： .myPadding { padding-left: 20px; } 输出设置，Less 没有输出设置，Sass 提供 4 中输出选项：nested, compact, compressed 和 expanded。 输出样式的风格可以有四种选择，默认为 nested nested：嵌套缩进的 css 代码 expanded：展开的多行 css 代码 compact：简洁格式的 css 代码 compressed：压缩后的 css 代码 Sass 支持条件语句，可以使用if{} else{}, for{}循环等等。而 Less 不支持。 @if lightness($color) > 30% { } @else { } @for $i from 1 to 10 { .border-#{$i} { border: #{$i}px solid blue; } } 引用外部 CSS 文件 scss 引用的外部文件命名必须以_开头, 如下例所示: 其中_test1.scss、_test2.scss、_test3.scss 文件分别设置的 h1 h2 h3。文件名如果以下划线_开头的话，Sass 会认为该文件是一个引用文件，不会将其编译为 css 文件 // 源代码： @import '_test1.scss'; @import '_test2.scss'; @import '_test3.scss'; // 编译后： h1 { font-size: 17px; } h2 { font-size: 17px; } h3 { font-size: 17px; } Less 引用外部文件和 css 中的@import 没什么差异。 Sass 和 Less 的工具库不同 Sass 有工具库 Compass, 简单说，Sass 和 Compass 的关系有点像 Javascript 和 jQuery 的关系, Compass 是 Sass 的工具库。在它的基础上，封装了一系列有用的模块和模板，补充强化了 Sass 的功能。bootstrap v4 Less 有 UI 组件库 Bootstrap v3 1.8.4. 三. 总结 不管是 Sass 还是 Less，都可以视为一种基于 CSS 之上的高级语言，其目的是使得 CSS 开发更灵活和更强大，Sass 的功能比 Less 强大，基本可以说是一种真正的编程语言了，Less 则相对清晰明了，易于上手，对编译环境要求比较宽松。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/transform.html": {
    "url": "CSS/transform.html",
    "title": "transform",
    "keywords": "",
    "body": "1. CSS 动画：transform1.1. 2D 变换1.1.1. 原点1.1.2. 旋转1.1.3. 缩放1.1.4. 平移1.1.5. 斜切（Skew）1.1.6. 组合 Transform1. CSS 动画：transform 1.1. 2D 变换 有四个主要的变换函数：translate, rotate, scale, skew。这些函数通过组合进 matrix 变换函数。 1.1.1. 原点 用 transform-origin 改变变换的原点。默认在中心。其取值与 background-position 类似。两个值分别表示水平和垂直偏移。可以使用关键字（top, center, bottom, left, right）和数值，位置可以位于元素之外。 例如，原点放在左上角，可以表述为等价的三种形式： transform-origin: left top; transform-origin: 0 0; // 像素 transform-origin: 0% 0%; 1.1.2. 旋转 旋转图片。可以是浮点数。正负值分别表示顺时针和逆时针变换。 单位： deg： 360 度，如 rotate(90deg)。 grad：用于简化计算：一圈算 400 grad。如 rotate(100grad)。 rad： 一圈 2π。如 rotate(1.57rad)。 turn：表示一圈。如 rotate(.25turn)。 注意问题： 页面上的其他内容的布局不受变换影响。因此可能出现交叠。 DOM 不受影响。被变换的元素的属性值（如 offsetWidth）保持不变。 CSS transform 本质上对变换元素进行相对定位；元素原来位置保持不动。 如果 overflow 设为 scroll 或 auto，因变换导致的溢出会导致滚动条出现。 其他 CSS 规则在变换前施加，特效会随着旋转。 值总是要带单位，即使是 0。 若需要绕右上角转到，需要设置 transform-origin： img.tilt { width: 300px; height: 300px; float: left; transform-origin: right top; transform: rotate(−10deg); } 1.1.3. 缩放 scale 函数的参数是乘数。如 scale(2) 长宽放大 2 倍。scale(.5) 长宽缩小一倍。 利用负值可以反转图像。例如左右反转： 水平和垂直方向可以独立缩放，例如： transform: scale(0.5, 2); 或者使用独立的函数：scaleX 用于水平缩放、scaleY 用于垂直缩放。 1.1.4. 平移 translate(x, y) 沿水平和垂直方向移动元素。translateX() 沿水平移动；translateY() 垂直移动。 transform: translate(50px, -4em); 1.1.5. 斜切（Skew） transform: skewX(21deg) 设置元素的左右两边相对垂线偏移 21 度，即整个元素向右斜切。 拉伸也有两个独立的函数：skewX 和 skewY。 1.1.6. 组合 Transform 两种组合方式：transform 属性中空格分隔多个函数；或作为 matrix 属性的值。 空格分隔的多个transform属性值： transform: translate(50px, -4em) rotate(15deg); matrix 属性的写法略。 注意，写多个 transform 属性不会组合变换！最后一个变换声明会覆盖前面的。 transform: translate(50px, -4em); transform: rotate(15deg); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "CSS/transition.html": {
    "url": "CSS/transition.html",
    "title": "transition",
    "keywords": "",
    "body": "1. Transition1.1. 延时1.2. Easing 函数1.2.1. Transition 速记1. Transition CSS Transition 是最简单形式的动画：从一个可视状态变换到另一个可视状态。如果需要更多状态，需要使用关键帧动画。 例子：鼠标以上后，图片旋转。 img:hover { transform: rotate(7.5deg); transition: 2s all; } 值顺序不重要。可以是 2s all 或 all 2s。若时间需要精确到毫秒，可以使用小数加秒 transition: 2.35s all; 的形式，或毫秒形式 transition: 2350ms all;。 当鼠标移出时，元素立即回到了其初始状态。但有时你期望恢复初始状态也有平滑的动画。方法是将 :hover 中 transition 声明移到默认样式中，:hover 中只保留 transform。背后的原理是，将一个属性放入默认样式，不管进出状态，transition 都生效。 如果在动画过程中鼠标移出或移入，transition 会被打断，会平滑的反转。这个特性非常好！ transition 中可以只指定时间：transition: 2s;。 一般会把 transition 放入默认样式（如 .navButto）而不是最终样式（如 .navButton:hover）。==但对于下拉菜单，下列也可以缓慢动画，但收起最好非常快的完成，为此，可以在默认样式中使用 transition-delay: 5s;，但在最终样式（:hover）覆盖：transition-delay: 0;。== 不是所有的 CSS 属性都可以参与动画。可以参与的属性包括颜色和尺寸类的： transform color, background-color, border-color, opacity border-width, font-size, height, width letter-spacing, line-height, word-spacing margin, padding 定位属性，top, left, right, bottom You can find a complete list at www.w3.org/TR/css3-transitions/#animatable-properties. 只要 CSS 属性改变都可以触发 transition，包括通过 Javascript 改变 CSS 属性。 transition 包含四个控制属性，分别控制参与动画的属性、动画时间、动画类型、延迟时间（可选）。 transition-property 指定参与动画的属性。多个属性逗号风格。值 all 表示动画所有改变的 CSS 属性。 transition-duration 属性指定动画时间。单位可以是秒或毫秒。 每个属性的动画时间可以不同。为此，需要对应使用 transition-duration 和 transition-property（逗号分隔），如： transition-property: color, background-color, border-color; transition-duration: 0.25s, 0.75s, 2s; 1.1. 延时 延迟时间直接加到 transition 后面： transition: 2s 4s; 延迟不仅对动画开始有效，对动画反转回到起点也有效。例如上面的代码，动画会延迟 4 秒后开始；结束后会延迟 4 秒后再回到起始状态。（注意，鼠标在图片上停留至少 4 秒动画才会开始。） transition-delay: 0.5s; 有时不想让所有属性都延时触发，可以为每个属性分别指定延时： transition-property: color, background-color, border-color; transition-duration: 1s, 1s, 0.5s; transition-delay: 0, 0, 1s; 在某些浏览器中左右移动的动画可能不够流畅。使用 translateX 替代 left，会更流畅，适合移动绝对或相对定位的元素。 img { width: 300px; height: 300px; float: left; transition-property: opacity, translateX; transition-duration: 2s, 4s; } img:hover { opacity: 0.2; transform: translateX(60px); } 1.2. Easing 函数 CSS3 动画默认使用 ease。可以使用其他缓动，如 linear： transition: 2s transform linear; 独立的属性是 transition-timing-function。改属性可以取五个值：linear, ease, ease-in, ease-out, ease-in-out. 若不指定该属性，默认使用 ease。 要观看这些缓动函数的区别，参见：www.the-art-of-web.com/css/timing-function/。 transition-timing-function 属性还接受 cubic-bezier 值。The Bezier curve plots the progress of the animation over time. By adjusting two control points you can control how the line curves: the steeper the line, the faster the animation, the flatter the line, the slower. transition-timing-function: cubic-bezier(0.2, 0.96, 0.74, 0.07); Cubic Bezier 曲线最好通过工具创建盒测试。参见：https://matthewlein.com/tools/ceaser 可以对不同的属性施加不同的缓动函数。 1.2.1. Transition 速记 四个属性 transition-property transition-duration transition-timing-function transition-duration 可以合并成一个 transition 属性。空格分隔，分别列出要动画的属性、时常、缓动函数、延时： transition: all 1s ease-in 0.5s; 缓动函数和延时可不设 transition: all 1s; transition: background-color 1s; 属性位置只能填 all 或单个 CSS 属性。如果要动画多个属性，需要每个属性一个完整配置，逗号分隔。 transition: color 1s, background-color 1s, border-color 0.5s 1s; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "DotNet/": {
    "url": "DotNet/",
    "title": "DotNet",
    "keywords": "",
    "body": "1. TOC1. TOC async_await DotNetCore_Fundamentals interview_DotNet 原理 log4net_redis ORM Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "DotNet/async_await.html": {
    "url": "DotNet/async_await.html",
    "title": "async_await",
    "keywords": "",
    "body": "1. async and await1. async and await 需要完善异步操作，如多线程委托写法 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading; using System.Threading.Tasks; namespace AsyncProgramming { class Program { static void Main(string[] args) { #region 同步 //Console.WriteLine(\"start\"); ////模拟延迟操作 //Thread.Sleep(3000); //Console.WriteLine(\"end\"); //Console.ReadKey(); #endregion #region .net 4.0 //Console.WriteLine(\"main start\"); //step 1 ////模拟延迟操作，耗时操作交给新线程 //Thread thread = new Thread(() => //{ // Console.WriteLine(\"child thread starts\"); //step 3 // //子线程处理 // Thread.Sleep(3000); // Console.WriteLine(\"child thread end\"); //step 4 //}); //thread.Start(); //Console.WriteLine(\"main end\"); //step 2 //Console.ReadKey(); #endregion #region .net 4.5 Console.WriteLine(\"main start... threadId: \" + Thread.CurrentThread.ManagedThreadId); //step 1 //模拟延迟操作，耗时操作交给新线程 Do(); Console.WriteLine(\"main end... threadId: \" + Thread.CurrentThread.ManagedThreadId); //step 3 Console.ReadKey(); #endregion } async static void Do() { Console.WriteLine(\"child thread starts... threadId: \" + Thread.CurrentThread.ManagedThreadId); //step 2 await Task.Delay(3000); //await 要求方法必须异步方法 async //await后代码都会交给新线程执行。 Console.WriteLine(\"child thread end... threadId: \" + Thread.CurrentThread.ManagedThreadId); //step 4 } } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "DotNet/DotNetCore_Fundamentals.html": {
    "url": "DotNet/DotNetCore_Fundamentals.html",
    "title": "DotNetCore_Fundamentals",
    "keywords": "",
    "body": "1. .Net Core Fundamentals (.net core v1.1.2)1.1. Get Started1.2. Adding a Configuration Source1.3. Features of Asp.net core1.4. Startup.cs -- Entry point1.5. Request Pipeline & Middleware1.6. ViewComponents VS PartialView1.7. MVC cons and pros1.8. Web Api in .Net Core1. .Net Core Fundamentals (.net core v1.1.2) 1.1. Get Started Follow Official website: https://docs.microsoft.com/en-us/aspnet/core/getting-started 1.2. Adding a Configuration Source Asp.net core no longer uses web.config as configuration file. Instead, appsettings.json is used for this purpose. 1.3. Features of Asp.net core Modular version of .NET Framework supports different environments cross-platform better performance Dependency Injection (Loose coupling, less code changes, better testability) 1.4. Startup.cs -- Entry point ConfigureServices is used to add services to the container, and to configure those services, Dependency Injection! AddTransient: Every request creates an instance. 每次请求都创建一个新的实例. always different; a new instance is provided to every controller and every service. AddScoped: the same within a request, but different across different requests. 相同请求得到同一个实例，常用注册 Repository。不同请求实例不同 AddSingleton: the same for every object and every request Configure is used to specify how an ASP.NET application will respond to individual HTTP requests. Use middleware to configure the HTTP request pipeline 1.5. Request Pipeline & Middleware Request --> Middleware --> Middleware --> ... --> Response 1.6. ViewComponents VS PartialView ViewComponent is a upgrade of PartialView. Partial View: Usually contains only html code and the model which has to be the one passed in calling page. Render PartialView in Parent View: @Html.Partial(\"partialview\", model) ViewComponent: Contains logic! It has a Invoke method which will be called and render its ViewComponent using System.Collections.Generic; using Aspnetcore.Pieshop.Webapp.Models; using Aspnetcore.Pieshop.Webapp.ViewModels; using Microsoft.AspNetCore.Mvc; namespace Aspnetcore.Pieshop.Webapp.ViewComponents { public class ShoppingCartSummaryViewComponent : ViewComponent { private readonly ShoppingCart _shoppingCart; public ShoppingCartSummaryViewComponent(ShoppingCart shoppingCart) { _shoppingCart = shoppingCart; } public IViewComponentResult Invoke() { var items = _shoppingCart.GetShoppingCartItems(); _shoppingCart.ShoppingCartItems = items; var shoppingCartViewModel = new ShoppingCartViewModel { ShoppingCart = _shoppingCart, ShoppingCartTotal = _shoppingCart.GetShoppingCartTotal() }; return View(shoppingCartViewModel); } } } Parent View which called the ViewComponent: // Maybe in _Layout.cshtml @await Component.InvokeAsync(\"ShoppingCartSummary\") 1.7. MVC cons and pros pros: Separation of Concerns testability reuse cons: View may change too fast and Model cannot keep pace with View. Usually have to create ViewModels for View. This is painful as application get larger and larger. 1.8. Web Api in .Net Core Post: Use POST for creating a resource 201 Created Header: content-type Validation Data annotations ModelState Put/Patch: Use PUT for full updates, PATCH for partial updates JsonPatch standard 204 NoContent or 200 Ok Delete: DELETE is for deleting resources 204 NoContent Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "DotNet/helpers/": {
    "url": "DotNet/helpers/",
    "title": "DotNet/helpers",
    "keywords": "",
    "body": "1. TOC1. TOC PinyinHelper Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "DotNet/helpers/PinyinHelper.html": {
    "url": "DotNet/helpers/PinyinHelper.html",
    "title": "PinyinHelper",
    "keywords": "",
    "body": "1. PinyinHelper1. PinyinHelper ChineseChar cc = new ChineseChar(string text); var pinyin = cc.Pinyins; foreach(string s in pinyin) { Console.Write(s); } // 获得中文首字母 string txt = textBox1.Text; foreach(char c in txt) { ChineseChar cc = new ChineseChar(c); string pinyin = cc.Pinyins[0]; //多音字中第一个拼音 char firstLetter = pinyin[0]; textBox2.Text += firstLetter; } // 中国人 => ZGR public static string GetPinyinFirstLetter(string str) { StringBuilder pinyin = new StringBuilder(); foreach(var s in str) { ChineseChar cc = new ChineseChar(s); pinyin.Append(cc.Pinyins[0][0]); //Pinyins[0]多音字第一个音（zhong1）,[0][0]第一个音首字母 } return pinyin.ToString(); } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "DotNet/interview_DotNet原理.html": {
    "url": "DotNet/interview_DotNet原理.html",
    "title": "interview_DotNet 原理",
    "keywords": "",
    "body": "1. .Net 原理1.1. Asp.net 原理1.2. MVC 51. .Net 原理 1.1. Asp.net 原理 下面是请求管道中的 19 个事件。 HttpContext：ecb → HttpWorkerRequest → HttpContext HttpApplicationFactory. 获取了 HttpApplication 实例之后。 BeginRequest: 开始处理请求 AuthenticateRequest 授权验证请求，获取用户授权信息 PostAuthenticateRequest 获取成功 AunthorizeRequest 授权，一般来检查用户是否获得权限 PostAuthorizeRequest: 获得授权 ResolveRequestCache: 获取页面缓存结果 PostResolveRequestCache 已获取缓存 当前请求映射到 MvcHandler（pr）： 创建控制器工厂 ，创建控制器，调用 action 执行，view→response //action Handler : PR() PostMapRequestHandler 创建页面对象:创建 最终处理当前 http 请求的 Handler 实例： 第一从 HttpContext 中获取当前的 PR Handler ，Create PreAcquireRequestState 获取 Session PostAcquireRequestState 获得 Session PreRequestHandlerExecute:准备执行页面对象，执行页面对象的 ProcessRequest 方法 PostRequestHandlerExecute 执行完页面对象了 ReleaseRequestState 释放请求状态 PostReleaseRequestState 已释放请求状态 UpdateRequestCache 更新缓存 PostUpdateRequestCache 已更新缓存 LogRequest 日志记录 PostLogRequest 已完成日志 EndRequest 完成 1.2. MVC 5 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "DotNet/log4net_redis.html": {
    "url": "DotNet/log4net_redis.html",
    "title": "log4net_redis",
    "keywords": "",
    "body": "1. 文件并发(日志处理)--队列--Redis+Log4Net1.1. 方式一：使用队列1.2. 方式二：使用 Redis 与 Log4Net 完成分布式日志记录1. 文件并发(日志处理)--队列--Redis+Log4Net 多线程操作同一个文件时会出现并发问题。解决的一个办法就是给文件加锁(lock)，但是这样的话，一个线程操作文件时，其它的都得等待，这样的话性能非常差。另外一个解决方案，就是先将数据放在队列中，然后开启一个线程，负责从队列中取出数据，再写到文件中。 在这之前，有必要先了解下 Redis，关于 Redis 的介绍可以参考我的这篇博文：ASP.NET Redis 开发 Redis 工具和所需资料代码全下载，地址：http://pan.baidu.com/s/155F6A 下面我们讲解一个实际项目中应用的案例，关于日志的处理.这里是使用 ASP.NET MVC 项目作为 Demo。 1.1. 方式一：使用队列 思路：把所有产生的日志信息存放到一个队列里面，然后通过新建一个线程，不断的从这个队列里面读取异常信息，然后往日志里面写。也就是所谓的生产者、消费者模式。 1. 新建一个类 MyErrorAttribute using System.Web.Mvc; public class MyErrorAttribute: HandleErrorAttribute { public static Queue ExceptionQueue = new Queue (); public override void OnException(ExceptionContext filterContext) { ExceptionQueue.Enqueue(filterContext.Exception); filterContext.HttpContext.Response.Redirect(\"~/Error.html\"); base.OnException(filterContext); } } 2. 在 FilterConfig 类中进行如下修改： public class FilterConfig { public static void RegisterGlobalFilters(GlobalFilterCollection filters){ //filters.Add(new HandleErrorAttribute()); filters.Add(new MyErrorAttribute()); } string filePath = Server.MapPath(\"~/Logs/\"); ThreadPool.QueueUserWorkItem(o => { while (true) { if (MyErrorAttribute.ExceptionQueue.Count > 0) { Exception ex = MyErrorAttribute.ExceptionQueue.Dequeue(); if (ex != null) { string fileName = filePath + DateTime.Now.ToString(\"yyyy-MM-dd\") + \".txt\"; File.AppendAllText(fileName, ex.Message); } else { Thread.Sleep(50); } } else { Thread.Sleep(50); } } }); } 1.2. 方式二：使用 Redis 与 Log4Net 完成分布式日志记录 在程序最开始加入log4net.Config.XmlConfigurator.Configure() 在要打印日志的地方LogManager.GetLogger(typeof(Program)).Debug(“信息”); 。通过 LogManager.GetLogger 传递要记录的日志类类名获得这个类的 ILog（这样在日志文件中就能看到这条日志是哪个类输出的了），然后调用 Debug 方法输出消息。因为一个类内部不止一个地方要打印日志，所以一般把 ILog 声明为一个 static 字段。 Private static ILog logger = LogManager.GetLogger(typeof(Test)) 输出错误信息用 ILog.Error 方法，第二个参数可以传递 Exception 对象。log.Error(\"错误\"+ex)，log.Error(\"错误\",ex) Appender：可以将日志输出到不同的地方，不同的输出目标对应不同的 Appender：RollingFileAppender（滚动文件）、AdoNetAppender（数据库）、SmtpAppender （邮件）等。 level（级别）：标识这条日志信息的重要级别 None>Fatal>ERROR>WARN>DEBUG>INFO>ALL，设定一个 Level，那么低于这个 Level 的日志是不会被写到 Appender 中的. Log4Net 还可以设定多个 Appender，可以实现同时将日志记录到文件、数据、发送邮件等；可以设定不同的 Appender 的不同的 Level，可以实现普通级别都记录到文件，Error 以上级别发送邮件；可以实现对不同的类设定不同的 Appender；还可以自定义 Appender，这样可以自己实现将 Error 信息发短信等. 配置 Log4Net，在 Web.config 中添加如下配置： ServiceStack.dll、ServiceStack.Interfaces.dll、ServiceStack.ServiceInterface.dll、log4net.dll 的引用，然后新建一个类 MyErrorAttribute using System.Web.Mvc; using ServiceStack.Redis; public static IRedisClientsManager clientsManager = new PooledRedisClientManager(new string[] { \"127.0.0.1:6379\" }); public static IRedisClient redisClient = clientsManager.GetClient(); public override void OnException(ExceptionContext filterContext) { redisClient.EnqueueItemOnList(\"errorMsg\", filterContext.Exception.ToString()); filterContext.HttpContext.Response.Redirect(\"~/Error.html\"); base.OnException(filterContext); } 在 FilterConfig 类中进行如下修改： public class FilterConfig { public static void RegisterGlobalFilters(GlobalFilterCollection filters) { //filters.Add(new HandleErrorAttribute()); //filters.Add(new MyErrorAttribute()); filters.Add(new MyExceptionAttribute()); } } 在 Gobal.asax.cs 中的 Application_Start 事件里添加如下代码： log4net.Config.XmlConfigurator.Configure(); //获取Log4Net配置信息 ThreadPool.QueueUserWorkItem(o => { while (true) { if (MyExceptionAttribute.redisClient.GetListCount(\"errorMsg\") > 0) { string msg = MyExceptionAttribute.redisClient.DequeueItemFromList(\"errorMsg\"); if (!string.IsNullOrEmpty(msg)) { ILog logger = LogManager.GetLogger(\"testError\"); logger.Error(msg); //将异常信息写入Log4Net中 } else { Thread.Sleep(50); } } else { Thread.Sleep(50); } } }); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "DotNet/ORM.html": {
    "url": "DotNet/ORM.html",
    "title": "ORM",
    "keywords": "",
    "body": "1. ORM1.1. 常见1.2. 互联网产品不用 EF1. ORM 开发人员不需要写 sql 语句操作数据库。 1.1. 常见 Entity Framework/ NHibernate / Dapper / Petapoco / MyBatis.net / CYQData / MonoSql 1.2. 互联网产品不用 EF 执行效率相对纯 sqlDataReader 低 EF 对项目侵入性较高 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Git/": {
    "url": "Git/",
    "title": "Git",
    "keywords": "",
    "body": "1. TOC1. TOC git_alias git_cheatsheet git_in_work git1 Gitlab git 删除撤销 Git 查看、删除、重命名远程分支和 tag ignore_files_locally todo Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Git/git_alias.html": {
    "url": "Git/git_alias.html",
    "title": "git_alias",
    "keywords": "",
    "body": "1. Git Alias1. Git Alias git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status alias gbr=\"git branch | grep -v \"master\" | xargs git branch -D\" # delete all local branches except master, but master-test won't be deleted git branch | grep -ve \" master$\" | xargs git branch -D # This will remove branches named (e.g.) test-master, master-test. # more than 1 branch can be added to the grep expression like \"master\\|develop\\|current_branch\" git branch | egrep -v \"(master|\\*)\" | xargs git branch -D # deletes everything except master and the branch I am currently in git config --global alias.unstage 'reset HEAD --' # `git unstage fileA` will perform like `git reset HEAD -- fileA` git config --global alias.last 'log -1 HEAD' # git last As you can tell, Git simply replaces the new command with whatever you alias it for. However, maybe you want to run an external command, rather than a Git subcommand. In that case, you start the command with a ! character. This is useful if you write your own tools that work with a Git repository. We can demonstrate by aliasing git visual to run gitk: $ git config --global alias.visual '!gitk' Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Git/git_cheatsheet.html": {
    "url": "Git/git_cheatsheet.html",
    "title": "git_cheatsheet",
    "keywords": "",
    "body": "1. Git Cheat Sheet1.1. Git Resources1.2. Awesome Git Aliases1.3. Super Git Scripts1.4. Global Configuration Preferences1.5. Git Recipes1.5.1. Now what exactly depends on this package...?1.5.2. Hatin' on merge commits1.5.3. I take it back!1.5.4. Catching up1.6. Special Git Files1.6.1. .gitignore1.6.2. .gitattributes1.7. Git Commands1.7.1. git help1.7.2. git config1.7.3. git init1.7.4. git status1.7.5. git diff1.7.6. git checkout1.7.7. git add1.7.8. git commit1.7.9. git tag1.7.10. git blame1.7.11. git reset1.7.12. git revert1.7.13. git log1.7.14. git remote1.7.15. git push1.7.16. git fetch1.7.17. git pull1.7.18. git clone1.7.19. git branch1.7.20. git merge1.7.21. git rebase1.7.22. git rm1.7.23. git clean1.7.24. git stash1. Git Cheat Sheet 1.1. Git Resources Resource Notes http://git-scm.com/ Official git website http://git-scm.com/docs Git docs https://help.github.com/articles/generating-ssh-keys/ Generate an SSH Key https://help.github.com/articles/changing-a-remote-s-url/ Setup the Remote URL https://github.com/pluralsight/git-switch GitSwitch is a windows utility for managing multiple git credentials https://github.com/pluralsight/pairing-station PairingStation is a mac app for managing multiple git credentials https://www.codeschool.com/learn/git CodeSchool courses on using git 1.2. Awesome Git Aliases git config --global alias.aliases \"\\!git config --list | grep alias | sed -e 's/alias\\.//' | sed -e $'s/=/\\t/'\" git config --global alias.b \"branch\" git config --global alias.ba \"branch -a\" git config --global alias.bd \"branch -d\" git config --global alias.bda \"\\!git branch | grep -v master | grep -v '*' | xargs git branch -d\" git config --global alias.brda \"\\!git branch --remotes --merged master | grep -v master | sed -e 's/\\// :/' | xargs -n2 git push\" git config --global alias.cam \"commit -am\" >>>>>> add git cheatsheet and toc git config --global alias.cm \"commit -m\" git config --global alias.ch \"checkout\" git config --global alias.chb \"checkout -b\" git config --global alias.d \"diff\" git config --global alias.ds \"diff --staged\" git config --global alias.lga \"log --all --color --graph --pretty=format:'%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit\" git config --global alias.pr \"pull --rebase\" git config --global alias.restore \"\\!git checkout \\$(git rev-list -n 1 HEAD -- \\\"\\$1\\\")^ -- \\\"\\$1\\\"\" git config --global alias.rpo \"remote prune origin\" git config --global alias.s \"status -bsu\" 1.3. Super Git Scripts # Find remote branches that have not had activity for a specified amount of time. for k in $(git branch --remotes); do if [ -z \"$(git log -1 --after='24 months ago' $k)\" ]; then echo $k fi done 1.4. Global Configuration Preferences echo \".idea/\" >> $HOME/.gitignore git config --global core.excludesfile $HOME/.gitignore git config --global core.autocrlf true git config --global core.safecrlf false git config --global push.default simple git config --global color.ui true 1.5. Git Recipes 1.5.1. Now what exactly depends on this package...? When you find yourself wondering how a downstream dependency fits into the big picture, this command can show you the dependency tree: npm ls | grep -C 20 \"react\" 1.5.2. Hatin' on merge commits Don't you just hate those nasty merge commits cluttering up your commit history? This recipe is just the trick for merging a local branch into master without generating a merge commit. DO NOT use this recipe if your branch has been pushed to a remote! git checkout my-branch git rebase master git checkout master git merge my-branch 1.5.3. I take it back! Sometimes, don't you wish you could just go back in time and do things a little bit differently? Well, with git you can. Here are the git commands to use for the three different scenarios you'll face when wanting to undo what's been done. Command Use Case git checkout Use checkout if your changes have not been checked in. git reset Use reset if your changes have been checked in, but not pushed to a remote. git revert Use revert if your changes have been checked in and pushed to a remote. 1.5.4. Catching up If you've forked a repo and then find yourself wanting to sync up with the latest changes in the original repo, this is the recipe for you. This recipe makes the assumption that your repo follows the standard conventions of naming the original remote the upstream remote. git fetch upstream git checkout master git merge upstream/master 1.6. Special Git Files 1.6.1. .gitignore The .gitignore file should be at the root of the project directory. This file tells git to ignore, or not track, the specified files. See the docs for a complete reference: https://git-scm.com/docs/gitignore # Lines that start with a pound sign (#) are comments # Blank lines are not interpreted # Ignore specific files .env secrets.txt # Ignore entire folders node_modules bin log # Patterns are supported *.log **/*.log # Negate a previous pattern to NOT ignore a file !critical.log 1.6.2. .gitattributes The .gitattributes file should be at the root of the project directory. This file tells git how to handle certain files or file types. See the docs for a complete reference: https://git-scm.com/docs/gitattributes The -text option tells git not to normalize the line endings on that file. In other words, leave this file alone. *.txt text *.vcproj eol=crlf *.sh eol=lf *.jpg -text 1.7. Git Commands When working with git commands, options can be combined. For example, git commit -am is the same as git commit -a -m and git status -su is the same as git status -s -u. 1.7.1. git help Command Description git help Prints basic usage for the help command to the console. git help Launches detailed help docs for the specified command. For example, git help commit or git help clone 1.7.2. git config For a large, but not necessarily complete, list of configuration variables, see http://git-scm.com/docs/git-config#_variables Command Description git config Prints basic usage for the config command to the console. git config --global Use the global user configuration git config --system Use the system configuration, i.e. the config for all users on the computer git config --list Prints the applicable configurations for the repository, namely the local, global, and system configurations, so some variables might be listed multiple times. git config Set the value for a config variable. For example, git config --global color.ui true git config --get Get the value for a config variable. For example, git config --global --get color.ui git config --unset Remove a variable from the config. git config --global alias. \"\" Set a command alias. For example, git config --global alias.pr \"pull --rebase\" then use git pr git config --global user.name \"User Name\" Set the global user name git config --global user.email \"user@site.com\" Set the global email address git config --global core.autocrlf true Set the global line endings policy to \\r\\n (carriage return) on checkout and \\n (line feed) on commit git config --global core.autocrlf input Changes the line ending to \\n on commit. git config --global core.editor Set the global editor used by git for things like commit messages 1.7.3. git init Command Description git init Create a new, empty git repository. 1.7.4. git status Command Description git status Shows changes since the last commit git status -s Displays a short, condensed status message. Alias for --short git status -u Show untracked files. Alias for --untracked 1.7.5. git diff When viewing the diff in a bash console, hit q to exit. Command Description git diff Show the differences in tracked, unstaged files. git diff --staged Show the differences in staged files. Synonymous with git diff --cached git diff Show the differences in the specified file. git diff Show the changes you have in your working tree relative to the named . git diff Show the differences between two branches. git diff HEAD~5 Show the differences in the working tree against 5 commits back. 1.7.6. git checkout Command Description git checkout Replace the contents of the file in the working directory with the contents from the last commit. This effectively blows away the changes in the specified path since the last commit. git checkout . Checkout all files from the last commit. This effectively blows away all changes to tracked files since your last commit. git checkout Switch to the specified branch. If you have changes in your working directory when you switch branches, those changes will be preserved. git checkout -b Create a new branch and immediately switch to the new branch. git checkout Checks out the code at the commit where the tag was inserted. git checkout -- Checkout a file from a different branch. Useful if you're in a branch and want to get a single file in sync with master or any other branch. 1.7.7. git add Command Description git add Add the specified file or folder to the staging area. git add -A Add all modified and untracked files to the staging area. Alias for --all git add . Functionally equivalent to --all git add *.txt Wildcards are supported. A command like this would add all .txt files in the top level folder. git add \"*.txt\" Adding quotes around the wildcard will make it work in the top level folder and in all sub folders. 1.7.8. git commit Command Description git commit Commit the staged files. This will open up an editor to type in your commit message. git commit -m \"message\" Commit staged files with the specified commit message. git commit -a Add all modified tracked files and then commit. This DOES NOT add untracked files. Alias for --all git commit --amend Amend the last commit by adding additional files or changing the commit message. Do not amend commits that have been pushed to a remote repository! git commit --dry-run Does not create a commit, but instead shows what would have been committed. 1.7.9. git tag Command Description git tag Lists all of the tags. Same as running git tag -l git tag Create a new lightweight tag. This does not create a tag object. Lightweight tags are only recommended for temporary or private use for identifying commits. git tag -a Create an unsigned, annotated tag object. For example, git tag -a v1.2.7. -a is an alias for --annotate. git tag -s Create a GPG-signed tag object using the default email address's key. For example, git tag -s v2.2.9. -s is an alias for --sign. git tag -m Add the message for the tag object from the command line. For example, git tag -a v3.1.0 -m 'new feature: time travel'. -m is an alias for --message. git tag -a Tag a previous commit by its id. For example, git tag -a v5.3.1 9fceb02 -m 'forgot to tag this!' git tag -l List all tags that match the given pattern. If no pattern is given, all tags are listed. -l is an alias for --list. git tag -d Delete a local tag. For example git tag -d v1.2.3. -d is an alias for --delete. git push : Use git push to delete a remote tag. For example, git push origin :v1.2.3 1.7.10. git blame Command Description git blame See which commit is responsible for each line in the specified file. 1.7.11. git reset Never use the reset command to undo changes that have been pushed! If changes have been pushed, use git revert to undo commits. Command Description git reset Unstage all files that have been staged using the add command. git reset Unstage the specified file or folder. git reset --soft HEAD^ Undo, or reset, the last commit and put the changes from that commit into the staging area. git reset --hard HEAD^ Undo, or reset, the last commit and discard the changes. git reset --hard HEAD^^^ Completely blow away the last three commits. git reset --soft Undo changes back to the specified commit. 1.7.12. git revert Use git revert if the commit to undo has been pushed to a remote. Command Description git revert Create an inverse commit of the specified commit. For example, git revert f32ab34 1.7.13. git log When viewing the diff in a bash console, hit q to exit. Command Description git log Show the commit log. git log --graph Show a text based representation of the branches. git log --all Show all of the commits as if they had been specified on the command line. git log --oneline Show each commit on a single line. git log --abbrev-commit Show only the first 7 characters of the commit instead of the full 40 byte hex object name. 1.7.14. git remote There are a couple of remote naming conventions: origin is the name of the remote that is the primary owner of the repository. upstream is the name of the original remote from which a repository was forked. Command Description git remote List the remotes for the repository. git remote -v Give detailed information about remotes. Alias for --verbose. git remote add Add a remote to an existing repo. git remote rm Remove a remote. git remote show Show detailed information about a remote, including remote branches and whether the branches are tracked or not. git remote prune Remove stale, local branches that have been removed from the remote. 1.7.15. git push Command Description git push Push the specified branch to the specified to the specified remote. git push -u Push using the -u flag to remember the remote to use for the branch. After pushing with the -u flag, you can just use git push. -u is an alias for --set-upstream. git push After pushing with the -u flag, this will push the branch to the upstream remote. git push : Delete a remote branch. For example, git push origin :new-feature git push : Delete a remote tag. For example, git push origin :v1.2.6 git push : If the local branch has a different name than the remote branch, use this command to push the local branch to the remote. git push --tags Push tags. For some strange reason, tags are not pushed unless this flag is used and using this flag does not push code. git push --recurse-submodules=on-demand If using submodules, use this flag to push your current branch and also all of the submodules. 1.7.16. git fetch Command Description git fetch Retrieves and pulls down information from the remote, but does not merge it into the local copy 1.7.17. git pull Command Description git pull Pull down changes from the remote. If needed a merge commit will be created. Shorthand for git fetch followed by git merge FETCH_HEAD git pull --rebase Pull down changes from the remote, and if needed, rebase local commits instead of creating a merge commit. Shorthand for git fetch followed by git rebase FETCH_HEAD 1.7.18. git clone Command Description git clone Clone a repository. Provide a url to clone a remotely hosted repo. git clone Clone a repo into the specified repo. 1.7.19. git branch Command Description git branch List the active branch and all local branches. git branch -r List remote branches. git branch -a List all branches, both local and remote. git branch Create a new branch with the specified name. git branch Create a new branch that points to a specific commit. git branch -d Safely delete a branch. If the branch has not been merged into master or has uncommitted changes, the delete will fail. git branch -D Force delete a branch. This will blow the branch away regardless of branch state. git push : Use git push to delete a remote branch. For example, git push origin :cool-branch 1.7.20. git merge Command Description git merge Merge the specified branch into the current branch. git merge / Merge a remote branch into a local branch. git merge --no-ff Do a recursive merge. Tell git not to do a fast-forward merge. 1.7.21. git rebase Rebase moves commits made on the current branch since the branch was made into a temporary area, does a fast-forward merge of new commits in the original branch into the current branch, and then replays the current branch commits (which creates new commit hashes in the process). This effectively makes it as if you had started the branch at the current state of the original branch. This is a useful technique for not creating automatic 'merge commits' that would get created using git merge. DO NOT rebase a branch that has been pushed to a remote. Command Description git rebase Replay the commits in the current branch on top of any commits from the specified branch. git rebase --continue Continue a rebase after fixing a conflict. git rebase -i Do an interactive rebase. 1.7.22. git rm Command Description git rm Remove the file(s) that match the specified file pattern from the working tree and from the index. git rm -n Do a dry run to see which files will be removed. git rm -r Recursively remove all of the files in the specified directory. git rm --cached Remove matching files from the index, but does not touch the working tree. In other words, the file is no longer tracked in git, but the file is not modified by this command. 1.7.23. git clean Command Description git clean Remove untracked files from the working directory git clean -n Do a dry run - preview files that are going to be deleted git clean -f Force delete. Remove files without requiring a confirmation git clean -x Remove files that are ignored in your .gitignore file. For more examples, see http://stackoverflow.com/questions/61212/how-do-i-remove-local-untracked-files-from-my-current-git-branch 1.7.24. git stash Stashing files is particularly useful for when you have changes in the working directory that you aren't ready to commit, but you need to pull or push or something. Stashing the files will preserve your changes in the stashed copy. Most common usage is git stash, [do some stuff], git stash pop Command Description git stash Same as git stash save git stash save Save all changed files and stash them away. git stash save --keep-index Causes the staging area not to get stashed. git stash save --include-untracked Stash untracked files as well git stash save \"message\" A message can be included when stashing. git stash apply Restores the files at the top of the stash. git stash apply A stash can be picked out of the stack by name to restore. git stash drop Deletes the top stash. git stash pop Shortcut for git stash apply followed by git stash drop. git stash list List the stack of stashes git stash list --stat Summarize the file changes in the stash. git stash show Show the changes for the stash git stash show Show the changes for the named stash git stash branch Pulls a stash out into a new branch git stash clear Drop all of the stashes in the stack **tech.joshegan.com Josh Egan ** harp and hosted on GitHub ======= Proudly built with harp and hosted on GitHub add git cheatsheet and toc Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Git/git_in_work.html": {
    "url": "Git/git_in_work.html",
    "title": "git_in_work",
    "keywords": "",
    "body": "1. git commands I used during work1.1. push my new feature branch to staging1. git commands I used during work ng g c projects/admin-portal/configure/database -m projects/admin-portal/configure/configure.routing.module git commit --no-verify --amend --no-edit 1.1. push my new feature branch to staging git branch -d staging/admin-portal # delete local staging git checkout project/admin-portal # switch to master git branch staging/admin-portal # create staging branch based on master git checkout staging/admin-portal # switch to staging git merge --no-edit origin/feature/admin-portal/myFeature --no-ff # merge remote feature to staging, no fast forward to create a merge commit git push -u origin staging/admin-portal -f # push to remote force, set upstream then build and deploy Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Git/git1.html": {
    "url": "Git/git1.html",
    "title": "git1",
    "keywords": "",
    "body": "In your github fork, you need to keep your master branch clean, by clean I mean without any changes, like that you can create at any time a branch from your master. Each time that you want to commit a bug or a feature, you need to create a branch for it, which will be a copy of your master branch. When you do a pull request on a branch, you can continue to work on another branch and make another pull request on this other branch. Before creating a new branch, pull the changes from upstream. Your master needs to be up to date. Create the branch on your local machine and switch in this branch : $ git checkout -b [name_of_your_new_branch] Change working branch : $ git checkout [name_of_your_new_branch] Push the branch on github : $ git push origin [name_of_your_new_branch] When you want to commit something in your branch, be sure to be in your branch. Add -u parameter to set upstream. You can see all branches created by using : $ git branch Which will show : * approval_messages master master_clean Add a new remote for your branch : $ git remote add [name_of_your_remote] Push changes from your commit into your branch : $ git push [name_of_your_new_remote] [name_of_your_branch] Update your branch when the original branch from official repository has been updated : $ git fetch [name_of_your_remote] Then you need to apply to merge changes, if your branch is derivated from develop you need to do : $ git merge [name_of_your_remote]/develop Delete a branch on your local filesystem : $ git branch -d [name_of_your_new_branch] To force the deletion of local branch on your filesystem : $ git branch -D [name_of_your_new_branch] Delete the branch on github : $ git push origin :[name_of_your_new_branch] The only difference is the : to say delete, you can do it too by using github interface to remove branch : https://help.github.com/articles/deleting-unused-branches. If you want to change default branch, it's so easy with github, in your fork go into Admin and in the drop-down list default branch choose what you want. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Git/Gitlab.html": {
    "url": "Git/Gitlab.html",
    "title": "Gitlab",
    "keywords": "",
    "body": "1. Gitlab by Cotton Hou1.1. Config1.2. Preference1.3. Notification1.4. Merge Request Settings1. Gitlab by Cotton Hou 1.1. Config brew install git git config --get-regexp user # user.name, user.email git config [—global] user.name \"Guanghui Wang\" git config [—global] user.email \"guanghuiw@vmware.com\" git config --global color.ui true git config --global fetch.prune true 1.2. Preference Star the projects I'm interested. https://gitlab.eng.vmware.com/profile/preferences Set Default dashboard to starred projects 1.3. Notification https://gitlab.eng.vmware.com/profile/notifications and set \"Global notification level\" to disabled change starred projects notification level to \"participate\"(in indivisual project overview page) 1.4. Merge Request Settings https://gitlab.eng.vmware.com/repo/edit rep > Settings > General create branch based on master, and then immediately create merge request, WIP: branchName(work in progress) check​ \"remove source branch when merge request is accepted.\" Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Git/git删除撤销.html": {
    "url": "Git/git删除撤销.html",
    "title": "git 删除撤销",
    "keywords": "",
    "body": "1. 后悔药1.1. 最倒霉 -- 错误 commit 提交到了 remote1. 后悔药 1.1. 最倒霉 -- 错误 commit 提交到了 remote git log # 查看想回到第几个 git rebase -i HEAD~3 # pick 其中一个，其余删除或者加 # comment 掉 ctrl + x # exit yes # save 回车 # 退出模式 然后进行修改，最后 git push origin +master 覆盖掉 remote 的提交。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Git/Git查看、删除、重命名远程分支和tag.html": {
    "url": "Git/Git查看、删除、重命名远程分支和tag.html",
    "title": "Git 查看、删除、重命名远程分支和 tag",
    "keywords": "",
    "body": "1. Git 查看、删除、重命名远程分支和 tag1.1. 1. 查看远程分支1.2. 2. 删除远程分支和 tag1.3. 3. 删除不存在对应远程分支的本地分支1.4. 4. 重命名远程分支1.5. 5. 把本地 tag 推送到远程1.6. 6. 获取远程 tag1.7. git tag — 标签相关操作1.7.1. 列出标签1.7.2. 打标签1.7.3. 切换到标签1.7.4. 删除标签1.7.5. 给指定的 commit 打标签1.7.6. 标签发布1. Git 查看、删除、重命名远程分支和 tag 1.1. 1. 查看远程分支 加上-a 参数可以查看远程分支，远程分支会用红色表示出来（如果你开了颜色支持的话）： git branch -a master remote tungway v1.52 * zrong remotes/origin/master remotes/origin/tungway remotes/origin/v1.52 remotes/origin/zrong 1.2. 2. 删除远程分支和 tag git branch -D gh-pages 删除本地分支 在 Git v1.7.0 之后，可以使用这种语法删除远程分支： git push origin --delete 删除 tag 这么用： git push origin --delete tag 否则，可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支： git push origin : 这是删除 tag 的方法，推送一个空 tag 到远程 tag： git tag -d git push origin :refs/tags/ 两种语法作用完全相同。 1.3. 3. 删除不存在对应远程分支的本地分支 假设这样一种情况： 我创建了本地分支 b1 并 pull 到远程分支 origin/b1； 其他人在本地使用 fetch 或 pull 创建了本地的 b1 分支； 我删除了 origin/b1 远程分支； 其他人再次执行 fetch 或者 pull 并不会删除这个他们本地的 b1 分支，运行 git branch -a 也不能看出这个 branch 被删除了，如何处理？ 使用下面的代码查看 b1 的状态： git remote show origin * remote origin Fetch URL: git@github.com:xxx/xxx.git Push URL: git@github.com:xxx/xxx.git HEAD branch: master Remote branches: master tracked refs/remotes/origin/b1 stale (use 'git remote prune' to remove) Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date) 这时候能够看到 b1 是 stale 的，使用 git remote prune origin 可以将其从本地版本库中去除。 更简单的方法是使用这个命令，它在 fetch 之后删除掉没有与远程分支对应的本地分支： git fetch -p 1.4. 4. 重命名远程分支 在 git 中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。 例如下面的例子中，我需要把 devel 分支重命名为 develop 分支： $ git branch -av * devel 752bb84 Merge pull request #158 from Gwill/devel master 53b27b8 Merge pull request #138 from tdlrobin/master zrong 2ae98d8 modify CCFileUtils, export getFileData remotes/origin/HEAD -> origin/master remotes/origin/add_build_script d4a8c4f Merge branch 'master' into add_build_script remotes/origin/devel 752bb84 Merge pull request #158 from Gwill/devel remotes/origin/devel_qt51 62208f1 update .gitignore remotes/origin/master 53b27b8 Merge pull request #138 from tdlrobin/master remotes/origin/zrong 2ae98d8 modify CCFileUtils, export getFileData 删除远程分支： git push --delete origin devel To git@github.com:zrong/quick-cocos2d-x.git - [deleted] devel 重命名本地分支： git branch -m devel develop 推送本地分支： git push origin develop 然而，在 github 上操作的时候，我在删除远程分支时碰到这个错误： git push --delete origin devel remote: error: refusing to delete the current branch: refs/heads/devel To git@github.com:zrong/quick-cocos2d-x.git ! [remote rejected] devel (deletion of the current branch prohibited) error: failed to push some refs to 'git@github.com:zrong/quick-cocos2d-x.git' 这是由于在 github 中，devel 是项目的默认分支。要解决此问题，这样操作： 进入 github 中该项目的 Settings 页面； 设置 Default Branch 为其他的分支（例如 master）； 重新执行删除远程分支命令。 1.5. 5. 把本地 tag 推送到远程 git push --tags 1.6. 6. 获取远程 tag git fetch origin tag 1.7. git tag — 标签相关操作 常见操作： git log # 查看最新 commit git tag -a v1.1.0 9fbc3d0 -m 'some comment' git push origin master --tags git tag # Show local tags git tag -d v1.1.0 # delete local tag git push origin --delete tag v1.1.0 # delete remote 1.7.1. 列出标签 git tag # 在控制台打印出当前仓库的所有标签 git tag -l 'v0.1.*' # 搜索符合模式的标签 1.7.2. 打标签 git 标签分为两种类型：轻量标签和附注标签。轻量标签是指向提交对象的引用，附注标签则是仓库中的一个独立对象。建议使用附注标签。 git tag v0.1.2-light # 创建轻量标签 git tag -a v0.1.2 -m '0.1.2版本' # 创建附注标签 创建轻量标签不需要传递参数，直接指定标签名称即可。创建附注标签时，参数 a 即 annotated 的缩写，指定标签类型，后附标签名。参数 m 指定标签说明，说明信息会保存在标签对象中。 1.7.3. 切换到标签 与切换分支命令相同，用git checkout [tagname] 查看标签信息，用git show命令可以查看标签的版本信息： git show v0.1.2 1.7.4. 删除标签 误打或需要修改标签时，需要先将标签删除，再打新标签。 git tag -d v0.1.2 # 删除标签 参数 d 即 delete 的缩写，意为删除其后指定的标签。 1.7.5. 给指定的 commit 打标签 打标签不必要在 head 之上，也可在之前的版本上打，这需要你知道某个提交对象的校验和（通过git log获取）。 git log git tag -a v0.1.1 9fbc3d0 -m 'some comment' 1.7.6. 标签发布 通常的git push不会将标签对象提交到 git 服务器，我们需要进行显式的操作： git push origin v0.1.2 # 将v0.1.2标签提交到git服务器 git push origin master --tags # 将本地所有标签一次性提交到git服务器 注意：如果想看之前某个标签状态下的文件，可以这样操作 git tag # 查看当前分支下的标签 git checkout v0.21 # 此时会指向打v0.21标签时的代码状态，（但现在处于一个空的分支上） cat test.txt # 查看某个文件 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Git/ignore_files_locally.html": {
    "url": "Git/ignore_files_locally.html",
    "title": "ignore_files_locally",
    "keywords": "",
    "body": "1. Git ignore files locally1. Git ignore files locally known 2 ways: .gitignore or .git/info/exclude not to manage files with Git. There are times when you want to ignore files that are already managed with Git locally. # when some files you don't want to submit to git server, e.g. angular proxy.js since proxy url is shifting heavily during development git update-index --skip-worktree path/to/file git update-index --no-skip-worktree path/to/file # assume never changed by developers, and to speed up git behavior by ignoring unnecessary files. e.g. node_modules. of course it's usually in .gitignore git update-index --assume-unchanged path/to/file git update-index --no-assume-unchanged path/to/file Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Git/todo.html": {
    "url": "Git/todo.html",
    "title": "todo",
    "keywords": "",
    "body": " git 教程简明 git 教程 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "HighChart/": {
    "url": "HighChart/",
    "title": "HighChart",
    "keywords": "",
    "body": "1. TOC1. TOC highChart_config highChart_demo highChart_draggable Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "HighChart/highChart_config.html": {
    "url": "HighChart/highChart_config.html",
    "title": "highChart_config",
    "keywords": "",
    "body": "1. HighChart config1. HighChart config export const config = { title: '', legend: { enabled: false, }, colors: [ // '#7373FF', // push it to first when needing to display myProduct: purple(myproduct) '#ffd669', // yellow '#F5896C', // red '#72C284', // green '#f15c80', '#e4d354', '#8d4653', '#91e8e1', ], chart: { height: 260, width: 600, style: { fontFamily: '.PingFang SC', color: '#d8d9d8', }, }, yAxis: { allowDecimals: false, title: { text: '', }, min: 0, max: 5, tickInterval: 1, // gridLineDashStyle: 'longdash', // minorGridLineColor: '#f5f5f5', // gridLineWidth: 2, gridLineColor: '#f5f5f5', labels: { style: { color: '#a6a6a6', }, }, }, credits: { enabled: false, }, animation: false, plotOptions: { series: { point: { events: { // drag: function(e) { // // Returning false stops the drag and drops. Example: // if (e.y > 100) { // this.y = 100 // return false // } // }, // drop: function(e) { // console.log(e) // console.log(this) // // 更新用户数据到state // } }, pointWidth: 18, //stacking: 'percent', dataLabels: { enabled: true, inside: true, align: 'right', color: '#fff', }, }, // stickyTracking: false }, spline: { marker: { radius: 6, lineColor: '#666666', lineWidth: 1, }, }, line: { cursor: 'ns-resize', }, }, tooltip: { yDecimals: 2, }, }; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "HighChart/highChart_demo.html": {
    "url": "HighChart/highChart_demo.html",
    "title": "highChart_demo",
    "keywords": "",
    "body": "1. HighChart Demo1. HighChart Demo import React, { Component } from 'react'; import PropTypes from 'prop-types'; import uid from 'uid'; import { config } from '../chartConfig'; import Chart from '../../common/chart/Chart.jsx'; import highChartsDragabled from 'highcharts-draggable-points'; import { MY_PRODUCT_ID, MY_PRODUCT_COLOR } from '../const'; import update from 'immutability-helper'; class ChanpinjiazhilianJiazhiquxian extends Component { constructor(props) { super(props); } render() { const { products } = this.props; const colors = config.colors; // const products = [ // { // id: MY_PRODUCT_ID, // name: MY_PRODUCT_NAME, // analysis: [ // { id: 1, key: 'time', value: 5, category: 'delete' }, // { id: 2, key: 'space', value: 4, category: 'creativity' }, // { id: 3, key: 'cost', value: 2, category: 'add' } // ] // }, // { // id: '34dsaffda', // name: 'iphone 5', // analysis: [ // { id: 1, key: 'time', value: 5, category: 'delete' }, // { id: 2, key: 'space', value: 4, category: 'creativity' }, // { id: 3, key: 'cost', value: 2, category: 'add' } // ] // }, // { // id: 'dfasfdfsa', // name: 'huawei mate', // analysis: [ // { id: 1, key: 'time', value: 5, category: 'delete' }, // { id: 2, key: 'space', value: 4, category: 'creativity' }, // { id: 3, key: 'cost', value: 2, category: 'add' } // ] // } // ] const keys = products[0].analysis.map((p) => p.key); const chartData = { xAxis: { categories: keys, lineColor: '#f5f5f5', // lineWidth: 3, tickWidth: 0, // gridLineColor: '#197F07', // gridLineWidth: 3, // minorGridLineColor: '#f5f5f5', labels: { style: { color: '#a6a6a6', }, }, plotBands: [ // { // color: 'orange', // Color value // from: 0.97, // Start of the plot band // to: 1.03 // End of the plot band // } ], }, series: [], }; products.forEach((product, i) => { const values = product.analysis.map((a, index) => { chartData.xAxis.plotBands.push({ color: '#fcfcfc', // Color value from: index - 0.03, // Start of the plot band to: index + 0.03, // End of the plot band }); return { analysisId: a.analysisId, yaosu: a.key, y: a.value, productId: product.id, productName: product.name, }; }); let seriesSettings = { name: product.name, data: values, type: 'line', // draggableX: true, draggableY: true, dragMaxY: 5, dragMinY: 0, minPointLength: 1, lineWidth: 1, marker: { enabled: true, symbol: 'circle', radius: 6, }, }; if (product.id === MY_PRODUCT_ID) { seriesSettings.dashStyle = 'Solid'; } else { seriesSettings.dashStyle = 'longdash'; } chartData.series.push(seriesSettings); }); config.colors[myProductIndex] = MY_PRODUCT_COLOR; const chartConfig = { ...config, ...chartData, }; let chartChangeset = []; config.chart.width = 800; config.plotOptions.series.point.events = { drag: function(e) { const { productId } = this; if (productId !== MY_PRODUCT_ID) return false; // 禁用非 我的产品拖动 // Returning false stops the drag and drops if (e.y > 5) { this.y = 5; return false; } }, drop: function() { this.y = Math.round(this.y); // this.update(this.y) const { productId, analysisId, y } = this; chartChangeset.push({ productId, analysisId, y }); }, }; const buildUpdateOperation = (source, operationArr) => { let result = {}; // source: copy products // operationArr: [ { id: '111', analysisId: 1, value: 99 }, { id: '111', analysisId: 3, value: 99 }, { id: '222', analysisId: 3, value: 99 } ] operationArr.forEach((c) => { const targetIndex = source.findIndex((x) => x.id === c.productId); const target = source.find((x) => x.id === c.productId); const targetAnalysisIndex = target.analysis.findIndex((x) => x.analysisId === c.analysisId); const targetAnalysis = target.analysis.find((x) => x.analysisId === c.analysisId); if (result[targetIndex]) { result[targetIndex].analysis[targetAnalysisIndex] = { $merge: { value: c.y } }; } else { result[targetIndex] = { analysis: { [targetAnalysisIndex]: { $merge: { value: c.y } }, }, }; } }); /** * { * 1: { * analysis: { * 0: { $merge: { value: 99 }}, * 2: { $merge: { value: 99 }} * } * }, * 2: { * analysis: { * 2: { $merge: { value: 99 }} * } * } * } */ return result; }; const saveData = (step) => { const operation = buildUpdateOperation(products, chartChangeset); var result = update(products, operation); saveAnliFun(result, () => { setCurrentStep.call(this, step + 1); }); }; return ( {products.map((p, index) => ( {p.name} ))} ); } } export default ChanpinjiazhilianJiazhiquxian; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "HighChart/highChart_draggable.html": {
    "url": "HighChart/highChart_draggable.html",
    "title": "highChart_draggable",
    "keywords": "",
    "body": "1. HighChart Draggable1. HighChart Draggable // // // var chart = new Highcharts.Chart({ chart: { renderTo: 'container', animation: false, }, title: { text: 'Highcharts draggable points demo', }, xAxis: { categories: [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', ], }, yAxis: { allowDecimals: false, title: { text: '', }, min: 0, max: 5, tickInterval: 1, gridLineColor: '#f5f5f5', labels: { style: { color: '#a6a6a6', }, }, }, plotOptions: { series: { point: { events: { drag: function(e) { // Returning false stops the drag and drops. Example: /* if (e.newY > 300) { this.y = 300; return false; } */ e.y = Math.round(e.y); $('#drag').html( 'Dragging ' + this.series.name + ', ' + this.category + ' to ' + Highcharts.numberFormat(e.y, 2) + '', ); }, drop: function(e) { // this.update(Math.round(this.y)); this.update(Math.round(e.y)); $('#drop').html( 'In ' + this.series.name + ', ' + this.category + ' was set to ' + Highcharts.numberFormat(this.y, 2) + '', ); }, }, }, stickyTracking: false, }, column: { stacking: 'normal', }, line: { cursor: 'ns-resize', }, }, tooltip: { yDecimals: 2, }, series: [ { data: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], draggableY: true, dragMinY: 0, dragMaxY: 5, minPointLength: 1, }, ], }); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "HTML/": {
    "url": "HTML/",
    "title": "HTML",
    "keywords": "",
    "body": "1. TOC1. TOC canvas code_meta code_navigator_geolocation h5_drag h5_fileReader interview_template interview_WebComponent interview_自定义元素 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "HTML/canvas.html": {
    "url": "HTML/canvas.html",
    "title": "canvas",
    "keywords": "",
    "body": "1. canvas 库1. canvas 库 easelJs: http://createjs.com/getting-started/easeljs paper.js: https://github.com/paperjs/paper.js fabrics: http://fabricjs.com/ Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "HTML/code_meta.html": {
    "url": "HTML/code_meta.html",
    "title": "code_meta",
    "keywords": "",
    "body": "1. meta1. meta 注意 DNS 预解析 meta 参考资料 参考资料 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "HTML/code_navigator_geolocation.html": {
    "url": "HTML/code_navigator_geolocation.html",
    "title": "code_navigator_geolocation",
    "keywords": "",
    "body": "1. H5 地址信息位置1. H5 地址信息位置 if ('geolocation' in navigator) { navigator.geolocation.getCurrentPosition(function(position) { console.log(position); }); } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "HTML/h5_drag.html": {
    "url": "HTML/h5_drag.html",
    "title": "h5_drag",
    "keywords": "",
    "body": "1. Drag and Drop 拖拽1.1. 实现拖放的步骤1.1.1. 创建一个可拖拽对象1.1.2. 放置对象1.1.3. dragenter 事件，用来确定放置目标是否接受放置。1.1.4. dragover 事件，用来确定给用户显示怎样的反馈信息。1.1.5. 最后是 drop 事件，允许放置对象。1.1.6. 例子：1.2. 拖放的相关事件1.3. DataTransfer 对象的属性与方法1.3.1. DataTransfer 对象的属性1.4. draggable 属性兼容性1. Drag and Drop 拖拽 在 HTML5 之前，如果要实现拖放效果，一般会使用 mousedown、mousemove 和 mouseup 三个事件进行组合来模拟出拖拽效果，比较麻烦。而 HTML5 规范实现了原生拖放功能，使得元素拖放的实现更加方便和高效。 默认情况下，图像、链接和文本是可以拖动的。文本只有在被选中的情况下才能拖动，而图像和链接在任何时候都可以拖动。 HTML5 为所有的 HTML 元素规定了一个 draggable 属性，表示元素是否允许拖动。要想让其他元素也能被拖动，可以设置这个属性为 true。 A. 被拖动的源对象可以触发的事件 ondragstart：源对象开始被拖动 ondrag：源对象被拖动过程中(鼠标可能在移动也可能未移动) ondragend：源对象被拖动结束 B. 拖动源对象可以进入到上方的目标对象可以触发的事件： ondragenter：目标对象被源对象拖动着进入 ondragover：目标对象被源对象拖动着悬停在上方 ondragleave：源对象拖动着离开了目标对象 ondrop：源对象拖动着在目标对象上方释放/松手 C. 如何在拖动的源对象事件和目标对象事件间传递数据: 数据传递对象, 用于在源对象和目标对象的事件间传递数据: e.dataTransfer 源对象上的事件处理中保存数据：e.dataTransfer.setData(k, v); k-v 必须都是 string 类型 目标对象上的事件处理中读取数据：var v = e.dataTransfer.getData(k); 1.1. 实现拖放的步骤 1.1.1. 创建一个可拖拽对象 如果想要拖动某个元素，需要设置元素的 draggable 属性为 true。 给 dragstart 设置一个事件监听器存储拖拽数据。 document.getElementById('dragImg').addEventListener( 'dragstart', function(event) { // 存储拖拽数据和拖拽效果... event.dataTransfer.setData('Text', ev.target.id); }, false, ); 1.1.2. 放置对象 假设放置对象的 DOM 为： 1.1.3. dragenter 事件，用来确定放置目标是否接受放置。 如果放置被接受，那么这个事件必须取消。 document.getElementById('dragTarget').addEventListener( 'dragenter', function(event) { // 阻止浏览器默认事件 event.preventDefault(); }, false, ); 1.1.4. dragover 事件，用来确定给用户显示怎样的反馈信息。 如果这个事件被取消，反馈信息（通常就是光标）就会基于 dropEffect 属性的值更新。 document.getElementById('dragTarget').addEventListener( 'dragover', function(event) { // 阻止浏览器默认事件. ondragover 有一个默认行为！！！那就是当ondragover 触发时，ondrop 会失效！！！ event.preventDefault(); }, false, ); 1.1.5. 最后是 drop 事件，允许放置对象。 document.getElementById('dragTarget').addEventListener( 'drop', function(event) { event.preventDefault(); var data = event.dataTransfer.getData('Text'); event.target.appendChild(document.getElementById(data)); }, false, ); 1.1.6. 例子： 转载自：http://www.w3school.com.cn/tiy/t.asp?f=html5_draganddrop #dragTarget { width: 488px; height: 70px; padding: 10px; border: 1px solid #aaaaaa; } function allowDrop(ev) { ev.preventDefault(); } function drag(ev) { ev.dataTransfer.setData(\"Text\", ev.target.id); } function drop(ev) { ev.preventDefault(); var data = ev.dataTransfer.getData(\"Text\"); ev.target.appendChild(document.getElementById(data)); } 请把 W3School 的图片拖放到矩形中： 1.2. 拖放的相关事件 事件 产生事件的元素 描述 dragstart 被拖放的元素 开始拖放操作 drag 被拖放的元素 拖放过程中 dragenter 拖放过程中鼠标经过的元素 被拖放元素开始进入本元素的范围内 dragover 拖放过程中鼠标经过的元素 被拖放元素正在本元素范围内移动 dragleave 拖放过程中鼠标经过的元素 被拖放元素离开本元素的范围 drop 拖放的目标元素 有其他元素被拖放到本元素中 dragend 拖放的对象元素 拖放操作结束 1.3. DataTransfer 对象的属性与方法 1.3.1. DataTransfer 对象的属性 属性 描述 dropEffect 表示拖放操作的视觉效果，允许对其进行值的设定。该效果必须在用 effectAllowed 属性指定的允许的视觉效果范围内，允许指定的值有：none、copy、link、move。 effectAllowed 用来指定当元素被拖放时所允许的视觉效果。可以指定的值有：none、copy、copyLink、copyMove、link、linkMove、all、uninitialize。 files 返回表示被拖拽文件的 FileList。 types 存入数据的 MIME 类型。如果任意文件被拖拽，那么其中一个类型将会是字符串”Files”。 方法 描述 void setData(DOMString format, DOMString data) 向 DataTransfer 对象存入数据。 DOMString getData(DOMString data) 读取 DataTransfer 对象中的数据。 void clearData(DOMString format) 清除 DataTransfer 对象中的数据。如果省略参数 format，则清除全部数据。 void setDragImage(Element image, long x, long y) 用 img 元素来设置拖放图标。 1.4. draggable 属性兼容性 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "HTML/h5_fileReader.html": {
    "url": "HTML/h5_fileReader.html",
    "title": "h5_fileReader",
    "keywords": "",
    "body": "1. HTML5 新增的文件操作对象1. HTML5 新增的文件操作对象 File: 代表一个文件对象 FileList: 代表一个文件列表对象，类数组 FileReader: 用于从文件中读取数据 FileWriter: 用于向文件中写出数据 从电脑托一张图片到网页目标区域，显示该图片。类似于上传头像的一种方式。 #container { border: 1px solid #aaa; border-radius: 3px; padding: 10px; margin: 10px; min-height: 400px; } 拖放API的扩展知识 请拖动您的照片到下方方框区域 //监听 document 的 drop 事件——取消其默认行为：在新窗口中打开图片 document.ondragover = function(e){ e.preventDefault(); //使得drop事件可以触发 } document.ondrop = function(e){ e.preventDefault(); //阻止在新窗口中打开图片，否则仍然会执行下载操作！！！ } //监听 div#container 的 drop 事件，设法读取到释放的图片数据，显示出来 container.ondragover = function(e){ e.preventDefault(); } container.ondrop = function(e){ console.log('客户端拖动着一张图片释放了...') //当前的目标对象读取拖放源对象存储的数据 //console.log(e.dataTransfer); //显示有问题 //console.log(e.dataTransfer.files.length); //拖进来的图片的数量 var f0 = e.dataTransfer.files[0]; //文件对象 File //从文件对象中读取数据 var fr = new FileReader(); //fr.readAsText(f0); //从文件中读取文本字符串 fr.readAsDataURL(f0); //从文件中读取URL数据 fr.onload = function(){ console.log('读取文件完成') console.log(fr.result); var img = new Image(); img.src = fr.result; //URL数据 container.appendChild(img); } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "HTML/interview_template.html": {
    "url": "HTML/interview_template.html",
    "title": "interview_template",
    "keywords": "",
    "body": "1. Html template1. Html template 默认隐层的，html parser 会解析检查他的 content 是否合法，并不会渲染他。template 有 content 属性。var clonedNode = document.importNode(templateDOM.content, true) 得到 clone 节点，再 appendChild 到相应父级中。 element is a mechanism for holding client-side content that is not to be rendered when a page is loaded but may subsequently be instantiated during runtime using JavaScript. Think of a template as a content fragment that is being stored for subsequent use in the document. While the parser does process the contents of the element while loading the page, it does so only to ensure that those contents are valid; the element's contents are not rendered, however. UPC_Code Product_Name // Test to see if the browser supports the HTML template element by checking // for the presence of the template element's content attribute. if ('content' in document.createElement('template')) { // Instantiate the table with the existing HTML tbody // and the row with the template var t = document.querySelector('#productRow'), td = t.content.querySelectorAll('td'); td[0].textContent = '1235646565'; td[1].textContent = 'Stuff'; // Clone the new row and insert it into the table var tb = document.querySelector('tbody'); var clone = document.importNode(t.content, true); tb.appendChild(clone); // Create a new row td[0].textContent = '0384928528'; td[1].textContent = 'Acme Kidney Beans'; // Clone the new row and insert it into the table var clone2 = document.importNode(t.content, true); tb.appendChild(clone2); } else { // Find another way to add the rows to the table because // the HTML template element is not supported. } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "HTML/interview_WebComponent.html": {
    "url": "HTML/interview_WebComponent.html",
    "title": "interview_WebComponent",
    "keywords": "",
    "body": "1. Web Components, Shadow DOM, template1.1. Web components1.2. Image Slider example1.2.1. Shadow DOM1.2.2. Templates1.2.3. Shadow DOM1.2.4. Shadowy Sliders1.2.5. Insertion Points by content1.2.6. Custom Elements1.2.7. Polymer1.2.8. SEO1.2.9. Accessibility1.2.10. Style tags? Um, no thanks.1. Web Components, Shadow DOM, template 1.1. Web components bundle markup and styles into custom HTML elements. They fully encapsulate all of their HTML and CSS. That means the styles that you write always render as you intended, and your HTML is safe from the prying eyes of external JavaScript. 1.2. Image Slider example Think about how you currently implement an image slider, it might look something like this: We want it to be something like: 1.2.1. Shadow DOM Think of tag: 为什么写个 video 就能能看到 开始、音量调节 等按钮？他们存放在 shadow dom 中 There's a play button, a scrubber, timecodes and a volume slider. Lots of stuff that you didn't have to write any markup for, it just appeared when you asked for . But what you're actually seeing is an illusion. The browser makers needed a way to guarantee that the tags they implemented would always render the same, regardless of any wacky HTML, CSS or JavaScript we might already have on the page. To do this, they created a secret passageway where they could hide their code and keep it out of our hot little hands. They called this secret place: the Shadow DOM. Use Chrome Developer Tools and enable the Show user agent shadow DOM flag. That'll let you inspect the element in more detail. Inside you'll find that there's a ton of HTML all hidden away. So how to use our custom tag like ? 1.2.2. Templates Hello there! This content is top secret :) Everything inside a template is considered inert by the browser. This means tags with external sources — , , , etc. — do not make http requests and tags do not execute. It also means that nothing from within the template is rendered on the page until we activate it using JavaScript. So the first step in creating our is to put all of its HTML and CSS into a . Once we've done this, we're ready to move it into the shadow DOM. 1.2.3. Shadow DOM To create shadow DOM, select an element and call its createShadowRoot method. This will return a document fragment which you can then fill with content. var host = document.querySelector('.container'); var root = host.createShadowRoot(); root.innerHTML = 'How you doing?' Shadow Host In shadow DOM parlance, the element that you call createShadowRoot on is known as the Shadow Host. It's the only piece visible to the user, and it's where you would ask the user to supply your element with content. If you think about our tag from before, the element itself is the shadow host, and the contents are the tags you nest inside of it. Shadow Root The document fragment returned by createShadowRoot is known as the Shadow Root. The shadow root, and its descendants, are hidden from the user, but they're what the browser will actually render when it sees our tag. In the example, the play button, scrubber, timecode, etc. are all descendants of the shadow root. They show up on the screen but their markup is not visible to the user. Shadow Boundary Any HTML and CSS inside of the shadow root is protected from the parent document by an invisible barrier called the Shadow Boundary. The shadow boundary prevents CSS in the parent document from bleeding into the shadow DOM, and it also prevents external JavaScript from traversing into the shadow root. Translation: Let's say you have a style tag in the shadow DOM that specifies all h3's should have a color of red. Meanwhile, in the parent document, you have a style that specifies h3's should have a color of blue. In this instance, h3's appearing within the shadow DOM will be red, and h3's outside of the shadow DOM will be blue. The two styles will happily ignore each other thanks to our friend, the shadow boundary. And if, at some point, the parent document goes looking for h3's with $('h3'), the shadow boundary will prevent any exploration into the shadow root and the selection will only return h3's that are external to the shadow DOM. 1.2.4. Shadowy Sliders To get our img-slider into the shadow DOM we'll need to create a shadow host and populate it with the contents of our template. * { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; box-sizing: border-box; } #slider { max-width: 600px; text-align: center; margin: 0 auto; } #overflow { width: 100%; overflow: hidden; } #slides .inner { width: 400%; } #slides .inner { -webkit-transform: translateZ(0); -moz-transform: translateZ(0); -o-transform: translateZ(0); -ms-transform: translateZ(0); transform: translateZ(0); -webkit-transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); -moz-transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); -o-transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); -ms-transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); -webkit-transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); -moz-transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); -o-transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); -ms-transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); } #slides img { width: 25%; float: left; } #slide1:checked ~ #slides .inner { margin-left: 0; } #slide2:checked ~ #slides .inner { margin-left: -100%; } #slide3:checked ~ #slides .inner { margin-left: -200%; } #slide4:checked ~ #slides .inner { margin-left: -300%; } input[type=\"radio\"] { display: none; } label { background: #CCC; display: inline-block; cursor: pointer; width: 10px; height: 10px; border-radius: 5px; } #slide1:checked ~ label[for=\"slide1\"], #slide2:checked ~ label[for=\"slide2\"], #slide3:checked ~ label[for=\"slide3\"], #slide4:checked ~ label[for=\"slide4\"] { background: #333; } // Add the template to the Shadow DOM var tmpl = document.querySelector('template'); var host = document.querySelector('.img-slider'); var root = host.createShadowRoot(); root.appendChild(document.importNode(tmpl.content, true)); In this instance we've created a div and given it the class img-slider so it can act as our shadow host. We select the template and do a deep copy of its internals with document.importNode. These internals are then appended to our newly created shadow root. 1.2.5. Insertion Points by content At this point our img-slider is inside the shadow DOM but the image paths are hard coded. Just like the tags nested inside of , we'd like the images to come from the user, so we'll have to invite them over from the shadow host. To pull items into the shadow DOM we use the new tag. The tag uses CSS selectors to cherry-pick elements from the shadow host and project them into the shadow DOM. These projections are known as insertion points. We'll make it easy on ourselves and assume that the slider only contains images, that way we can create an insertion point using the img selector. ... Because we are projecting content into the Shadow DOM using an insertion point, we'll also need to use the new ::content pseudo-element to update our CSS. #slides ::content img { width: 25%; float: left; } If you want to know more about the new CSS selectors and combinators added by Shadow DOM, take a look at this cheat sheet I threw together. Now we're ready to populate our img-slider. final html: * { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; box-sizing: border-box; } #slider { max-width: 600px; text-align: center; margin: 0 auto; } #overflow { width: 100%; overflow: hidden; } #slides .inner { width: 400%; } #slides .inner { -webkit-transform: translateZ(0); -moz-transform: translateZ(0); -o-transform: translateZ(0); -ms-transform: translateZ(0); transform: translateZ(0); -webkit-transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); -moz-transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); -o-transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); -ms-transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); -webkit-transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); -moz-transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); -o-transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); -ms-transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); } #slides ::content img { width: 25%; float: left; } #slide1:checked ~ #slides .inner { margin-left: 0; } #slide2:checked ~ #slides .inner { margin-left: -100%; } #slide3:checked ~ #slides .inner { margin-left: -200%; } #slide4:checked ~ #slides .inner { margin-left: -300%; } input[type=\"radio\"] { display: none; } label { background: #CCC; display: inline-block; cursor: pointer; width: 10px; height: 10px; border-radius: 5px; } #slide1:checked ~ label[for=\"slide1\"], #slide2:checked ~ label[for=\"slide2\"], #slide3:checked ~ label[for=\"slide3\"], #slide4:checked ~ label[for=\"slide4\"] { background: #333; } // Polyfill support HTMLElement.prototype.createShadowRoot = HTMLElement.prototype.createShadowRoot || HTMLElement.prototype.webkitCreateShadowRoot || function() {}; // Add the template to the Shadow DOM var tmpl = document.querySelector('template'); var host = document.querySelector('.img-slider'); var root = host.createShadowRoot(); root.appendChild(document.importNode(tmpl.content, true)); Next, we can turn this img-slider div into its own tag. 1.2.6. Custom Elements A Custom Element two requirements: name must contain a dash prototype must extend HTMLElement // Grab our template full of slider markup and styles var tmpl = document.querySelector('template'); // Create a prototype for a new element that extends HTMLElement var ImgSliderProto = Object.create(HTMLElement.prototype); // Setup our Shadow DOM and clone the template ImgSliderProto.createdCallback = function() { var root = this.createShadowRoot(); root.appendChild(document.importNode(tmpl.content, true)); }; // Register our new element var ImgSlider = document.registerElement('img-slider', { prototype: ImgSliderProto }); The Object.create method returns a new prototype which extends HTMLElement. When the parser finds our tag in the document it will check to see if it has a method named createdCallback. If it finds this method it will run it immediately. This is a good place to do setup work, so we create some Shadow DOM and clone our template into it. We pass the tag name and prototype to a new method on the document, called registerElement, and after that we're ready to go. Now that our element is registered there are a few different ways to use it. The first, and most straightforward, is to just use the tag somewhere in our HTML. But we can also call document.createElement(\"img-slider\") or we can use the constructor that was returned by document.registerElement and stored in the ImgSlider variable. It's up to you which style you prefer. Final: * { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; box-sizing: border-box; } #slider { max-width: 600px; text-align: center; margin: 0 auto; } #overflow { width: 100%; overflow: hidden; } #slides .inner { width: 400%; } #slides .inner { -webkit-transform: translateZ(0); -moz-transform: translateZ(0); -o-transform: translateZ(0); -ms-transform: translateZ(0); transform: translateZ(0); -webkit-transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); -moz-transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); -o-transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); -ms-transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); transition: all 800ms cubic-bezier(0.770, 0.000, 0.175, 1.000); -webkit-transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); -moz-transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); -o-transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); -ms-transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); transition-timing-function: cubic-bezier(0.770, 0.000, 0.175, 1.000); } #slides ::content img { width: 25%; float: left; } #slide1:checked ~ #slides .inner { margin-left: 0; } #slide2:checked ~ #slides .inner { margin-left: -100%; } #slide3:checked ~ #slides .inner { margin-left: -200%; } #slide4:checked ~ #slides .inner { margin-left: -300%; } input[type=\"radio\"] { display: none; } label { background: #CCC; display: inline-block; cursor: pointer; width: 10px; height: 10px; border-radius: 5px; } #slide1:checked ~ label[for=\"slide1\"], #slide2:checked ~ label[for=\"slide2\"], #slide3:checked ~ label[for=\"slide3\"], #slide4:checked ~ label[for=\"slide4\"] { background: #333; } // Polyfill support HTMLElement.prototype.createShadowRoot = HTMLElement.prototype.createShadowRoot || HTMLElement.prototype.webkitCreateShadowRoot || function() {}; // Grab our template full of slider markup and styles var tmpl = document.querySelector('template'); // Create a prototype for a new element that extends HTMLElement var ImgSliderProto = Object.create(HTMLElement.prototype); // Setup our Shadow DOM and clone the template ImgSliderProto.createdCallback = function() { var root = this.createShadowRoot(); root.appendChild(document.importNode(tmpl.content, true)); }; // Register our new element var ImgSlider = document.registerElement('img-slider', { prototype: ImgSliderProto, }); 1.2.7. Polymer Let's look at how we could rewrite our img-slider using Google's Web Component library, Polymer. Polymer adds a new tag to the browser, , which automagically turns templates into shadow DOM and registers custom elements for us. All we need to do is to tell Polymer what name to use for the tag and to make sure we include our template markup. I find it's often easier to create elements using Polymer because of all the niceties built into the library. This includes two-way binding between elements and models, automatic node finding and support for other new standards like Web Animations. Also, the developers on the polymer-dev mailing list are extremely active and helpful, which is great when you're first learning the ropes, and the StackOverflow community is growing. This is just a tiny example of what Polymer can do, so be sure to visit its project page and also checkout Mozilla's alternative, X-Tag. 1.2.8. SEO At this moment it's unclear how well crawlers support Custom Elements and Shadow DOM. The Polymer FAQ states: Search engines have been dealing with heavy AJAX based application for some time now. Moving away from JS and being more declarative is a good thing and will generally make things better. The Google Webmaster's blog recently announced that the Google crawler will execute JavaScript on your page before indexing it. And using a tool like Fetch as Google will allow you to see what the crawler sees as it parses your site. A good example is the Polymer website, which is built with custom elements and is easily searched in Google. One tip I've learned from speaking with members of the Polymer team is to try to make sure the content inside of your custom element is static, and not coming from a data binding. Here is some interesting, and searchable content... {{crazyDynamicContent}} Click here To be fair, this isn't a new problem. AJAX heavy sites have been dealing with this issue for a few years now and thankfully there are solutions out there. 1.2.9. Accessibility Obviously when you're hiding markup in secret shadow DOM sandboxes the issue of accessibility becomes pretty important. Steve Faulkner took a look at accessibility in shadow DOM and seemed to be satisfied with what he found. Results from initial testing indicate that inclusion of ARIA roles, states and properties in content wholly inside the Shadow DOM works fine. The accessibility information is exposed correctly via the accessibility API. Screen readers can access content in the Shadow DOM without issue. The full post is available here. Marcy Sutton has also written a post exploring this topic in which she explains: Web Components, including Shadow DOM, are accessible because assistive technologies encounter pages as rendered, meaning the entire document is read as “one happy tree”. Marcy also points out that the img-slider I built in this post is not accessible because our css label trick makes it inaccessible from the keyboard. Keep that in mind if you're looking to reuse it in a project. Surely there will be bumps along the way but that sounds like a pretty great start! 1.2.10. Style tags? Um, no thanks. Unfortunately tags do not work inside of the Shadow DOM, which means the only way to pull in external CSS is through @import. In other words, tags are—for the moment—unavoidable. Keep in mind that the styles we're talking about are relevant only to a component, whereas we've previously been trained to favor external files because they often affect our entire application. So is it such a bad thing to put a tag inside of an element, if all of those styles are scoped just to that one entity? Personally I think it's OK, but the option of external files would be very nice to have. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "HTML/interview_自定义元素.html": {
    "url": "HTML/interview_自定义元素.html",
    "title": "interview_自定义元素",
    "keywords": "",
    "body": "1. HTML 自定义元素教程 custom elements1.1. 浏览器处理1.2. HTML Import1.3. Custom Elements 标准1. HTML 自定义元素教程 custom elements 组件是 Web 开发的方向，现在的热点是 JavaScript 组件，但是 HTML 组件未来可能更有希望。 1.1. 浏览器处理 我们一般都使用标准的 HTML 元素。 Hello World 上面代码中， 就是标准的 HTML 元素。 如果使用非标准的自定义元素，会有什么结果？ Hello World 上面代码中， 就是非标准元素，浏览器不认识它。这段代码的运行结果是，浏览器照常显示 Hello World，这说明浏览器并没有过滤这个元素。 现在，为自定义元素加上样式。 greeting { display: block; font-size: 36px; color: red; } 运行结果如下。 接着，使用脚本操作这个元素。 function customTag(tagName, fn) { Array.from(document.getElementsByTagName(tagName)).forEach(fn); } function greetingHandler(element) { element.innerHTML = '你好，世界'; } customTag('greeting', greetingHandler); 运行结果如下。 这说明，浏览器对待自定义元素，就像对待标准元素一样，只是没有默认的样式和行为。这种处理方式是写入 HTML5 标准 的。 \"User agents must treat elements and attributes that they do not understand as semantically neutral; leaving them in the DOM (for DOM processors), and styling them according to CSS (for CSS processors), but not inferring any meaning from them.\" 上面这段话的意思是，浏览器必须将自定义元素保留在 DOM 之中，但不会任何语义。除此之外，自定义元素与标准元素都一致。 事实上，浏览器提供了一个HTMLUnknownElement对象，所有自定义元素都是该对象的实例。 var tabs = document.createElement('tabs'); tabs instanceof HTMLUnknownElement; // true tabs instanceof HTMLElement; // true 上面代码中，tabs是一个自定义元素，同时继承了HTMLUnknownElement和HTMLElement接口。 1.2. HTML Import 有了自定义元素，就可以写出语义性非常好的 HTML 代码。 微博 微信 上面的代码，一眼就能看出语义。 如果将元素的样式与脚本，封装在一个 HTML 文件share-buttons.html之中，这个元素就可以复用了。 使用的时候，先引入share-buttons.html。 然后，就可以在网页中使用了。 Title ... ... HTML imports 的更多用法可以参考教程（1，2）。目前只有 Chrome 浏览器支持这个语法。 1.3. Custom Elements 标准 HTML5 标准规定了自定义元素是合法的。然后，W3C 就为自定义元素制定了一个单独的 Custom Elements 标准。 它与其他三个标准放在一起---- HTML Imports，HTML Template、Shadow DOM----统称为 Web Components 规范。目前，这个规范只有 Chrome 浏览器支持。 Custom Elements 标准对自定义元素的名字做了限制。 \"自定义元素的名字必须包含一个破折号（-）所以、和都是正确的名字，而和是不正确的。这样的限制使得 HTML 解析器可以分辨那些是标准元素，哪些是自定义元素。\" 注意，一旦名字之中使用了破折号，自定义元素就不是HTMLUnknownElement的实例了。 var xTabs = document.createElement('x-tabs'); xTabs instanceof HTMLUnknownElement; // false xTabs instanceof HTMLElement; // true Custom Elements 标准规定了，自定义元素的定义可以使用 ES6 的class语法。 // 定义一个 class MyElement extends HTMLElement {...} window.customElements.define('my-element', MyElement); 上面代码中，原生的window.customElements对象的define方法用来定义 Custom Element。该方法接受两个参数，第一个参数是自定义元素的名字，第二个参数是一个 ES6 的class。 这个class使用get和set方法定义 Custom Element 的某个属性。 class MyElement extends HTMLElement { get content() { return this.getAttribute('content'); } set content(val) { this.setAttribute('content', val); } } 有了这个定义，网页之中就可以插入了。 Hello 处理脚本如下。 function customTag(tagName, fn) { Array.from(document.getElementsByTagName(tagName)).forEach(fn); } function myElementHandler(element) { element.textConent = element.content; } customTag('my-element', myElementHandler); 运行结果如下。 ES6 Class 的一个好处是，可以很容易地写出继承类。 class MyNewElement extends MyElement { // ... } customElements.define('my-new-element', MyNewElement); 更多用法请参考谷歌的官方教程。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/": {
    "url": "Javascript/",
    "title": "Javascript",
    "keywords": "",
    "body": "1. TOC1. TOC gQuery inheritance 升级版 composition inheritance 继承 Naming_convention oop reduce throttle_debounce_immediate webworker XMLHttpRequest 前端知识目录 模版编译 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Javascript/ES6/": {
    "url": "Javascript/ES6/",
    "title": "Javascript/ES6",
    "keywords": "",
    "body": "1. TOC1. TOC const 地址不变 destructuring es6_getter_setter fetch forin_vs_forof promise proxying tail_call_optimization template_string_loop_json Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Javascript/ES6/const地址不变.html": {
    "url": "Javascript/ES6/const地址不变.html",
    "title": "const 地址不变",
    "keywords": "",
    "body": "1. javascript const 理解，如何冻结对象1.1. 完全冻结对象：包含冻结对象本身和对象属性1. javascript const 理解，如何冻结对象 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 const foo = {}; foo.prop = 123; foo.prop; // 123 foo = {}; // TypeError: \"foo\" is read-only 上面代码中，常量储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 1.1. 完全冻结对象：包含冻结对象本身和对象属性 const constantize = (obj) => { Object.freeze(obj); Object.keys(obj).forEach((value, index) => { if (typeof obj[value] === 'object') { constantize(obj[value]); } }); }; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/ES6/destructuring.html": {
    "url": "Javascript/ES6/destructuring.html",
    "title": "destructuring",
    "keywords": "",
    "body": "1. 对于 Set 结构， 也可以使用数组的解构赋值1.1. 只有 undefined 才能触发默认值1.1.1. 主要用途1. 对于 Set 结构， 也可以使用数组的解构赋值 let [a, b, c] = new Set(['a', 'b', 'c']); console.log(a); // \"a\" 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。 function* fibs() { var a = 0; var b = 1; while (true) { yield a; [a, b] = [b, a + b]; } } var [first, second, third, fourth, fifth, sixth] = fibs(); sixth; // 5 上面代码中， fibs 是一个Generator函数，原生具有Iterator接口。 解构赋值会依次从这个接口获取值。 1.1. 只有 undefined 才能触发默认值 [1, undefined, 3].map((x = 'yes') => x); // [ 1, 'yes', 3 ] 1.1.1. 主要用途 交换变量的值: [x, y] = [y, x]; 从函数返回多个值: 将它们放在数组或对象里返回 function example() { return [1, 2, 3]; } var [a, b, c] = example(); // 返回一个对象 function example() { return { foo: 1, bar: 2, }; } var { foo, bar } = example(); 函数参数的定义: 解构赋值可以方便地将一组参数与变量名对应起来。 // 参数是一组有次序的值 function f([x, y, z]) { ... } f([1, 2, 3]) // 参数是一组无次序的值 function f({x, y, z}) { ... } f({x:1, y:2, z:3}) 提取 JSON 数据 var jsonData = { id: 42, status: 'OK', data: [867, 5309], }; let { id, status, data: number } = jsonData; console.log(id, status, number); // 42, OK, [867, 5309] 函数参数的默认值 jQuery.ajax = function (url, { async = true, beforeSend = function () {}, cache = true, complete = function () {}, crossDomain = false, global = true, // ... more config }) { // ... do stuff }; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo'这样的语句。 遍历 Map 结构: 任何部署了Iterator接口的对象，都可以用for...of循环遍历。 var map = new Map(); map.set('first', 'hello'); map.set('second', 'world'); for (let [key, value] of map) { console.log(key + \" is \" + value); } // first is hello // second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 // 获取键名 for (let [key] of map) { // ... } // 获取键值 for (let [,value] of map) { // ... } 输入模块的指定方法: 加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。 const { SourceMapConsumer, SourceNode } = require('source-map'); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/ES6/es6_getter_setter.html": {
    "url": "Javascript/ES6/es6_getter_setter.html",
    "title": "es6_getter_setter",
    "keywords": "",
    "body": "1. ES2015 class getter setter1. ES2015 class getter setter class Rectangle { constructor(width, height) { this._width = width; this._height = height; } set width(width) { this._width = width; } get width() { return this._width; } set height(height) { this._height = height; } get height() { return this._height; } get area() { return this._width * this._height; } } var r = new Rectangle(50, 20); r.area === 1000; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/ES6/fetch.html": {
    "url": "Javascript/ES6/fetch.html",
    "title": "fetch",
    "keywords": "",
    "body": "1. Fetch API1.1. get request1.2. post request1.3. Main parts1. Fetch API Modern networking api built on promises a Living standard Available on window and worker 1.1. get request fetch(url) .then((res) => { if (res.ok) { return res; } throw new Error('error'); }) // .then(res => res.text()) // .then(res => res.json()) .then((res) => { console.log(res.type); // \"cors\" for (const [a, b] of res.headers.entries()) { console.log(`${a}: ${b}`); } return res; }) .then((res) => console.dir(res) || res) .catch(console.error); 1.2. post request const data = new FormData(); data.append('foo', 'bar'); data.append('name', 'derek'); fetch(url, { method: 'POST', body: data, }) .then((res) => { if (res.ok) { return res; } throw new Error('error'); }) .then((res) => res.json()) .then((res) => console.dir(res) || res) .catch(console.error); var p = fetch(url, { method: 'POST', body: data, }).then((res) => { if (res.ok) { return res; } throw new Error('error'); }); p .then((res) => res.clone()) .then((res) => res.blob()) .then((res) => console.log(res) || res); p .then((res) => res.clone()) .then((res) => res.json()) .then((res) => console.log(res.form) || res); 1.3. Main parts Request: Url Method Headers Body Context Referrer ReferrerPolicy Mode Credentials Redirect Integrity Cache Response: Url Headers Body Status StatusText Ok Type Redirected UseFinalUrl Headers: append() set() delete() get() getAll() has() entries() keys() values() Body: arrayBuffer() blob() text() Response.clone() Request.clone() json() formData() bodyUsed Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/ES6/forin_vs_forof.html": {
    "url": "Javascript/ES6/forin_vs_forof.html",
    "title": "forin_vs_forof",
    "keywords": "",
    "body": "1. Difference between for...of and for...in1. Difference between for...of and for...in The for...in loop will iterate over all enumerable properties of an object. Note that if someone added new properties to Array.prototype, they will also be iterated over by this loop. Therefore this method is \"not\" recommended. The for...of syntax is specific to collections, rather than all objects. It will iterate in this manner over the elements of any collection that has a [Symbol.iterator] property. The following example shows the difference between a for...of loop and a for...in loop. Object.prototype.objCustom = function() {}; Array.prototype.arrCustom = function() {}; let iterable = [3, 5, 7]; iterable.foo = 'hello'; for (let i in iterable) { if (iterable.hasOwnProperty(i)) { console.log(i); // logs 0, 1, 2, \"foo\" } // console.log(i); // logs 0, 1, 2, \"foo\", \"arrCustom\", \"objCustom\" } for (let i of iterable) { console.log(i); // logs 3, 5, 7 } Using for of: for(let v of ['dog', 'cat', 'hen']) { // Do something }); Another way of iterating over an array that was added with ECMAScript 5 is forEach(): ['dog', 'cat', 'hen'].forEach(function(currentValue, index, array) { // Do something with currentValue or array[index] }); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/ES6/promise.html": {
    "url": "Javascript/ES6/promise.html",
    "title": "promise",
    "keywords": "",
    "body": "1. Promise1.1. A real demo1.2. Promise 回调在 react 中的应用1.2.1. Promise 链1.2.2. Promise.all1.2.3. Promise.race1.2.4. demo1.3. reference1. Promise Promise visualization function example() { // do some work if (successful) { return result; } else { throw new Error('failed'); } } Promise constructor: new Promise(function (resolve, reject){ // do some work if (successful) { resolve(result); } else { reject(throw new Error('failed')); } }) If your promise only has resolve, below is the same: new Promise(function(resolve, reject) { resolve(someValue); }); Promise.resolve(someValue); 1.1. A real demo // sync navigator.geolocation.getCurrentPosition( function(position) { console.log(position.coords.latitude); }, function(err) { console.error(err.message); }, ); // promise creator function getCurrentPositionWithPromise() { return new Promise(function(resolve, reject) { navigator.geolocation.getCurrentPosition(resolve, reject); // navigator.geolocation.getCurrentPosition(function(position){ // resolve(position); // }, function(err){ // reject(err.message); // }) }); } // use promise creator getCurrentPositionWithPromise .then((res) => { console.log(res.coords.latitude); return res; }) .catch((err) => console.log(err.message)); async function main() { try { let p = await getCurrentPositionWithPromise(); console.info(p.coords.latitude); } catch (e) { console.error(e.message); } } main(); 1.2. Promise 回调在 react 中的应用 参见 React/SetStateAsync.md 在 react component 中经常需要执行一个函数去 setHigherLevelComponentState，而等到高层 component 状态更新完毕后去进行当前 component 的一些操作 高层 component： 通过 props 把该方法传给孩子 function setOutlines(obj, actionType) { let outlines = []; switch (actionType) { case 'add': outlines = [...this.state.outlines, obj]; break; case 'edit': outlines = this.state.outlines.map((i) => { if (i.id == obj.id) { return { ...i, ...obj }; } else { return i; } }); break; case 'delete': outlines = this.state.outlines.filter((item) => item.id != obj.id); break; default: break; } return new Promise((resolve, reject) => { this.setState({ outlines }, () => { resolve(); }); }); } 低层 component： 在提交表单更新了 outlines 数据后，会 re-render，此时滚动滚动条到最低端看到刚添加的数据 function submitAddForm() { this.props .setOutlines( { id: uid(), detail: this.addText.value, }, 'add', ) .then(() => { console.log(this.mainBox.scrollTop, this.listBox.scrollHeight); this.mainBox.scrollTop = this.listBox.scrollHeight || 0; }); this.closeModal(); } 1.2.1. Promise 链 function foo(result) { console.log(result); return result + result; } let promise = new Promise((resolve, reject) => { try { setTimeout(() => { resolve('hello'); }, 250); } catch (e) { reject(new Error('exception!')); } }); //手动链接 promise .then(foo) .then(foo) .then(foo); //控制台输出： hello // hellohello // hellohellohellohello //动态链接 var funcs = [foo, foo, foo]; funcs.forEach(function(func) { promise = promise.then(func); }); //精简后的动态链接 var funcs = [foo, foo, foo]; funcs.reduce(function(prev, current) { return prev.then(current); }, promise); // ----------------------- Promise 创建函数 -------------------------- let createPromise = (para) => new Promise((resolve, reject) => { setTimeout(function() { resolve(para); }, 250); }); //手动链接 createPromise('hello') .then(foo) .then(foo) .then(foo); //控制台输出： hello // hellohello // hellohellohellohello //动态链接 var funcs = [foo, foo, foo]; var temp = createPromise('hello'); funcs.forEach(function(func) { temp = temp.then(func); }); // 精简后的动态链接 var funcs = [foo, foo, foo]; funcs.reduce(function(prev, current) { return prev.then(current); }, createPromise('hello')); 1.2.2. Promise.all Promise.all([3, promise, foo]) .then((res) => console.log(res)) .catch((reject) => { console.log('err'); }); // [ 3, 'hello', [Function: foo] ] 1.2.3. Promise.race Promise.race([3, promise, foo]) .then((res) => console.log(res)) .catch((reject) => { console.log('err'); }); // 3 1.2.4. demo function msgAfterTimeout(msg, who, timeout) { return new Promise((resolve, reject) => { setTimeout(() => resolve(`${msg} Hello ${who}!`), timeout); }); } msgAfterTimeout('', 'Foo', 100) .then((msg) => msgAfterTimeout(msg, 'Bar', 200)) .then((msg) => { console.log(`done after 300ms:${msg}`); }); // done after 300ms: Hello Foo! Hello Bar! // ---Promise.all--- function fetchAsync(url, timeout, onData, onError) { // ... } let fetchPromised = (url, timeout) => { return new Promise((resolve, reject) => { fetchAsync(url, timeout, resolve, reject); }); }; Promise.all([ fetchPromised('http://backend/foo.txt', 500), fetchPromised('http://backend/bar.txt', 500), fetchPromised('http://backend/baz.txt', 500), ]).then( (data) => { let [foo, bar, baz] = data; console.log(`success: foo=${foo} bar=${bar} baz=${baz}`); }, (err) => { console.log(`error: ${err}`); }, ); 1.3. reference 手写一个 promise：https://github.com/panyifei/Front-end-learning/blob/master/框架以及规范/Promise.md Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/ES6/proxying.html": {
    "url": "Javascript/ES6/proxying.html",
    "title": "proxying",
    "keywords": "",
    "body": "1. Proxying1. Proxying // Meta-Programming // Hooking into runtime-level object meta-operations. let target = { foo: 'Welcome, foo', }; let proxy = new Proxy(target, { get(receiver, name) { return name in receiver ? receiver[name] : `Hello, ${name}`; }, }); proxy.foo === 'Welcome, foo'; // true proxy.world === 'Hello, world'; // true Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/ES6/tail_call_optimization.html": {
    "url": "Javascript/ES6/tail_call_optimization.html",
    "title": "tail_call_optimization",
    "keywords": "",
    "body": "1. 尾调优化 Tail call optimization (TCO)1.1. 尾递归1.1.1. 两个案例1.1.2. 编译器是怎样优化尾递归的1.2. 尾调用1. 尾调优化 Tail call optimization (TCO) 1.1. 尾递归 使用一个 accumulator 参数来保存之前的计算的结果。这样计算到 N 的时候，之前栈计算的内容，都是可以抛弃不用保存的。这就解决一个递归很重要的问题，即栈溢出。在尾递归中，之前计算的结果都已经积累并以参数的形式交给下一次操作了，之前的函数留存在栈上的数据都可以清空。 尾递归使递归在调用堆栈上不会产生堆积 。 缺点: 将思路转换为循环的思路导致可读性的下降，而可读性是传统递归最大的优点。 1.1.1. 两个案例 传统递归： // This is just a short reminder of this great explanation: // http://www.2ality.com/2015/06/tail-call-optimization.html // not TCO function factorial(n) { if (n factorial(6) 6 * factorial(5) 5 * factorial (4) 4 * factorial(3) 3 * factorial(2) 2 * factorial(1) 1 * factorial(0) 1 (resuming previous execution) 1 * 1 = 1 (resuming…) 2 * 1 = 2 (…) 3 * 2 = 6 … 4 * 6 = 24 5 * 24 = 120 6 * 120 = 720 factorial(6) = 720 call stack needs to keep the previous result for calculating the next. 每次重复的过程调用都使得调用链条不断加长，系统不得不使用栈进行数据保存和恢复。 尾递归： // TCO function factorial(n) { var result = recursiveFactorial(n, 1); console.log(result); } function recursiveFactorial(n, accumulator) { if (n factorial(6) inner anonymous function (recursiveFactorial) gets called with (n = 6, res = 1) recursiveFactorial(5, 1 * 6) recursiveFactorial(4, 6 * 5) recursiveFactorial(3, 30 * 4) recursiveFactorial(2, 120 * 3) recursiveFactorial(1, 360 * 2) recursiveFactorial(0, 720) 720 720 720 720 720 720 720 recursiveFactorial(6, 1) = 720 factorial(6) = 720 以 f(6) 为例，以上尾递归类似： var res = 1; var n = 6; while (n > 1) { res = res * n; n--; } 案例 2： // 然后再用最著名的Fibonacci数列来举例，传统的递归是: function FibonacciRecursively(n) { return n 1.1.2. 编译器是怎样优化尾递归的 我们知道递归调用是通过栈来实现的，每调用一次函数，系统都将函数当前的变量、返回地址等信息保存为一个栈帧压入到栈中，那么一旦要处理的运算很大或者数据很多，有可能会导致很多函数调用或者很大的栈帧，这样不断的压栈，很容易导致栈的溢出。 尾递归的特性：函数在递归调用之前已经把所有的计算任务已经完毕了，他只要把得到的结果全交给子函数就可以了，无需保存什么，子函数其实可以不需要再去创建一个栈帧，直接在当前栈帧上把原先的数据覆盖即可。相对的，如果是普通的递归，函数在递归调用之前并没有完成全部计算，还需要调用递归函数完成后才能完成运算任务。比如return n * factorial(n - 1); 这句话，factorial(n) 在算完 factorial(n-1) 之后才能得到 n * factorial(n - 1) 的运算结果然后才能返回。 综上所述，尾递归的时候，不会去不断创建新的栈帧，而是在当前的栈帧上不断的去更新覆盖，一来防止栈溢出，二来节省了调用函数时创建栈帧的开销。 1.2. 尾调用 尾调用为 tail-call。尾递归也是一种尾调用，但是尾调用并不一定是尾递归。尾调用更广。 尾调用是指 一个函数的最后一个动作是一个函数调用 的情形。称这个调用位置为 尾位置 。如果尾位置调用这个函数自己，那才可以称为 尾递归 。 尾调用的重要性，在于它可以不在调用栈上面添加一个新的堆栈帧 call stack frame – 而是更新它。 当一个函数调用时，电脑必须记住调用函数的位置，即返回位置，才可以在调用结束时带着返回值回到该位置，返回位置一般存在调用栈上。在尾调用的情况下，电脑不需要记住尾调用的位置而是可以从被调用的函数直接带着返回值返回到调用函数的返回位置。尾调用消除即是在不改变当前调用栈的情况下调到新函数的一种优化。 尾调用优化就是以对尾调用这种情况，进行尾调用的消除，以不用添加新的堆栈，只是更新它，来提高效率。只有当某个函数的最后一个操作仅仅是调用其它函数，而不会将其函数返回值另作他用的情况下，进行尾调用优化。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/ES6/template_string_loop_json.html": {
    "url": "Javascript/ES6/template_string_loop_json.html",
    "title": "template_string_loop_json",
    "keywords": "",
    "body": "1. ES6 模版字符串遍历 json 数据生成 table1. ES6 模版字符串遍历 json 数据生成 table // 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。 const table = (addresses) => ` ${addresses .map( (addr) => ` ${addr.first} ${addr.last} `, ) .join('')} `; const data = [{ first: 'Jane', last: 'Bond' }, { first: 'Lars', last: 'Croft' }]; console.log(table(data)); 最终生成： Jane Bond Lars Croft Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/gQuery.html": {
    "url": "Javascript/gQuery.html",
    "title": "gQuery",
    "keywords": "",
    "body": "1. gQuery1. gQuery jquery 原理 源码 核心架构 事件委托 插件机制：http://www.zhangxinxu.com/wordpress/2013/07/jquery-%E5%8E%9F%E7%90%86-%E6%9C%BA%E5%88%B6/ 原型上 有对于 string、array、math 工具方法。选择器。模板引擎。extend。通过 extend 又扩充了对事件的封装。 //定义一个对象 - 名字是$$ var $$ = function() {}; $$.prototype = { constructor: $$, init: function() { this.stringExtend(); this.MathExtend(); this.arrayExtend(); }, stringExtend: function() { String.prototype.formatString = function(data) { return this.replace(/@\\((\\w+)\\)/g, function(match, key) { return typeof data[key] === 'undefined' ? '' : data[key]; }); }; /*trim是 ES5 新增的*/ String.prototype.trim = function() { return this.replace(/(^\\s*)|(\\s*$)/g, ''); }; /*字符串-去掉前空白字符 */ String.prototype.ltrim = function() { return this.replace(/(^\\s*)/g, ''); }; String.prototype.rtrim = function() { return this.replace(/(\\s*$)/g, ''); }; /* 将一个字符串的首字母大写，其它字符小写 */ String.prototype.capitalize = function() { return this.trim().replace(/^(\\w{1})(.*)/g, function(match, g1, g2) { return g1.toUpperCase() + g2.toLowerCase(); }); }; /* 将字符串中的下划线转换成中划线 */ String.prototype.dashString = function() { return this.replace(/\\_/g, '-'); }; /* 检测字符串是否是空串 */ String.prototype.isEmpty = function() { return this.length === 0; }; /* 找到一个字符串中所有数字 console.log('a55fdaf455454sfdsfaf'.findNum()); */ String.prototype.findNum = function() { return this.match(/\\d+/g); }; /* 检测字符串是否包含特定的字符串 */ String.prototype.includes = function(target) { return this.indexOf(target) !== -1; }; /* 对字符串中的特殊字符进行转义，避免XSS */ String.prototype.escapeHTML = function() { // 转义后的字符是可以直接设置成innerHTML的值。 replace(/&/g, // '&amp;')这条replace()调用一定要写在所有的特殊字符转义的前面，不然转换后有&符号的会再被转一次 return this.replace(/&/g, '&amp;') .replace(/\\/g, '&gt;') .replace(/\\'/g, '&#39;') .replace(/\\\"/g, '&quot;'); // var strArr = this.split(''); // for (var pos = 0, l = strArr.length, tmp; pos ': // replaceArr(strArr, pos, '&gt;'); // break; // case \"'\": // replaceArr(strArr, pos, '&#39;'); // break; // case '\"': // replaceArr(strArr, pos, '&quot;'); // break; // case '&': // replaceArr(strArr, pos, '&amp;'); // break; // default: // } // } // return strArr.join(''); // function replaceArr(arr, pos, item) { // return arr.splice(pos, 1, item); // } }; /* 对字符串进行反转义 */ String.prototype.unescapeHTML = function() { return this.replace(/&amp;/, '&') .replace(/&lt;/g, '') .replace(/&#39;/g, \"'\") .replace(/&quot;/g, '\"') .replace(/&#(\\d+)/g, function($0, $1) { return String.formCharCode(parseInt($1, 10)); }); }; String.prototype.reverse = function() { return this.toString() .split('') .reverse() .join(''); }; }, arrayExtend: function() { /* 将数组清空，并返回这个数组的引用*/ Array.prototype.clear = function() { this.length = 0; return this; }; /* 返回数组第一项*/ Array.prototype.first = function() { return this[0]; }; /* 返回数组最后一项*/ Array.prototype.last = function() { return this[this.length - 1]; }; /*计算类*/ function calc(arr, callback) { var ret; for (var i = 0; i item)) { return item; } else { return max; } }); }; Array.prototype.min = function() { return calc(this, function(item, min) { if (!(min = 0; --i) { callbackRet = callback.call(null, callbackRet, this[i], i, this); } return callbackRet; }; /** * 返回目标值在数组中第一次出现的位置，搜索从左向右进行。 * 如果目标值在数组中不存在，则返回-1。可以指定一个搜索起始位置。默认为0 */ Array.prototype.indexOf = function(target, start) { var l = this.length, start = ~~start; //可以指定一个搜索起始位置。默认为0。start不传，默认为undefined,~~undefined -> 0 if (start = 0; --start) { if (this[start] === target) return start; } return -1; }; /** * 对于单一类型的数组，可以使用此方法去重。 * 但这类数组：[ 'ff', 1, '1' ]会去重失败 */ Array.prototype.enhanceUnique = function() { var ret = [], tempMap = {}, temp, i = 0, l = this.length, undef = void 0; for (; i 1 Math.ceil():向上取整。Math.ceil(1.1) -> 2 v // = Math.random() * n:会产生一个 0 = 200 && xhr.status data[time].找到以@开头的字符串，然后用数据替换@之后同名数据 var user // = { \"name\": \"guanghui\" }; console.log(formatString(\"欢迎@(name)来到百度世界\", // user)); formatString: function(str, json) { return str.replace(/@\\((\\w+)\\)/g, function(match, key) { return typeof json[key] === 'undefined' ? '' : json[key]; }); }, // arttemplate 语法 bindTemplate: function(json, renderContainerId, tempId) { document.getElementById(renderContainerId).innerHTML = template(tempId, json); }, artTemplate: function(id, html, json) { var render = template.compile(html); document.getElementById(id).innerHTML = render(json); }, // 给一个对象扩充功能 extendMany: function() { var key, i = 0, len = arguments.length, target = null, copy; if (len === 0) { return; } else if (len === 1) { target = this; } else { i++; target = arguments[0]; } for (; i Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/inheritance升级版composition.html": {
    "url": "Javascript/inheritance升级版composition.html",
    "title": "inheritance 升级版 composition",
    "keywords": "",
    "body": "1. aggregation composition 组合1. aggregation composition 组合 组合比继承好啊。下面的例子，生成了一个三维的带颜色的立方体。如果用继承做，需在继承类中写三维和颜色代码，但三维和颜色并没有抽离出来。如果又有个圆形希望变成三维和带颜色，又要在继承类中写三维和颜色代码。和立方体的代码不方便维护。 // npm install aggregation var aggregation = require('aggregation/es6'); var aggregation = (baseClass, ...mixins) => { let base = class _Combined extends baseClass { constructor(...args) { super(...args); mixins.forEach((mixin) => { mixin.prototype.initializer.call(this); }); } }; let copyProps = (target, source) => { Object.getOwnPropertyNames(source) .concat(Object.getOwnPropertySymbols(source)) .forEach((prop) => { if ( prop.match( /^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/, ) ) return; Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop)); }); }; mixins.forEach((mixin) => { copyProps(base.prototype, mixin.prototype); copyProps(base, mixin); }); return base; }; 具体使用： class Colored { initializer() { this._color = 'white'; } get color() { return this._color; } set color(v) { this._color = v; } } class ZCoord { initializer() { this._z = 0; } get z() { return this._z; } set z(v) { this._z = v; } } // base class class Shape { constructor(x, y) { this._x = x; this._y = y; } get x() { return this._x; } set x(v) { this._x = v; } get y() { return this._y; } set y(v) { this._y = v; } } // Shape is base. Colored, ZCoord are features class Rectangle extends aggregation(Shape, Colored, ZCoord) {} var rect = new Rectangle(7, 42); rect.z = 1000; rect.color = 'red'; console.log(rect.x, rect.y, rect.z, rect.color); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/inheritance继承.html": {
    "url": "Javascript/inheritance继承.html",
    "title": "inheritance 继承",
    "keywords": "",
    "body": "1. Inheritance(继承)1.1. Compose Inheritance1.1.1. example 11.1.2. example 21.1.3. example 31.1.4. ES2015 class extends1. Inheritance(继承) 1.1. Compose Inheritance 1.1.1. example 1 prop in function, method in prototype // Base var Person = function(name, age) { this.name = name; this.age = age; }; Person.prototype = { constructor: Person, say: function() { console.log('Hello Everyone!'); }, }; // 学生类,继承自人 var Student = function(name, age, lesson) { Person.call(this, name, age); //继承了构造器属性 // Person.apply(this, arguments); this.lesson = lesson; }; Student.prototype = new Person(); //继承了Person.prototype Student.prototype.getTeacher = function() { console.log('Mr Zhang'); }; //使用 var xiaoWang = new Student('wang', 20, 'javascript'); var xiaoLi = new Student('li', 30, 'javascript'); console.log(xiaoWang.name); //wang console.log(xiaoWang.age); //20 console.log(xiaoWang.lesson); //javascript console.log(xiaoLi.name); //li xiaoWang.say(); //'Hello Everyone!' xiaoLi.say(); //'Hello Everyone!' console.log(xiaoWang.say === xiaoLi.say); //true console.log(xiaoWang.getTeacher === xiaoLi.getTeacher); //true 1.1.2. example 2 // 教师类,继承自人 var Teacher = function(name, age, subject) { Person.call(this, name, age); this.subject = subject; }; Teacher.prototype = new Person(); Teacher.prototype.giveLecture = function() { console.log('网页平面'); }; //使用 var tc = new Teacher('zhang', 25, 'javascript'); console.log(tc.name); //zhang console.log(tc.age); //25 console.log(tc.subject); //javascript tc.giveLecture(); //网页平面 tc.say(); //'Hello Everyone!' console.log(tc.say === xiaoWang.say); //true 1.1.3. example 3 //定义产品对象 function Base() { /*产品名称*/ this.name = ''; /*普通价格*/ this.normalPrice = 144; /*团购价格*/ this.youhuijia = 120; /*已经购买的人数*/ this.buySum = 100; /*轮播图片列表*/ this.images = []; } Base.prototype = { Constructor: Base, /*普通购买*/ buy: function() {}, /*绑定图片列表*/ bindDOMImage: function() { var str = ''; for (var i = 0, len = this.images.length; i '; str += ''; str += ''; str += ''; } $('#etalage').html(str); /*jquery插件实现的幻灯片特效*/ $('#etalage').etalage({ thumb_image_width: 250, thumb_image_height: 300 }); }, /*绑定详细信息*/ bindDOMDetail: function() {}, /*绑定事件*/ bindEvents: function() {}, /*团购*/ groupBuy: function() {}, /*添加到购物车*/ addCart: function() {}, }; //继承的固定格式 /*构造函数中写法*/ var Book = function() { Base.call(this, arguments); this.author = '糖葫芦'; this.publisher = '清华大学出版社'; this.pages = 333; this.publishTimes = 2; this.type = 'IT教育'; this.publishTime = '2016-09-09'; }; /*原型写法*/ Book.prototype = new Base(); /*重写 覆盖基类方法*/ Book.prototype.bindDOMDetail = function() { var str = ''; str += '' + this.name + ''; str += ''; str += '' + this.buySum + '人购买'; str += ''; str += ''; str += ''; str += '$' + this.normalPrice + ''; str += '$' + this.youhuijia + ''; str += '优惠价'; str += ''; str += '作者:'; str += '' + this.author + ''; str += '出版日期:'; str += '' + this.publishTime + ''; str += '出版社:'; str += '' + this.publisher + ''; str += '页数:'; str += '' + this.pages + ''; str += '分类:'; str += '' + this.type + ''; $('.bookdetail').html(str); }; //Book.prototype.constructor = Book; Book.prototype.readTry = function() {}; Book.prototype.readAll = function() {}; /*不能使用如下写法，因为这个写法相当于重新定义一个原型对象*/ //Book.prototype = {} 1.1.4. ES2015 class extends // es6 class Point { constructor(x, y) { this.x = x; this.y = y; } } class ColorPoint extends Point { constructor(x, y, color) { // this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 } } // 子类的 constructor 方法没有调用 super 之前就使用 this 关键字会报错，而放在 super 方法之后就是正确的。 // 下面是生成子类实例的代码。 let cp = new ColorPoint(25, 8, 'green'); console.log(cp.x); console.log(cp.y); console.log(cp.color); 原文地址 http://es6.ruanyifeng.com/ Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/Naming_convention.html": {
    "url": "Javascript/Naming_convention.html",
    "title": "Naming_convention",
    "keywords": "",
    "body": "1. Naming convention1. Naming convention var __proto__; // private var _time; // private var obj = { __proto__: {}, }; function myFun() { let local; const LOCAL = 2; var obj = { ATTR: {}, }; } myFun.EVENT_TYPE = 1; var obj = { DIR: { TOP: 1, BOTTOM: 2, LEFT: 3, RIGHT: 4 }, }; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/oop.html": {
    "url": "Javascript/oop.html",
    "title": "oop",
    "keywords": "",
    "body": "1. OOP(面向对象)1. OOP(面向对象) function ClassName() { this.doms = { lastOnline: document.querySelector('.lastOnline'), indicator: document.querySelector('.indicator'), indicatorModal: document.querySelector('.indicator-modal'), }; this.doms.indicatorTable = this.doms.indicatorModal.querySelector('table'); this.doms.thead = this.doms.indicatorTable.tHead; this.doms.tbody = this.doms.indicatorTable.tBodies[0]; this.init(); } ClassName.prototype = { constructor: ClassName, init: function() { this.loadData(); this.bindEvents(); }, setModalPosition: function(dom) { var indicatorPosition = getPosition(dom.indicator); dom.indicatorModal.style.left = indicatorPosition.left - dom.indicatorModal.offsetWidth + dom.indicator.offsetWidth + 'px'; dom.indicatorModal.style.top = indicatorPosition.top + dom.indicator.offsetHeight + 10 + 'px'; }, setIndicatorColor: function(date) {}, loadData: function() { var instance = this; var href = location.href; // load modal window detail ajax('get', href.slice(0, href.lastIndexOf('/')) + '/data/indicator.json', '', function(data) { instance.bindIndicatorModalDOM(data); }); }, bindIndicatorModalDOM: function(data) { var instance = this; var strHead = ''; var strBody = ''; strHead += '' + data.head[0] + '' + data.head[1] + '' + data.head[2] + ''; for (var i = 0; i ' + data.body[i].product + '' + data.body[i].lastActiveDate + ''; } instance.doms.thead.innerHTML = strHead; instance.doms.tbody.innerHTML = strBody; this.bindToolip(); }, bindEvents: function() { var indicatorTimer = null; var indicatorModalTimer = null; var instance = this; var dom = this.doms; dom.indicator.onmouseenter = function() { //hold on .5s to display indicatorTimer = setTimeout(function() { dom.indicatorModal.style.display = 'block'; instance.setModalPosition(dom); }, 500); }; dom.indicator.onmouseleave = function() { clearTimeout(indicatorTimer); indicatorModalTimer = setTimeout(function() { dom.indicatorModal.style.display = 'none'; }, 500); }; dom.indicatorModal.onmouseenter = function() { //fast move from icon to modal window, keep modal open clearTimeout(indicatorModalTimer); dom.indicatorModal.style.display = 'block'; }; dom.indicatorModal.onmouseleave = function() { clearTimeout(indicatorModalTimer); dom.indicatorModal.style.display = 'none'; }; }, bindToolip: function() { var activityTR = this.doms.indicatorModal.querySelectorAll('.activity'); for (var i = 0; i Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/plugins/": {
    "url": "Javascript/plugins/",
    "title": "Javascript/plugins",
    "keywords": "",
    "body": "1. TOC1. TOC Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Javascript/plugins/pagination/": {
    "url": "Javascript/plugins/pagination/",
    "title": "Javascript/plugins/pagination",
    "keywords": "",
    "body": "1. TOC1. TOC pagination 分页 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Javascript/plugins/pagination/pagination分页.html": {
    "url": "Javascript/plugins/pagination/pagination分页.html",
    "title": "pagination 分页",
    "keywords": "",
    "body": "1. 分页1.1. pagination code1.2. pagination css1.3. pagination usage1.4. pagination html1.5. pagination test data1. 分页 1.1. pagination code // 求得页码总数，需要Math.ceil(totalCount/pageSize) /* 使用方法： window.onload = function() { pagination({ id: 'pagination', pageIndex: 1, // 当前要显示页面，1开始 pageSize: 4, // 每页显示条数 totalCount: data.length, // 总数据个数，总页码pageCount = Math.ceil(totalCount/pageSize) callBack: function(currentPageIndex, pageSize, totalPageCount) { // 分页标签加载完毕后执行 // alert('当前页:' + currentPageIndex + ',总共页:' + totalPageCount); loadData(currentPageIndex, pageSize); }， aClick: function(targetA) { // 点击某个a执行 targetA.style.opacity = 0.1; }, delayTime: 500 // 点击某个a后延迟500ms，再重新call page() }); }; */ /* 首页 上一页 [2] [3] 4 [5] [6] 下一页 尾页 */ function pagination(pageInfo) { if (!pageInfo.id) { return false; } // -------------------------分页链接生成 开始----------------------------------- var paginationObj = document.getElementById(pageInfo.id); paginationObj.innerHTML = ''; // 清空 var pageIndex = pageInfo.pageIndex || 1; var pageSize = pageInfo.pageSize || 5; var pageCount = Math.ceil(pageInfo.totalCount / pageSize); var callBack = pageInfo.callBack || function() {}; var aClick = pageInfo.aClick || function() {}; var delayTime = pageInfo.delayTime || 0; if (pageIndex >= 4 && pageCount >= 6) { var oA = document.createElement('a'); oA.href = '#1'; oA.innerHTML = '首页'; paginationObj.appendChild(oA); } if (pageIndex >= 2) { var oA = document.createElement('a'); oA.href = '#' + (pageIndex - 1); oA.innerHTML = '上一页'; paginationObj.appendChild(oA); } if (pageCount = 1) { var oA = document.createElement('a'); oA.href = '#' + (pageIndex + 1); oA.innerHTML = '下一页'; paginationObj.appendChild(oA); } if (pageCount - pageIndex >= 3 && pageCount >= 6) { var oA = document.createElement('a'); oA.href = '#' + pageCount; oA.innerHTML = '尾页'; paginationObj.appendChild(oA); } // --------------------------------分页链接生成 结束------------------------------ // 加载完分页表前后执行函数 callBack(pageIndex, pageSize, pageCount, paginationObj); // /* // 添加点击事件（传统） // var aA = paginationObj.getElementsByTagName('a'); // for (var i = 0; i Pasted from https://bitbucket.org/snippets/wghglory/7j6px/js_pagination 1.2. pagination css #pagination { line-height: 36px; display: flex; height: 36px; border-radius: 4px; background-color: #fff; box-shadow: 0 6px 10px rgba(0, 0, 0, 0.1); justify-content: center; align-items: center; } #pagination a { line-height: 24px; height: 24px; margin: 0 4px; padding: 0 10px; border-radius: 2px; background: linear-gradient(to bottom, #f0ece6, #e5ddda) no-repeat #d5ccc8; box-shadow: 0 1px 0 rgba(111, 89, 79, 0.4); color: #5a5a5a; text-decoration: none; } #pagination a.active { color: #fff; background-image: none; /* remove gradient and use #d5ccc8*/ box-shadow: inset 0 1px 3px rgba(111, 89, 79, 0.4), 0 1px 0 rgba(111, 89, 79, 0.4); } Pasted from https://bitbucket.org/snippets/wghglory/7j6px/js_pagination 1.3. pagination usage function loadData(pageIndex, pageSize) { // click first page, pageIndex = 1, not 0 based var messageListHtml = ''; var pageSize = pageSize || 5; var startIndex = (pageIndex - 1) * pageSize; //starting data var endIndex = startIndex + pageSize; //ending data endIndex = endIndex > data.length ? data.length : endIndex; for (var i = startIndex; i ' + data[i].post.username + '[' + formatDate(data[i].post.time) + ']' + data[i].post.content + ''; for (var r in data[i].replies) { messageListHtml += '' + data[i].replies[r].username + '[' + formatDate(data[i].replies[r].time) + ']' + data[i].replies[r].content + ''; } messageListHtml += ''; } messageUl.innerHTML = messageListHtml; } Pasted from https://bitbucket.org/snippets/wghglory/7j6px/js_pagination 1.4. pagination html pagination demo 用封装的分页控件 分页先入场，然后li入场。点击分页，分页先隐藏，li消失，分页入场，li入场 留言回复 You're very busying![2016-07-18 20:48:22] 学习课程 管理员回复[2016-07-14 17:57:49] 我不受si~~ 管理员回复2[2016-07-16 18:16:43] this is good --> 首页 上一页 1 2 3 4 5 6 下一页 末页 --> pagination({ id: 'pagination', pageIndex: 1, // 当前要显示页面，1开始 pageSize: 6, // 每页显示条数 totalCount: data.length, // 总数据个数，总页码pageCount = Math.ceil(totalCount/pageSize) callBack: function(currentPageIndex, pageSize, totalPageCount, paginationObj) { // alert('当前页:' + currentPageIndex + ',总共页:' + totalPageCount); // for (var i = 0; i Pasted from https://bitbucket.org/snippets/wghglory/7j6px/js_pagination 1.5. pagination test data var data = [ { post: { id: 5, username: 'different user name', title: 'this will be title', time: new Date('July 17, 2016 14:10:05'), content: 'First DATA...', }, replies: [], }, { post: { id: 1, username: 'different user name', title: 'this will be title', time: new Date('July 17, 2016 14:10:05'), content: '学习课程，学习js', }, replies: [ { id: 2, username: 'different user name', title: 'this will be title', time: new Date('July 17, 2016 14:10:05'), content: '好好学习，天天做出好东西', }, { id: 1, username: 'different user name', title: 'this will be title', time: new Date('July 17, 2016 14:10:05'), content: '又回复', }, ], }, ]; Pasted from https://bitbucket.org/snippets/wghglory/7j6px/js_pagination Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/reduce.html": {
    "url": "Javascript/reduce.html",
    "title": "reduce",
    "keywords": "",
    "body": "1. javascript array.reduce1.1. map is 阉割版的 reduce1. javascript array.reduce We often need to take a list of things and convert that into just one item - whether an integer, an object, or another array. var scores = [89, 76, 47, 95]; var initialValue = 0; var reducer = function(accumulator, item) { return accumulator + item; }; var total = scores.reduce(reducer, initialValue); var average = total / scores.length; You'll notice .reduce takes in two values, a callback function and an initial value. The callback (reducer) function has two parameters. The first time the reducer function is called, it's going to be passed the initialValue you gave it (the 2nd argument to .reduce) and the first item in the actual array. So in our example above the first time that our reducer function runs, accumulator is going to be 0 and item is going to be 89. Remember, the goal is to transform an array into a single value. We currently have two numbers, 0 and 89, and are goal is to get that to one value. Because we're wanting to find the sum of every item in the array, we'll add 89 + 0 to get 89. That brings up a very important step. The thing that gets returned from the reducer function will then be passed as the accumulator the next time the function runs. So when reducer runs again, accumulator will be 89 and item will now be the second item in the array, 76. This pattern continues until we have no more items in the array and we get the summation of all of our reducer functions, which is 307. .reduce can be used for more than transforming an array of numbers. It's all about that initialValue that you pass to reduce. If you want the end result to be an object (therefore converting an array into an object), have the initialValue be an object and add properties to that object as you go. Here's an example of how you would do that below. You have an array of foods and you want to transform that to an object whose keys are the food itself and whose values are how many votes that food received. var votes = ['tacos', 'pizza', 'pizza', 'tacos', 'fries', 'ice cream', 'ice cream', 'pizza']; var initialValue = {}; var reducer = function(tally, vote) { if (!tally[vote]) { tally[vote] = 1; } else { tally[vote] = tally[vote] + 1; } return tally; }; var result = votes.reduce(reducer, initialValue); // {tacos: 2, pizza: 3, fries: 1, ice cream: 2} In our api.js, getStarCount will sum up each repo's star: function getStarCount(repos) { return repos.data.reduce(function(count, repo) { return count + repo.stargazers_count; }, 0); } 1.1. map is 阉割版的 reduce // map const keys = arr.map((p) => p.key); //reduce const keys = arr.reduce((accu, current) => { return [...accu, current.key]; }, []); 现在 arr 里面有个 categoryId，在他 =1 的时候我不想获取值，希望进行下次循环 const keys = products[0].analysis.reduce((accu, current) => { if (current.categoryId === 1) return accu; else { return [...accu, current.key]; } }, []); const values = product.analysis.reduce((accu, current, index) => { if (current.categoryId === 1) return accu; return [ ...accu, { analysisId: current.analysisId, yaosu: current.key, y: current.value, productId: product.id, productName: product.name, }, ]; }, []); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/throttle_debounce_immediate.html": {
    "url": "Javascript/throttle_debounce_immediate.html",
    "title": "throttle_debounce_immediate",
    "keywords": "",
    "body": "1. throttle debounce 两种优化技巧1.1. 总结1. throttle debounce 两种优化技巧 resize 当节点尺寸发生变化时，触发这个事件。通常用在 window 上，这样可以监听浏览器窗口的变化。通常用在复杂布局和响应式上。出于对性能的考虑，你可以使用函数 throttle 或者 debounce 技巧来进行优化。 throttle: 某一段时间内无论多次调用，只执行一次函数，到达时间就执行。预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。好比一台自动的饮料机，按拿铁按钮，在出饮料的过程中，不管按多少这个按钮，都不会连续出饮料，中间按钮的响应会被忽略，必须要等这一杯的容量全部出完之后，再按拿铁按钮才会出下一杯。 debounce: 某一段时间内等待是否还会重复调用，如果不会再调用，就执行函数；如果还有重复调用，则不执行继续等待。如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。也就是说当调用动作 n 毫秒后，才会执行该动作，若在这 n 毫秒内又调用此动作则将重新计算执行时间。一部电梯停在某一个楼层，当有一个人进来后，20 秒后自动关门，这 20 秒的等待期间，又一个人按了电梯进来，这 20 秒又重新计算，直到电梯关门那一刻才算是响应了事件。 1.1. 总结 当有持续性动作的时候，Throttle 降低频率持续性触发，而 Debounce 和 Immediate 只会触发一次，且 Debounce 在动作之后触发，Immediate 在动作之前触发。 /* 每次清除之前的定时器，开启新的定时任务，如果规定时间 delta 内再次运行，继续清计时器。直到时间超过规定时间，执行任务 */ function debounce(fn, delta, context) { var timeoutID = null; return function() { clearTimeout(timeoutID); var args = arguments; timeoutID = setTimeout(function() { fn.apply(context, args); }, delta); }; } function immediate(fn, delta, context) { var timeoutID = null; var safe = true; return function() { var args = arguments; if (safe) { fn.call(context, args); safe = false; } clearTimeout(timeoutID); timeoutID = setTimeout(function() { safe = true; }, delta); }; } /* 首次执行，且立马标记 safe = false。开启定时器，规定时间到了后标记重置，所以规定时间内又想执行无效 */ function throttle(fn, delta, context) { var safe = true; return function() { var args = arguments; if (safe) { fn.call(context, args); safe = false; setTimeout(function() { safe = true; }, delta); } }; } // alternate implementation function throttleRender(fn, delta, context) { return function() { var args = arguments; var then = 0; function repeat(now) { requestAnimationFrame(repeat); if (now - then >= delta) { then = now; fn.call(context, args); } } requestAnimationFrame(repeat); }; } /** * 具体使用： */ document.addEventListener('mousemove', throttle(() => console.log('throttle'), 1000)); document.addEventListener('mousemove', debounce(() => console.log('debounce'), 1000)); document.addEventListener('mousemove', immediate(() => console.log('immediate'), 1000)); https://zhirzh.github.io/2016/10/20/timing-controls-3 https://css-tricks.com/debouncing-throttling-explained-examples/ Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/webworker.html": {
    "url": "Javascript/webworker.html",
    "title": "webworker",
    "keywords": "",
    "body": "1. Web Worker1.1. Web worker demo1.2. reference1. Web Worker A web worker is a JavaScript that runs in the background, independently of other scripts, without affecting the performance of the page. You can continue to do whatever you want: clicking, selecting things, etc., while the web worker runs in the background. 1.1. Web worker demo // demo_workers.js var i = 0; function timedCount() { i = i + 1; postMessage(i); setTimeout(timedCount, 500); } timedCount(); Count numbers: Start Worker Stop Worker var w; function startWorker() { if(typeof(Worker) !== \"undefined\") { if(typeof(w) == \"undefined\") { w = new Worker(\"demo_workers.js\"); } w.onmessage = function(event) { document.getElementById(\"result\").innerHTML = event.data; }; } else { document.getElementById(\"result\").innerHTML = \"Sorry! No Web Worker support.\"; } } function stopWorker() { w.terminate(); w = undefined; // can reuse the Web Worker when calling startWorker() again } 1.2. reference https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/XMLHttpRequest.html": {
    "url": "Javascript/XMLHttpRequest.html",
    "title": "XMLHttpRequest",
    "keywords": "",
    "body": "1. XMLHttpRequest1.1. 接收响应1.2. 解码响应1.3. 对请求正文进行编码1.3.1. Form-encoded 请求1.3.2. JSON 编码的请求1.3.3. 上传文件1.3.4. multipart/form-data 请求1.4. HTTP 进度事件1.5. 上传进度事件1.6. 放弃请求与超时1. XMLHttpRequest readyState: 表示请求状态的整数，取值: UNSENT（0）: 对象已创建 OPENED（1）: open()成功调用，在这个状态下，可以为 xhr 设置请求头，或者使用 send()发送请求 HEADERS_RECEIVED(2): 所有重定向已经自动完成访问，并且最终响应的 HTTP 头已经收到 LOADING(3): 响应体正在接收 DONE(4): 数据传输完成或者传输产生错误 onreadystatechange: readyState 改变时调用的函数 status: 服务器返回的 HTTP 状态码（如，200， 404） statusText: 服务器返回的 HTTP 状态信息（如，OK，No Content） responseText: 作为字符串形式的来自服务器的完整响应 responseXML: Document 对象，表示服务器的响应解析成的 XML 文档 abort(): 取消异步 HTTP 请求 getAllResponseHeaders(): 返回一个字符串，包含响应中服务器发送的全部 HTTP 报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行 getResponseHeader(headerName): 返回 headName 对应的报头值 open(method, url, asynchronous [, user, password]): 初始化准备发送到服务器上的请求。method 是 HTTP 方法，不区分大小写；url 是请求发送的相对或绝对 URL；asynchronous 表示请求是否异步；user 和 password 提供身份验证 setRequestHeader(name, value): 设置 HTTP 报头 send(body): 对服务器请求进行初始化。参数 body 包含请求的主体部分，对于 POST 请求为键值对字符串；对于 GET 请求，为 null XMLHttpRequest 是用于 HTTP 协议的，因此 FTP 或 file: 协议不能使用 XMLHttpRequest。 setRequestHeader 有一些请求头是你不能指定的。XMLHttpRequest 会帮你设定。不能通过 setRequestHeader() 指定的头有: Accept-Charset Accept-Encoding Connection Content-Length Cookie Cookie2 Content-Transfer-Encoding TE Date Trailer Expect Transfer-Encoding Host Upgrade Keep-Alive User-Agent Referer Via function postMessage(msg) { var request = new XMLHttpRequest(); // New request request.open('POST', '/log.php'); request.setRequestHeader('Content-Type', 'text/plain;charset=UTF-8'); // 必须在 `open()` 后、 `send()` 之前调用 request.send(msg); // The request is done. We ignore any response or any error. } 1.1. 接收响应 通过 XMLHttpRequest 对象的属性或方法获取响应的信息: status 和 statusText 分别以数字和文本形式返回 HTTP 状态，如 200 和 “OK”。 响应头可以通过 getResponseHeader() 和 getAllResponseHeaders() 获取。 XMLHttpRequest 会自动处理 cookies，因此当你传 “Set-Cookie” 或 “Set-Cookie2” 给 getResponseHeader() 得到的是 null。 responseText 是响应的字符串形式，responseXML 是文档形式。 XMLHttpRequest 一般是异步的。send() 方法调用后立即返回。表示响应的属性和方法要等到收到响应后才有效。要判断响应是否就绪，需要监听 readystatechange 事件（或 XHR2 progress 事件）。 readyState 属性是一个整数，表示 HTTP 请求的状态。规范定义了一些常量，但老的浏览器，包括 IE8 未定义，因此很多时候直接使用数字。 UNSENT 或 0:open() 尚未被调用 OPENED 或 1:open() 已经被调用 HEADERS_RECEIVED 或 2:头部已经收到 LOADING 或 3:响应正文正在被接收 DONE 或 4:响应完成 理论上，每当 readyState 属性改变都会触发 readystatechange 事件。实际中，readyState 变到 0 或 1 可能不触发。send() 调用后一般会触发一次，即使 readyState 仍为 OPENED。一些浏览器在 LOADING 状态会触发多个事件，算进度反馈。所有浏览器当状态变为 4 时都会触发 readystatechange。 监听 readystatechange 事件的方法是设置 XMLHttpRequest 对象的 onreadystatechange 属性。也可以用 addEventListener()。 function getText(url, callback) { var request = new XMLHttpRequest(); request.open('GET', url); request.onreadystatechange = function() { if (request.readyState === 4 && request.status === 200) { var type = request.getResponseHeader('Content-Type'); if (type.match(/^text/)) callback(request.responseText); } }; request.send(null); // Send the request now } 1.2. 解码响应 响应若是文本，可以通过 responseText 属性获取。 如果服务器发送的是 XML 或 XHTML 文档，你可以通过 responseXML 属性获取解析后的版本。该属性的值是一个 Document 对象。 服务器还可以响应结构化的数据，如 JSON 编码的字符串。只能用 JSON.parse() 解析 responseText 了。 服务器可能响应二进制数据（如图片）。responseText 属性只用于文本，不能用于处理二进制响应。XHR2 定义了一种处理二进制响应的方法，但目前尚没有浏览器支持。 如果服务器响应未设置正确的 MIME 类型，XMLHttpRequest 对象不会解析并设置 responseXML 属性。如果服务器错误的设置了 content-type 的 charset 参数， XMLHttpRequest 解码会出错。为此，XHR2 定义了一个 overrideMimeType() 方法，你如果你知道响应的 MIME，在调用 send() 前调用 overrideMimeType()，让 XMLHttpRequest 忽略响应的 content-type 头。 // Don't process the response as an XML document request.overrideMimeType('text/plain; charset=utf-8'); 1.3. 对请求正文进行编码 1.3.1. Form-encoded 请求 编码表单数据的方法是:对每个表单项的键与值分别进行正常的 URI 编码（特殊字符由十六进制字符替代），用等号分割键值、用 & 分割表单项: find=pizza&zipcode=02134&radius=1km 这种格式的数据的 MIME 为:application/x-www-form-urlencoded。当你发送这类数据时，必须将请求头 Content-Type 设为该值。 把一个对象按表单编码: function encodeFormData(data) { if (!data) return ''; var pairs = []; for (var name in data) { if (!data.hasOwnProperty(name)) continue; if (typeof data[name] === 'function') continue; var value = data[name].toString(); name = encodeURIComponent(name.replace(' ', '+')); value = encodeURIComponent(value.replace(' ', '+')); pairs.push(name + '=' + value); } return pairs.join('&'); } 表单编码的数据还可以用于 GET 请求，附加到 GET 请求的查询串上: request.open('GET', url + '?' + encodeFormData(data)); 1.3.2. JSON 编码的请求 request.send(JSON.stringify(data)); 1.3.3. 上传文件 HTTP 表单总是能发送文件。但直到最近，XHR2 API 才允许通过传 File 对象到 send() 方法上传文件。 获得 File 对象的方法。 元素有一个 files 属性，是一个类数组的对象，含有 File 对象。拖放 API 通过 dataTransfer.files 属性提供类似结构。 File 类型是 Blob 的子类型。XHR2 实际允许通过 send() 方法发送任何 Blob 对象。若你不显式设置，Blob 的 type 属性会被用于设置 Content-Type。如果你要上传二进制数据，可以将其转换为 Blob 后上传。 1.3.4. multipart/form-data 请求 若表单既有文件又有其他元素，浏览器无法使用普通的表单编码，要使用一种特殊的 Content-Type: multipart/form-data。这种编码使用一个较长的边界字符串将请求分割成多个部分。 XHR2 定义了一个新的 FormData API，使得发送 multipart 请求变得简单。首先通过 FormData() 构造器创建 FormData 对象。然后通过 append() 方法添加一个个 “parts”，可以是字符串、File 或 Blob 对象。最后将 FormData 对象传入 send() 方法。 1.4. HTTP 进度事件 XHR2 草案定义了一个新的事件模型。多数现代浏览器支持。使用新的事件模型后就不必再使用 readyState 属性判断请求状态了。 触发顺序如下。当 send() 被调用，触发 loadstart 事件。在服务器响应下载的过程中 而不是上传过程中！！， XMLHttpRequest 触发多个 progress 事件，一般每 50 毫秒一次。请求完成后，触发 load 事件。 完成的请求不一定成功。load 事件的处理器需要检查返回的状态码。有三种可能的错误。若请求超时，触发 timeout 事件。若请求被放弃，触发 abort 事件。其他错误，如“太多重定向），触发 error 事件。 对于一个请求，load、 abort、 timeout 和 error 这四个事件，浏览器只会触发其中一个。XHR2 草案规定上述四个事件触发后，要再触发一个 loadend 事件。 可以通过 XMLHttpRequest 的 addEventListener() 方法注册这些事件的处理器。若只需要一个处理器，可以设置相应的处理器属性，如 onprogress、 onload 等。 进度事件的事件对象，除了一般 Event 对象的属性，如 type、timestamp。 loaded 属性是已传输的字节数。 total 属性是要传输的总的字节数，来自 Content-Length 头。若响应没有该头，该值为 0。lengthComputable 属性，布尔，用于判断到底知不知道响应的长度。 上述是下载的传输，而不是指上传的传输 这几个属性对于计算已加载的百分比: request.onprogress = function(e) { if (e.lengthComputable) progress.innerHTML = Math.round(100 * e.loaded / e.total) + '% Complete'; }; 1.5. 上传进度事件 XHR2 允许监控上传 HTTP 请求的进度。XMLHttpRequest 的 upload 属性是一个对象，有自己的 addEventListener() 方法，以及进度事件属性，如 onprogress 和 onload。 例如，对于一个 XMLHttpRequest 对象 x，设置 x.onprogress 属性监听响应的下载进度。设置 x.upload.onprogress 监听请求的上传进度。 1.6. 放弃请求与超时 调用 XMLHttpRequest 对象的 abort() 方法可以取消正在进行的请求。并且在 XHR2 中调用 abort() 方法会触发 abort 事件。 XHR2 定义了一个 timeout 属性，指定超时（毫秒）后自动放弃请求，并触发 timeout 事件。目前还没有浏览器支持这一点。但我们可以通过 setTimeout() 和 abort() 自己模拟。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/前端知识目录.html": {
    "url": "Javascript/前端知识目录.html",
    "title": "前端知识目录",
    "keywords": "",
    "body": "1. 前端知识1.1. 0. 前端自动化(Workflow)1.2. 1. 前端框架(Frameworks)1.3. 2. JavaScript 框架汇总1.4. 3. 前端游戏框架1.5. 4. ui组件库1.6. 5. 基础模版1.7. 6. 排版1.8. 7. 网格系统1.9. 8. HTML5 API 应用1.10. 9. UA 识别1.11. 10. 表单处理1.11.1. 10.1 表单验证(Form Validator)1.11.2. 10.2 相关1.11.3. 10.3 单选框/复选框相关1.11.4. 10.4 上传组件1.11.5. 10.5 日期选择1.11.6. 10.6 取色1.11.7. 10.7 标签插件(Tag)1.11.8. 10.8 自动完成插件1.11.9. 10.9 样式修正1.12. 11. 图表绘制1.13. 12. 日期格式化1.14. 13. 页面交互1.14.1. 13.1 Slider1.14.2. 13.2 瀑布流1.14.3. 13.3 图片懒加载/加载监听1.14.4. 13.4 图片轮播/展示1.14.5. 13.5 图片剪裁/处理1.14.6. 13.6 进度条1.14.7. 13.7 侧滑插件(offcancas)1.14.8. 13.8 菜单(Menu)1.14.9. 13.9 滚动侦测(ScrollSpy)1.14.10. 13.10 滚动加载更多1.14.11. 13.11 平滑滚动插件(Smooth Scroll)1.14.12. 13.12 全屏滚动1.14.13. 13.13 分屏滚动1.14.14. 13.14 转场效果1.14.15. 13.15 固定元素(Sticky)1.14.16. 13.16 触控事件1.14.17. 13.17 拖拽组件1.14.18. 13.18 隐藏或展示页面元素1.14.19. 13.19 滚动条1.14.20. 13.20 视差滚动(Parallax Scrolling)1.15. 14. 代码高亮插件/代码编辑器1.16. 15. UI Icon 组件1.17. 16. 动画1.18. 17. 本地存储1.19. 18. 模板引擎1.20. 19. 通知组件/弹框组件1.21. 20. 提示控件(Tooltips)1.22. 21. 对话框/弹出层(lightbox)1.23. 22. 文档/表格1.24. 23. 目录树插件1.25. 24. Ajax 模块1.26. 25. 音频/视频1.27. 26. 按钮1.28. 27. 富文本编辑器/Markdown 编辑器/Markdown 解析器1.29. 28. 内容提取(Readability)1.30. 29. 颜色(CSS Colors)/SVG1.31. 30. 实用工具/其他插件1.32. 前端参考集1. 前端知识 1.1. 0. 前端自动化(Workflow) 前端构建工具 Yeoman – a set of tools for automating development workflow gulp – The streaming build system grunt – the JavaScript Task Runner F.I.S – 前端集成解决方案 前端模块管理器 Bower – A package manager for the web Browserify Component Duo RequireJS Sea.js css 预处理器 Less – Less is More , Than CSS Sass – Syntactically Awesome Style Sheets Stylus – Expressive, dynamic, robust CSS 1.2. 1. 前端框架(Frameworks) Bootstrap Foundation Amaze UI Semantic UI Pure CSS topcoat UIkit Material UI Framework7 mui ionic framework Fries jQuery Mobile 1.3. 2. JavaScript 框架汇总 JavaScript 框架 react Angular jQuery Backbone.js Ractive.js KISSY Zepto.js Vanilla JS Avalon 轻量级 JavaScript 框架 Min.js – Super minimal selector and event library skel.js – A lightweight responsive framework JavaScript 工具库 underscore.js Way.js – 双向数据绑定库 Keys.js – 应用快捷键 1.4. 3. 前端游戏框架 cocos2d-html5 Egret Engine LimeJS EaselJS three.js AlloyStick The-Best-JS-Game-Framework CanvasEngine Quintus 1.5. 4. ui组件库 GMU NEC NEJ Pure CSS Components magic-of-css 1.6. 5. 基础模版 HTML5 BOILERPLATE Modernizr Normalize.css Responsive – 响应式布局 1.7. 6. 排版 yue.css typo.css chinese-copywriting-guidelines – 中文文案排版指南 1.8. 7. 网格系统 grid Flexbox Grid 1.9. 8. HTML5 API 应用 History.js – gracefully supports the HTML5 History/State APIs jquery-pjax – pushState+ajax jquery-address – Deep Linking Notify.js(Web Notifications API) 1.10. 9. UA 识别 detector 1.11. 10. 表单处理 1.11.1. 10.1 表单验证(Form Validator) Validator Parsley jquery.form.js – jQuery Form Plugin Validform validator.js formvalidator.js Fort.js – 表单填写进度提示 1.11.2. 10.2 相关 Chosen Select2 bootstrap-select 1.11.3. 10.3 单选框/复选框相关 iCheck – 增强复选框和单选按钮 1.11.4. 10.4 上传组件 jQuery File Upload Plugin 百度 Web Uploader Uploadify Plupload arale-upload – 轻量级 iframe and html5 file uploader Dropzone.js – drag’n’drop library 拖拽上传 flow.js 1.11.5. 10.5 日期选择 Both Date and Time picker widget based on twitter bootstrap GMU 日历组件 Mobiscroll 1.11.6. 10.6 取色 Colorpicker plugin for Twitter Bootstrap 1.11.7. 10.7 标签插件(Tag) TaggingJS – 可以灵活定制的 jQuery 标签系统插件 1.11.8. 10.8 自动完成插件 At.js – 一个 Twitter/微博样式的@自动完成插件 jquery-textcomplete – 智能搜索提示框/自动补全 1.11.9. 10.9 样式修正 autosize – 使文本框自动适应所输入的内容 1.12. 11. 图表绘制 Highcharts Chart.js – Simple HTML5 Charts using Canvas 百度 ECharts Chartist.js D3.js – A JavaScript visualization library for HTML and SVG.intro-to-d3 – a D3.js tutorial 1.13. 12. 日期格式化 Moment.js Smart Time Ago – 显示相对时间 1.14. 13. 页面交互 1.14.1. 13.1 Slider slick – the last carousel you’ll ever need Swipe – the most accurate touch slider Swiper – Most modern mobile touch slider iscroll – Smooth scrolling for the web OwlCarousel – create beautiful responsive carousel slider jquery-mousewheel – jQuery 鼠标滚轮滚动侦测插件 1.14.2. 13.2 瀑布流 Masonry Isotope – Filter & sort magical layouts 1.14.3. 13.3 图片懒加载/加载监听 imagesLoaded Echo.js lazySizes jquery_lazyload lazyload.js waitForImages – 图片加载监听库 1.14.4. 13.4 图片轮播/展示 FlexSlider unslider – 小而美的轮播库 prettyPhoto 1.14.5. 13.5 图片剪裁/处理 croppic – an image cropping jquery plugin jQuery.eraser – 图像擦除插件 1.14.6. 13.6 进度条 NProgress.js progress.js Pace – Automatic page load progress bar jquery-ajax-progress 1.14.7. 13.7 侧滑插件(offcancas) pushy – a responsive off-canvas navigation menu 1.14.8. 13.8 菜单(Menu) SuperFish – 基于 jQuery 的级联下拉菜单 Responsive Nav – 响应式导航 1.14.9. 13.9 滚动侦测(ScrollSpy) jquery-scrollspy(1) jquery-scrollspy(2) Waypoints 1.14.10. 13.10 滚动加载更多 jScroll 1.14.11. 13.11 平滑滚动插件(Smooth Scroll) jquery-smooth-scroll jquery.scrollTo – 平滑滚动到页面指定位置 1.14.12. 13.12 全屏滚动 pagePiling.js – 全屏滚动效果 1.14.13. 13.13 分屏滚动 multiscroll.js – 分屏滚动效果 1.14.14. 13.14 转场效果 Animsition – 页面切换时的过渡效果 1.14.15. 13.15 固定元素(Sticky) sticky – jQuery Plugin for Sticky Objects jquery.pin – 固定页面元素 1.14.16. 13.16 触控事件 Hammer.js jquery.event.move.js 1.14.17. 13.17 拖拽组件 Draggabilly – 专注于拖拽功能的 JS 库 1.14.18. 13.18 隐藏或展示页面元素 Headroom.js – 在不需要页头时将其隐藏 Readmore.js – 内容显示与隐藏插件 1.14.19. 13.19 滚动条 jScrollPane 1.14.20. 13.20 视差滚动(Parallax Scrolling) parallax.js jparallax 1.15. 14. 代码高亮插件/代码编辑器 google-code-prettify highlight.js Rainbow ACE CodeMirror Crayon Syntax Highlighter prism – Lightweight, robust, elegant syntax highlighting. 1.16. 15. UI Icon 组件 Font Awesome Glyphter: The SVG Font Machine Perfect Icons iconizr Cikonss – 纯 CSS 实现的响应式 Icon Simple Icons 1.17. 16. 动画 animate.css – A cross-browser library of CSS animations. Transit – CSS transitions and transformations for jQuery Move.js – 简化 CSS3 动画的 JS 库 ScrollMe – 在网页中加入各种滚动动画效果 Effeckt.css – A Performant Transitions and Animations Library NEC 动画库 csshake – CSS classes to move your DOM magic – CSS3 Animations with special effects Hover.css css-loaders SpinKit 1.18. 17. 本地存储 cross-storage – Cross domain local storage localForage pouchdb basil.js 1.19. 18. 模板引擎 mustache.js Handlebars.js artTemplate baiduTemplate JSRender EJS – JavaScript Templates Juicer – A Light Javascript Templete Engine. Tempo json2html 1.20. 19. 通知组件/弹框组件 alertify.js AlertifyJS SweetAlert Messenger – 非常酷的弹框组件 PNotify Notify.js – A simple, versatile notification library 1.21. 20. 提示控件(Tooltips) qTip2 – Pretty powerful tooltips tooltip – CSS Tooltips tooltipster – A jQuery tooltip plugin grumble.js – 气泡形状的提示（Tooltip）控件 Ouibounce – 离站提示控件 1.22. 21. 对话框/弹出层(lightbox) fancyBox – Fancy jQuery lightbox jquery-lightbox – The popular lightbox script, ported to jQuery Colorbox – a jQuery lightbox artDialog – 经典的网页对话框组件 DialogEffects 1.23. 22. 文档/表格 handsontable – 在线可编辑 excel 表格 jQuery Bootgrid – 用于 ajax 生成动态表格 DataTables – Table plug-in for jQuery 1.24. 23. 目录树插件 zTree_v3 – jQuery Tree Plugin jstree – jQuery Tree Plugin fancytree – Tree plugin for jQuery 1.25. 24. Ajax 模块 fetch – A window.fetch JavaScript polyfill reqwest – browser asynchronous http requests minAjax.js 1.26. 25. 音频/视频 jPlayer – HTML5 Audio & Video for jQuery video.js – HTML5 & Flash video player Accessible HTML5 Video Player – PayPal 开源的 HTML5 视频播放器 Clappr – 开源的 Web 视频播放器 Plyr – A simple HTML5 media player FitVids.js – A lightweight, easy-to-use jQuery plugin for fluid width video embeds. BigVideo.js – The jQuery Plugin for Big Background Video BigScreen – A simple library for using the JavaScript Full Screen API Vide – 视频背景 winamp2-js 1.27. 26. 按钮 Buttons – A CSS button library ButtonComponentMorph ProgressButtonStyles CreativeButtons CSS3 buttons jquery.onoff – Interactive, accessible toggle switches for the web. 1.28. 27. 富文本编辑器/Markdown 编辑器/Markdown 解析器 Simditor – 简单快速的富文本编辑器 BachEditor – 一个有情怀的编辑器 bootstrap-markdown marked – markdown 解析器 1.29. 28. 内容提取(Readability) Readability json.human.js – Json Formatting for Human Beings 1.30. 29. 颜色(CSS Colors)/SVG CSS Colours SVGeneration 1.31. 30. 实用工具/其他插件 jquery-cookie FastClick – 处理移动端 click 事件 300 毫秒延迟 screenfull.js – 全屏切换 Async.js – 异步操作 html2canvas – 实现纯 JS 网页截图 jquery.qrcode.js – 生成二维码的 jQuery 插件 FocusPoint.js 实现图片的响应式裁剪 DD_belatedPNG.js – 让 IE6 支持透明 PNG 图片 nakedpassword – 用脱衣女帮助检测密码强度 PDF.js – 一个 JavaScript 编写的 PDF 阅读器 1.32. 前端参考集 frontend-guidelines – Some HTML, CSS and JS best practices. Codrops – Useful resources Front-end Code Standards & Best Practices frontend-dev-bookmarks Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/工具类/": {
    "url": "Javascript/工具类/",
    "title": "Javascript/工具类",
    "keywords": "",
    "body": "1. TOC1. TOC code_common code_cookie code_dom code_Event code_Internationalization_localization code_modal code_money code_queryString code_random code_time code_view Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Javascript/工具类/code_common.html": {
    "url": "Javascript/工具类/code_common.html",
    "title": "code_common",
    "keywords": "",
    "body": "1. Common1. Common // find inputValue from originalList's props fields function searchTerm(inputValue: string, props: Array, originalList: Array) { let filteredList: any[]; if (inputValue && props && originalList) { inputValue = inputValue.toLowerCase(); let filtered = originalList.filter((item) => { let match = false; for (let prop of props) { if ( item[prop] .toString() .toLowerCase() .indexOf(inputValue) > -1 ) { match = true; break; } } return match; }); filteredList = filtered; } else { filteredList = originalList; } return filteredList; } /** array: [{id:1,name:'guanghui'},{id:2,name:'john'}] to object: {1:{id:1,name:'guanghui'},2:{id:2,name:'john'}} */ mapArr2Obj(arr) { return arr.reduce((accumulator, current) => { accumulator[current.id] = current; return accumulator; }, {}); } /** * 判断一个对象是否是数组，参数不是对象或者不是数组，返回false * * @param {Object} obj 需要测试是否为数组的对象 * @return {Boolean} 传入参数是数组返回true，否则返回false */ // 如果浏览器支持 Array.isArray() 可以直接判断否则需进行必要判断 function isArray(obj) { if (typeof obj === 'object') { return Object.prototype.toString.call(obj) === '[object Array]'; } return false; // return obj instanceof Array; //method 2 // return obj.constructor == Array; //method 3 } /** * 判断对象是否为函数，如果当前运行环境对可调用对象（如正则表达式）的 typeof 返回' function'，采用通用方法，否则采用优化方法 * * @param {Any} arg 需要检测是否为函数的对象 * @return {boolean} 如果参数是函数，返回true，否则false */ function isFunction(arg) { if (arg) { if (typeof /./ !== 'function') { return typeof arg === 'function'; } else { return Object.prototype.toString.call(arg) === '[object Function]'; } } return false; } /** * 解析一个 url 并生成 window.location 对象中包含的域 * console.log(parseUrl('http://google.com?s=fdf&g=guang')); * * location: * { * href: '包含完整的url', * origin: '包含协议到pathname之前的内容', * protocol: 'url使用的协议，包含末尾的:', * username: '用户名', // 暂时不支持 * password: '密码', // 暂时不支持 * host: '完整主机名，包含:和端口', * hostname: '主机名，不包含端口' * port: '端口号', * pathname: '服务器上访问资源的路径/开头', * search: 'query string，?开头', * hash: '#开头的fragment identifier' * } * * @param {string} url 需要解析的url * @return {Object} 包含url信息的对象 */ function parseUrl(url) { var result = {}; var keys = [ 'href', 'origin', 'protocol', 'host', 'hostname', 'port', 'pathname', 'search', 'hash', ]; var i, len; var regexp = /(([^:]+:)\\/\\/(([^:\\/\\?#]+)(:\\d+)?))(\\/[^?#]*)?(\\?[^#]*)?(#.*)?/; var match = regexp.exec(url); if (match) { for (i = keys.length - 1; i >= 0; --i) { result[keys[i]] = match[i] ? match[i] : ''; } } return result; } function getQueryStringParameterByName(name, url) { if (!url) url = window.location.href; name = name.replace(/[[\\]]/g, '\\\\$&'); var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'), results = regex.exec(url); if (!results) return null; if (!results[2]) return ''; return decodeURIComponent(results[2].replace(/\\+/g, ' ')); } /** * 忽略大小写后的安字符串名字排序。在 node 读取文件夹中文件时，排序忽略英文大小写 * @param {array} arr */ export function sortByAlphaIgnoreCase(arr) { arr.sort((a, b) => { return a.localeCompare(b, undefined /* Ignore language */, { sensitivity: 'base', }); }); } /** * 深拷贝 deepClone，也可以用 lodash 里面的 */ function deepClone(obj) { let temp = Array.isArray(obj) ? [] : {}; for (let key in obj) { //是否有嵌套对象 temp[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key]; } return temp; } /** * var a = { name: 'qiu', birth: new Date(), pattern: /qiu/gim, container: document.body, hobby: ['book', new Date(), /aaa/gim, 111] }; var b = deepClone(a) * @param {object} obj */ function deepClone(obj) { var _toString = Object.prototype.toString; // null, undefined, non-object, function if (!obj || typeof obj !== 'object') { return obj; } // DOM Node if (obj.nodeType && 'cloneNode' in obj) { return obj.cloneNode(true); } // Date if (_toString.call(obj) === '[object Date]') { return new Date(obj.getTime()); } // RegExp if (_toString.call(obj) === '[object RegExp]') { var flags = []; if (obj.global) { flags.push('g'); } if (obj.multiline) { flags.push('m'); } if (obj.ignoreCase) { flags.push('i'); } return new RegExp(obj.source, flags.join('')); } var result = Array.isArray(obj) ? [] : obj.constructor ? new obj.constructor() : {}; for (var key in obj) { result[key] = deepClone(obj[key]); } return result; } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/工具类/code_cookie.html": {
    "url": "Javascript/工具类/code_cookie.html",
    "title": "code_cookie",
    "keywords": "",
    "body": "1. Cookie1. Cookie var cookieUtil = (function(window, undefined) { var doc = window.document; var cookieUtil = { /** * 根据 opt 中设置的值设置cookie * * @param {Object} opt 包含cookie信息的对象，选项如下 * key {string} 需要设置的名字 * value {string} 需要设置的值 * maxAge {number} 有效期 * domain {string} domain * path {string} path * secure {boolean} secure * * @return {string} opt 对应的设置 cookie的字符串 */ setItem: function(opt) { var result = []; var str; if (opt.key) { result.push(encodeURIComponent(opt.key) + '=' + encodeURIComponent(opt.value)); if ('maxAge' in opt) { result.push('max-age=' + opt.maxAge); } if ('domain' in opt) { result.push('domain=' + opt.domain); } if ('path' in opt) { result.push('path=' + opt.path); } if (opt.secure) { result.push('secure'); } str = result.join('; '); doc.cookie = str; } return str; }, /** * 从 cookie 读取指定 key 的值，如果key有多个值，返回数组，如果没有 * 对应key，返回undefined * * @param {string} key 需要从 cookie 获取值得 key * @return {string|Array|undefined} 根据cookie数据返回不同值 */ getItem: function(key) { key = encodeURIComponent(key); var result; var pairs = doc.cookie.split('; '); var i, len, item, value; for (i = 0, len = pairs.length; i Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/工具类/code_dom.html": {
    "url": "Javascript/工具类/code_dom.html",
    "title": "code_dom",
    "keywords": "",
    "body": "1. DOM1. DOM /** * 获取某个 DOM 元素的某个属性 * @param {*} obj * @param {*} attr */ export function getStyle(obj, attr) { if (attr == 'rotate') { return obj.rotate; } let i = parseFloat( obj.currentStyle ? obj.currentStyle[attr] : document.defaultView.getComputedStyle(obj, false)[attr], ); let val = i ? i : 0; if (attr == 'opacity') { val *= 100; } return val; } function getStyle(obj, attr) { if (obj.currentStyle) { return obj.currentStyle[attr]; // IE } else { return getComputedStyle(obj, false)[attr]; // standard } } /** * 编写一个函数实现form的序列化(即将一个表单中的键值序列化为可提交的字符串) * aaa bbb qiu de qing description Football Basketball Female Male var form = document.getElementById('target'); console.log(serializeForm(form)); * @param {FormElement} form 需要序列化的表单元素 * @return {string} 表单序列化后的字符串 */ function serializeForm(form) { if (!form || form.nodeName.toUpperCase() !== 'FORM') { return; } var result = []; var i, len; var field, fieldName, fieldType; for (i = 0, len = form.length; i div*4. 2nd div index should be 1 * @method getIndex * @param {[type]} obj [description] * @return {[type]} [description] */ function getIndex(obj) { // var siblingsAndSelf = getChildren(obj.parentNode); var siblingsAndSelf = obj.parentNode.children; for (var i = 0; i = 0; i--) { //if (eles[i].className == classname) { //if (eles[i].className.search(classname) != -1) { //也不行，比如有个class叫largebox。 if (reg.test(eles[i].className)) { //单词边界\\b result.push(eles[i]); } } return result; } //not useful function getByParent(obj, tagname, classname) { // 通过父级的className以及tagName获取元素 var re = new RegExp('(^|\\\\s)' + classname + '(\\\\s|$)'); while (obj.parentNode) { if (obj.parentNode.tagName != tagname) { obj = obj.parentNode; } else { if (re.test(obj.parentNode.className)) { return obj.parentNode; } else { obj = obj.parentNode; } } } } */ Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/工具类/code_Event.html": {
    "url": "Javascript/工具类/code_Event.html",
    "title": "code_Event",
    "keywords": "",
    "body": "1. Event1. Event /** * 请实现一个MyEvent类, 继承自此类的对象都会拥有两个方法on, off, once, trigger; */ function MyEvent() { if (!(this instanceof MyEvent)) { return new MyEvent(); } this._callbacks = {}; } MyEvent.prototype.on = function(type, handler) { this_callbacks = this._callbacks || {}; this._callbacks[type] = this.callbacks[type] || []; this._callbacks[type].push(handler); return this; }; MyEvent.prototype.off = function(type, handler) { var list = this._callbacks[type]; if (list) { for (var i = list.length; i >= 0; --i) { if (list[i] === handler) { list.splice(i, 1); } } } return this; }; MyEvent.prototype.trigger = function(type, data) { var list = this._callbacks[type]; if (list) { for (var i = 0, len = list.length; i Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/工具类/code_Internationalization_localization.html": {
    "url": "Javascript/工具类/code_Internationalization_localization.html",
    "title": "code_Internationalization_localization",
    "keywords": "",
    "body": "1. 国际化 本地化 internationalization localization1. 国际化 本地化 internationalization localization var l10nEN = new Intl.NumberFormat('en-US'); var l10nDE = new Intl.NumberFormat('de-DE'); l10nEN.format(1234567.89) === '1,234,567.89'; l10nDE.format(1234567.89) === '1.234.567,89'; var l10nUSD = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }); var l10nGBP = new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }); var l10nEUR = new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }); l10nUSD.format(100200300.4) === '$100,200,300.40'; l10nGBP.format(100200300.4) === '£100,200,300.40'; l10nEUR.format(100200300.4) === '100.200.300,40 €'; var l10nEN = new Intl.DateTimeFormat('en-US'); var l10nDE = new Intl.DateTimeFormat('de-DE'); l10nEN.format(new Date('2015-01-02')) === '1/2/2015'; l10nDE.format(new Date('2015-01-02')) === '2.1.2015'; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/工具类/code_modal.html": {
    "url": "Javascript/工具类/code_modal.html",
    "title": "code_modal",
    "keywords": "",
    "body": "1. 移动端模态窗 modal1.1. 方案 11.2. 方案 2：js 之 touchmove + preventDefault1.3. 方案 3：移动端滚动穿透问题完美解决方案 ✔️1.4. reference1. 移动端模态窗 modal 移动端当有 fixed 遮罩背景和弹出层时，在屏幕上滑动能够滑动背景下面的内容，这就是著名的滚动穿透问题 1.1. 方案 1 body.modal-open, html.modal-open { overflow: hidden; height: 100%; } 页面弹出层上将 .modal-open 添加到 html 上，禁用 html 和 body 的滚动条 但是这个方案有两个缺点： 由于 html 和 body 的滚动条都被禁用，弹出层后页面的滚动位置会丢失，需要用 js 来还原 页面的背景还是能够有滚动的效果 1.2. 方案 2：js 之 touchmove + preventDefault modal.addEventListener( 'touchmove', function(e) { e.preventDefault(); }, false, ); 这样用 js 阻止滚动后看起来效果不错了，但是也有一个缺点： 弹出层里不能有其它需要滚动的内容（如大段文字需要固定高度，显示滚动条也会被阻止） 1.3. 方案 3：移动端滚动穿透问题完美解决方案 ✔️ body.modal-open { position: fixed; width: 100%; } 如果只是上面的 css，滚动条的位置同样会丢失。所以如果需要保持滚动条的位置需要用 js 保存滚动条位置，关闭的时候还原滚动位置。 /** * ModalHelper helpers resolve the modal scrolling issue on mobile devices * https://github.com/twbs/bootstrap/issues/15852 * requires document.scrollingElement polyfill https://uedsky.com/demo/src/polyfills/document.scrollingElement.js */ var ModalHelper = (function(bodyCls) { var scrollTop; return { afterOpen: function() { scrollTop = document.scrollingElement.scrollTop; document.body.classList.add(bodyCls); document.body.style.top = -scrollTop + 'px'; }, beforeClose: function() { document.body.classList.remove(bodyCls); // scrollTop lost after set position:fixed, restore it back. document.scrollingElement.scrollTop = scrollTop; }, }; })('modal-open'); 例子： body.modal-open { position: fixed; width: 100%; } .modal { background: rgba(0, 0, 0, 0.5); position: fixed; top: 0; right: 0; bottom: 0; left: 0; display: none; } .modal-frame { position: absolute; left: 10%; right: 10%; top: 50%; transform: translateY(-50%); border: solid 1px #ddd; background: #fff; padding: 1em; } Open Modal 这里是可滚动内容 Modal Content Modal Content Modal Content Modal Content Modal Content Modal Content Modal Content Modal Content Modal Content Modal Content Modal Content (function() { /** * ModalHelper helpers resolve the modal scrolling issue on mobile devices * https://github.com/twbs/bootstrap/issues/15852 * requires document.scrollingElement polyfill https://github.com/yangg/scrolling-element */ var ModalHelper = (function(bodyCls) { var scrollTop; return { afterOpen: function() { scrollTop = document.scrollingElement.scrollTop; document.body.classList.add(bodyCls); document.body.style.top = -scrollTop + 'px'; }, beforeClose: function() { document.body.classList.remove(bodyCls); // scrollTop lost after set position:fixed, restore it back. document.scrollingElement.scrollTop = scrollTop; } }; })('modal-open'); function openModal() { document.getElementById('modal').style.display = 'block'; ModalHelper.afterOpen(); } function closeModal() { ModalHelper.beforeClose(); document.getElementById('modal').style.display = 'none'; } document.querySelector('button').onclick = openModal; document.querySelector('#modal').onclick = closeModal; })(); 1.4. reference https://uedsky.com/demo/modal-scroll.html Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/工具类/code_money.html": {
    "url": "Javascript/工具类/code_money.html",
    "title": "code_money",
    "keywords": "",
    "body": "1. Money1. Money /** * 如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』? * @param {Number} num */ function commafy(num) { return ( num && num.toString().replace(/(\\d)(?=(\\d{3})+\\.)/g, function($1, $2) { return $2 + ','; }) ); } /** * 数字转换成金钱，每三位加\",\"。并且控制小数点保留位数 * @param {Number} number 数字 * @param {Number} digit 小数点后保留位数 * toMoney(12345435.34, 2) */ function toMoney(number, digit) { digit = digit > 0 && digit Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/工具类/code_queryString.html": {
    "url": "Javascript/工具类/code_queryString.html",
    "title": "code_queryString",
    "keywords": "",
    "body": "1. queryString1. queryString /** * @param {object} data * 表单数据装配成 queryString */ function encodeFormData(data) { if (!data) return ''; var pairs = []; for (var name in data) { if (!data.hasOwnProperty(name)) continue; if (typeof data[name] === 'function') continue; var value = data[name].toString(); name = encodeURIComponent(name.replace(' ', '+')); value = encodeURIComponent(value.replace(' ', '+')); pairs.push(name + '=' + value); } return pairs.join('&'); } /** * usage: * query string: ?foo=lorem&bar=&baz var foo = getParameterByName('foo'); // \"lorem\" var bar = getParameterByName('bar'); // \"\" (present with empty value) var baz = getParameterByName('baz'); // \"\" (present with no value) var qux = getParameterByName('qux'); // null (absent) Note: If a parameter is present several times (?foo=lorem&foo=ipsum), you will get the first value (lorem). method 2: `URLSearchParams` var searchParams = new URLSearchParams(window.location.search); //?anything=123 console.log(searchParams.get(\"anything\")) //123 method 3: import queryString from 'query-string'; queryString.parse('?playerOneName=wghglory&playerTwoName=ff'); // {playerOneName: \"wghglory\", playerTwoName: \"ff\"} * @param {string} name * @param {string} url */ function getParameterByName(name, url) { if (!url) url = window.location.href; name = name.replace(/[\\[\\]]/g, '\\\\$&'); var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'), results = regex.exec(url); if (!results) return null; if (!results[2]) return ''; return decodeURIComponent(results[2].replace(/\\+/g, ' ')); } /** * 解析query string转换为对象，一个key有多个值时生成数组 * * @param {String} query 需要解析的query字符串，开头可以是?， * console.log(parseQuery('sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8')); * 按照application/x-www-form-urlencoded编码 * @return {Object} 参数解析后的对象 */ function parseQuery(query) { var result = {}; // 如果不是字符串返回空对象 if (typeof query !== 'string') { return result; } // 去掉字符串开头可能带的? if (query.charAt(0) === '?') { query = query.substring(1); } var pairs = query.split('&'); var pair; var key, value; var i, len; for (i = 0, len = pairs.length; i Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/工具类/code_random.html": {
    "url": "Javascript/工具类/code_random.html",
    "title": "code_random",
    "keywords": "",
    "body": "1. 如何实现数组的随机排序？1. 如何实现数组的随机排序？ // 方法一：随意交换某个随机位置和 i 的位置 var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; function randSort1(arr) { for (var i = 0, len = arr.length; i 0) { var randomIndex = parseInt(Math.random() * arr.length); mixedArray.push(arr[randomIndex]); arr.splice(randomIndex, 1); } return mixedArray; } console.log(randSort2(arr)); // 方法三： var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; arr.sort(function() { return Math.random() - 0.5; }); console.log(arr); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/工具类/code_time.html": {
    "url": "Javascript/工具类/code_time.html",
    "title": "code_time",
    "keywords": "",
    "body": "1. Time Helper1.1. Declaratively Programming Demo(functional programming)1.2. 多久之前发布评论1. Time Helper 参考 moment.js export function formatDate(date) { let day = date.getDate(); if (day 1.1. Declaratively Programming Demo(functional programming) /** * compose * @param {functions} fns a list of functions * reduce first para: function second para: initial value cb first para is initial value(arg in this case) cb second para is a item(one item of fns in this case) 目的是执行第一个函数，得到结果再交给第二个函数执行 compose(f1, f2) 是构建传入 function，compose(f1, f2)(initialValue) 是返回最终结果 */ const compose = (...fns) => (arg) => fns.reduce((accu, f) => f(accu), arg); /** Clock Demo */ const oneSecond = () => 1000; const getCurrentTime = () => new Date(); const clear = () => console.clear(); const log = (message) => console.log(message); const abstractClockTime = (date) => ({ hours: date.getHours(), minutes: date.getMinutes(), seconds: date.getSeconds(), }); const civilianHours = (clockTime) => ({ ...clockTime, hours: clockTime.hours > 12 ? clockTime.hours - 12 : clockTime.hours, }); const appendAMPM = (clockTime) => ({ ...clockTime, ampm: clockTime.hours >= 12 ? 'PM' : 'AM', }); const display = (target) => (time) => target(time); const formatClock = (format) => (time) => format .replace('hh', time.hours) .replace('mm', time.minutes) .replace('ss', time.seconds) .replace('tt', time.ampm); const prependZero = (key) => (clockTime) => ({ ...clockTime, [key]: clockTime[key] (arg) => fns.reduce((accu, f) => f(accu), arg); // clockTime 作为 arg，初始值。先 appendAMPM(clockTime)，返回的对象作为 civilianHours 的参数，执行 civilianHours const convertToCivilianTime = (clockTime) => compose(appendAMPM, civilianHours)(clockTime); const doubleDigits = (civilianTime) => compose(prependZero('hours'), prependZero('minutes'), prependZero('seconds'))(civilianTime); const startTicking = () => setInterval( compose( clear, getCurrentTime, abstractClockTime, convertToCivilianTime, doubleDigits, formatClock('hh:mm:ss tt'), display(log), ), oneSecond(), ); startTicking(); 1.2. 多久之前发布评论 const second = 1000, minute = 60 * second, hour = 60 * minute, day = 24 * hour, timeframe = { second, minute, hour, day }, breakpoints = { second: 60, minute: 60, hour: 24, day: 30, }; const toDate = (timeStampString) => new Date(timeStampString); const getDiff = (timestamp, now) => toDate(now) - toDate(timestamp); const isUnderTime = (diff, timeframe, time) => diff / timeframe Math.floor(diff / timeframe); const printResult = (result, timeframeName) => `${result} ${timeframeName + (result > 1 ? 's' : '')}`; const checkDate = (diff, timeframeName, underTime, timeframe) => isUnderTime(diff, timeframe[timeframeName], underTime) ? printResult(diffOverTimeframe(diff, timeframe[timeframeName]), timeframeName) : null; const printFullDate = (dateTime) => `${dateTime.getMonth() + 1}/${dateTime.getDate()}/${dateTime.getFullYear()}`; const lessThanAMinute = (timeString) => timeString.match(/seconds/) ? 'less than a minute' : timeString + ' ago'; const _checkNext = (result, callback) => (result ? lessThanAMinute(result) : callback()); const checkNext = ([tfName, ...rest], timeframe, timestamp, now) => _checkNext(checkDate(getDiff(timestamp, now), tfName, breakpoints[tfName], timeframe), () => howLongAgo(rest, timeframe, timestamp, now), ); const howLongAgo = (remainingTimeframe, timeframe, timestamp, now) => !remainingTimeframe.length ? printFullDate(toDate(timestamp)) : checkNext(remainingTimeframe, timeframe, timestamp, now); export const ago = (timestamp, now = new Date().toString()) => howLongAgo(Object.keys(timeframe), timeframe, timestamp, now); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/工具类/code_view.html": {
    "url": "Javascript/工具类/code_view.html",
    "title": "code_view",
    "keywords": "",
    "body": "1. 页面展示相关 Helper1. 页面展示相关 Helper /** * 获取元素左上角 相对浏览器左上角（0，0）元素的坐标 * @param {object} element * * @return {object} 元素左上角相对浏览器（0，0）坐标和元素宽高(包括 padding，border) */ function getPosition(element) { var rect = element.getBoundingClientRect(); return { x: rect.left, y: rect.top, width: rect.width, height: rect.height }; // let top = 0; // let left = 0; // while (element) { // top += element.offsetTop; // left += element.offsetLeft; // element = element.offsetParent; // } // return { // top, // left // }; } /** * 查询指定窗口的视口尺寸，如果不指定窗口，查询当前窗口尺寸 **/ function getViewportSize(w) { w = w || window; // IE9及标准浏览器中可使用此标准方法 if ('innerHeight' in w) { return { width: w.innerWidth, height: w.innerHeight, }; } var d = w.document; // IE 8及以下浏览器在标准模式下 if (document.compatMode === 'CSS1Compat') { return { width: d.documentElement.clientWidth, height: d.documentElement.clientHeight, }; } // IE8及以下浏览器在怪癖模式下 return { width: d.body.clientWidth, height: d.body.clientHeight, }; } /** * 获取指定window中滚动条的偏移量，如未指定则获取当前 window 滚动条偏移量 * * @param {window} w 需要获取滚动条偏移量的窗口 * @return {Object} obj.x为水平滚动条偏移量,obj.y为竖直滚动条偏移量 */ function getScrollOffset(w) { w = w || window; // 如果是标准浏览器 if (w.pageXOffset != null) { return { x: w.pageXOffset, y: w.pageYOffset, }; } // 老版本IE，根据兼容性不同访问不同元素 var d = w.document; if (d.compatMode === 'CSS1Compat') { return { x: d.documentElement.scrollLeft, y: d.documentElement.scrollTop, }; } return { x: d.body.scrollLeft, y: d.body.scrollTop, }; } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/效果/": {
    "url": "Javascript/效果/",
    "title": "Javascript/效果",
    "keywords": "",
    "body": "1. TOC1. TOC Tween 图片加载 滚动坐标宽高 滚动条自动滑动到底 鼠标进入 div 方向 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Javascript/效果/Tween.html": {
    "url": "Javascript/效果/Tween.html",
    "title": "Tween",
    "keywords": "",
    "body": "1. Tween1. Tween /* * Tween.js * t: current time（当前时间）； * b: beginning value（初始值）； * c: change in value（变化量）； * d: duration（持续时间）。 * you can visit 'http://easings.net/zh-cn' to get effect */ var Tween = { Linear: function(t, b, c, d) { return c * t / d + b; }, Quad: { easeIn: function(t, b, c, d) { return c * (t /= d) * t + b; }, easeOut: function(t, b, c, d) { return -c * (t /= d) * (t - 2) + b; }, easeInOut: function(t, b, c, d) { if ((t /= d / 2) Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/效果/图片加载.html": {
    "url": "Javascript/效果/图片加载.html",
    "title": "图片加载",
    "keywords": "",
    "body": "1. 图片加载1.1. 一张张加载1.2. 图片按需、延迟加载 (Lazy-loading) 三种实现方式1.2.1. 第一种1.3. 第二种 使用 throttle 优化 scroll1.4. 第三种： 使用 IntersectionObserver API1.5. 预加载1. 图片加载 1.1. 一张张加载 // 首先html中的图片不要加路径。src为空 var imgArr = ['a1.png', 'a2.png', 'a3.png', 'a4.png']; var imgElements = document.getElementsByTagName('img'); var i = 0; function loadImage(n) { if (n > imgArr.length - 1) return; imgElements[n].src = imgArr[n]; imgElements[n].onload = function() { loadImage(++i); }; } loadImage(i); 1.2. 图片按需、延迟加载 (Lazy-loading) 三种实现方式 定义：延迟加载也称为惰性加载，即在长网页中延迟加载图像。用户滚动到它们之前，视口外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快。在某些情况下，它还可以帮助减少服务器负载。举个例子来说明，当打开淘宝首页的时候，只有在浏览器窗口里的图片才会被加载，当你滚动首页向下滑的时候，进入视口内的图片才会被加载，而其它从未进入视口的图像不会也不会加载。 那么延迟加载有什么好处： 提升用户的体验，试想一下，如果打开页面的时候就将页面上所有的图片全部获取加载，如果图片数量较大，对于用户来说简直就是灾难，会出现卡顿现象，影响用户体验。 有选择性地请求图片，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。 1.2.1. 第一种 首先将页面上的图片的 src 属性设为 loading.gif，而图片的真实路径则设置在 data-src 属性中，页面滚动的时候计算图片的位置与滚动的位置，当图片出现在浏览器视口内时，将图片的 src 属性设置为 data-src 的值，这样，就可以实现延迟加载。 https://github.com/craigbuckler/progressive-image.js https://codepen.io/craigbuckler/pen/dNpaWp .item { width: 300px; display: inline-block; } .item .itemtitle { font-weight: bold; font-size: 2em; } .hidden { display: none; } Amalgam Comics Characters Dark Claw Super Soldier Spider Boy View more Iron Lantern Amazon Hawkeye var lazy = []; registerListener('load', setLazy); registerListener('load', lazyLoad); registerListener('scroll', lazyLoad); registerListener('resize', lazyLoad); function setLazy() { document.getElementById('listing').removeChild(document.getElementById('viewMore')); document.getElementById('nextPage').removeAttribute('class'); lazy = document.getElementsByClassName('lazy'); console.log('Found ' + lazy.length + ' lazy images'); } function lazyLoad() { for (var i = 0; i = 0 && rect.right >= 0 && rect.top Lazyload 1 img { display: block; margin-bottom: 50px; height: 200px; } function lazyload() { var images = document.getElementsByTagName('img'); var len = images.length; var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 return function () { var seeHeight = document.documentElement.clientHeight; var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; for (var i = n; i 比较 image 的 offsetTop 与 seeHeight + scrollTop 的大小，当小于时则说明图片已经出现过在视口中，这时候继续判断图片是否已经替换过，如果没有替换过，则进行替换。 需要提及的是变量 n 是用来保存已经加载的图片数量，避免每次都从第一张图片开始遍历，提升性能。 1.3. 第二种 使用 throttle 优化 scroll 上面的代码是没什么问题，但是性能偏差。如果直接将函数绑定在 scroll 事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。我粗略地估计一下，当简单地滚动一下页面，函数至少触发了十来次，这显然是十分没必要的。所以在做事件绑定的时候，可以对 lazyload 函数进行函数节流（throttle）与函数去抖（debounce）处理。 Debounce：一部电梯停在某一个楼层，当有一个人进来后，20 秒后自动关门，这 20 秒的等待期间，又一个人按了电梯进来，这 20 秒又重新计算，直到电梯关门那一刻才算是响应了事件。 Throttle：好比一台自动的饮料机，按拿铁按钮，在出饮料的过程中，不管按多少这个按钮，都不会连续出饮料，中间按钮的响应会被忽略，必须要等这一杯的容量全部出完之后，再按拿铁按钮才会出下一杯。 下面就是经过 throttle 处理后的代码： Lazyload 2 img { display: block; margin-bottom: 50px; height: 200px; } function throttle(fn, delay, atleast) { var timeout = null, startTime = new Date(); return function () { var curTime = new Date(); clearTimeout(timeout); if (curTime - startTime >= atleast) { fn(); startTime = curTime; } else { timeout = setTimeout(fn, delay); } } } function lazyload() { var images = document.getElementsByTagName('img'); var len = images.length; var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 return function () { var seeHeight = document.documentElement.clientHeight; var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; for (var i = n; i 设置了 500ms 的延迟，和 1000ms 的间隔，当超过 1000ms 未触发该函数，则立即执行该函数，不然则延迟 500ms 执行该函数。 1.4. 第三种： 使用 IntersectionObserver API 目前有一个新的 IntersectionObserver API，可以自动”观察”元素是否可见，只有 IE 不支持 这里不过多介绍 IntersectionObserver API 的详细使用，感兴趣可以另外阅读下面的文章： IntersectionObserver API 使用教程 > Intersection Observer API Lazyload 3 img { display: block; margin-bottom: 50px; width: 800px; } var io = new IntersectionObserver(function (items) { items.forEach(function (item) { var target = item.target; if (target.getAttribute('src') == 'images/loading.gif') { target.src = target.getAttribute('data-src'); } }) }); Array.from(document.querySelectorAll('img')).forEach(function (item) { io.observe(item); }); IntersectionObserver 传入一个回调函数，当其观察到元素集合出现时候，则会执行该函数。 io.observe 即要观察的元素，要一个个添加才可以。 io 管理的是一个数组，当元素出现或消失的时候，数组添加或删除该元素，并且执行该回调函数。 1.5. 预加载 看漫画，提前加载下一张 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/效果/滚动_坐标_宽高.html": {
    "url": "Javascript/效果/滚动_坐标_宽高.html",
    "title": "滚动坐标宽高",
    "keywords": "",
    "body": "1. 布局-JavaScript1.1. 大小1.1.1. JavaScript 读取宽高1.1.2. JavaScript 设置尺寸1.1.3. JavaScript 间接尺寸读写1.1.4. 元素的右 padding 和下 padding 在内盒边缘还是内容盒子边缘的问题1.1.5. 浏览器视口大小1.2. 位置1.2.1. 文档坐标与视口坐标1.2.2. 相对于 offsetParent 的 offsetTop 和 offsetLeft1.2.3. getBoundingClientRect()1.2.4. clientLeft 和 clientTop1.2.5. 利用 scrollTop 和 scrollLeft 读写1.2.6. 主滚动条位置1.3. 利用 elementFromPoint() 获知在某个点最上面的元素1.4. 利用 scrollIntoView() 将元素滚动到视野内1.5. 精确滚动1.6. jQuery 相关方法1. 布局-JavaScript 1.1. 大小 1.1.1. JavaScript 读取宽高 1、clientWidth 和 clientHeight 内盒大小 + padding 大小，不包含滚动条。对于内联元素 clientWidth clientHeight 总是返回 0。 2、offsetHeight 和 offsetWidth 内盒大小 + padding 大小 + 滚动条大小 + border 大小。getBoundingClientRect() 返回的对象的 height 和 width 与这两个属性等价。 内联元素可能跨多行，因此可能包含多个矩形。如第一行末尾的矩形和第二个开头的矩形。调用内联元素的 getBoundingClientRect() 返回的是包围所有这些矩形的矩形。例如对于换行的内联元素，矩形包含两个行的全部宽度。 3、scrollWidth 和 scrollHeight 该属性会被取整。如果想要小数，使用 element.getBoundingClientRect()。 有滚动条时 子元素的外盒仍然在父元素的内盒内。只是子元素的右 margin 和父元素的右 padding 会被丢弃。上下和左 padding / margin 正常。 scrollWidth 包括子元素的 CSS width 、两侧 padding、两侧 border、左侧 margin，加自身的左侧 padding。即子元素的右侧 margin 和自身的右侧 padding 不包括在 scrollWidth 中。 scrollHeight 包括子元素的 CSS height 、两侧 padding、两侧 border、两侧 margin，加自身的两侧 padding。算法与 scrollWidth 不同。 例子： 外层 div 的 scrollWidth 为 124，scrollHeight 为 258。（Chrome 测试） 无滚动条时（子元素外盒小于父元素内盒） 元素的 scrollWidth 等于其 clientWidth，scrollHeight 等于其 clientHeight；与子元素无关。 4、getComputedStyle() getComputedStyle(element) 返回的对象表示元素计算出的样式属性。width 和 height 返回一个字符串，px 结尾。这两个值的含义取决于浏览器： Chrome 浏览器为内盒的宽高。即 CSS 的 width / height 减去滚动条。 对于其他浏览器，等于 CSS 的 width / height，即内盒大小 + 滚动条。 5、style.width 和 style.height 元素的 style 属性的子属性 width 和 height，它们返回元素内联样式中设置的 width 和 height。若没有设置内联样式返回空。若设置了返回设置了的字符串，设置什么单位就返回什么单位。因此基本上读取这两个属性是没有意义的。 1.1.2. JavaScript 设置尺寸 通过 JavaScript 设置元素个组件大小，只能通过元素的 style 属性，如 div.style.width = \"10px\"。本质上设置的是元素的内联样式。可以设置所有内联样式允许的属性，如 width padding borderTopWidth marginBottom 等。 1.1.3. JavaScript 间接尺寸读写 1、读取滚动条宽度/高度 滚动条宽度 = offsetWidth - clientWidth - pxToNumber(computedStyle.borderLeftWidth) - pxToNumber(computedStyle.borderRightWidth) 滚动条高度类似。 2、读取外盒宽度/高度 外盒宽度 = offsetWidth + pxToNumber(computedStyle.marginLeft) + pxToNumber(computedStyle.marginRight) 外盒高度亦然。 3、设置外盒宽度/高度 思路：我们只能设置内联 CSS 的 width，因此要把外盒宽度转换为此宽度。 style.width = numberToPx(outerWidth - horizontalPBM(computedStyle)) 高度亦然。 4、读取内盒宽度/高度 稳定的方法是用 clientWidth 减去 padding。注意仅在 Chome 下 computedStyle.width 等于内盒宽度。 4、设置内盒宽度/高度 我们想确保内盒为指定尺寸，为了设置 CSS 的宽高时要在指定尺寸基础上加滚动条宽度。 style.width = numberToPx(innerWidth + scrollBarWidth) 1.1.4. 元素的右 padding 和下 padding 在内盒边缘还是内容盒子边缘的问题 参见：http://stackoverflow.com/a/33672058 1.1.5. 浏览器视口大小 与滚动条位置一样，IE8 不支持标准做法，IE 中的可行方法取决于浏览器处于 quirks 模式还是标准模式。下面给出获取视口大小的通用方法： // Return the viewport size as w and h properties of an object function getViewportSize(w) { // Use the specified window or the current window if no argument w = w || window; // This works for all browsers except IE8 and before if (w.innerWidth != null) return { w: w.innerWidth, h: w.innerHeight }; // For IE (or any browser) in Standards mode var d = w.document; if (document.compatMode == 'CSS1Compat') return { w: d.documentElement.clientWidth, h: d.documentElement.clientHeight, }; // For browsers in Quirks mode return { w: d.body.clientWidth, h: d.body.clientWidth }; } 1.2. 位置 1.2.1. 文档坐标与视口坐标 X 轴向右，Y 轴向下。坐标系统原点可以有两个：可以相对于文档的左上角，或文档所在的视口的左上角。定义在 Frame 中的文档，视口 元素。（有时视口坐标也被称为窗口（window）坐标）。 通过 CSS 指定元素位置时使用的是文档坐标。但查询元素位置最简单的方法返回的是视口坐标。在鼠标事件中，鼠标指针的坐标是视口坐标。 1.2.2. 相对于 offsetParent 的 offsetTop 和 offsetLeft offsetTop 和 offsetLeft 是元素节点相对于 offsetParent 的偏移像素。偏移是元素的 border 外边缘到 offsetParent 的 border 内边缘偏移。 offsetParent 是定位祖先：最近的 position 值不为 static 的元素。如果找不到选 元素（或其他 document）。寻找过程中遇到 则选这些元素，即使它们的 position 值为 static。 当 offsetParent 是 ， 且 或 有 margin/padding/border，多数浏览器会把相对于“边框外”改成“边框内”。 1.2.3. getBoundingClientRect() getBoundingClientRect() 返回一个对象，带有 top right bottom left x y width height 8 个属性，表示元素的 border 外边缘相对于浏览器视口左边和顶边的距离。注意 right 是元素右 border 外边缘相对于视口左边而不是右边的距离。bottom 类似。 If you want to query the individual rectangles of inline elements, call the getClientRects() method to obtain a read-only array-like object whose elements are rectangle objects like those returned by getBoundingClientRect(). 1.2.4. clientLeft 和 clientTop clientLeft 和 clientTop 属性返回 padding 外缘和 border 外缘之间的距离，多数情况下就是左边和上边边框的宽度。如果元素有滚动条且滚动条在左面或上边（很少见）clientLeft、clientTop 也包含滚动条宽度。对于内联元素 clientLeft 和 clientTop 总是 0。 没有 clientRight 和 clientBottom。 1.2.5. 利用 scrollTop 和 scrollLeft 读写 scrollTop 和 scrollLeft 表示已被滚动了距离。这两个属性是可写的。 1.2.6. 主滚动条位置 function getScrollOffsets(w) { // Use the specified window or the current window if no argument w = w || window; // 除了 IE8 if (w.pageXOffset != null) return { x: w.pageXOffset, y: w.pageYOffset }; // For IE (or any browser) in Standards mode var d = w.document; if (document.compatMode == 'CSS1Compat') return { x: d.documentElement.scrollLeft, y: d.documentElement.scrollTop }; // For browsers in Quirks mode return { x: d.body.scrollLeft, y: d.body.scrollTop }; } 1.3. 利用 elementFromPoint() 获知在某个点最上面的元素 利用 document 的 elementFromPoint(left, top) 获知在某个点最上面的元素。其中 left、top 是相对于是视口左边与顶边的距离。 如果指定点超出视口，elementFromPoint() 将返回 null，即使这个点转换成文档坐标后是有效的。 elementFromPoint() 看似很有用，如判断当前鼠标经过的元素。但实际鼠标事件已经通过 target 属性包含了这个信息。 elementFromPoint() 很少在实际中使用。 1.4. 利用 scrollIntoView() 将元素滚动到视野内 若一个节点在一个可滚动的容器内，可以让该节点滚动到视野内。 document.querySelector('content').children[4].scrollIntoView(true); 默认尝试令元素上边接近视口上边。如果传入一个 false。则尝试令元素下边接近视口下边。如果需要浏览器还会水平滚动视口让元素可见。 1.5. 精确滚动 scrollTo() 和 scrollBy() 都是 window 对象的方法。 除了设置 scrollTop 或 scrollLeft，还可以使用 scrollTo()（或 scroll()）。传入一个文档坐标，令这个点滚到视口的左上角。如果位置太接近底边或右边，则尽可能滚的远。 例子，滚到文档底部： // 获取文档和视口的高度 var documentHeight = document.documentElement.offsetHeight; var viewportHeight = window.innerHeight; window.scrollTo(0, documentHeight - viewportHeight); scrollBy() 则是增量的。例子： // 每200毫秒滚10像素 javascript: void setInterval(function() { scrollBy(0, 10); }, 200); 1.6. jQuery 相关方法 offset() offset() 方法返回元素的文档坐标。返回的对象包含 left 和 top 两个属性。 传入含有这两个属性的对象可以设置元素位置。如果需要会自动设置 CSS 的 position 属性。 var elt = $('#sprite'); var position = elt.offset(); position.top += 100; elt.offset(position); // Move all elements to the right by a distance that depends on their // position in the document $('h1').offset(function(index, curpos) { return { left: curpos.left + 25 * index, top: curpos.top }; }); position() position() 方法是只读的，返回的位置相对于 offset parent。 offsetParent() 返回元素的定位祖先。 大小 有三组查询元素宽度高度的方法。 width() 和 height() 返回内盒宽高（不包含 padding, border, margin） innerWidth() 和 innerHeight() 返回的宽度和高度中含 padding。 outerWidth() 和 outerHeight() 返回的大小中含有 padding 和 border。调用时传入 true，则同时包含元素的 margin。 var body = $('body'); var contentWidth = body.width(); var paddingWidth = body.innerWidth(); var borderWidth = body.outerWidth(); var marginWidth = body.outerWidth(true); var padding = paddingWidth - contentWidth; var borders = borderWidth - paddingWidth; var margins = marginWidth - borderWidth; 对于 Window， width() 和 height() 返回窗口的视口大小。对于 Document，width() 和 height() 返回窗口的文档大小。其他方法只能对元素调用。 width() 和 height() 还可以设置元素的宽高。若只传入数字，单位取像素。如果传入字符串，会被当成 CSS 宽度高度值，可以任意单位。 如果元素使用了 box-sizing: border-box，则设置的值中含 border 和 padding。 滚动 scrollTop() 和 scrollLeft() 用于读取、设置元素滚动条位置。两个方法能用于 Window 对象或 Document 元素。如果对 Document 调用，则返回或设置包含文档的 Window 对象的滚动条位置。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/效果/滚动条自动滑动到底.html": {
    "url": "Javascript/效果/滚动条自动滑动到底.html",
    "title": "滚动条自动滑动到底",
    "keywords": "",
    "body": "1. 滚动条自动滑动到底1. 滚动条自动滑动到底 有一个 div，里面是一个 input，下面创建按钮。点击创建按钮后在按钮上面创建新的 input。这样可以添加多个 input。div 高度固定，overflow auto。我想在添加新的 input 后 scroll 到底部，这样能一直看到新添加的 input 和创建按钮。 let newInput = document.createElement('input'); newInput.type = 'text'; newInput.classList.add('form-control'); newInput.placeholder = '请输入要素'; parentDiv.insertBefore(newInput, createButtonElement); newInput.focus(); parentDiv.scrollTop = divEle.scrollHeight; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/效果/鼠标进入div方向.html": {
    "url": "Javascript/效果/鼠标进入div方向.html",
    "title": "鼠标进入 div 方向",
    "keywords": "",
    "body": "1. 判断鼠标进入 div 的方向1. 判断鼠标进入 div 的方向 .demo { width: 400px; height: 300px; background-color: pink; margin: 100px auto; } $(function () { $('div').on('mouseenter mouseleave', function (e) { var w = $(this).width(); // 得到盒子宽度 var h = $(this).height(); // 得到盒子高度 var x = (e.pageX - this.offsetLeft - (w / 2)) * (w > h ? (h / w) : 1); var y = (e.pageY - this.offsetTop - (h / 2)) * (h > w ? (w / h) : 1); var direction = Math.round((((Math.atan2(y, x) * (180 / Math.PI)) + 180) / 90) + 3) % 4; //direction的值为“0,1,2,3”分别对应着“上，右，下，左” // 将点的坐标对应的弧度值换算成角度度数值 var dirName = new Array('上方', '右侧', '下方', '左侧'); if (e.type == 'mouseenter') { $(this).html(dirName[direction] + '进入'); } else { $(this).html(dirName[direction] + '离开'); } }); }) Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Javascript/模版编译.html": {
    "url": "Javascript/模版编译.html",
    "title": "模版编译",
    "keywords": "",
    "body": "1. 模板编译1. 模板编译 一个通过模板字符串生成正式模板的实例: var template = ` `; 该模板使用放置 JavaScript 代码，使用输出 JavaScript 表达式。将其转换为 JavaScript 表达式字符串。 echo(''); for (var i = 0; i '); echo(data.supplies[i]); echo(''); } echo(''); 这个转换使用正则表达式就行了。 function compile(template) { var outputExpression = //g; var expr = //g; template = template .replace(outputExpression, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`'); template = 'echo(`' + template + '`);'; console.log(template); // echo(``); // for (var i = 0; i `); // echo(data.supplies[i]); // echo(``); // } // echo(``); var script = `(function parse(data){ var output = \"\"; function echo(html){ output += html; } ${template} return output; })`; return script; } compile 函数的用法如下: var template = ` `; var parse = eval(compile(template)); console.log(parse); console.log( parse({ supplies: ['broom', 'mop', 'cleaner'], }), ); // div.innerHTML = parse({ supplies: [\"broom\", \"mop\", \"cleaner\"] }); // // broom // mop // cleaner // Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Mobile/": {
    "url": "Mobile/",
    "title": "Mobile",
    "keywords": "",
    "body": "1. TOC1. TOC Android drag rem scss touch viewport zepto 常见问题 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Mobile/Android.html": {
    "url": "Mobile/Android.html",
    "title": "Android",
    "keywords": "",
    "body": "1. 疑难杂症1.1. Android1.1.1. Android WebView :active 失效1. 疑难杂症 1.1. Android 1.1.1. Android WebView :active 失效 Android WebView :active 失效，即点击瞬间的效果无法被触发。最简单的解决办法是，添加： 详情讨论见：http://stackoverflow.com/questions/4940429/how-to-simulate-active-css-pseudo-class-in-android-on-non-link-elements Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Mobile/drag.html": {
    "url": "Mobile/drag.html",
    "title": "drag",
    "keywords": "",
    "body": "1. 移动端拖拽1. 移动端拖拽 /** * 移动端拖拽 * 元素绝对定位，父级相对定位 * 如果父级为window，则可以只传一个参数，物体相对于window范围拖动 * 传2个参数，则父级为第二个参数，物体相对于父级范围拖动 * 参数为id值 * @param {node} obj drag target * @param {node} parentNode */ JC.tools.drag = function(obj, parentNode) { var pWidth, pHeight; if (arguments.length == 1) { parentNode = window.self; pWidth = parentNode.innerWidth; pHeight = parentNode.innerHeight; } else { pWidth = parentNode.clientWidth; pHeight = parentNode.clientHeight; } obj.addEventListener('touchstart', function(event) { //当只有一个手指时 . if (event.touches.length === 1) { event.preventDefault(); } var touch = event.targetTouches[0]; var disX = touch.clientX - obj.offsetLeft, disY = touch.clientY - obj.offsetTop; var oWidth = obj.offsetWidth, oHeight = obj.offsetHeight; function moving(event) { var touch = event.targetTouches[0]; obj.style.left = touch.clientX - disX + 'px'; obj.style.top = touch.clientY - disY + 'px'; //左侧 if (obj.offsetLeft = pWidth - oWidth) { obj.style.left = pWidth - oWidth + 'px'; } //上面 if (obj.offsetTop = pHeight - oHeight) { obj.style.top = pHeight - oHeight + 'px'; } } obj.addEventListener('touchmove', moving); obj.addEventListener('touchend', function() { obj.removeEventListener('touchmove', moving); obj.removeEventListener('touchend', moving); }); }); }; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Mobile/rem.html": {
    "url": "Mobile/rem.html",
    "title": "rem",
    "keywords": "",
    "body": "1. Rem 布局1. Rem 布局 窗口 resize 时候 和 初始化 时根据视窗宽度计算 html fontSize，从而改变 rem。以下 js 放到相对靠前的位置。 (function(doc, win) { var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function() { var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 16 * (clientWidth / 375) + 'px'; }; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false); })(document, window); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Mobile/scss.html": {
    "url": "Mobile/scss.html",
    "title": "scss",
    "keywords": "",
    "body": "1. 移动端基础样式1.1. Use gulp to build scss1. 移动端基础样式 _mixin.scss: //基础font-size $font: 16; //设计稿宽度 $screen: 750; @function px2rem($n) { @return #{$n/($screen * $font/375)}rem; } @function calcPX($m, $n) { @return calc(#{$m} - #{$n/($screen * $font/375)}rem); } $backgroundGray: rgb(250, 250, 250); $mainGreen: #00c993; $borderGray: #eee; $lightGray: #a4a7c0; reset.scss: (pc, mobile both work) @import 'mixin'; body, p, h1, h2, h3, h4, h5, h6, dl, dd { margin: 0; padding: 0; font-size: px2rem(16); } ol, ul { list-style: none; padding: 0; margin: 0; font-size: px2rem(16); } a { text-decoration: none; font-size: px2rem(16); font-family: 'PingFang SC', sans-serif; } img { border: none; vertical-align: top; } /*图片下没缝隙用vertical-align*/ th, td { padding: 0; } table { border-collapse: collapse; } form { margin: 0; } input, button { font-size: px2rem(16); margin: 0; padding: 0; vertical-align: top; outline: none; border: 0; font-weight: 200; -webkit-appearance: none; } @mixin placeholderMixin { color: $lightGray; font-size: px2rem(16); font-weight: 200; letter-spacing: 4px; } ::-webkit-input-placeholder { /* WebKit browsers */ @include placeholderMixin; } :-moz-placeholder { /* Mozilla Firefox 4 to 18 */ @include placeholderMixin; } ::-moz-placeholder { /* Mozilla Firefox 19+ */ @include placeholderMixin; } :-ms-input-placeholder { /* Internet Explorer 10+ */ @include placeholderMixin; } select { margin: 0; } textarea { margin: 0; padding: 0; resize: none; overflow: auto; outline: none; -webkit-appearance: none; } .clear { zoom: 1; } .clear:after { content: ''; display: block; clear: both; } common.scss: html, body { height: 100%; font-family: 'PingFang SC', sans-serif; } .gray { background: rgb(250, 250, 250); } a:hover, a:visited, a:link, a:active { color: #ffffff; } .flexbox { display: flex; justify-content: center; align-items: center; } .flexbox-vertical { display: flex; flex-direction: column; justify-content: center; align-items: center; } .container { height: 100%; } .show { display: block; } .hide { display: none; } 在某个页面使用 mixin 定义的函数 @import 'mixin'; main { padding: 0 px2rem(15); padding-top: px2rem(45); height: calcPX(100%, 60); overflow-y: auto; } 1.1. Use gulp to build scss \"scripts\": { \"scss\": \"gulp watch\" }, \"devDependencies\": { \"gulp\": \"^3.9.1\", \"gulp-autoprefixer\": \"^3.1.1\", \"gulp-sass\": \"^3.1.0\", \"gulp-uglify\": \"^2.1.2\", \"gulp-util\": \"^3.0.8\", } gulpfile.js: var gulp = require('gulp'); // sass 插件var var sass = require('gulp-sass'); // 给css3属性添加浏览器前缀插件 var autoprefixer = require('gulp-autoprefixer'); // 编译sass文件，添加css3属性浏览器前缀 gulp.task('sass', function() { return gulp .src('./scss/*.scss') .pipe(sass()) .pipe(autoprefixer()) .pipe(gulp.dest('./css')); }); // 监控任务 gulp.task('watch', ['sass'], function() { gulp.watch('./scss/*.scss', ['sass']); }); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Mobile/touch.html": {
    "url": "Mobile/touch.html",
    "title": "touch",
    "keywords": "",
    "body": "1. 移动端 touch 事件1.1. touch 事件中的 touches、targetTouches 和 changedTouches1.1.1. 触点坐标选取1.2. touchmove 事件对象的获取1.3. 为何不用 click 以及 tap 由来1.4. 点击穿透的场景1.4.1. 解决“点透”问题1.5. reference1. 移动端 touch 事件 1.1. touch 事件中的 touches、targetTouches 和 changedTouches touches: 当前屏幕上所有触摸点的列表 targetTouches: 当前对象上所有触摸点的列表 changedTouches: 涉及当前(引发)事件的触摸点的列表 通过一个例子来区分一下触摸事件中的这三个属性： 用一个手指接触屏幕，触发事件，此时这三个属性有相同的值。 用第二个手指接触屏幕，此时，touches 有两个元素，每个手指触摸点为一个值。当两个手指触摸相同元素时，targetTouches 和 touches 的值相同，否则 targetTouches 只有一个值。changedTouches 此时只有一个值，为第二个手指的触摸点，因为第二个手指是引发事件的原因 用两个手指同时接触屏幕，此时 changedTouches 有两个值，每一个手指的触摸点都有一个值 手指滑动时，三个值都会发生变化 一个手指离开屏幕，touches 和 targetTouches 中对应的元素会同时移除，而 changedTouches 仍然会存在元素。 手指都离开屏幕之后，touches 和 targetTouches 中将不会再有值，changedTouches 还会有一个值，此值为最后一个离开屏幕的手指的接触点。 1.1.1. 触点坐标选取 touchstart 和 touchmove 使用: e.targetTouches[0].pageX 或 (jquery)e.originalEvent.targetTouches[0].pageX touchend 使用: e.changedTouches[0].pageX 或 (jquery)e.originalEvent.changedTouches[0].pageX 1.2. touchmove 事件对象的获取 想要在 touchmove:function(e, 参数一) 加一个参数，结果直接使用 e.preventDefault() 就会 e 报错，处理方法为使用 arguments[0] 获取 event 参数 obj.addEventListener('touchmove', function(e, 参数一) { var e = arguments[0]; e.preventDefault(); }); 1.3. 为何不用 click 以及 tap 由来 用过 Zepto 或 KISSY 等移动端 js 库的人肯定对 tap 事件不陌生，我们做 PC 页面时绑定 click，相应地手机页面就绑定 tap。但原生的 touch 事件本身是没有 tap 的，js 库里提供的 tap 事件都是模拟出来的。 手机上响应 click 事件会有 300ms 的延迟，浏览器在 touchend 后会等待约 300ms，原因是判断用户是否有双击（double tap）行为。如果没有 tap 行为，则触发 click 事件，而双击过程中就不适合触发 click 事件了。 Zepto tap 就是为了解决 click 300ms 延迟而产生的。tap 事件是模拟出来的，Zepto 对 singleTap 事件的处理：在 touchend 响应 250ms 无操作后，则触发 singleTap。 1.4. 点击穿透的场景 我们经常会看到“弹窗/浮层”这种东西 整个容器里有一个底层元素的 div，和一个弹出层 modal div 底层元素 弹出层 关闭 然后为底层元素绑定 click 事件，而弹出层的关闭按钮绑定 tap 事件。 // hide modal $('#closePopup').on('tap', function(e) { $('#popupLayer').hide(); $('#bgMask').hide(); }); // 底层有 click 事件，或者底层是个 a, input $('#underLayer').on('click', function() { alert('underLayer clicked'); }); zepto 的 tap 通过兼听绑定在 document 上的 touch 事件来完成 tap 事件的模拟的，tap 事件是冒泡到 document 上触发的。而在冒泡到 document 之前，用户手的接触屏幕(touchstart)和离开屏幕(touchend)是会触发 click 事件的。因为 click 事件有延迟触发，所以在执行完 tap 事件之后，modal 组件马上就隐藏了，此时 click 事件还在延迟的 300ms 之中。当 300ms 到来的时候，click 到的其实是 modal 下方的元素，如果正下方的元素绑定的有 click 事件此时便会触发，如果没有绑定 click 事件的话就当没 click，但是正下方的是 input 输入框(或者选择框或者单选复选框)，点击默认聚焦而弹出输入键盘，这就是常出现的“点透”的情况。 1.4.1. 解决“点透”问题 引入 fastclick.js，因为 fastclick 源码不依赖其他库所以你可以在原生的 js 前直接加上。https://github.com/ftlabs/fastclick。思路是取消 click 事件（参看源码 164-173 行），用 touchend 模拟快速点击行为（参看源码 521-610 行）。 window.addEventListener( 'load', function() { FastClick.attach(document.body); }, false, ); 用 touchend 代替 tap 事件并阻止掉 touchend 的默认行为 $('#layer').on('touchend', function(event) { //很多处理比如隐藏什么的任务 event.preventDefault(); }); 延迟一定的时间(300ms+)来处理事件。（可以和 fadeInIn/fadeOut 等动画结合使用，可以做出过度效果） $('#layer').on('tap', function(event) { setTimeout(function() { //程序处理 }, 320); }); 遮挡(╮(╯﹏╰)╭)。动态地在触摸位置生成一个透明的元素，这样当上层元素消失而延迟的 click 来到时，它点击到的是那个透明的元素，也不会“穿透”到底下。在一定的 timeout 后再将生成的透明元素移除。 pointer-events 是 CSS3 中的属性(比较麻烦且有缺陷，不建议使用) auto：效果和没有定义 pointer-events 属性相同，鼠标不会穿透当前层。 none：元素不再是鼠标事件的目标，鼠标不再监听当前元素。但是如果它的子元素设置了 pointer-events 为其它值，比如 auto，鼠标还是会监听这个子元素的。 $('#closePopup').on('tap', function(e) { $('#popupLayer').hide(); $('#bgMask').hide(); // close button tap 时下层元素不被监听 $('#underLayer').css('pointer-events', 'none'); // 下层元素恢复监听 setTimeout(function() { $('#underLayer').css('pointer-events', 'auto'); }, 400); }); 1.5. reference http://www.cnblogs.com/yexiaochai/p/3462657.html 对于需要同时绑定 tap 和 touchmove 的元素：https://segmentfault.com/a/1190000005791890 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Mobile/viewport.html": {
    "url": "Mobile/viewport.html",
    "title": "viewport",
    "keywords": "",
    "body": "1. Viewport1. Viewport width [pixel_value | device-width] width 直接去设置具体数值大部分的安卓手机不支持的 但是 IOS 支持 user-scalable 是否允许缩放 （no||yes） initial-scale 初始比例 minimum-scale 允许缩放的最小比例 maximum-scale 允许缩放的最大比例 target-densitydpi dpi_value 70–400 //每英寸像素点的个数 device-dpi 设备默认像素密度 high-dpi 高像素密度 medium-dpi 中等像素密度 low-dpi 低像素密度 webkit 内核已不准备再支持 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Mobile/zepto.html": {
    "url": "Mobile/zepto.html",
    "title": "zepto",
    "keywords": "",
    "body": "1. 移动端使用 zepto 而不是 jquery1. 移动端使用 zepto 而不是 jquery 项目引入 zepto.js, zepto.touch.js。之后才可以用 tap 等 touch 事件 zepto.touch.js: // Zepto.js // (c) 2010-2016 Thomas Fuchs // Zepto.js may be freely distributed under the MIT license. (function($) { var touch = {}, touchTimeout, tapTimeout, swipeTimeout, longTapTimeout, longTapDelay = 750, gesture, down, up, move, eventMap, initialized = false; function swipeDirection(x1, x2, y1, y2) { return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? x1 - x2 > 0 ? 'Left' : 'Right' : y1 - y2 > 0 ? 'Up' : 'Down'; } function longTap() { longTapTimeout = null; if (touch.last) { touch.el.trigger('longTap'); touch = {}; } } function cancelLongTap() { if (longTapTimeout) clearTimeout(longTapTimeout); longTapTimeout = null; } function cancelAll() { if (touchTimeout) clearTimeout(touchTimeout); if (tapTimeout) clearTimeout(tapTimeout); if (swipeTimeout) clearTimeout(swipeTimeout); if (longTapTimeout) clearTimeout(longTapTimeout); touchTimeout = tapTimeout = swipeTimeout = longTapTimeout = null; touch = {}; } function isPrimaryTouch(event) { return ( (event.pointerType == 'touch' || event.pointerType == event.MSPOINTER_TYPE_TOUCH) && event.isPrimary ); } function isPointerEventType(e, type) { return e.type == 'pointer' + type || e.type.toLowerCase() == 'mspointer' + type; } // helper function for tests, so they check for different APIs function unregisterTouchEvents() { if (!initialized) return; $(document) .off(eventMap.down, down) .off(eventMap.up, up) .off(eventMap.move, move) .off(eventMap.cancel, cancelAll); $(window).off('scroll', cancelAll); cancelAll(); initialized = false; } function setup(__eventMap) { var now, delta, deltaX = 0, deltaY = 0, firstTouch, _isPointerType; unregisterTouchEvents(); eventMap = __eventMap && 'down' in __eventMap ? __eventMap : 'ontouchstart' in document ? { down: 'touchstart', up: 'touchend', move: 'touchmove', cancel: 'touchcancel', } : 'onpointerdown' in document ? { down: 'pointerdown', up: 'pointerup', move: 'pointermove', cancel: 'pointercancel', } : 'onmspointerdown' in document ? { down: 'MSPointerDown', up: 'MSPointerUp', move: 'MSPointerMove', cancel: 'MSPointerCancel', } : false; // No API availables for touch events if (!eventMap) return; if ('MSGesture' in window) { gesture = new MSGesture(); gesture.target = document.body; $(document).bind('MSGestureEnd', function(e) { var swipeDirectionFromVelocity = e.velocityX > 1 ? 'Right' : e.velocityX 1 ? 'Down' : e.velocityY 0 && delta 30) || (touch.y2 && Math.abs(touch.y1 - touch.y2) > 30) ) swipeTimeout = setTimeout(function() { if (touch.el) { touch.el.trigger('swipe'); touch.el.trigger('swipe' + swipeDirection(touch.x1, touch.x2, touch.y1, touch.y2)); } touch = {}; }, 0); else if ('last' in touch) if (deltaX \"TypeError: 'undefined' is not an object (evaluating 'touch.el.trigger'), when double tap if (touch.el) touch.el.trigger(event); // trigger double tap immediately if (touch.isDoubleTap) { if (touch.el) touch.el.trigger('doubleTap'); touch = {}; } else { // trigger single tap after 250ms of inactivity touchTimeout = setTimeout(function() { touchTimeout = null; if (touch.el) touch.el.trigger('singleTap'); touch = {}; }, 250); } }, 0); } else { touch = {}; } deltaX = deltaY = 0; }; $(document) .on(eventMap.up, up) .on(eventMap.down, down) .on(eventMap.move, move); // when the browser window loses focus, // for example when a modal dialog is shown, // cancel all ongoing events $(document).on(eventMap.cancel, cancelAll); // scrolling the window indicates intention of the user // to scroll, not tap or swipe, so cancel all ongoing events $(window).on('scroll', cancelAll); initialized = true; } [ 'swipe', 'swipeLeft', 'swipeRight', 'swipeUp', 'swipeDown', 'doubleTap', 'tap', 'singleTap', 'longTap', ].forEach(function(eventName) { $.fn[eventName] = function(callback) { return this.on(eventName, callback); }; }); $.touch = { setup: setup }; $(document).ready(setup); })(Zepto); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Mobile/常见问题.html": {
    "url": "Mobile/常见问题.html",
    "title": "常见问题",
    "keywords": "",
    "body": "1. 常见问题1.1. 触摸事件的介绍1.2. 基本知识点1.3. 屏幕旋转事件(onorientationchange)1. 常见问题 1.1. 触摸事件的介绍 Gestures 这个事件针对 IOS 设备上的，一个 Gestures 事件在两个或更多手指触摸屏幕时触发。如果任何手指你正在监听的 Gesture 事件(gesturestart，gesturechange，gestureend)节点上，你将收到对应的 gestures 事件。 Gesturestart：当一个手指已经按在屏幕上，而另一个手指又触摸在屏幕时触发。 Gesturechange：当触摸屏幕的任何一个手指的位置发生改变的时候触发。 Gestureend：当任何一个手指从屏幕上面移开时触发。 触摸事件和手势事件的之间关系： 当一个手指放在屏幕上时，会触发 touchstar t 事件，而另一个手指触摸在屏幕上时触发 gesturestart 事件，随后触发基于该手指的 touchstart 事件。 如果一个或两个手指在屏幕上滑动时，将会触发 gesturechange 事件，但是只要有一个手指移开时候，则会触发 gestureend 事件，紧接着会触发 touchend 事件。 手势的专有属性： rotation: 表示手指变化引起的旋转角度，负值表示逆时针，正值表示顺时针，从 0 开始； scale: 表示 2 个手指之间的距离情况，向内收缩会缩短距离，这个值从 1 开始的，并随距离拉大而增长。 1.2. 基本知识点 判断是否为 iPhone // 判断是否为 iPhone ： function isAppleMobile() { return navigator.platform.indexOf('iPad') != -1; } 自动大写与自动修正 要关闭这两项功能，可以通过 autocapitalize 与 autocorrect 这两个选项： 禁止 iOS 弹出各种操作窗口 -webkit-touch-callout: none; 禁止用户选中文字 -webkit-user-select: none; 关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格 this.value = this.value.replace(/u2006/g, ''); Android 上去掉语音输入按钮 input::-webkit-input-speech-button { display: none; } 判断是否为微信浏览器； function is_weixn() { var ua = navigator.userAgent.toLowerCase(); if (ua.match(/MicroMessenger/i) == 'micromessenger') { return true; } else { return false; } } 1.3. 屏幕旋转事件(onorientationchange) 判断屏幕是否旋转的 JS 代码如下： function orientationChange() { switch (window.orientation) { case 0: alert('肖像模式 0,screen-width: ' + screen.width + '; screen-height:' + screen.height); break; case -90: alert('左旋 -90,screen-width: ' + screen.width + '; screen-height:' + screen.height); break; case 90: alert('右旋 90,screen-width: ' + screen.width + '; screen-height:' + screen.height); break; case 180: alert('风景模式 180,screen-width: ' + screen.width + '; screen-height:' + screen.height); break; } } // 添加测试监听函数代码如下： addEventListener('load', function() { orientationChange(); window.onorientationchange = orientationChange; }); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Nodejs/": {
    "url": "Nodejs/",
    "title": "Nodejs",
    "keywords": "",
    "body": "1. TOC1. TOC npm Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Nodejs/npm.html": {
    "url": "Nodejs/npm.html",
    "title": "npm",
    "keywords": "",
    "body": "1. NPM commands1. NPM commands check a package versions: npm view ng-zorro-antd versions (https://docs.npmjs.com/cli/view.html) Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/": {
    "url": "ProjectConfig/",
    "title": "ProjectConfig",
    "keywords": "",
    "body": "1. TOC1. TOC Mock npm_scripts_over_gulp webpack Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "ProjectConfig/Javacript-Starter/": {
    "url": "ProjectConfig/Javacript-Starter/",
    "title": "ProjectConfig/Javacript-Starter",
    "keywords": "",
    "body": "1. TOC1. TOC 01_Consideration 02_Editors_Configuration 03_package_managers 04_devServer 05_automation 06_transpiling 07_bundle_webpack_rollup 08_linting 09_testing_CI 10_httpcall_mock 11_structure 12_production_build 13_deployment Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "ProjectConfig/Javacript-Starter/01_Consideration.html": {
    "url": "ProjectConfig/Javacript-Starter/01_Consideration.html",
    "title": "01_Consideration",
    "keywords": "",
    "body": "1. Things to be considered1.1. What belongs in Starter Kit1. Things to be considered Editor Which one? Which plugins? Use built in terminal? Editor config Module format ES6 Modules, CommonJS... HTML generation Minify? Use plugin? Inject prod only concerns? Templating language? Transpiling Native ES or diff language? Use experimental features? Which plugins? Production vs dev config Bundler Webpack, Browserify, Rollup... Linting Which linter? Enable which rules? Warning or error? Which plugins? Use a preset? Testing Framework? Assertion Library? Helpers? Test file location? File naming? What environment? Mocking? Code Coverage Continuous Integration Project structure By file type or feature? Centralize API? Allow Inline JS? Extract to POJOs? HTTP Library Mock schema format Mock data generation Mock server Production build Minification Sourcemaps Bundle splitting Cache busting Error logging 1.1. What belongs in Starter Kit Package Management Bundling Minification Sourcemaps Transpiling Dynamic HTML Generation Centralized HTTP Mock API framework Component libraries Development Webserver Linting Automated testing Continuous Integration Automated build Automated deployment Working example app Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/Javacript-Starter/02_Editors_Configuration.html": {
    "url": "ProjectConfig/Javacript-Starter/02_Editors_Configuration.html",
    "title": "02_Editors_Configuration",
    "keywords": "",
    "body": "1. Editors, Configuration1.1. Editor (Vscode, atom, webstorm, brackets)1.2. Automated Consistency via EditorConfig1. Editors, Configuration 1.1. Editor (Vscode, atom, webstorm, brackets) Strong ES2015+ support Autocompletion Parse ES6 imports Report unused imports Automated refactoring Framework intelligence Built in terminal 1.2. Automated Consistency via EditorConfig .editorconfig: # editorconfig.org root = true [*] indent_style = space # hit tab, editorconfig converts it into 2 spaces indent_size = 2 end_of_line = lf # line feed, \\n charset = utf-8 trim_trailing_whitespace = true insert_final_newline = true [*.md] trim_trailing_whitespace = false Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/Javacript-Starter/03_package_managers.html": {
    "url": "ProjectConfig/Javacript-Starter/03_package_managers.html",
    "title": "03_package_managers",
    "keywords": "",
    "body": "1. Package Managers1.1. Security Scanning1.1.1. Usage of node security platform1. Package Managers npm, bower, jspm, jam, volo npm is best, because it offers everything, like linting, transpiling, etc. 1.1. Security Scanning Anyone can creates npm package, so we need to security scanning. retire.js node security platform (better) 1.1.1. Usage of node security platform npm install -g nsp cd your-project nsp check # result usually: (+) No known vulnerabilities found When to Run Security Check Manually - Easy to forget npm install - May be issue later production build - Expensive to change pull request - Expensive to change npm start - Slows start slightly Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/Javacript-Starter/04_devServer.html": {
    "url": "ProjectConfig/Javacript-Starter/04_devServer.html",
    "title": "04_devServer",
    "keywords": "",
    "body": "1. Development Web Servers1.1. Express setup1.2. Sharing work-in-progress1.2.1. localtunnel (great!)1.2.2. ngrok1.2.3. now1.2.4. Surge1. Development Web Servers http-server: Ultra -simple, Single command serves current directory live-server: Lightweight, Support live-reloading Express: Comprehensive, Highly Configurable, Production grade, Can run it everywhere budo: Integrates with Browserify, Includes hot reloading Webpack dev server: Built in to Webpack, Serves from memory, Includes hot reloading Browsersync: Dedicated IP for sharing work on LAN. ==All interactions remain in sync!== Great for cross-device testing. Integrates with Webpack, Browserify, Gulp 1.1. Express setup /** express dev server */ let express = require('express'); let path = require('path'); let open = require('open'); let port = 3000; let app = express(); app.get('/', (req, res) => { res.sendFile(path.join(__dirname, '../src/index.html')); }); app.listen(port, (err) => { if (err) { console.log(err); } else { open(`http://localhost:${port}`); } }); 1.2. Sharing work-in-progress localtunnel ngrok Surge now 1.2.1. localtunnel (great!) Easiest setup Ultra-versatile. Easily share work on your local machine. 让内网服务器暴露到公网上的开源项目 Setup: 1. `npm install localtunnel -g` 2. Start your app, if port is 3000 3. `lt --port 3000` or `lt --port 3000 --subdomain wghglory` Result is like: your url is: https://pgerjpkszz.localtunnel.me or https://wghglory.localtunnel.me Note: multiple devices, use browserSync and localtunnel together 1.2.2. ngrok Easy setup Secure. Secure tunnel to your local machine Sign up Install ngrok Install authtoken Start your app ./ngrok http 80 1.2.3. now No firewall hole Hosting persists. Quickly deploy Node.js to the cloud npm install -g now Create start script now 1.2.4. Surge No firewall hole Hosting persists. Quickly host static files to public URL npm install -g surge surge Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/Javacript-Starter/05_automation.html": {
    "url": "ProjectConfig/Javacript-Starter/05_automation.html",
    "title": "05_automation",
    "keywords": "",
    "body": "1. Automation1.1. Why npm Scripts1.1.1. Usage1. Automation Grunt The \"original\" Configuration over code Writes intermediary (中间的) files between steps Large plugin ecosystem Gulp In-memory streams Fast Code over configuration Large plugin ecosystem npm Scripts Declared in package.json Leverage your OS command line Directly use npm packages Call separate Node scripts Convention-based pre/post hooks Leverage world's largest package manager 1.1. Why npm Scripts Use tools directly No need for separate plugins Simpler debugging Better docs Easy to learn Simple Previous project I used gulp, gulp-eslint. There is a strange bug when I stop watching files once I have a certain number of files. I have to figure out was the bug in gulp? Eslint? gulp-eslint? my gulp config? I have to wait the author to update their plugins. 1.1.1. Usage Run concurrently: \"start\": \"npm-run-all --parallel security-check start:server\", \"start2\": \"npm run security-check & npm run start:server\", Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/Javacript-Starter/06_transpiling.html": {
    "url": "ProjectConfig/Javacript-Starter/06_transpiling.html",
    "title": "06_transpiling",
    "keywords": "",
    "body": "1. Transpiling1.1. Babel for nodejs1. Transpiling Babel Standardized JS Leverage full JS Ecosystem experimental features earlier No type defs, annotations required Test, lint, great libs Typescript Superset of Javascript Enhanced AutoCompletion Safer refactoring Clearer intent Additional non-standard features like interface Elm Compiles down to JS Clean Syntax Immutable data structures Friendly errors All errors are compile-time errors Interops with JS 1.1. Babel for nodejs .babelrc: { \"presets\": [ // \"env\", // \"react\" \"latest\" ] } Use babel-node buildScripts/startMessage instead of node buildScripts/startMessage so node.js can use import new features. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/Javacript-Starter/07_bundle_webpack_rollup.html": {
    "url": "ProjectConfig/Javacript-Starter/07_bundle_webpack_rollup.html",
    "title": "07_bundle_webpack_rollup",
    "keywords": "",
    "body": "1. Why bundling1.1. Module Format1.2. Why Use ES6 Modules1.3. Bundler1.3.1. Browserify1.3.2. Webpack1.3.3. Rollup1.3.4. JSPM1.4. Sourcemaps1. Why bundling CommonJS doesn't work in web browsers Package project into file(s) Improve Node performance 1.1. Module Format IIFE Asynchronous Module Definition (AMD) CommonJS (CJS) Universal Module Definition (UMD) ES6 Modules 1.2. Why Use ES6 Modules Standardized Statically analyzable Improved autocomplete Intelligent refactoring Fails fast Tree shaking Easy to read Named imports Default exports 1.3. Bundler require.js (old) Browserify Webpack Rollup JSPM 1.3.1. Browserify The first bundler to reach mass adoption Bundle npm packages for the web Large plugin ecosystem 1.3.2. Webpack loaders, plugins Bundles more than just JS Import CSS, images, etc like JS Bundle splitting Built in hot-reloading web server Webpack 2 offers tree shaking: using ES6 import so tree shaking will be ready for you 1.3.3. Rollup Tree shaking Faster loading production code Quite new Great for library authors No hot reloading and code splitting yet 1.3.4. JSPM Uses SystemJS, a universal module loader Can load modules at runtime Has its own package manager Can install from npm, git Uses Rollup 1.4. Sourcemaps To debug. Map code back to original source Part of our build downloaded only if you open developer tools write debugger in code Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/Javacript-Starter/08_linting.html": {
    "url": "ProjectConfig/Javacript-Starter/08_linting.html",
    "title": "08_linting",
    "keywords": "",
    "body": "1. Linting1.1. ESLint1.1.1. Warnings vs Errors1.1.2. Plugins1.1.3. preset1.1.4. Issue1.2. Why Lint via an Automated Build Process1.2.1. Usage1. Linting Enforce Consistency Curly brace position confirm / alert Trailing commas Globals eval Avoid Mistakes Extra parenthesis Overwriting function Assignment in conditional Missing default case in switch debugger / console.log 1.1. ESLint 1.1.1. Warnings vs Errors Warning Can continue development Can be ignored Team must agree: Fix warnings Error Breaks the build Cannot be ignored Team is forced to comply 1.1.2. Plugins eslint-plugin-react, eslint-plugin-angular, eslint-plugin-node 1.1.3. preset from scratch recommended presets: airbnb 1.1.4. Issue ESLint doesn't watch files eslint-loader if using webpack Re-lints all files upon save. eslint-watch is a npm package (better solution) ESLint wrapper that adds file watch Not tied to webpack Better warning/error formatting Displays clean message Easily lint tests and build scripts too ESLint doesn't support many experimental JavaScript features Run ESLint directly Supports ES6 and ES7 natively Also supports object spread use Babel-eslint Also lints stage 0 - 4 features 1.2. Why Lint via an Automated Build Process One place to check Universal configuration Part of continuous integration 1.2.1. Usage npm scripts: \"lint\": \"esw webpack.config.* src buildScripts --color\", // tell which files or folders to lint \"lint:watch\": \"npm run lint -- --watch\" dependencies: \"eslint\": \"4.6.1\", \"eslint-watch\": \"3.1.2\", .eslintrc.json { \"root\": true, \"extends\": [ \"eslint:recommended\" // \"plugin:react/recommended\" ], \"parserOptions\": { \"ecmaVersion\": 7, \"sourceType\": \"module\" }, \"env\": { \"browser\": true, \"node\": true, \"mocha\": true }, \"rules\": { \"no-console\": 1 } } disable linting for individual file: /* eslint-disable no-console */ console.log('111'); disable linting for a specific line console.log('111'); // eslint-disable-line no-console Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/Javacript-Starter/09_testing_CI.html": {
    "url": "ProjectConfig/Javacript-Starter/09_testing_CI.html",
    "title": "09_testing_CI",
    "keywords": "",
    "body": "1. Testing 测试 for Javascript1.1. JavaScript testing styles1.1.1. Unit Tests vs Integration Tests1.2. 6 key testing decisions1.2.1. Frameworks1.2.2. Assertion Library1.2.3. Helper library1.2.4. Where to run tests1.2.5. Where do test files belong1.2.6. Naming Convention1.2.7. When should unit tests run1.3. Configure testing and write test1.3.1. Test setup1.3.2. watch tests1.4. Continuous integration1.4.1. Why CI?1.4.2. What does a CI server do?1.4.3. CI server1. Testing 测试 for Javascript 1.1. JavaScript testing styles Style Focus Unit Single function or module Integration Interactions between modules UI Automate interactions with UI 1.1.1. Unit Tests vs Integration Tests Unit Tests Integration Tests Test a small unit Test multiple units Often single function Often involves clicking and making calls to a webApi using automation tool like Selenium Fast Slow Run upon save Often run on demand, or in QA 1.2. 6 key testing decisions Framework Assertion Library Helper Libraries Where to run tests Where to place tests When to run tests 1.2.1. Frameworks Mocha: highly configurable, large ecosystem, No Assertion Jasmine: large ecosystem, built-in assertion library Jest: wrapper for jasmine by facebook, popular among react developers Tape: simple QUnit: jquery creator writes AVA: run test parallel Choose any of these just like choosing a gym. 1.2.2. Assertion Library Declare what you expect. expect(2 + 2).to.equal(4); assert(2 + 2).equals(4); Chai Should.js expect 1.2.3. Helper library JSDOM Simulate the browser's DOM Run DOM-related tests without a browser Cheerio jQuery for the server Query virtual DOM using jQuery selectors 1.2.4. Where to run tests Browser(slower, not good) Karma, Testem Headless Browser PhantomJS (great) In-memory DOM JSDOM (great): https://github.com/tmpvar/jsdom 1.2.5. Where do test files belong Centralized (✘) Less \"noise\" in src folder (they are important source, asset. not liability) Deployment confusion (deploy won't be an issue for alongside way) Inertia 惯性 (backend test prefers Centralized test, not frontend) import file from '../../src/long/path' // file.test.js Alongside (✔️ more suitable for javascript test) Easy imports Clear visibility Convenient to open No recreating folder structure Easy file moves Path to file under test is always ./filename: import file from './file' // file.test.js 1.2.6. Naming Convention fileName.spec.js fileName.test.js 1.2.7. When should unit tests run Rapid feedback: run every time you hit save Facilitates TDD Automatic = Low friction 摩擦 Increases test visibility For integration test, admittedly slow, you should run separately. 1.3. Configure testing and write test I'm using below skills for unit tests Framework: Mocha Assertion Library: Chai Helper Libraries: JSDOM Where to run tests: Node Where to place tests: Alongside When to run tests: Upon save 1.3.1. Test setup npm scripts: using \"progress reporter\" because of clean output \"test\": \"mocha --reporter progress buildScripts/testSetup.js src/**/*.test.js\" create buildScripts/testSetup.js // This file isn't transpilied, so must use CommonJS and ES5 // register babel to transpile before our tests run require('babel-register'); // disable webpack features that Mocha doesn't understand // import 'index.css', webpack understands, but not mocha require.extensions['.css'] = function() {}; // mocha, treat it as a empty function create src/index.test.js import { expect } from 'chai'; describe('our first test', () => { it('should pass', () => { expect(true).to.equal(true); }); }); DOM testing by JSDOM v11 import { expect } from 'chai'; import { JSDOM } from 'jsdom'; import fs from 'fs'; describe('index.html', () => { it('should say hello', () => { const index = fs.readFileSync('./src/index.html', 'utf-8'); const dom = new JSDOM(index); const h1 = dom.window.document.querySelector('h1'); expect(h1.textContent).to.equal('hello world'); }); }); 1.3.2. watch tests \"scripts\": { \"start\": \"npm-run-all --parallel security-check start:server lint:watch test:watch\", \"test\": \"mocha --reporter progress buildScripts/testSetup.js src/**/*.test.js\", \"test:watch\": \"npm run test -- -w\" // or \"npm run test -- --watch\" } 1.4. Continuous integration The code is working on my machine, but it breaks on the CI server. 1.4.1. Why CI? Forgot to commit new file Forgot to update package.json commit doesn't run cross-platform node version conflicts bad merge didn't run tests 1.4.2. What does a CI server do? Run automated build Run your tests Check code coverage automate deployment 1.4.3. CI server Travis CI(linux) Jenkins Appveyor (windows) CircleCI Semaphore SnapCI Travis CI for unix Sign in by github and you should see all repositories. Turn on \"wghglory/javascript-starter-kit\". Create .travis.yml language: node_js node_js: - \"7\" If I intently change index.html h1 from 'hello world' to 'hello' and then commit to github. Note our test watching task only watches js now, so html changes won't be reflected in terminal unless restarting. After commit and push to github. Travis will build and give us the build result. Appveyor for windows appveyor.yml: # test against this version of node.s environment: matrix: # node.js - nodejs_version: \"7\" # install scripts. (runs after repo cloning) install: # get the latest stable version of node.js or io.js - ps: Install-Product node $env:nodejs_version # install modules - npm install # post-install test scripts test_script: # output useful info for debugging - node --version - npm --version # run tests - npm test # don't actually build build: off Usage is same with Travis. Sign in by github, add the project. When push commits to github, appveyor will build. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/Javacript-Starter/10_httpcall_mock.html": {
    "url": "ProjectConfig/Javacript-Starter/10_httpcall_mock.html",
    "title": "10_httpcall_mock",
    "keywords": "",
    "body": "1. Http call1.1. Http call approaches1.1.1. Fetch1.1.2. Axios1.2. Why centralize API calls1.3. Mock1.3.1. Why Mock HTTP?1.3.2. How to Mock HTTP (also review interview/frontend/Mock.md)1.3.3. Authentication1.3.4. Our Plan for Mocking HTTP1.3.5. Mocking Libraries1.3.6. Demo1. Http call 1.1. Http call approaches Node http request (✅) Browser XMLHttpRequest jQuery Framework-based (Angular http service) Fetch (✅ polyfill for both regular version or isomorphic-fetch) Node & Browser (any below is good) isomorphic-fetch xhr superAgent axios (great) 1.1.1. Fetch You can find compatibility for fetch: https://caniuse.com/#search=fetch Fetch cannot be cancelled at this time. const request = new Request('http://your-api.com/user', { method: 'GET', mode: 'cors', headers: new Headers({ 'Content-Type': 'text/html; charset=UTF-8', }), }); fetch(request).then(onSuccess, onError); 1.1.2. Axios axios({ url: 'http://your-api.com/user', method: 'post', headers: { 'Content-type': 'text/html; charset=UTF-8', }, data: 'text', }).then(onSuccess, onError); 1.2. Why centralize API calls Configure all calls Handle preloader logic Handle errors Single seam(缝合；接合) for mocking create src/api/userApi.js import 'whatwg-fetch'; // let browser that hasn't supported fetch work with fetch const onSuccess = (response) => response.json(); const onError = (error) => console.log(error); //eslint-disable-line no-console const get = (url) => fetch(url).then(onSuccess, onError); export const getUsers = () => get('users'); So in index.js, I can call this api: import { getUsers } from './api/userApi'; getUsers().then((result) => {}); Only send polyfill to those who need it: 1.3. Mock 1.3.1. Why Mock HTTP? Unit Testing Instant response Keep working when services are down Rapid prototyping Avoid inter-team bottlenecks Work offline 1.3.2. How to Mock HTTP (also review interview/frontend/Mock.md) Nock (mock http calls in unit test) Static JSON Create development webserver api-mock JSON server JSON Schema faker(random data) Browsersync Express, etc. My json server: https://my-json-server.typicode.com/ 1.3.3. Authentication https://dzone.com/articles/basic-authentication-for-json-server https://medium.com/@kaustubhtalathi/mock-data-for-angular-5-applications-with-json-server-part-1-d377eced223b https://github.com/techiediaries/fake-api-jwt-json-server 1.3.4. Our Plan for Mocking HTTP Declare our schema: JSON Schema Faker Generate Random Data: faker.js chance.js randexp.js Serve Data via API JSON Server 1.3.5. Mocking Libraries Json Schema Json Schema Faker 1.3.6. Demo 1. create Schema: buildScripts/mockDataSchema.js export const schema = { type: 'object', properties: { users: { type: 'array', minItems: 3, maxItems: 5, items: { type: 'object', properties: { id: { type: 'number', unique: true, minimum: 1, }, firstName: { type: 'string', faker: 'name.firstName', }, lastName: { type: 'string', faker: 'name.lastName', }, email: { type: 'string', faker: 'internet.email', }, }, required: ['id', 'firstName', 'lastName', 'email'], }, }, }, required: ['users'], }; 2. generate Mock Data: buildScripts/generateMockData.js import jsf from 'json-schema-faker'; import { schema } from './mockDataSchema'; import fs from 'fs'; import chalk from 'chalk'; const json = JSON.stringify(jsf(schema)); fs.writeFile('./src/api/db.json', json, (err) => { if (err) { return console.log(chalk.red(err)); } else { console.log(chalk.green('Mock data generated.')); } }); npm scripts: \"generate-mock-data\": \"babel-node buildScripts/generateMockData\" Run npm run generate-mock-data and you should see src/api/db.json. 3. serving mock data via json server npm scripts: \"start-mockapi\": \"json-server --watch src/api/db.json --port 3001\" npm run start-mockapi and access http://localhost:3001/users, you should see the data I prefer to change data every time when restarting the app. Randomized data is helpful. empty lists long lists long value testing filtering sorting To change data, follow below: npm scripts: \"start\": \"npm-run-all --parallel security-check start:server lint:watch test:watch start-mockapi\", \"generate-mock-data\": \"babel-node buildScripts/generateMockData\", \"prestart-mockapi\": \"npm run generate-mock-data\", \"start-mockapi\": \"json-server --watch src/api/db.json --port 3001\" Targeting mock api or production api by environment Assume srcServer.js's app.get('/users') is called only for production, while in dev mode, we should hit Json-server port 3001. So when requesting localhost:3000/, we know it's development environment and call getUsers api which hosting in port 3001 by Json-server. When request http://production, we call production api. api/baseUrl.js export default function getBaseUrl() { const inDevelopment = window.location.hostname === 'localhost'; return inDevelopment ? 'http://localhost:3001/' : '/'; // first is json-server address, second is production api address } api/userApi.js import getBaseUrl from './baseUrl'; const baseUrl = getBaseUrl(); const get = (url) => fetch(baseUrl + url).then(onSuccess, onError); delete user for Json-server index.js const deleteLinks = document.querySelectorAll('.deleteUser'); Array.from(deleteLinks, (link) => { link.onclick = (e) => { const ele = e.target; e.preventDefault(); deleteUser(ele.dataset.id); const row = ele.parentNode.parentNode; // tr row.parentNode.removeChild(row); }; }); userApi.js const del = (url) => { const request = new Request(baseUrl + url, { method: 'delete', }); return fetch(request).then(onSuccess, onError); }; export const deleteUser = (id) => del(`users/${id}`); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/Javacript-Starter/11_structure.html": {
    "url": "ProjectConfig/Javacript-Starter/11_structure.html",
    "title": "11_structure",
    "keywords": "",
    "body": "1. Project Structure1.1. Why Include a Demo App?1.2. Tips1. Project Structure 1.1. Why Include a Demo App? Examples of: Automated deployment Directory structure and file naming Framework usage Testing Mock API Codifies decisions Interactive example of working with starter 1.2. Tips Cannot put js in html. Put js in a .js file // slap code here... Test this? Lint this? Reuse this? Transpile this? Import explicit dependencies? Consider organizing by feature Organize by file type (MVC) /components /data /models /views Organize by Feature (larger app) /authors /courses Extract logic into \"POJOs\" (plain old javascript object, no framework-specific code) Put utils to utils folder, this doesn't have any relationship with react. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/Javacript-Starter/12_production_build.html": {
    "url": "ProjectConfig/Javacript-Starter/12_production_build.html",
    "title": "12_production_build",
    "keywords": "",
    "body": "1. Production1.1. Minification1.1.1. How Does Minification Work?1.1.2. Switching Api by queryString1.1.3. Production build npm scripts1.1.4. Why Manipulate HTML for Production?1.1.5. Why Bundle/Code Splitting1.1.6. Cache Busting1.1.7. Separate CSS1.1.8. Error Logging1. Production 1.1. Minification 1.1.1. How Does Minification Work? Shortens variable and function names Removes comments Removes whitespace and new lines Dead code elimination / Tree-shaking Debug via sourcemap 1.1.2. Switching Api by queryString baseUrl.js: /** this determines api address */ export default function getBaseUrl() { return getQueryStringParameterByName('useMockApi') ? 'http://localhost:3001/' // mockapi address : '/'; // production api } function getQueryStringParameterByName(name, url) { if (!url) url = window.location.href; name = name.replace(/[[\\]]/g, '\\\\$&'); var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'), results = regex.exec(url); if (!results) return null; if (!results[2]) return ''; return decodeURIComponent(results[2].replace(/\\+/g, ' ')); } http://localhost:3000/?useMockApi=true will use Mock Data. Otherwise, without useMockApi, will hit production Api. 1.1.3. Production build npm scripts Create build.js and distServer.js \"clean-dist\": \"rimraf ./dist && mkdir dist\", \"prebuild\": \"npm-run-all clean-dist test lint\", \"build\": \"babel-node buildScripts/build.js\", \"postbuild\": \"babel-node buildScripts/distServer.js\" 1.1.4. Why Manipulate HTML for Production? Reference bundles automatically Handle dynamic bundle names Inject production only resources Minify Best way is to use html-webpack-plugin since we use webpack. 1.1.5. Why Bundle/Code Splitting Important for larger application Speed initial page load Avoid re-downloading all libraries vendor.js /* eslint-disable no-unused-vars */ import fetch from 'whatwg-fetch'; webpack.config.prod.js entry: { + vendor: path.resolve(__dirname, 'src/vendor'), + main: path.resolve(__dirname, 'src/index') }, output: { path: path.resolve(__dirname, 'dist'), publicPath: '/', + filename: '[name].js' }, plugins: [ + // Use CommonsChunkPlugin to create a separate bundle + // of vendor libraries so that they're cached separately. + new webpack.optimize.CommonsChunkPlugin({ + name: 'vendor' + }) ] 1.1.6. Cache Busting Save HTTP Requests Force request for latest version Setup Cache busting Hash bundle filename. If no code changes, no filename changes. Generate HTML dynamically import WebpackMd5Hash from 'webpack-md5-hash'; export default { output: { path: path.resolve(__dirname, 'dist'), publicPath: '/', filename: '[name].[chunkhash].js', }, plugins: [ // Hash the files using MD5 so that their names change when the content changes. new WebpackMd5Hash(), ], }; 1.1.7. Separate CSS import ExtractTextPlugin from 'extract-text-webpack-plugin'; export default { plugins: [ // Generate an external css file with a hash in the filename new ExtractTextPlugin('[name].[contenthash].css'), ], module: { rules: [ { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: 'style-loader', use: 'css-loader', publicPath: '/dist', }), }, ], }, }; 1.1.8. Error Logging TrackJS(✅) Sentry New Relic Raygun Things to be considered: Error Metadata Browser Stack trace Previous actions Custom API for enhanced tracking Notifications & integrations Analytics and filtering Pricing Track.js Install the Tracker Library The Tracker library lives in your web application. Paste this snippet before your other scripts in the of your page. window._trackJs = { token: '7a7c1c686a66488c8bd4b229de471250' }; Track an Error Tracker logs errors automatically, but to verify it's working let's try it manually. You can track an error from anywhere in your application, or in your developer console: trackJs.track('ahoy trackjs!'); 手动错误上报：(interview/frontend/错误监控.md） window.addEventListener( 'error', function(e) { console.log('捕获', e); new Image().src = 'http://baidu.com/tesjk?r=tksjk'; }, true, ); Now the error logging happened both development and production environment. Actually we only want to monitor production. We can extend HtmlWebpackPlugin property and its default template ejs to update index.html // webpack.config.prod.js plugins: [ new HtmlWebpackPlugin({ template: 'src/index.html', inject: true, minify: { removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true, }, // Properties you define here are available in index.html // using htmlWebpackPlugin.options.varName trackJSToken: '7a7c1c686a66488c8bd4b229de471250', }), ]; index.html window._trackJs = { token: '7a7c1c686a66488c8bd4b229de471250' }; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/Javacript-Starter/13_deployment.html": {
    "url": "ProjectConfig/Javacript-Starter/13_deployment.html",
    "title": "13_deployment",
    "keywords": "",
    "body": "1. Deployment1.1. Why Separate the UI and API?1.2. Cloud hosting1.3. Hosting javascript-starter-kit-api(API) to Heroku1.4. Deploy static files(UI) to Surge1.4.1. Reference1. Deployment 1.1. Why Separate the UI and API? Simple, low-risk, UI only deploys Separates concerns Separate teams Less to understand Scale back-end separately Cheap UI hosting (hosting only static files) Serve UI via a content delivery network Use the API tech you like 1.2. Cloud hosting amazon web services microsoft azure Heroku firebase google cloud platform github (static files only) Surge (static files only) 1.3. Hosting javascript-starter-kit-api(API) to Heroku We separate API and UI. The repository is at https://github.com/wghglory/javascript-starter-kit-api. See some configurations needed there for heroku. This api repository will be hosted in heroku. app.json - describe app to heroku Procfile - command that heroku should run 1.4. Deploy static files(UI) to Surge package.json: \"deploy\": \"surge ./dist\" npm run build -s npm run deploy 1.4.1. Reference React starter: http://andrewhfarmer.com/starter-project/ Angular starter: https://github.com/gianarb/awesome-angularjs Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/Mock.html": {
    "url": "ProjectConfig/Mock.html",
    "title": "Mock",
    "keywords": "",
    "body": "1. 前端数据 mock1.1. Json Server 创建本地 json 文件作为数据库1.2. Faker.js 产生数据1.3. 具体步骤1.3.1. 1. Declare Schema1.3.2. 2. Generate Random Data1.3.3. 3.  Serve Random Data1. 前端数据 mock 1.1. Json Server 创建本地 json 文件作为数据库 https://www.techiediaries.com/fake-api-jwt-json-server/(perfect!) https://github.com/typicode/json-server https://coligo.io/create-mock-rest-api-with-json-server 1.2. Faker.js 产生数据 Faker graphql-js 1.3. 具体步骤 1.3.1. 1. Declare Schema Test schema at http://json-schema-faker.js.org install packages: npm i json-schema-faker json-server --save-dev // create buildScripts/mockDataSchema.js var schema = { type: 'object', properties: { users: { type: 'array', minItems: 3, maxItems: 5, items: { type: 'object', properties: { id: { type: 'number', unique: true, minimum: 1, }, firstName: { type: 'string', faker: 'name.firstName', }, lastName: { type: 'string', faker: 'name.lastName', }, email: { type: 'string', faker: 'internet.email', }, }, required: ['id', 'type', 'lastname', 'email'], }, }, }, required: ['users'], }; module.exports = schema; 1.3.2. 2. Generate Random Data // create buildScripts/generateMockData.js /* This script generates mock data for local development. This way you don't have to point to an actual API, but you can enjoy realistic, but randomized data, and rapid page loads due to local, static data. */ var jsf = require('json-schema-faker'); var mockDataSchema = require('./mockDataSchema'); var fs = require('fs'); var json = JSON.stringify(jsf(mockDataSchema)); fs.writeFile('./src/api/db.json', json, function(err) { if (err) { return console.log(err); } else { console.log('Mock data generated.'); } }); in package.json \"generate-mock-data\": \"node buildScripts/generateMockData\" 1.3.3. 3.  Serve Random Data package.json: if prestart-mockapi is used, data will be regenerated everytime npm run start-mockapi. \"generate-mock-data\": \"node buildScripts/generateMockData\", \"prestart-mockapi\": \"npm run generate-mock-data\", \"start-mockapi\": \"json-server --watch src/api/db.json --port 3001\" run the mock server: npm run start-mockapi Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/nginx/": {
    "url": "ProjectConfig/nginx/",
    "title": "ProjectConfig/nginx",
    "keywords": "",
    "body": "1. TOC1. TOC Nginx 创狐 Nginx 配置 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "ProjectConfig/nginx/Nginx.html": {
    "url": "ProjectConfig/nginx/Nginx.html",
    "title": "Nginx",
    "keywords": "",
    "body": "1. Nginx1.1. 安装并启动 Nginx1.2. Nginx 配置不完全详解1.3. Nginx 配置最佳实践1.4. default 配置解析1.5. 配置反向代理1.6. 配置临时跳转1.7. 配置限制访问1.8. default-ssl 配置解析1.9. 小结1.10. 反向代理1. Nginx http://www.jianshu.com/p/e24d676060c1 Nginx(发音：engine X)是一款轻量级的HTTP服务器（相比于 Apache、Lighttpd 而言），同时是一个高性能的HTTP和反向代理服务器，如今国内主流网站基本搭建于Nginx之上，诸如新浪、腾讯、网易、豆瓣。 Nginx 主要以事件驱动的方式编写，有兴趣可以移步这里看他们的源码，这让它拥有非常好的性能，同时也是一个非常高效的反向代理、负载均衡。 官方站点也指出了Nginx作为 HTTP 服务器的几项基本特性： 处理静态文件，索引文件以及自动索引；打开文件描述符缓冲 无缓存的反向代理加速，简单的负载均衡和容错 FastCGI，简单的负载均衡和容错 模块化的结构，包括 gzipping, byte ranges, chunked responses 以及 SSI-filter 等 filter。 支持 SSL 和 TLSSNI. 1.1. 安装并启动 Nginx 由于我是用 Mac 办公的，所以安装Nginx是采用brew进行的，在终端输入下面命令安装好Nginx： # 强烈建议每次 brew 安装软件的时候先执行 rew update 保持软件依赖包都是最新的 brew install nginx 安装后 path：/usr/local/etc/nginx/nginx.conf 紧接着就可以用浏览器打开http://localhost:8080看到 Nginx 的欢迎信息。 跟Linux系统有些不同，在Mac下面Nginx默认监听了8080端口号，若强迫症（比如我）不希望每次打开网页都要输入端口号的话，那么请在终端执行下面命令： # 下面的1.12.0请根据最新安装版本号对应修改 sudo chown root:wheel /usr/local/Cellar/nginx/1.12.0/bin/nginx sudo chmod u+s /usr/local/Cellar/nginx/1.12.0/bin/nginx # 用vi编辑器打开nginx配置文件，找到server字段的listen字段并将其值修改为80 vi /usr/local/etc/nginx/nginx.conf 修改完上面配置信息之后，执行下面命令检查配置文件语法是否有误并且重新加载配置： nginx -t && nginx -s reload 如果遇到问题 nginx: [emerg] open() \"/usr/local/Cellar/nginx/1.12.1/logs/access.log\" failed (2: No such file or directory) 手动创建 logs 文件夹和 access.log 文件 在 Mac 上用 brew 安装 Nginx，然后修改 Nginx 配置文件，再重启时报出如下错误： nginx: [error] invalid PID number \"\" in \"/usr/local/var/run/nginx/nginx.pid\" 解决办法： sudo nginx -c /usr/local/etc/nginx/nginx.conf sudo nginx -s reload 更多关于Nginx命令的帮助可以输入nginx -h查看，若想每次开机自动开启Nginx，在终端执行下面命令即可： ln -sfv /usr/local/opt/nginx/*.plist ~/Library/LaunchAgents launchctl load ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist 1.2. Nginx 配置不完全详解 下面是我机器上的Nginx的配置文件： 强烈建议大家先打开自己的默认 Nginx 配置跟我的对比来看可以在终端执行 cat /usr/local/etc/nginx/nginx.conf.default 查看默认配置文件 # user字段表明了Nginx服务是由哪个用户哪个群组来负责维护进程的，默认是nobody # 我这里用了cainengtian用户，staff组来启动并维护进程 # 查看当前用户命令： whoami # 查看当前用户所属组命令： groups ，当前用户可能有多个所属组，选第一个即可 user cainengtian staff; # worker_processes字段表示Nginx服务占用的内核数量 # 为了充分利用服务器性能你可以直接写你本机最高内核 # 查看本机最高内核数量命令： sysctl -n hw.ncpu worker_processes 4; # error_log字段表示Nginx错误日志记录的位置 # 模式选择：debug/info/notice/warn/error/crit # 上面模式从左到右记录的信息从最详细到最少 error_log /usr/local/var/logs/nginx/error.log debug; # Nginx执行的进程id,默认配置文件是注释了 # 如果上面worker_processes的数量大于1那Nginx就会启动多个进程 # 而发信号的时候需要知道要向哪个进程发信息，不同进程有不同的pid，所以写进文件发信号比较简单 # 你只需要手动创建，比如我下面的位置： touch /usr/local/var/run/nginx.pid pid /usr/local/var/run/nginx.pid; events { # 每一个worker进程能并发处理的最大连接数 # 当作为反向代理服务器，计算公式为： `worker_processes * worker_connections / 4` # 当作为HTTP服务器时，公式是除以2 worker_connections 2048; } http { # 关闭错误页面的nginx版本数字，提高安全性 server_tokens off; include mime.types; default_type application/octet-stream; # 日志记录格式，如果关闭了access_log可以注释掉这段 #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; # 关闭access_log可以让读取磁盘IO操作更快 # 当然如果你在学习的过程中可以打开方便查看Nginx的访问日志 access_log off; sendfile on; # 在一个数据包里发送所有头文件，而不是一个接一个的发送 tcp_nopush on; # 不要缓存 tcp_nodelay on; keepalive_timeout 65; gzip on; client_max_body_size 10m; client_body_buffer_size 128k; # 关于下面这段在后面紧接着来谈！ include /usr/local/etc/nginx/sites-enabled/*; } 1.3. Nginx 配置最佳实践 上面的配置文件最后一行include关键词会将/usr/local/etc/nginx/sites-enabled/文件夹下面的所有文件都加载进当前的配置文件，这样子就可以将配置文件分离，nginx.conf这个配置文件修改之后以后基本不会修改，配置不同站点的时候只需要在/usr/local/etc/nginx/sites-enabled/不断增加新的文件即可，这是比较好的配置方式。 比如我在/usr/local/etc/nginx/sites-enabled/下面增加了两个文件，用来配置普通的HTTP服务还有HTTPS服务： touch /usr/local/etc/nginx/sites-enabled/default touch /usr/local/etc/nginx/sites-enabled/default-ssl 1.4. default 配置解析 Nginx整个配置的结构大致如下： ... events { ... } http { ... server { ... location xxx { ... } } } 对比上面我的nginx.conf文件可以知道default文件的内容就是配置server部分的，下面先弄一份最基本的配置（带有详细说明）： server { # Nginx监听端口号 listen 80; # 服务器的名字，默认为localhost，你也可以写成 aotu.jd.com，这样子就可以通过 aotu.jd.com来访问 server_name localhost; # 代码放置的根目录 root /var/www/; # 编码 charset utf-8; location / { # index字段声明了解析的后缀名的先后顺序 # 下面匹配到/的时候默认找后缀名为php的文件，找不到再找html，再找不到就找htm index index.php index.html index.htm; # 自动索引 autoindex on; # 这里引入了解析PHP的东西 include /usr/local/etc/nginx/conf.d/php-fpm; } # 404页面跳转到404.html，相对于上面的root目录 error_page 404 /404.html; # 403页面跳转到403.html，相对于上面的root目录 error_page 403 /403.html; # 50x页面跳转到50x.html error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } 上面的配置的意思就是：访问http://localhost『80 端口号可以直接省略』的时候会在/var/www/下面找index.php文件，如果没有找到就找index.html，如果再没有找到那就找index.htm，如果还是没有找到的话就404跳转到404.html，如果你刚好将/var/www/设置为root用户访问的话，那么就会直接无访问权限403跳转到403.html。 # 当用root配置的时候，root后面指定的目录是上级目录 # 并且该上级目录必须含有和location后指定的名称的同名目录，否则404 # root末尾的\"/\"加不加无所谓 # 下面的配置如果访问站点http://localhost/test1访问的就是/var/www/test1目录下的站点信息 location /test1/ { root /var/www/; } # 如果用alias配置，其后面跟的指定目录是准确的，并且末尾必须加\"/\"，否则404 # 下面的配置如果访问站点http://localhost/test2访问的就是/var/www/目录下的站点信息 location /test2/ { alias /var/www/; } 大家在实践过程中注意区分即可，配置之后要是碰到404可以先考虑是否是这个原因。 1.5. 配置反向代理 对于前端工程师而言，可能最容易成为全栈的技能就是NodeJS了，当我们用express框架写好了一个Node应用之后，比如启动的时候的访问地址是：http://localhost:3000/，但是在部署到服务器上去之后，我们当然不希望别人这样子访问，最好的情况肯定是隐藏掉端口号。 例如我有一个Node服务的名字是o2blog_wx，在启动Node的时候访问的地址是：http://localhost:3000/，但是对外网我们希望是：http://aotu.jd.com/o2blog_wx，接下来我们将通过 Nginx 进行配置（带有详细注释）。 server { listen 80; server_name aotu.jd.com; root /var/www/; location /o2blog_wx/ { # 反向代理我们通过proxy_pass字段来设置 # 也就是当访问http://aotu.jd.com/o2blog_wx的时候经过Nginx反向代理到服务器上的http://127.0.0.1:3000 # 同时由于解析到服务器上的时候o2blog_wx这个字段都要处理 # 所以通过rewrite字段来进行正则匹配替换 # 也就是http://aotu.jd.com/o2blog_wx/hello经过Nginx解析到服务器变成http://127.0.0.1:3000/hello proxy_pass http://127.0.0.1:3000; rewrite ^/o2blog_wx/(.*) /$1 break; } } 1.6. 配置临时跳转 有时候我们觉得一开始配置的 URL 不好想换掉，但又不想原先的链接失效，比如一开始对外网的链接是：http://aotu.jd.com/o2blog_wx/，后来想改成http://aotu.jd.com/wxblog，又不想原先的失效。 这个时候可以在Nginx上配置一个302临时跳转，如下（server部分跟前面的一样）： location /o2blog_wx/ { # 当匹配到http://aotu.jd.com/o2blog_wx/的时候会跳转到http://aotu.jd.com/wxblog return 302 http://aotu.jd.com/wxblog } 1.7. 配置限制访问 在一台服务器上的资源不全部都是对外开放的，这个时候就需要通过Nginx配置一个限制访问，比如查看本服务器的 PHP 信息，我们就可以通过下面配置来实现限制访问： # 当匹配到/info的时候只允许10.7.101.224访问，其它的全部限制 # 同时改写为/info.php location = /info { allow 10.7.101.224; deny all; rewrite (.*) /info.php } 这个时候只有 IP 为10.7.101.224的机器才可以访问：http://aotu.jd.com/info，其它机器都会403拒绝访问！ 当然最佳的实践是将IP抽取出来变成白名单，这样子就可以实现部分IP可以访问，其它的不能访问。 1.8. default-ssl 配置解析 我们都知道HTTP在传输的过程中都是明文的，这直接导致了在传输的任何一个过程中都容易被窃取信息，所以才有了SSL（安全套接层）以及升级版TLS（传输层安全协议）的出现，其实就是在HTTP应用层给TCP/IP传输层的中间增加了TLS/SSL层，统称为HTTPS。 那如何通过Nginx配置HTTPS站点呢，下面就是default-ssl配置文件的内容（详细解析）： server { # 默认情况下HTTPS监听443端口 listen 443 ssl; server_name localhost; root /var/www/; # 下面这些都是配置SSL需要的 ssl on; # 下面两个字段需要的crt利用openssl生成，具体可以看[这里](http://nginx.org/en/docs/http/configuring_https_servers.html) ssl_certificate ssl/localhost.crt; ssl_certificate_key ssl/localhost.key; ssl_session_timeout 10m; ssl_protocols SSLv2 SSLv3 TLSv1; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location = /info { allow 127.0.0.1; deny all; rewrite (.*) /info.php; } location /phpmyadmin/ { root /usr/local/share/phpmyadmin; index index.php index.html index.htm; } location / { include /usr/local/etc/nginx/conf.d/php-fpm; } error_page 403 /403.html; error_page 404 /404.html; } 上面配置之后，就可以通过https://localhost/访问我们的Nginx首页了。 当然若要在对外网使用，必须购买第三方信任证书才行，有兴趣的童鞋可以谷歌了解，这里不细谈。 1.9. 小结 写到这里，最基本的Nginx配置就基本介绍完了，若按照我上面的配置一步步跟着改，基本上都可以跑起来Nginx服务了吧，若想更加深入学习Nginx的配置，强烈建议看官方文档，写得很清晰明了，还是那句老话：授之以鱼不如授之以渔。 1.10. 反向代理 提到反向代理，必然先提到正向代理，正向代理(forward)是一个位于客户端【用户 A】和原始服务器(origin server)【服务器 B】之间的服务器【代理服务器 Z】，为了从原始服务器取得内容，用户 A 向代理服务器 Z 发送一个请求并指定目标(服务器 B),然后代理服务器 Z 向服务器 B 转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。 正向代理示意图 从上图可以看出，所谓的正向代理就是代理服务器替代访问方【用户A】去访问目标服务器【服务器B】，在现实中的例子就是『翻墙』！但如果代理服务器 Z 被完全控制（或不完全控制），就变成了『肉鸡』了。 而反向代理与正向代理相反，对客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间（name-space）中的内容发送普通请求，接着反向代理将判断向何处（原始服务器）转交请求，并将获得的内容返回给客户端。 使用反向代理服务器主要核心作用如下： 保护和隐藏原始资源服务器 反向代理原理图 从上图可以看出，用户 A 始终认为它访问的是原始服务器 B 而不是代理服务器 Z，但实际上反向代理服务器接受用户 A 的应答，从原始资源服务器 B 中取得用户 A 的需求资源，然后发送给用户 A。由于防火墙的作用，只允许代理服务器 Z 访问原始资源服务器 B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器 B，但用户 A 并不知情。 负载均衡 反向代理负载均衡示例图 当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器 B 的时候，让不同的代理服务器 Z（x）去应答不同的用户，然后发送不同用户需要的资源。 当然反向代理服务器像正向代理服务器一样拥有 CACHE 的作用，它可以缓存原始资源服务器 B 的资源，而不是每次都要向原始资源服务器 B 请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户 X 来自同一个网络，那么用户 X 访问反向代理服务器 X，就会得到很高质量的速度。这正是CDN技术的核心。如下图： CDN 原理图 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/nginx/创狐Nginx配置.html": {
    "url": "ProjectConfig/nginx/创狐Nginx配置.html",
    "title": "创狐 Nginx 配置",
    "keywords": "",
    "body": "1. 创狐 Nginx 配置1. 创狐 Nginx 配置 mac nginx path: /usr/local/etc/nginx/nginx.conf worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log logs/access.log main; sendfile on; keepalive_timeout 65; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; #gzip_http_version 1.0; gzip_comp_level 5; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; gzip_vary off; gzip_disable \"MSIE [1-6]\\.\"; # pgc server { listen 8093; location / { #需要修改成你本地项目的build文件夹地址 root /Users/derek/Work/Hifox/ch-frontend/jc-pgc/build/; } location /api/ { proxy_pass http://106.15.179.107:7126/; proxy_set_header X-Forwarded-Host $host:8093; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location /r/ { #上传目录 alias D:\\\\dir; } } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/npm_scripts_over_gulp.html": {
    "url": "ProjectConfig/npm_scripts_over_gulp.html",
    "title": "npm_scripts_over_gulp",
    "keywords": "",
    "body": "1. Npm scripts instead of gulp or grunt1.1. npm tricks1.1.1. package.json1.1.2. Useful Commands1.1.3. reference1. Npm scripts instead of gulp or grunt 1.1. npm tricks \"&\": run concurrently (windows: START /B) \"&&\": chaining commands. First must pass, then run second \";\": second will execute even if first command has error \"|\": piping output, take the result of left command, pass result to terminal or next task in pipeline \"-- \": pass arguments into the underlying commands (npm test -- -w, -w is passed to npm test) \">\": redirection operator, write output to file 1.1.1. package.json { \"name\": \"basic-config\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"noeffect2second\": \"echo 'hello'; echo 'world'\", // ; second will execute even if first command has error // \"start\": \"./node_modules/.bin/webpack-dev-server --open\", \"start\": \"node index.js\", \"start:dev\": \"node index.js 4000\", \"pretest\": \"npm run compile && npm run lint\", \"posttest\": \"echo 'after tests are run'\", \"pretest\": \"npm run compile && npm run lint\", \"test\": \"mocha test -u bdd -R spec\", \"compile:coffee\": \"coffee --compile --output ./lib ./src/coffeescripts\", \"compile:ts\": \"tsc --outDir ./lib --module commonjs ./src/typescripts/tsCode.ts\", \"compile\": \"npm run compile:coffee && npm run compile:ts\", \"precompile\": \"npm run clean\", \"clean\": \"rimraf lib/*\", // 兼容 unix 和 windows. For mac: \"rm -rf lib/*.*\" \"build:less\": \"lessc client/less/demo.less public/css/site.css\", \"build:bundle\": \"browserify ./client/js/app.js | uglifyjs -mc > ./public/js/bundle.js\", \"build:clean\": \"rimraf public/css/*, public/js/*\", \"prebuild\": \"npm run build:clean\", \"build\": \"npm run build:less && npm run build:bundle\", // \"build\": \"NODE_ENV='production' webpack --config ./webpack.production.config.js -p\", \"watch:test\": \"npm run test -- -w -R min\", \"watch:lint\": \"watch 'npm run lint' .\", \"watch:server\": \"nodemon --ignore client --ignore public index.js\", \"watch:coffee\": \"coffee --compile -w --output ./lib ./src/coffeescripts\", \"watch:ts\": \"tsc -w --outDir ./lib --module commonjs ./src/typescripts/tsCode.ts\", \"watch:bundle\": \"watchify ./client/js/app.js -o ./public/js/bundle.js -dv\", // no minification \"watch:bundleWatcher\": \"watch 'npm run build:bundle' client\", // will minify \"watch:browser\": \"live-reload --port 9091 public/\", \"watch\": \"npm run watch:test & npm run watch:bundle & npm run watch:server & npm run watch:browser\", \"version:major\": \"npm version major\", \"version:minor\": \"npm version minor\", \"version:patch\": \"npm version patch\", \"prepush:origin\": \"echo 'Pushing code to GitHub'\", \"push:origin\": \"git push --tags origin HEAD:master\", \"prepush:heroku\": \"echo 'Pushing code to Heroku'\", \"push:heroku\": \"git push heroku master\", \"push:s3\": \"s3-cli sync ./dist/ s3://example-com/prod-site/\", \"push:azure\": \"git push azure master\", \"launch:prod\": \"heroku open\", \"launch:prod:windows\": \"start https://stupidlittlewebsite.herokuapp.com/\", \"push\": \"npm run push:origin && npm run push:heroku\", // \"deploy\": \"npm run build && firebase deploy\", \"deploy:prod\": \"npm run test:deploy -s && npm run build -s && npm run version:patch && npm run push && npm run launch:prod\", \"deploy:prod:time\": \"time(npm run deploy:prod)\", \"deploy:prod:script\": \"bash ./deployProd.sh\", // windows: bash ./deployProd.bat \"test:deploy\": \"npm t -- -R dot\", \"test:configoptions\": \"mocha test --reporter $npm_package_config_reporter\", \"fix\": \"./node_modules/.bin/eslint . --ext .js --fix\", \"lint\": \"./node_modules/.bin/eslint . --ext .js\", \"firebase-init\": \"firebase login && firebase init\" }, \"config\": { \"reporter\": \"landing\" }, // heroku needs it I guess \"engines\": { \"node\": \"~7.8.0\", \"npm\": \"~4.2.0\" }, \"repository\": { \"type\": \"git\", \"url\": \"https://wghglory@bitbucket.org/wghglory/guanghui.notebook.git\" }, \"devDependencies\": { \"browserify\": \"^14.4.0\", // \"coffee-script\": \"^1.10.0\", // \"jshint\": \"^2.8.0\", \"less\": \"^2.7.2\", \"live-reload\": \"^1.1.0\", \"mocha\": \"^3.5.3\", \"nodemon\": \"^1.12.0\", \"rimraf\": \"^2.6.2\", \"should\": \"^13.0.1\", \"supertest\": \"^3.0.0\", \"typescript\": \"^2.5.2\", \"uglifyjs\": \"^2.4.11\", \"watch\": \"^1.0.2\", \"watchify\": \"^3.9.0\" } } 1.1.2. Useful Commands npm run # show a log of the available commands in package.json npm run test npm test -s # 简略结果 short, small output npm tst npm t npm start npm install mocha should --save-dev 在运行 npm version 之前，最好把 git repository 远程连接配置好。这样 npm version patch 时，package.json version 和 git tag 会同步都更新。再通过下面命令把 tag 推送到远端。 npm version major/minor/patch # increments both package.json and sets a tag in git repository if package.json indicates repository git push --tags origin HEAD:master See installed tools: ls node_modules/.bin 1.1.3. reference https://github.com/coryhouse/react-slingshot/blob/master/package.json https://libraries.io/ https://docs.npmjs.com/misc/scripts https://www.pluralsight.com/courses/npm-build-tool-introduction Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "ProjectConfig/webpack.html": {
    "url": "ProjectConfig/webpack.html",
    "title": "webpack",
    "keywords": "",
    "body": "1. Webpack1. Webpack Webpack is a module bundler that helps us make production and development transformations to the code we write. The reason for it to exist is that web developers shouldn’t have to transform code every time they want to test or deploy it. These transformations include but are not limited to: bundling js, bundling css, minification and uglification, jsx to js, sass/less to css, et cetera. Webpack needs the entry point for the main javascript files. It has a modules property that we use to specify all loaders (rules) that need to make a transformation on the code. It has plugins property which specifies plugins like html-webpack-config’s object in its array. It needs the template and filename in the output distribution folder. Webpack loaders allow us to preprocess files (like css, et cetera) as we require them into the root js file. While using webpack-dev-server to run a web server locally, any changes we make do not cause webpack to compile our bundle to the dist folder. However, it dynamically updates quickly because webpack saves the changes in a cache that is meant to refresh quickly rather than compiling a build bundle every time a change is made. 2 core things: Loaders, plugins Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Python/": {
    "url": "Python/",
    "title": "Python",
    "keywords": "",
    "body": "1. TOC1. TOC basic Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Python/basic.html": {
    "url": "Python/basic.html",
    "title": "basic",
    "keywords": "",
    "body": "1. Python1.1. Syntax1.1.1. COMMON ARITHMETIC OPERATORS1.1.2. COMMON VARIABLE OPERATIONS1.1.3. DISPLAYING VALUES1.1.4. LIST OPERATIONS1.2. Concepts1.3. Resources1. Python https://www.dataquest.io/ 1.1. Syntax 1.1.1. COMMON ARITHMETIC OPERATORS Parentheses (): (5 / 5) + 5 Exponent **: 65 **5 Multiplication *: 5 * 5 Division /: 5 / 5 Addition +: 5 + 5 Subtraction -: 5 - 5 1.1.2. COMMON VARIABLE OPERATIONS Assigning a value directly to a variable: integer_val = 5 float_val = 5.0 string_val = \"5\" Assigning the result of a calculation to a variable: total = 5 + 5 average = (5 + 5 + 5) / 3 1.1.3. DISPLAYING VALUES Displaying a value: integer_val = 5 print(5) print(integer_val) print(5 + 5 + 5) Displaying a value's data type: integer_val = 5 print(type(integer_val)) 1.1.4. LIST OPERATIONS Creating an empty list: crime_rates = [] Creating a list with values: crime_rates = [749, 371, 828, 503, 1379] Appending a value to a list: crime_rates = [] crime_rates.append(749) crime_rates.append(371) Accessing individual elements in a list: crime_rates = [749, 371, 828, 503, 1379] cr_first = crime_rates[0] cr_third = crime_rates[2] Working with the length of a list: crime_rates = [749, 371, 828, 503, 1379] length = len(crime_rates) last_element = crime_rates[length-1] Accessing slices of values in a list: crime_rates = [749, 371, 828, 503, 1379] cr_slice = crime_rates[0:3] # Values at 0, 1, 2 1.2. Concepts When evaluating expressions, Python uses the order of operations rules from mathematics. Every value in Python has a data type associated with it. The common data types are: Strings: \"6\" Integers: 6 Floats: 6.0 1.3. Resources Documentation on all arithmetic operators List of reserved words in Python Documentation on lists Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/": {
    "url": "React/",
    "title": "React",
    "keywords": "",
    "body": "1. TOC1. TOC caveat code_async_await code_remarkable_markdown_library code_评分 Flux HOF_currying_HOC immutability-helper Immutability Imperative_vs_Declarative Inheritance _vs_composition interview_react1 interview_react2 lifecycle Presentational_vs_Container_Components Pure_vs_Impure_functions react-router react16 setStateAsync Testing Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "React/caveat.html": {
    "url": "React/caveat.html",
    "title": "caveat",
    "keywords": "",
    "body": "1. Something you need to know about react1.1.1. 1. React is MVC's V1.1.2. 2. Keep your components small1.1.3. 3. Write functional components1.1.4. 4. Write stateless components1.1.5. 6. Always use propTypes1. Something you need to know about react 1.1.1. 1. React is MVC's V 1.1.2. 2. Keep your components small const LatestPostsComponent = (props) => ( Latest posts {props.posts.map((post) => )} ); The component itself is a , with only 2 s inside it. The first one has a heading, and second one just maps over some data, rendering a for each element. That last part, extracting the as its own component, is the important bit. 1.1.3. 3. Write functional components class MyComponent extends React.Component { render() { return ; } } const MyComponent = (props) => ; don't use ref often: ref encourage a very imperative, almost jquery-like way of writing components, taking us away from the functional, one-way data flow philosophy for which we chose React in the first place! don't use state if possible 1.1.4. 4. Write stateless components State makes components difficult to test When components are just functions of input props, testing is a lot easier. (More on testing later). State makes it too easy to put business logic in the component React is a view library, so while render logic in the components is OK, business logic is a massive code smell. But when so much of your application's state is right there in the component, easily accessible by this.state, it can become really tempting to start putting things like calculations or validation into the component, where it does not belong. Revisiting my earlier point, this makes testing that much harder - you can't test render logic without the business logic getting in the way, and vice versa! 1.1.5. 6. Always use propTypes propTypes offer us a really easy way to add a bit more type safety to our components. They look like this: import PropTypes from 'prop-types'; const ListOfNumbers = (props) => ( {props.numbers.map((number) => {number})} ); ListOfNumbers.propTypes = { className: PropTypes.string.isRequired, numbers: PropTypes.arrayOf(PropTypes.number), }; When in development (not production), if any component is not given a required prop, or is given the wrong type for one of its props, then React will log an error to let you know. This has several benefits: It can catch bugs early, by preventing silly mistakes If you use isRequired, then you don't need to check for undefined or null as often It acts as documentation, saving readers from having to search through a component to find all the props that it needs The above list looks a bit like one you might see from someone advocating for static typing over dynamic typing. Personally, I usually prefer dynamic typing for the ease and speed of development it provides, but I find that propTypes add a lot of safety to my React components, without making things any more difficult. Frankly I see no reason not to use them. One final tip is to make your tests fail on any propType errors. The following is a bit of a blunt instrument, but it's simple and it works: beforeAll(() => { console.error = (error) => { throw new Error(error); }; }); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/code_async_await.html": {
    "url": "React/code_async_await.html",
    "title": "code_async_await",
    "keywords": "",
    "body": "1. React 中的 async 和 await1. React 中的 async 和 await 使用了蚂蚁金服 antd import React, { Component } from 'react'; import { Table, Pagination, Popconfirm, Button } from 'antd'; import moment from 'moment'; import { getUsers, createUser, updateUser, deleteUser } from '../../services/user'; import { getOrganizationsBatch } from '../../services/organization'; import UserEditModal from './UserEditModal'; import UserCreateModal from './UserCreateModal'; import './UserList.scss'; export default class UserList extends Component { constructor(props) { super(props); this.fetchUsers = this.fetchUsers.bind(this); this.fetchOrganizations = this.fetchOrganizations.bind(this); this.pageChangeHandler = this.pageChangeHandler.bind(this); this.createHandler = this.createHandler.bind(this); this.editHandler = this.editHandler.bind(this); this.deleteHandler = this.deleteHandler.bind(this); this.state = { loading: true, users: [], last: false, //last page totalPages: 0, totalElements: 0, first: true, //first page numberOfElements: 0, sort: null, pageSize: 0, pageIndex: 0, }; } componentDidMount() { this.fetchUsers(); } // webpack! entry: ['babel-polyfill', './src/index.js'], async fetchUsers(pageIndex, pageSize) { let res = await getUsers(pageIndex, pageSize); let formattedUsers = await this.fetchOrganizations(res.content); this.setState({ loading: false, users: formattedUsers, // added organization name last: res.last, totalPages: res.totalPages, totalElements: res.totalElements, first: res.first, numberOfElements: res.numberOfElements, sort: res.sort, pageSize: res.size, pageIndex: res.number + 1, // 后台number从0开始，pageIndex从1，展示pagination }); } // // Promise 写法 // // method 1: 2个 then 嵌套 // fetchUsers(pageIndex, pageSize) { // getUsers(pageIndex, pageSize).then((res) => { // this.fetchOrganizations(res.content).then((formattedUsers) => // this.setState({ // loading: false, // users: formattedUsers, // added organization name // last: res.last, // totalPages: res.totalPages, // totalElements: res.totalElements, // first: res.first, // numberOfElements: res.numberOfElements, // sort: res.sort, // pageSize: res.size, // pageIndex: res.number + 1, // 后台number从0开始，pageIndex从1，展示pagination // }), // ); // }); // } // // method 2: 没有 then 的嵌套 // fetchUsers(pageIndex, pageSize) { // getUsers(pageIndex, pageSize) // .then((res) => { // this.setState({ // loading: false, // last: res.last, // totalPages: res.totalPages, // totalElements: res.totalElements, // first: res.first, // numberOfElements: res.numberOfElements, // sort: res.sort, // pageSize: res.size, // pageIndex: res.number + 1, // 后台number从0开始，pageIndex从1，展示pagination // }); // return this.fetchOrganizations(res.content); // }) // .then((formattedUsers) => // this.setState({ // users: formattedUsers, // added organization name // }), // ); // } fetchOrganizations(users) { let organizationIds = new Set(); users.forEach((u) => organizationIds.add(u.organizationId)); let orgMap = new Map(); //key: organizationId, value: organizationName return getOrganizationsBatch(Array.from(organizationIds)).then((res) => { const organizations = res.content; organizations.forEach((o) => orgMap.set(o.id, o.name)); users.forEach((u) => (u.organizationName = orgMap.get(u.organizationId))); return users; }); } pageChangeHandler(pageIndex) { // 发给后台的页码从0开始 this.fetchUsers(pageIndex - 1, this.state.pageSize); } editHandler(id, model) { updateUser(id, model); } deleteHandler(id) { deleteUser(id); } createHandler(model) { createUser(model); } render() { const columns = [ { title: 'Id', dataIndex: 'id', key: 'id', width: 200, }, { title: '用户名', dataIndex: 'userName', key: 'userName', render: (text) => {text}, }, { title: '邮件', dataIndex: 'email', key: 'email', }, { title: '电话', dataIndex: 'phone', key: 'phone', }, { title: '真实姓名', dataIndex: 'trueName', key: 'trueName', }, { title: '注册时间', dataIndex: 'createdOn', key: 'createdOn', render: (text) => moment(new Date(text)).format('YYYY-MM-DD HH:mm:ss'), }, { title: '禁用', dataIndex: 'enable', key: 'enable', render: (text) => (text ? '正常' : '禁用'), }, { title: '组织Id', dataIndex: 'organizationId', key: 'organizationId', }, { title: '组织', dataIndex: 'organizationName', key: 'organizationName', }, { title: '权限', dataIndex: 'permissions', key: 'permissions', render: (arr) => arr.join(', '), }, { title: '备注', dataIndex: 'comment', key: 'comment', }, { title: '操作', key: 'operation', render: (text, record) => ( 编辑 删除 ), }, ]; const rowSelection = { onChange: (selectedRowKeys, selectedRows) => { // console.log(`selectedRowKeys: ${selectedRowKeys}`, `selectedRows: ${selectedRows}`) }, }; const dataSet = this.state.users != null ? this.state.users : []; return ( 创建用户 record.id} size=\"middle\" bordered pagination={false} /> `${range[0]}-${range[1]} / ${total} 条`} showQuickJumper current={this.state.pageIndex} onChange={this.pageChangeHandler} total={this.state.totalElements} pageSize={this.state.pageSize} /> ); } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/code_remarkable_markdown_library.html": {
    "url": "React/code_remarkable_markdown_library.html",
    "title": "code_remarkable_markdown_library",
    "keywords": "",
    "body": "1. remarkable, an external Markdown library1. remarkable, an external Markdown library convert markdown text in real-time class MarkdownEditor extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.state = { value: 'Type some *markdown* here!' }; } handleChange(e) { this.setState({ value: e.target.value }); } getRawMarkup() { var md = new Remarkable(); return { __html: md.render(this.state.value) }; } render() { return ( Input Output ); } } ReactDOM.render(, mountNode); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/code_评分.html": {
    "url": "React/code_评分.html",
    "title": "code_评分",
    "keywords": "",
    "body": "1. 核心 react 代码1. 核心 react 代码 /* * usage: */ import React from 'react'; import PropTypes from 'prop-types'; const Star = ({ selected = false, onClick = (f) => f }) => ( ); Star.propTypes = { selected: PropTypes.bool, onClick: PropTypes.func, }; export default class StarRating extends React.Component { constructor(props) { super(props); this.state = { starsSelected: props.starsSelected, }; this.change = this.change.bind(this); } change(starsSelected) { this.setState({ starsSelected }); } render() { const { totalStars } = this.props; const { starsSelected } = this.state; return ( {[...Array(totalStars)].map((n, i) => ( this.change(i + 1)} /> ))} {starsSelected} of {totalStars} stars ); } } StarRating.propTypes = { totalStars: PropTypes.number, starsSelected: PropTypes.number, }; StarRating.defaultProps = { totalStars: 5, starsSelected: 0, }; css 代码： html, body, #app { height: 100%; margin: 0; padding: 0; } #app { display: flex; align-items: center; justify-content: center; } .star-rating { display: flex; flex-wrap: wrap; justify-content: space-around; } .star { cursor: pointer; width: 2em; height: 2em; background-color: grey; -webkit-clip-path: polygon( 50% 0%, 63% 38%, 100% 38%, 69% 59%, 82% 100%, 50% 75%, 18% 100%, 31% 59%, 0% 38%, 37% 38% ); clip-path: polygon( 50% 0%, 63% 38%, 100% 38%, 69% 59%, 82% 100%, 50% 75%, 18% 100%, 31% 59%, 0% 38%, 37% 38% ); } .star.selected { background-color: red; } p { flex-basis: 100%; text-align: center; } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/Flux.html": {
    "url": "React/Flux.html",
    "title": "Flux",
    "keywords": "",
    "body": "1. MVC1.1. Flux architecture1. MVC Pros: perfect for one to one mapping: 20 views 20 controllers 20 models good separation of concerns easy to maintain and test Cons: 视图变化太快，模型需要经常变动 Sometimes your view may show several kinds of models, so it's hard to manage the relationship between view and model mappings. i.e, At first, you have a product view showing only product list. When project gets larger, this view may need include user model, comment model, etc. And other views may have the same issue. These dependencies are difficult to manage, and maybe there're cyclic dependencies. In Asp.net MVC, the solution is create a viewModel. But you have to write extra code about viewModel. 1.1. Flux architecture Due to the MVC shortcomings, Facebook has a view including message list, a small message window, message indicator on right conner. They use flux to manage the message state. flux one way data flow just as react: view(jsx) --> actions --> dispatcher(singleton, make sure action is handler one by one) --> stores(read only) --> back to view Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/HOF_currying_HOC.html": {
    "url": "React/HOF_currying_HOC.html",
    "title": "HOF_currying_HOC",
    "keywords": "",
    "body": "1. Higher-Order Functions -- Functions that can manipulate other functions.1.1. Take functions as arguments1.2. return functions - currying1.3. Higher Order Component1. Higher-Order Functions -- Functions that can manipulate other functions. 3 categories: take functions in as arguments return functions both 1.1. Take functions as arguments The first category of higher-order functions are functions that expect other functions as arguments. Array.map, Array.filter, and Array.reduce all take functions as arguments. They are higher-order functions. In the following example, we create an invokeIf callback function that will test a condition and invoke on callback function when it is true and another callback function when that condition is false: const invokeIf = (condition, fnTrue, fnFalse) => (condition ? fnTrue() : fnFalse()); const showWelcome = () => console.log('Welcome!!!'); const showUnauthorized = () => console.log('Unauthorized!!!'); invokeIf(true, showWelcome, showUnauthorized); // \"Welcome\" invokeIf(false, showWelcome, showUnauthorized); // \"Unauthorized\" invokeIf expects two functions: one for true, and one for false. This is demonstrated by sending both showWelcome and showUnauthorized to invokeIf. When the condition is true, showWelcome is invoked. When it is false, showUnauthorized is invoked. 1.2. return functions - currying Higher-order functions that return other functions can help us handle the complexities associated with asynchronicity in JavaScript. They can help us create functions that can be used or reused at our convenience. Currying is a functional technique that involves the use of higher-order functions. Currying is the practice of holding on to some of the values needed to complete an operation until the rest can be supplied at a later point in time. This is achieved through the use of a function that returns another function, the curried function. The following is an example of currying. The userLogs function hangs on to some information (the username) and returns a function that can be used and reused when the rest of the information (the message) is made available. In this example, log messages will all be prepended with the associated username. Notice that we’re using the getFakeMembers function that returns a promise. const userLogs = (userName) => (message) => console.log(`${userName} -> ${message}`); const log = userLogs('grandpa23'); log('attempted to load 20 fake members'); getFakeMembers(20).then( (members) => log(`successfully loaded ${members.length} members`), (error) => log('encountered an error loading members'), ); // grandpa23 -> attempted to load 20 fake members // grandpa23 -> successfully loaded 20 members // grandpa23 -> attempted to load 20 fake members // grandpa23 -> encountered an error loading members userLogs is the higher-order function. The log function is produced from userLogs, and every time the log function is used, “grandpa23” is prepended to the message. 1.3. Higher Order Component This is an example in react.fundamentals /** * HOC for data fetching */ import React from 'react'; const DataComponent = (ComposedComponent, url) => class NewComponent extends React.Component { constructor(props) { super(props); this.state = { data: [], loading: false, }; this._getData = this._getData.bind(this); this.fetchByParam = this.fetchByParam.bind(this); } _getData(param = {}) { // 如果 param 传入 url 参数则根据此 url 进行查询，不然根据顶层传入 url 参数查询 if (param.url) { url = param.url; } this.setState({ loading: true }); fetch(url) .then((response) => response.json()) .then((data) => { if (this._isMount) { this.setState({ loading: false, data: data.items, param }); } }); } fetchByParam(param) { this._getData(param); } componentWillMount() { this._getData(); } componentDidMount() { this._isMount = true; } componentWillUnmount() { this._isMount = false; } // only for solution 4. 返回的NewComponent作为子组件，父组件状态作为props传到子组件 // 父组件状态改变的时候，自组件props发生改变，该方法触发，根据传入的param进行数据查询 componentWillReceiveProps(nextProps) { // console.log(`nextProps`, nextProps.param); // call getData only when param props changed. Other props change will enter componentWillReceiveProps too, but we don't want to fetch data if (nextProps.param) { this._getData(nextProps.param); } } render() { return ( {this.state.loading ? ( Loading... ) : ( )} ); } }; export default DataComponent; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/immutability-helper.html": {
    "url": "React/immutability-helper.html",
    "title": "immutability-helper",
    "keywords": "",
    "body": "1. Immutability-helper 修改 nested array of objects1.1. 一次操作，只修改某个内嵌 object 的字段1.1.1. 如何根据 id 找到 对应的 index1.2. 多次操作1.2.1. 如何根据 actionArr 构建 update 语句1. Immutability-helper 修改 nested array of objects 1.1. 一次操作，只修改某个内嵌 object 的字段 原数组： const products = [ { id: '111', analysis: [{ id: 1, value: 0 }, { id: 2, value: 0 }, { id: 3, value: 0 }], }, { id: '222', analysis: [{ id: 1, value: 0 }, { id: 2, value: 0 }, { id: 3, value: 0 }], }, ]; 操作：根据 productId 和 analysisId 找到 nested object, 只更新他的 value const action = { id: '111', analysisId: 2, value: 99 }; 处理代码：使用 immutability-helper 时需要找到要更新 object 在 array 中的 index。如上面 id=111 对应 index=0，analysisId=2 对应 index=1 const newProducts = update(products, { 0: { analysis: { 1: { $merge: { value: 99 } }, // 0: { $merge: { value: 99 }} // 可以一次性更新多个操作，这里只是举例 }, }, }); 结果： const newProducts = [ { id: '111', analysis: [ { id: 1, value: 0 }, - { id: 2, value: 0 }, + { id: 2, value: 99 }, { id: 3, value: 0 } }, { id: '222', analysis: [ { id: 1, value: 0 }, { id: 2, value: 0 }, { id: 3, value: 0 } ] } ] 1.1.1. 如何根据 id 找到 对应的 index const targetProductIndex = products.findIndex((x) => x.id === action.id); const targetProduct = products.find((x) => x.id === action.id); const targetAnalysisIndex = targetProduct.analysis.findIndex((x) => x.id === action.analysisId); const targetAnalysis = targetProduct.analysis.find((x) => x.id === action.analysisId); const result = update(products, { [targetProductIndex]: { analysis: { [targetAnalysisIndex]: { $merge: { value: action.value } }, }, }, }); 1.2. 多次操作 const actionArr = [ { id: '111', analysisId: 1, value: 99 }, { id: '111', analysisId: 3, value: 99 }, { id: '222', analysisId: 3, value: 99 }, ]; 以上意味着 3 次操作。第一次找到 productId=111，再找到 analysisId=1，更新他 value 从 0 到 99。剩下两次操作类似。 经过操作后 products 的结果： const newProducts = [ { id: '111', analysis: [ - { id: 1, value: 0 }, + { id: 3, value: 99 }, { id: 2, value: 0 }, - { id: 3, value: 0, }, + { id: 3, value: 99 } ] }, { id: '222', analysis: [ { id: 1, value: 0 }, { id: 2, value: 0 }, - { id: 3, value: 0 }, + { id: 3, value: 99, }, ] } ] 处理代码： const newProducts = update(products, { 0: { analysis: { 0: { $merge: { value: 99 } }, 2: { $merge: { value: 99 } }, }, }, 1: { analysis: { 2: { $merge: { value: 99 } }, }, }, }); 1.2.1. 如何根据 actionArr 构建 update 语句 思路 1：每循环 actionArr 一次时，进行一次 update 操作，返回第一次操作后的结果，作为第二次 update 的对象。依次，所以用 reduce。但这样多次复制对象，不太好 多个循环积累更新： const actionArr = [ { id: '111', analysisId: 1, value: 99 }, { id: '111', analysisId: 3, value: 99 }, { id: '222', analysisId: 3, value: 99 }, ]; // acc 每次操作积累的结果，cur 是 actionArr 循环中当前对象。首次 acc = products const result = actionArr.reduce((acc, cur) => { const targetIndex = acc.findIndex((x) => x.id === cur.id); const target = acc.find((x) => x.id === cur.id); const targetAnalysisIndex = target.analysis.findIndex((x) => x.id === cur.analysisId); const targetAnalysis = target.analysis.find((x) => x.id === cur.analysisId); return update(acc, { [targetIndex]: { analysis: { [targetAnalysisIndex]: { $merge: { value: cur.value } }, }, }, }); }, products); 思路 2：循环构建好 update 语句中的对象，之后一次性更新 const buildUpdateOperation = (source, actionArr) => { let result = {}; actionArr.forEach((action) => { const targetIndex = source.findIndex((x) => x.id === action.id); const target = source.find((x) => x.id === action.id); const targetAnalysisIndex = target.analysis.findIndex((x) => x.id === action.analysisId); const targetAnalysis = target.analysis.find((x) => x.id === action.analysisId); if (result[targetIndex]) { // 第二次更新同一个 product，但 analysisId 不同 result[targetIndex].analysis[targetAnalysisIndex] = { $merge: { value: action.value } }; } else { // 首次不存在 index，赋值 result[targetIndex] = { analysis: { [targetAnalysisIndex]: { $merge: { value: c.value } }, }, }; } }); return result; }; 生成的结果为： { 0: { analysis: { 0: { $merge: { value: 99 } }, 2: { $merge: { value: 99 } } } }, 1: { analysis: { 2: { $merge: { value: 99 } } } } } 一次行更新： const updateQuery = buildUpdateOperation(products, actionArr); const newProducts = update(products, updateQuery); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/Immutability.html": {
    "url": "React/Immutability.html",
    "title": "Immutability",
    "keywords": "",
    "body": "1. Immutability 对象不可变性1.1. Why Immutability1.2. Immutability Use Case1.2.1. Array with simple types like number, string1.2.2. Object Change1.2.3. Array of Objects1. Immutability 对象不可变性 Most valuable reference: https://redux.js.org/recipes/structuringreducers/immutableupdatepatterns 通过复制一个新的对象，使得新对象和老对象不引用同一个地址。这样在一个 reducer 函数中不去直接修改老对象的属性，而是创建一个新对象并根据 action 修改其属性并返回。 var player = { score: 1, name: 'Jeff', }; var newPlayer = Object.assign({}, player, { score: 2 }); // Now player is unchanged, but newPlayer is {score: 2, name: 'Jeff'} // Or if you are using object spread syntax proposal, you can write: var newPlayer = { ...player, score: 2, }; 1.1. Why Immutability 因为我们知道修改之前和修改之后的状态，方便我们追踪对象改变的属性 Because shouldComponentUpdate or PureComponent does a shallow comparison of old and new values, 即只需要 === 比较引用地址是否相同。如果不遵循 不可变性，在原对象修改属性，=== 永远相同，Then UI won't change. reducer 作为一个纯函数，根据之前的 state 和 action 计算出一下个 state。纯函数不能有负效应，对象的不可改变性使得 reducer 能够输出唯一可以预测的值 immutability 要求复制对象，复制对象难道不影响性能吗？ 首先属性不多，其次并没有过分深层嵌套。比起检查每个属性是否改变更高效，而且很容易知道改变前和改变后以及改变的因素，能够方便 debug 和追踪状态改变。最后通过 !== 检测 prevStore 和当前 store 是否相等，即是否来自同一个地址，无需检测每一个属性。检测时配合 shouldComponentUpdate 1.2. Immutability Use Case 1.2.1. Array with simple types like number, string /* push a new element */ const addCounter = (arr) => { // return arr.concat([0]); // old way return [...arr, 0]; // ES6 way }; /* remove an element by index */ const removeCounter = (arr, index) => { // Old way: //return arr // .slice(0, index) // .concat(arr.slice(index + 1)); // ES6 way: return [...arr.slice(0, index), ...arr.slice(index + 1)]; }; /* modify an element by index */ const incrementCounter = (arr, index) => { // Old way: // return arr // .slice(0, index) // .concat([arr[index] + 1]) // .concat(arr.slice(index + 1)); // ES6 way: return [...arr.slice(0, index), arr[index] + 1, ...arr.slice(index + 1)]; }; 1.2.2. Object Change const toggleTodo = (todo) => { // return Object.assign({}, todo, { // completed: !todo.completed // }); return { ...todo, completed: !todo.completed, }; }; 1.2.3. Array of Objects This mixes creating/updating individual item and array together... const reducer = (state = [], action) => { // action : { type: '', payload: obj} const obj = action.payload; switch (action.type) { case 'add': return [...state, obj]; case 'edit': return state.map((item) => { if (item.id === obj.id) { return { ...item, ...obj }; // 用新对象 obj 覆盖掉老 object } else { return item; } }); case 'delete': return state.filter((item) => item.id !== obj.id); default: return state; } }; reducer composition. Separate individual and array: const individualReducer = (state, action) => { // action : { type: '', payload: obj} const obj = action.payload; switch (action.type) { case 'add': return obj; case 'edit': if (state.id === obj.id) return { ...state, ...obj }; else return state; default: return state; } }; const arrayReducer = (state = [], action) => { // action : { type: '', payload: obj} const obj = action.payload; switch (action.type) { case 'add': return [...state, individualReducer(undefined, action)]; case 'edit': return state.map((item) => individualReducer(item, action)); case 'delete': return state.filter((item) => item.id !== obj.id); default: return state; } }; In a functional program, data is immutable. It never changes. Instead of changing the original data structures, we build changed copies of those data structures and use them instead. Consider an object that represents the color lawn: let color_lawn = { title: 'lawn', color: '#00FF00', rating: 0, }; We could build a function that would rate colors, and use that function to change the rating of the color object: function rateColor(color, rating) { color.rating = rating; return color; } console.log(rateColor(color_lawn, 5).rating); // 5 console.log(color_lawn.rating); // 5 In JavaScript, function arguments are references to the actual data. Setting the color's rating like this is bad because it changes or mutates the original color object. We can rewrite the rateColor function so that it does not harm the original goods (the color object): ==Object.assign({}, color, {rating:rating})== var rateColor = function(color, rating) { return Object.assign({}, color, { rating: rating }); }; console.log(rateColor(color_lawn, 5).rating); // 5 console.log(color_lawn.rating); // 4 Here, we used Object.assign to change the color rating. Object.assign is the copy machine; it takes a blank object, copies the color to that object, and overwrites the rating on the copy. Now we can have a newly rated color object without having to change the original. We can write the same function using an ES6 arrow function along with the ES7 object spread operator. This rateColor function uses the spread operator to copy the color into a new object and then overwrite its rating: const rateColor = (color, rating) => ({ ...color, rating, }); This emerging JavaScript version of the rateColor function is exactly the same as the previous one. It treats color as an immutable object, does so with less syntax, and looks a little bit cleaner. Notice that we wrap the returned object in parentheses. With arrow functions, this is a required step since the arrow can't just point to an object's curly braces. Let's consider an array of color names: let list = [{ title: 'Rad Red' }, { title: 'Lawn' }, { title: 'Party Pink' }]; We could create a function that will add colors to that array using Array.push: var addColor = function(title, colors) { colors.push({ title: title }); return colors; }; console.log(addColor('Glam Green', list).length); // 4 console.log(list.length); // 4 However, Array.push is not an immutable function. This addColor function changes the original array by adding another field to it. In order to keep the colors array immutable, we must use Array.concat instead: const addColor = (title, array) => array.concat({ title }); console.log(addColor('Glam Green', list).length); // 4 console.log(list.length); // 3 Array.concat concatenates arrays. In this case, it takes a new object, with a new color title, and adds it to a copy of the original array. You can also use the ES6 spread operator to concatenate arrays in the same way it can be used to copy objects. Here is the emerging JavaScript equivalent of the previous addColor function: const addColor = (title, list) => [...list, { title }]; This function copies the original list to a new array and then adds a new object containing the color's title to that copy. It is immutable. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/Imperative_vs_Declarative.html": {
    "url": "React/Imperative_vs_Declarative.html",
    "title": "Imperative_vs_Declarative",
    "keywords": "",
    "body": "1. Imperative and Declarative1.1. Building a clock declaratively1. Imperative and Declarative Functional programming is a part of a larger programming paradigm: declarative programming. Declarative programming is a style of programming where applications are structured in a way that prioritizes describing what should happen over defining how it should happen. In order to understand declarative programming, we’ll contrast it with imperative programming, or a style of programming that is only concerned with how to achieve results with code. Let’s consider a common task: making a string URL-friendly. Typically, this can be accomplished by replacing all of the spaces in a string with hyphens, since spaces are not URL-friendly. First, let’s examine an imperative approach to this task: // Imperative programming // Just looking at the code alone does not tell us much. Imperative programs require lots of comments in order to understand what is going on. var string = 'This is the midday show with Cheryl Waters'; var urlFriendly = ''; for (var i = 0; i // declarative const string = 'This is the mid day show with Cheryl Waters'; const urlFriendly = string.replace(/ /g, '-'); console.log(urlFriendly); Here we are using string.replace along with a regular expression to replace all instances of spaces with hyphens. Using string.replace is a way of describing what is supposed to happen: spaces in the string should be replaced. The details of how spaces are dealt with are abstracted away inside the replace function. In a declarative program, the syntax itself describes what should happen and the details of how things happen are abstracted away. Declarative programs are easy to reason about because the code itself describes what is happening. For example, read the syntax in the following sample—it details what happens after members are loaded from an API: const loadAndMapMembers = compose( combineWith(sessionStorage, 'members'), save(sessionStorage, 'members'), scopeMembers(window), logMemberInfoToConsole, logFieldsToConsole('name.first'), countMembersBy('location.state'), prepStatesForMapping, save(sessionStorage, 'map'), renderUSMap, ); getFakeMembers(100).then(loadAndMapMembers); The declarative approach is more readable and, thus, easier to reason about. The details of how each of these functions is implemented are abstracted away. Those tiny functions are named well and combined in a way that describes how member data goes from being loaded to being saved and printed on a map, and this approach does not require many comments. Essentially, declarative programming produces applications that are easier to reason about, and when it is easier to reason about an application, that application is easier to scale. Now, let’s consider the task of building a document object model, or DOM. An imperative approach would be concerned with how the DOM is constructed: var target = document.getElementById('target'); var wrapper = document.createElement('div'); var headline = document.createElement('h1'); wrapper.id = 'welcome'; headline.innerText = 'Hello World'; wrapper.appendChild(headline); target.appendChild(wrapper); This code is concerned with creating elements, setting elements, and adding them to the document. It would be very hard to make changes, add features, or scale 10,000 lines of code where the DOM is constructed imperatively. Now let’s take a look at how we can construct a DOM declaratively using a React component: const Welcome = () => ( Hello World ); ReactDOM.render(, document.getElementById('target')); React is declarative. Here, the Welcome component describes the DOM that should be rendered. The render function uses the instructions declared in the component to build the DOM, abstracting away the details of how the DOM is to be rendered. We can clearly see that we want to render our Welcome component into the element with the ID of 'target'. 1.1. Building a clock declaratively Our challenge is to build a ticking clock. The clock needs to display hours, minutes, seconds and time of day in civilian time. Each field must always have double digits, meaning leading zeros need to be applied to single digit values like 1 or 2. The clock must also tick and change the display every second. First, let’s review an imperative solution for the clock. // Log Clock Time every Second setInterval(logClockTime, 1000); function logClockTime() { // Get Time string as civilian time var time = getClockTime(); // Clear the Console and log the time console.clear(); console.log(time); } function getClockTime() { // Get the Current Time var date = new Date(); // Serialize clock time var time = { hours: date.getHours(), minutes: date.getMinutes(), seconds: date.getSeconds(), ampm: 'AM', }; // Convert to civilian time if (time.hours == 12) { time.ampm = 'PM'; } else if (time.hours > 12) { time.ampm = 'PM'; time.hours -= 12; } // Prepend a 0 on the hours to make double digits if (time.hours It works, and the comments help us understand what is happening. However, these functions are large and complicated. Each function does a lot. They are hard to comprehend, they require comments and they are tough to maintain. Let’s see how a functional approach can produce a more scalable application. Our goal will be to break the application logic up into smaller parts, functions. Each function will be focused on a single task, and we will compose them into larger functions that we can use to create the clock. First, let’s create some functions that give us values and manage the console. We’ll need a function that gives us one second, a function that gives us the current time, and a couple of functions that will log messages on a console and clear the console. In functional programs, we should use functions over values wherever possible. We will invoke the function to obtain the value when needed. const oneSecond = () => 1000; const getCurrentTime = () => new Date(); const clear = () => console.clear(); const log = (message) => console.log(message); Next we will need some functions for transforming data. These three functions will be used to mutate the Date object into an object that can be used for our clock: serializeClockTime Takes a date object and returns a object for clock time that contains hours minutes and seconds. civilianHours Takes the clock time object and returns an object where hours are converted to civilian time. For example: 1300 becomes 1 o’clock appendAMPM Takes the clock time object and appends time of day, AM or PM, to that object. const serializeClockTime = (date) => ({ hours: date.getHours(), minutes: date.getMinutes(), seconds: date.getSeconds(), }); // clockTime { hours, minutes, seconds } const civilianHours = (clockTime) => ({ ...clockTime, hours: clockTime.hours > 12 ? clockTime.hours - 12 : clockTime.hours, }); const appendAMPM = (clockTime) => ({ ...clockTime, ampm: clockTime.hours >= 12 ? 'PM' : 'AM', }); These three functions are used to transform data without changing the original. They treat their arguments as immutable objects. Next we’ll need a few higher order functions: display Takes a target function and returns a function that will send a time to the target. In this example the target will be console.log. formatClock Takes a template string and uses it to return clock time formatted based upon the criteria from the string. In this example, the template is “hh:mm:ss tt”. FormatClock will replaces the placeholders with hours, minutes, seconds, and time of day. prependZero Takes an object’s key as an argument and prepends a zero to the value stored under that objects key. It takes in a key to a specific field and prepends values with a zero if the value is less than 10. // target is console.log in this case, target maybe alert etc const display = (target) => (time) => target(time); // 决定一种 format 格式，比如 const usFormat = formatClock('hh:mm:ss tt'); const formatClock = (format) => (time) => format .replace('hh', time.hours) .replace('mm', time.minutes) .replace('ss', time.seconds) .replace('tt', time.ampm); // key is hours, minutes, seconds, 决定了哪个属性需要 prepend 0 const prependZero = (key) => (clockTime) => ({ ...clockTime, [key]: clockTime[key] These higher order functions will be invoked to create the functions that will be reused to format the clock time for every tick. Both format clock and prependZero will be invoked once, initially setting up the required template or key. The inner functions that they return will be invoked once every second to format the time for display. Now that we have all of the functions required to build a ticking clock, we will need to compose them. We will use the compose function that we defined in the last section to handle composition: convertToCivilianTime A single function that will take clock time as an argument and transforms it into civilian time by using both civilian hours. doubleDigits A single function that will take civilian clock time and make sure the hours, minutes, and seconds display double digits by prepending zeros where needed. startTicking Starts the clock by setting an interval that will invoke a callback every second. The callback is composed using all of our functions. Every second the console is cleared, currentTime obtained, converted, civilianized, formatted, and displayed. // compose 从右向左执行！ const convertToCivilianTime = (clockTime) => compose(appendAMPM, civilianHours)(clockTime); const doubleDigits = (civilianTime) => compose(prependZero('hours'), prependZero('minutes'), prependZero('seconds'))(civilianTime); const startTicking = () => setInterval( compose( clear, getCurrentTime, serializeClockTime, convertToCivilianTime, doubleDigits, formatClock('hh:mm:ss tt'), display(log), ), oneSecond(), ); startTicking(); This declarative version of the clock achieves the same results as the imperative version. However, there quite a few benefits to this approach. all of these functions are easily testable and reusable. They can be used in future clocks or other digital displays. this program is easily scalable. There are no side effects. There are no global variables outside of functions themselves. There could still be bugs, but they will be easier to find. Full code: const oneSecond = () => 1000; const getCurrentTime = () => new Date(); const clear = () => console.clear(); const log = (message) => console.log(message); const abstractClockTime = (date) => ({ hours: date.getHours(), minutes: date.getMinutes(), seconds: date.getSeconds(), }); const civilianHours = (clockTime) => ({ ...clockTime, hours: clockTime.hours > 12 ? clockTime.hours - 12 : clockTime.hours, }); const appendAMPM = (clockTime) => ({ ...clockTime, ampm: clockTime.hours >= 12 ? 'PM' : 'AM', }); const display = (target) => (time) => target(time); const formatClock = (format) => (time) => format .replace('hh', time.hours) .replace('mm', time.minutes) .replace('ss', time.seconds) .replace('tt', time.ampm); const prependZero = (key) => (clockTime) => ({ ...clockTime, [key]: clockTime[key] (arg) => fns.reduce((accu, f) => f(accu), arg); // clockTime 作为 arg，初始值。先 appendAMPM(clockTime)，返回的对象作为 civilianHours 的参数，执行 civilianHours const convertToCivilianTime = (clockTime) => compose(appendAMPM, civilianHours)(clockTime); const doubleDigits = (civilianTime) => compose(prependZero('hours'), prependZero('minutes'), prependZero('seconds'))(civilianTime); const startTicking = () => setInterval( compose( clear, getCurrentTime, abstractClockTime, convertToCivilianTime, doubleDigits, formatClock('hh:mm:ss tt'), display(log), ), oneSecond(), ); startTicking(); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/interview_react1.html": {
    "url": "React/interview_react1.html",
    "title": "interview_react1",
    "keywords": "",
    "body": "1. React Fundamentals1.1. 思想1.2. React 解决了什么问题？思想？好在哪？1.3. 原理，diff1.3.1. tree diff1.3.2. component diff1.3.3. element diff1.3.4. 总结1.4. 组件化思想1.5. React Benefits1.6. What is React1.7. 如何设计一个好组件1.8. 如何对组件进行优化1.9. React 优化 Optimization1. React Fundamentals 1.1. 思想 Composition React 是 MVC's V。组件包含了虚拟 DOM 来展示 UI Components can be used to compose other components much like functional composition Well defined components can be used between different projects Declarative A declarative solution focusses on the WHAT rather than the HOW of the problem and uses the api that abstracts the how to do so. Unidirectional Dataflow In react the state is stored in a component as opposed to the DOM (which is how it is with JQuery) Hence the state is explicitly changed and that causes the DOM to re-render The data flows from the state to the DOM and not the other way around parent components pass data to children components with the help of props Explicit Mutations Changing the state has to be done explicitly in React Since changing the state of a component with this.setState renders it to the DOM there is no need of adding event listeners or dirty checking Just JavaScript React takes advantage of the JavaScript programming language’s functionality, api and capabilities (also functional style) 1.2. React 解决了什么问题？思想？好在哪？ a. React 实现了 Virtual DOM，diff 算法使得更新小量数据性能高 在一定程度上提升了性能，尤其是在进行小量数据更新时。因为 DOM 操作是很耗性能的，而 Virtual DOM 是在内存中进行操作的，当数据发生变化时，通过 diff 算法 比较两棵树之间的变化，再进行必要的 DOM 更新，省去了不必要的高消耗的 DOM 操作。当然，这种性能优化主要体现在有小量数据更新的情况下。因为 React 的基本思维模式是每次有变动就重新渲染整个应用，简单想来就是直接重置 innerHTML，比如说在一个大型列表所有数据都变动的情况下，重置 innerHTML 还比较合理，但若是只有一行数据变了，它也需要重置整个 innerHTML，就会造成大量的浪费。而 Virtual DOM 虽然进行了 JS 层面的计算，但是比起 DOM 操作来说，简直不要太便宜。 为什么操作真实 DOM 比 React 更快？ b. React 的一个核心思想是声明式编程。 命令式编程是解决做什么的问题，就像是下命令一样，关注于 WHAT，做什么就调用对象 API。而声明式编程关注于 HOW 如何做才能得到结果。在 React 中，我们只需要关注“目前的状态是什么”，而不是探究“我如何做才能让页面变成目前的状态”。React 就是不断声明，然后在特定的参数下渲染 UI 界面。这种编程方式可以让我们的代码更容易被理解，从而易于维护。 c. 组件化 React 天生组件化，我们可以将一个大的应用分割成很多小组件，这样有好几个优势。首先组件化的代码像一棵树一样清楚干净，比起传统的面条式代码可读性更高；其次前端人员在开发过程中可以并行开发组件而不影响，大大提高了开发效率；最重要的是，组件化使得复用性大大提高，团队可以沉淀一些公共组件或工具库。 d. 单向数据流 在 React 中数据流是单向的，由父节点流向子节点，如果父节点的 props 发生了变化，那么 React 会递归遍历整个组件树，重新渲染所有使用该属性的子组件。这种单向的数据流一方面比较清晰不容易混乱，另一方面是比较好维护，出了问题也比较好定位。 1.3. 原理，diff React diff 会帮助我们计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行实际 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染，因此 Virtual DOM 与 diff 是保证 React 性能口碑的幕后推手。而且 React 能够批处理虚拟 DOM 的刷新，在一个事件循环 (Event Loop)内的两次数据变化会被合并，例如你连续的先将节点内容从 A 变成 B，然后又从 B 变成 A，React 会认为 UI 不发生任何变化。尽管每一次都需要构造完整的虚拟 DOM 树，但是因为虚拟 DOM 是内存数据，性能是极高的，而对实际 DOM 进行操作的仅仅是 Diff 部分，因而能达到提高性能的目的。 传统 diff 算法通过循环递归对节点进行依次对比，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。 React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。 diff 策略： tree diff: Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。 component diff: 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。 element diff: 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。 1.3.1. tree diff 对树进行分层比较，两棵树只会对同一层次的节点进行比较。 既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。 分析至此，大部分人可能都存在这样的疑问：如果出现了 DOM 节点跨层级的移动操作，React diff 会有怎样的表现呢？是的，对此我也好奇不已，不如试验一番。 如下图，A 节点 (包括其子节点)整个被移动到 D 节点下，由于 React 只会简单的考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作。当根节点发现子节点中 A 消失了，就会直接销毁 A；当 D 发现多了一个子节点 A，则会创建新的 A (包括子节点)作为其子节点。此时，React diff 的执行情况：create A -> create B -> create C -> delete A。 由此可发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的树被整个重新创建，这是一种影响 React 性能的操作，因此 React 官方建议不要进行 DOM 节点跨层级的操作。 注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。 1.3.2. component diff React 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。 如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。 如下图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。虽然当两个 component 是不同类型但结构相似时，React diff 会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。 1.3.3. element diff 当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP (插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)。 INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。 MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。 REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。 如下图，老集合中包含节点：A、B、C、D，更新后的新集合中包含节点：B、A、D、C，此时新老集合进行 diff 差异化对比，发现 B != A，则创建并插入 B 至新集合，删除老集合 A；以此类推，创建并插入 A、D 和 C，删除 B、C 和 D。 React 发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。 针对这一现象，React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！ 新老集合所包含的节点，如下图所示，新老集合进行 diff 差异化对比，通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行移动操作，即可。 那么，如此高效的 diff 到底是如何运作的呢？让我们通过源码进行详细分析。 首先对新集合的节点进行循环遍历，for (name in nextChildren)，通过唯一 key 可以判断新老集合中是否存在相同的节点，if (prevChild === nextChild)，如果存在相同节点，则进行移动操作，但在移动前需要将当前节点在老集合中的位置与 lastIndex 进行比较，if (child._mountIndex 以上图为例，可以更为清晰直观的描述 diff 的差异对比过程： 从新集合中取得 B，判断老集合中存在相同节点 B，通过对比节点位置判断是否进行移动操作，B 在老集合中的位置 B._mountIndex = 1，此时 lastIndex = 0，不满足 child._mountIndex 从新集合中取得 A，判断老集合中存在相同节点 A，通过对比节点位置判断是否进行移动操作，A 在老集合中的位置 A._mountIndex = 0，此时 lastIndex = 1，满足 child._mountIndex 从新集合中取得 D，判断老集合中存在相同节点 D，通过对比节点位置判断是否进行移动操作，D 在老集合中的位置 D._mountIndex = 3，此时 lastIndex = 1，不满足 child._mountIndex 从新集合中取得 C，判断老集合中存在相同节点 C，通过对比节点位置判断是否进行移动操作，C 在老集合中的位置 C._mountIndex = 2，此时 lastIndex = 3，满足 child._mountIndex 以上主要分析新老集合中存在相同节点但位置不同时，对节点进行位置移动的情况，如果新集合中有新加入的节点且老集合存在需要删除的节点，那么 React diff 又是如何对比运作的呢？ 以下图为例： 从新集合中取得 B，判断老集合中存在相同节点 B，由于 B 在老集合中的位置 B._mountIndex = 1，此时 lastIndex = 0，因此不对 B 进行移动操作；更新 lastIndex ＝ 1，并将 B 的位置更新为新集合中的位置 B._mountIndex = 0，nextIndex++进入下一个节点的判断。 从新集合中取得 E，判断老集合中不存在相同节点 E，则创建新节点 E；更新 lastIndex ＝ 1，并将 E 的位置更新为新集合中的位置，nextIndex++进入下一个节点的判断。 从新集合中取得 C，判断老集合中存在相同节点 C，由于 C 在老集合中的位置 C._mountIndex = 2，此时 lastIndex = 1，因此对 C 进行移动操作；更新 lastIndex ＝ 2，并将 C 的位置更新为新集合中的位置，nextIndex++ 进入下一个节点的判断。 从新集合中取得 A，判断老集合中存在相同节点 A，由于 A 在老集合中的位置 A._mountIndex = 0，此时 lastIndex = 2，因此不对 A 进行移动操作；更新 lastIndex ＝ 2，并将 A 的位置更新为新集合中的位置，nextIndex++ 进入下一个节点的判断。 当完成新集合中所有节点 diff 时，最后还需要对老集合进行循环遍历，判断是否存在新集合中没有但老集合中仍存在的节点，发现存在这样的节点 D，因此删除节点 D，到此 diff 全部完成。 当然，React diff 还是存在些许不足与待优化的地方，如下图所示，若新集合的节点更新为：D、A、B、C，与老集合对比只有 D 节点移动，而 A、B、C 仍然保持原有的顺序，理论上 diff 应该只需对 D 执行移动操作，然而由于 D 在老集合的位置是最大的，导致其他节点的 _mountIndex 在此，读者们可以讨论思考：如何优化上述问题？ 建议：在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。 1.3.4. 总结 React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题； React 通过分层求异的策略，对 tree diff 进行算法优化； React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化； React 通过设置唯一 key的策略，对 element diff 进行算法优化； 建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升； 建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。 1.4. 组件化思想 组件，即封装起来的具有独立功能的 UI 部件。React 推荐以组件的方式去重新思考 UI 构成，将 UI 上每一个功能相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体 UI 的构建。 如果说 MVC 的思想让你做到 视图-数据-控制器 的分离，那么组件化的思考方式则是带来了UI 功能模块之间的分离。 对于 MVC 开发模式来说，开发者将三者定义成不同的类，实现了表现，数据，控制的分离。对于 React 而言，则完全是一个新的思路，开发者从功能的角度出发，将 UI 分成不同的组件，每个组件都独立封装。在 React 中，你按照界面模块自然划分的方式来组织和编写你的代码，整个 UI 是一个通过小组件构成的大组件，每个组件只关心自己部分的逻辑，彼此独立。 React 组件特征： 可组合(Composable)：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部 可重用(Reusable)：每个组件都是具有独立功能的，它可以被使用在多个 UI 场景 可维护(Maintainable)：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护 1.5. React Benefits just JavaScript js 原生方法入 each、map 遍历集合，无需 ngRepeat Declarative Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes. Declarative views make your code more predictable and easier to debug. Component-Based Since component logic is written in JavaScript instead of templates, you can easily pass rich data through your app and keep state out of the DOM. No string concatenation. Reactive update 通过算法做最小改变，速度快 One way Unidirectional data flow 很容易知道数据所处的状态。Only cares about state, and UI will be updated based on state Composition Components can nest others, Using Composition instead of Inheritance. 1.6. What is React We care only about the state, once state changes, UI will be automatically updated by React. State and UI are separated a library for building user interfaces. a React element is an object representation of a DOM node. It’s important to note that a React element isn’t actually the thing you’ll see on your screen, instead, it’s just an object representation of it. There’s a few reasons for this. JavaScript objects are lightweight — React can create and destroy these elements without too much overhead. React is able to analyze the object, diff it with the previous object representation to see what changed, and then update the actual DOM only where those changes occurred. This has some performance upsides to it. virtual DOM is a JavaScript representation of the actual DOM. React can keep track of the difference between the current virtual DOM (computed after some data changes), with the previous virtual DOM (computed before some data changes). React then isolates the changes between the old and new virtual DOM and then only updates the real DOM with the necessary changes. Because manipulating the actual DOM can be complex, React is able to minimize manipulations to the actual DOM by keeping track of a virtual DOM and only updating the real DOM when necessary and with only the necessary changes. By re-rendering the virtual DOM every time any state change occurs, React makes it easier to think about what state your application is in. Signal to notify our app some data has changed -> Re-render virtual DOM -> Diff previous virtual DOM with new virtual DOM -> Only update real DOM with necessary changes. 1.7. 如何设计一个好组件 SOLID: single responsibility, open-close, 里式替换, Interface segregation(small interface), DI 组件的主要目的是为了更好的复用，所以在设计组件的时候需要遵循高内聚低耦合的原则。 可以通过遵循几种设计模式原则来达到高复用的目的，比如单一职责原则：React 推崇的是“组合”而非“继承”，所以在设计时尽量不设计大的组件，而是开发若干个单一功能的组件，重点就是每个组件只做一件事。 开放/封闭原则，就是常说的对修改封闭，对扩展开放。在 React 中我们可以用高阶组件来实现。使用高阶组件来实现组件的复用。高阶组件就是一个包装了另一个 React 组件的 React 组件，它包括属性代理（高阶组件操控着传递给被包裹组件的属性）和反向继承（实际上高阶组件继承被包裹组件）。我们可以用高阶组件实现代码复用，逻辑抽象。 使用容器组件来处理逻辑，展示组件来展示数据（也就是逻辑处理与数据展示分离）。比如可以在容器组件中进行数据的请求与处理，然后将处理后的数据传递给展示组件，展示组件只负责展示，这样容器组件和展示组件就可以更好地复用了。 编写组件代码时要符合规范，总之就是要可读性强、复用性高、可维护性好。 1.8. 如何对组件进行优化 使用上线构建（Production Build）：会移除脚本中不必要的报错和警告，减少文件体积 避免重绘：重写 shouldComponentUpdate 函数，手动控制是否应该调用 render 函数进行重绘 使用 Immutable Data 不修改数据，而是重新赋值数据。这样在检测数据对象是否发生修改方面会非常快，因为只需要检测对象引用即可，不需要挨个检测对象属性的更改 在渲染组件时尽可能添加 key，这样 virtual DOM 在对比的时候就更容易知道哪里是修改元素，哪里是新插入的元素 1.9. React 优化 Optimization 1. Use the Production Build Typically you’d use Webpack's DefinePlugin method to set NODE_ENV to production. This will strip out things like propType validation and extra warnings. On top of that, it’s also a good idea to minify your code because React uses Uglify's dead-code elimination to strip out development only code and comments, which will drastically reduce the size of your bundle. TreeShaking new webpack.DefinePlugin({ 'process.env': { NODE_ENV: JSON.stringify('production'), }, }); 2. Profiling Components with the Chrome Performance Tab 3. Avoid Reconciliation, use shouldComponentUpdate or PureComponent but don't mutate data In some cases, your component can speed all of this up by overriding the lifecycle function shouldComponentUpdate, which is triggered before the re-rendering process starts. The default implementation of this function returns true, leaving React to perform the update. If you know that in some situations your component doesn't need to update, you can return false from shouldComponentUpdate instead, to skip the whole rendering process, including calling render() on this component and below. 4. looping thru -- add key 比如我们现在有个 listComponent，每个 item 是个 component，总共有很多 10 万个吧。新增一条数据时，如果不用 shouldComponentUpdate 也没加 key，react 会重新渲染 10 万个和这个新加的数据，性能弱。 //当下一次 props 和当前不同时，return true，告诉react去更新重新渲染。注意这里逻辑必须简洁，不然可能比react自动渲染的逻辑还费时 shouldComponentUpdate(nextProps, nextState){ return this.props.name !== nextProps.name } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/interview_react2.html": {
    "url": "React/interview_react2.html",
    "title": "interview_react2",
    "keywords": "",
    "body": "1. react interview1.1. Describe how events are handled in React. 事件在 React 中的处理方式1.2. 组件的 render 函数何时被调用1.3. 调用 render 时 DOM 就一定会被更新吗1.4. 不同父节点的组件需要对彼此的状态进行改变时应该怎么实现1.5. What happens when you call setState1.6. What’s the difference between an Element and a Component in React1.7. When would you use a Class Component over a Functional Component1.8. What are keys in React and why are they important1.9. If you created a React element like Twitter below, what would the component definition of Twitter look like1.10. Why would you use React.Children.map(props.children, () => ) instead of props.children.map(() => )1.11. What is the difference between createElement and cloneElement1.12. What is the second argument that can optionally be passed to setState and what is its purpose1.13. What is wrong with this code1.14. What is the difference between a controlled component and an uncontrolled component1.15. When to Use ref/uncontrolled components1.16. Exposing DOM Refs to Parent Components1.17. React.PureComponent1.18. Setting up first React component with npm, webpack and babel1.19. this.props.children1. react interview 1.1. Describe how events are handled in React. 事件在 React 中的处理方式 In order to solve cross browser compatibility issues, your event handlers in React will be passed instances of SyntheticEvent, which is React’s cross-browser wrapper around the browser’s native event. These synthetic events have the same interface as native events you’re used to, except they work identically across all browsers. What’s mildly interesting is that React doesn’t actually attach events to the child nodes themselves. React will listen to all events at the top level using a single event listener. This is good for performance and it also means that React doesn’t need to worry about keeping track of event listeners when updating the DOM. 在 React 底层，主要对合成事件做了两件事：事件委托和自动绑定。 事件委托：React 的事件代理机制不会把事件处理函数直接绑定到真实的结点上，而是把所有事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。 自动绑定：在 React 组件中，每个方法的上下文都会指向该组件的实例，即自动绑定 this 为当前组件。在使用 ES6 class 和纯函数时，这种自动绑定就不存在了，需要我们手动绑定 this.bind() 方法、双冒号语法、构造器内声明、箭头函数。用 bind 写在 constructor 里面最好。直接写在 jsx 中在 re-render 会有重新绑定的问题。 1.2. 组件的 render 函数何时被调用 组件 state 发生改变时会调用 render 函数，比如通过 setState 函数改变组件自身的 state 值 继承的 props 属性发生改变时也会调用 render 函数，即使改变的前后值一样 React 生命周期中有个 componentShouldUpdate 函数，默认返回 true，即允许 render 被调用，我们也可以重写这个函数，判断是否应该调用 render 函数 1.3. 调用 render 时 DOM 就一定会被更新吗 不一定更新。 React 组件中存在两类 DOM，render 函数被调用后， React 会根据 props 或者 state 重新创建一棵 virtual DOM 树，虽然每一次调用都重新创建，但因为创建是发生在内存中，所以很快不影响性能。而 virtual dom 的更新并不意味着真实 DOM 的更新，React 采用 diff 算法 将 virtual DOM 和真实 DOM 进行比较，找出需要更新的最小的部分，这时 Real DOM 才可能发生修改。 所以每次 state 的更改都会使得 render 函数被调用，但是页面 DOM 不一定发生修改。 1.4. 不同父节点的组件需要对彼此的状态进行改变时应该怎么实现 lifting state to parent of A and B 用 Flux/Redux 管理状态 1.5. What happens when you call setState The first thing React will do when setState is called is merge the object you passed into setState into the current state of the component. This will kick off a process called reconciliation. The end goal of reconciliation is to, in the most efficient way possible, update the UI based on this new state. To do this, React will construct a new tree of React elements (which you can think of as an object representation of your UI). Once it has this tree, in order to figure out how the UI should change in response to the new state, React will diff this new tree against the previous element tree. By doing this, React will then know the exact changes which occurred, and by knowing exactly what changes occurred, will able to minimize its footprint on the UI by only making updates where absolutely necessary. 1.6. What’s the difference between an Element and a Component in React Simply put, a React element describes what you want to see on the screen. Not so simply put, a React element is an object representation of some UI. A React component is a function or a class which optionally accepts input and returns a React element (typically via JSX which gets transpiled to a createElement invocation). For more info, check out React Elements vs React Components 1.7. When would you use a Class Component over a Functional Component If your component has state or a lifecycle method(s), use a Class component. Otherwise, use a Functional component. 1.8. What are keys in React and why are they important Keys are what help React keep track of what items have changed, been added, or been removed from a list. render () { return ( {this.state.todoItems.map(({task, uid}) => { return {task} })} ) } It’s important that each key be unique among siblings. We’ve talked a few times already about reconciliation and part of this reconciliation process is performing a diff of a new element tree with the most previous one. Keys make this process more efficient when dealing with lists because React can use the key on a child element to quickly know if an element is new or if it was just moved when comparing trees. And not only do keys make this process more efficient. But without keys, React can’t know which local state corresponds to which item on move. So never neglect keys when mapping. 1.9. If you created a React element like Twitter below, what would the component definition of Twitter look like {(user) => (user === null ? : )} import React, { Component } from 'react'; import fetchUser from 'twitter'; // fetchUser take in a username returns a promise which will resolve with that username's data. class Twitter extends Component { // finish this } Take notice of what’s inside the opening and closing tags above. Instead of another component as you’ve probably seen before, the Twitter component’s child is a function. What this means is that in the implementation of the Twitter component, we’ll need to treat props.children as a function. import React, { Component } from 'react'; import fetchUser from 'twitter'; class Twitter extends Component { constructor(props) { super(props); this.state = { user: null, }; } componentDidMount() { fetchUser(this.props.username).then((user) => this.setState({ user })); } render() { return this.props.children(this.state.user); } } Notice that, just as I mentioned above, I treat props.children as a function by invoking it and passing it the user. What’s great about this pattern is that we’ve decoupled our parent component from our child component. The parent component manages the state and the consumer of the parent component can decide in which way they’d like to apply the arguments they receive from the parent to their UI. To demonstrate this, let’s say in another file we want to render a Profile instead of a Badge, because we’re using the render callback pattern, we can easily swap around the UI without changing our implementation of the parent (Twitter) component. {(user) => (user === null ? : )} 1.10. Why would you use React.Children.map(props.children, () => ) instead of props.children.map(() => ) It’s not guaranteed that props.children will be an array. Take this code for example: Welcome. Inside of Parent if we were to try to map over children using props.children.map it would throw an error because props.children is an object, not an array. React only makes props.children an array if there are more than one child elements, like this: Welcome. props.children will now be an array This is why you want to favor React.Children.map because its implementation takes into account that props.children may be an array or an object. 1.11. What is the difference between createElement and cloneElement createElement is what JSX gets transpiled to and is what React uses to create React Elements (object representations of some UI). cloneElement is used in order to clone an element and pass it new props. They nailed the naming on these two &#x1F642;. 1.12. What is the second argument that can optionally be passed to setState and what is its purpose A callback function which will be invoked when setState has finished and the component is re-rendered. setState is asynchronous, which is why it takes in a second callback function. Typically it’s best to use another lifecycle method rather than relying on this callback function, but it’s good to know it exists. this.setState({ username: 'tylermcginnis33' }, () => console.log('setState has finished and the component has re-rendered.'), ); 1.13. What is wrong with this code this.setState((prevState, props) => { return { streak: prevState.streak + props.count, }; }); Nothing is wrong with it &#x1F642;. It’s rarely used and not well known, but you can also pass a function to setState that receives the previous state and props and returns a new state, just as we’re doing above. And not only is nothing wrong with it, but it’s also actively recommended if you’re setting state based on previous state. 1.14. What is the difference between a controlled component and an uncontrolled component Controlled Component The controlled way is when we bind the value of the input field to the state of that component So when the user types in the value, the state updates and then changes the value of the input field We can see the state change in real time as the user types in the React developer tool React docs typically recommend that we deal with forms This is called a controlled component because React is controlling the value of the specific input field Uncontrolled Component (using ref) The uncontrolled way is a little more traditional, where the user fills the input field and the state doesn’t change till he presses submit (or a similar event) A large part of React is this idea of having components control and manage their own state. What happens when we throw native HTML form elements (input, select, textarea, etc) into the mix? Should we have React be the “single source of truth” like we’re used to doing with React? Or should we allow that form data to live in the DOM like we’re used to typically doing with HTML form elements? These questions are at the heart of controlled vs uncontrolled components. A controlled component is a component where React is in control and is the single source of truth for the form data. As you can see below, username doesn’t live in the DOM but instead lives in our component state. Whenever we want to update username, we call setState as we’re used to. class ControlledForm extends Component { constructor(props) { super(props); this.state = { username: '', }; } updateUsername = (e) => { this.setState({ username: e.target.value, }); }; handleSubmit = () => {}; render() { return ( Submit ); } } An uncontrolled component is where your form data is handled by the DOM, instead of inside your React component. You use ref to accomplish this. class UnControlledForm extends Component { handleSubmit = () => { console.log('Input Value: ', this.input.value); }; render() { return ( (this.input = input)} /> Submit ); } } Though uncontrolled components are typically easier to implement since you just grab the value from the DOM using ref, it’s typically recommended that you favor controlled components over uncontrolled components. The main reasons for this are that controlled components support instant field validation, allow you to conditionally disable/enable buttons, enforce input formats, and are more “the React way”. 尽量用 controlled form。 1.15. When to Use ref/uncontrolled components Managing focus, text selection, or media playback. Triggering imperative animations. Integrating with third-party DOM libraries. Avoid using refs for anything that can be done declaratively. For example, instead of exposing open() and close() methods on a Dialog component, pass an isOpen prop to it. 1.16. Exposing DOM Refs to Parent Components In rare cases, you might want to have access to a child's DOM node from a parent component. This is generally not recommended because it breaks component encapsulation, but it can occasionally be useful for triggering focus or measuring the size or position of a child DOM node. In such cases we recommend exposing a special prop on the child. The child would take a function prop with an arbitrary name (e.g. inputRef) and attach it to the DOM node as a ref attribute. This lets the parent pass its ref callback to the child's DOM node through the component in the middle. This works both for classes and for functional components. function CustomTextInput(props) { return ( ); } class Parent extends React.Component { render() { return (this.inputElement = el)} />; } } In the example above, Parent passes its ref callback as an inputRef prop to the CustomTextInput, and the CustomTextInput passes the same function as a special ref attribute to the . As a result, this.inputElement in Parent will be set to the DOM node corresponding to the element in the CustomTextInput. Note that the name of the inputRef prop in the above example has no special meaning, as it is a regular component prop. However, using the ref attribute on the itself is important, as it tells React to attach a ref to its DOM node. 1.17. React.PureComponent React.PureComponent is exactly like React.Component but implements shouldComponentUpdate() with a shallow prop and state comparison. If your React component's render() function renders the same result given the same props and state, you can use React.PureComponent for a performance boost in some cases. Note React.PureComponent's shouldComponentUpdate() only shallowly compares the objects. If these contain complex data structures, it may produce false-negatives for deeper differences. Only extend PureComponent when you expect to have simple props and state, or use forceUpdate() when you know deep data structures have changed. Or, consider using immutable objects to facilitate fast comparisons of nested data. Furthermore, React.PureComponent's shouldComponentUpdate() skips prop updates for the whole component subtree. Make sure all the children components are also \"pure\". 1.18. Setting up first React component with npm, webpack and babel A React Component may be composed of the following: ui internal data lifecycle event Every component is supposed to have a render method. The reason is that the render method returns the template for that component and it is necessary for a component to have a UI. We need to tell ReactDOM to which element the components should be rendered to. You usually have to use ReactDOM.render only once in your applications because rendering the most parent element will render all the children as well. JSX is converted to React.createElement methods which describes what you see on the screen (notice only describes, doesn’t mean that it is what we see). React.createElement returns an object representation of the DOM node. It is also called virtual DOM node. React interprets JSX and transforms it into lightweight javascript objects which are used to create a virtual DOM. Changes in the virtual dom are tracked on only the necessary updates are rendered to the DOM. React.createElement takes 3 arguments: element type: div, span, component properties object children (multiple) When React encounters a component in any of the above arguments, it replaces that with what the components React.createElement returns. Hence when rendering the most parent component using ReactDOM, the entire virtual DOM is created. This invocation of React.createElement to create a virtual DOM node only happens while using ReactDOM.render and while changing state using setState. The process looks something like this, Signal to notify our app some data has changed -> re-render virtual dom -> diff previous virtual dom with new virtual dom -> only update real dom with necessary changes. This gives react performance ups. 1.19. this.props.children props.children is whatever is between the and closing blocks of a component. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/lifecycle.html": {
    "url": "React/lifecycle.html",
    "title": "lifecycle",
    "keywords": "",
    "body": "1. \bReact 生命周期1.1. 组件的生命周期1.2. 在哪些生命周期中可以修改组件的 state(setState)1.3. In which lifecycle event do you make AJAX requests and why1.4. What does shouldComponentUpdate do and why is it important1.5. Mounting Lifecycle1.5.1. componentWillMount1.5.2. componentDidMount, componentWillUnmount1.6. Updating Lifecycle1.6.1. componentWillReceiveProps(nextProps)1.6.2. shouldComponentUpdate(nextProps, nextState)1.6.3. componentWillUpdate(nextProps, nextState)1.6.4. componentDidUpdate(prevProps, prevState)1. \bReact 生命周期 1.1. 组件的生命周期 组件生命周期有三种阶段：初始化阶段（Mounting）、更新阶段（Updating）、析构阶段（Unmouting）。 初始化阶段： constructor()：初始化 state、绑定事件 componentWillMount()：在 render() 之前执行，除了同构，跟 constructor 没啥差别 render()：用于渲染 DOM。如果有操作 DOM 或和浏览器打交道的操作，最好在下一个步骤执行。 componentDidMount()：在 render() 之后立即执行，可以在这个函数中对 DOM 就进行操作，可以加载服务器数据，可以使用 setState() 方法触发重新渲染 组件更新阶段： componentWillReceiveProps(nextProps)：在已挂载的组件接收到新 props 时触发，传进来的 props 没有变化也可能触发该函数，若需要实现 props 变化才执行操作的话需要自己手动判断 componentShouldUpdate(nextProps，nextState)：默认返回 true，我们可以手动判断需不需要触发 render，若返回 false，就不触发下一步骤 componentWillUpdate()：componentShouldUpdate 返回 true 时触发，在 render 之前，可以在里面进行操作 DOM render()：重渲染 componentDidUpdate()：render 之后立即触发 组件卸载阶段： componentWillUnmount()：在组件销毁之前触发，可以处理一些清理操作，如无效的 timers 等 1.2. 在哪些生命周期中可以修改组件的 state(setState) componentDidMount 和 componentDidUpdate constructor、componentWillMount 中 setState 会发生错误：setState 只能在 mounted 或 mounting 组件中执行 componentWillUpdate 中 setState 会导致死循环 1.3. In which lifecycle event do you make AJAX requests and why AJAX requests should go in the componentDidMount lifecycle event. Fiber, the next implementation of React’s reconciliation algorithm, will have the ability to start and stop rendering as needed for performance benefits. One of the trade-offs of this is that componentWillMount, the other lifecycle event where it might make sense to make an AJAX request, will be “non-deterministic”. What this means is that React may start calling componentWillMount at various times whenever it feels like it needs to. This would obviously be a bad formula for AJAX requests. You can’t guarantee the AJAX request won’t resolve before the component mounts. If it did, that would mean that you’d be trying to setState on an unmounted component, which not only won’t work, but React will yell at you for. Doing AJAX in componentDidMount will guarantee that there’s a component to update. 1.4. What does shouldComponentUpdate do and why is it important Above we talked about reconciliation and what React does when setState is called. What shouldComponentUpdate does is it’s a lifecycle method that allows us to opt out of this reconciliation process for certain components (and their child components). Why would we ever want to do this? As mentioned above, “The end goal of reconciliation is to, in the most efficient way possible, update the UI based on new state.” If we know that a certain section of our UI isn’t going to change, there’s no reason to have React go through the trouble of trying to figure out if it should. By returning false from shouldComponentUpdate, React will assume that the current component, and all its child components, will stay the same as they currently are. 1.5. Mounting Lifecycle When a component gets mounted to the DOM or unmounted from it. 只能在 componentDidMount 中 发送异步请求、setState The mounting lifecycle consists of methods that are invoked when a component is mounted or unmounted. In other words, these methods allow you to initially set up state, make API calls, start and stop timers, manipulate the rendered DOM, initialize third-party libraries, and more. The mounting lifecycle is slightly different depending upon whether you use ES6 class syntax or React.createClass to create components. When you use createClass, getDefaultProps is invoked first to obtain the component's properties. Next, getInitialState is invoked to initialize the state. ES6 classes do not have these methods. Instead, default props are obtained and sent to the constructor as an argument. The constructor is where the state is initialized. Both ES6 class constructors and getInitialState have access to the properties and, if required, can use them to help define the initial state. 1.5.1. componentWillMount I don't think it's good to setState in componentWillMount I don't believe the 3rd judgement. If the api is too fast and returns the data even before component get mounted, setState won't work, although this is unlikely to happen. Calling setState before the component has rendered will not kick off the updating lifecycle. Calling setState after the component has been rendered will kick off the updating lifecycle. Note: with new React, you cannot make API calls in componentWillMount 1.5.2. componentDidMount, componentWillUnmount componentDidMount is invoked just after the component has rendered componentWillUnmount is invoked just before the component is unmounted. componentDidMount is the only good place to make API requests. This method is invoked after the component has rendered, so any setState calls from this method will kick off the updating lifecycle and re-render the component. componentDidMount is also a good place to initialize any third-party JavaScript that requires a DOM. For instance, you may want to incorporate a drag-and-drop library or a library that handles touch events. Typically, these libraries require a DOM before they can be initialized. To start background processes like intervals or timers. Any processes started in componentDidMount or componentWillMount can be cleaned up in componentWillUnmount. You don't want to leave background processes running when they are not needed. 1.6. Updating Lifecycle When a component receives new data and later. The updating lifecycle is a series of methods that are invoked ==when a component's state changes or when new properties are received from the parent.== This lifecycle can be used to incorporate JavaScript before the component updates or to interact with the DOM after the update. Additionally, it can be used to improve the performance of an application because it gives you the ability to cancel unnecessary updates. The updating lifecycle kicks off every time setState is called. Calling setState within the updating lifecycle other than componentWillReceiveProps will cause an infinite recursive loop that results in a stack overflow error. Therefore, setState can only be called in componentWillReceiveProps, which allows the component to update state when its properties are updated. 1.6.1. componentWillReceiveProps(nextProps) Triggered when the component receives new props from its parent component. This is the only method where setState can be called. 当组件传入的 props 发生变化时调用.例如：父组件状态改变，给子组件传入了新的 prop 值。用于组件 props 变化后，更新 state。 1.6.2. shouldComponentUpdate(nextProps, nextState) It's the update lifecycle's gatekeeper -- a predicate that can call off the update. This method can be used to ==improve performance== by only allowing necessary updates. 1.6.3. componentWillUpdate(nextProps, nextState) Invoked just before the component updates. Similar to componentWillMount, only it is invoked before each update occurs. 1.6.4. componentDidUpdate(prevProps, prevState) Invoked just after the update takes place, after the call to render. It is invoked after each update. Parent.js import React, { Component } from 'react'; import Child from './Child'; export default class App extends Component { constructor(props) { super(props); console.log('Parent - constructor'); this.state = { number: 100, }; this.addHandler = this.addHandler.bind(this); } addHandler() { this.setState((prevState) => ({ number: prevState.number + 1, })); } componentWillMount() { console.log('Parent - componentWillMount'); } componentDidMount() { console.log('Parent - componentDidMount'); } render() { console.log('Parent - render'); return ( {this.state.number} ); } shouldComponentUpdate(nextProps, nextState) { console.log('Parent - shouldComponentUpdate'); return true; } componentWillReceiveProps(nextProps) { console.log('Parent - componentWillReceiveProps'); } componentWillUpdate(nextProps, nextState) { console.log('Parent - componentWillUpdate'); } componentDidUpdate(prevProps, prevState) { console.log('Parent - componentDidUpdate'); } componentWillUnmount() { console.log('Parent - componentWillUnmount'); } } Child.js import React, { Component } from 'react'; export default class Child extends Component { constructor(props) { super(props); console.warn('Child - constructor'); } componentWillMount() { console.warn('Child - componentWillMount'); } componentDidMount() { console.warn('Child - componentDidMount'); } render() { console.warn('Child - render'); return Props from Parent: {this.props.number}; } shouldComponentUpdate(nextProps, nextState) { console.warn('Child - shouldComponentUpdate'); return true; } componentWillReceiveProps(nextProps) { console.warn('Child - componentWillReceiveProps'); } componentWillUpdate(nextProps, nextState) { console.warn('Child - componentWillUpdate'); } componentDidUpdate(prevProps, prevState) { console.warn('Child - componentDidUpdate'); } componentWillUnmount() { console.warn('Child - componentWillUnmount'); } } Initial load: 点击 parent button： Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/Presentational_vs_Container_Components.html": {
    "url": "React/Presentational_vs_Container_Components.html",
    "title": "Presentational_vs_Container_Components",
    "keywords": "",
    "body": "1. Presentational and Container Components1.1. presentational components1.2. container components1.2.1. Benefits of This Approach1.2.2. When to Introduce Containers?1.2.3. Other Dichotomies1. Presentational and Container Components 1.1. presentational components Are concerned with how things look. Another advantage of using stateless functional components is that we don't need to consider this May contain both presentational and container components inside, and usually have some DOM markup and styles of their own. Often allow containment via this.props.children. Have no dependencies on the rest of the app, such as Flux actions or stores. Don’t specify how the data is loaded or mutated. Receive data and callbacks exclusively via props. Rarely have their own state (when they do, it’s UI state rather than data). Are written as functional components unless they need state, lifecycle hooks, or performance optimizations. Examples: Page, Sidebar, Story, UserInfo, List. Presentational components are components that only render UI elements. They do not tightly couple with any data architecture. Instead, they receive data as props and send data to their parent component via callback function properties. They are purely concerned with the UI and can be reused across applications that contain different data. 1.2. container components Are concerned with how things work. May contain both presentational and container components inside but usually don’t have any DOM markup of their own except for some wrapping divs, and never have any styles. Provide the data and behavior to presentational or other container components. Call Flux actions and provide these as callbacks to the presentational components. Are often stateful, as they tend to serve as data sources. Are usually generated using higher order components such as connect() from React Redux, createContainer() from Relay, or Container.create() from Flux Utils, rather than written by hand. Examples: UserPage, FollowersSidebar, StoryContainer, FollowedUserList. Container components are components that connect presentational components to the data. In our case, container components will retrieve the store via context and manage any interactions with the store. They render presentational components by mapping properties to state and callback function properties to the store’s dispatch method. Container components are not concerned with UI elements; they are used to connect presentational components to data. I put them in different folders to make this distinction clear. 1.2.1. Benefits of This Approach Better separation of concerns. You understand your app and UI better by writing components this way. Better reusability. Presentational components are reusable. They are easy to swap out and easy to test. They can be composed to create the UI. Presentational components can be reused across browser applications that may use different data libraries. You can use the same presentational component with completely different state sources, and turn those into separate container components that can be further reused. Presentational components are essentially your app’s “palette”. You can put them on a single page and let the designer tweak all their variations without touching the app’s logic. You can run screenshot regression tests on that page. This forces you to extract “layout components” such as Sidebar, Page, ContextMenu and use this.props.children instead of duplicating the same markup and layout in several container components. Remember, components don’t have to emit DOM. They only need to provide composition boundaries between UI concerns. Container components are not concerned with the UI at all. Their main focus is connecting the presentation components to the data architecture. Container components can be reused across device platforms to connect native presentational components to the data. 1.2.2. When to Introduce Containers? I suggest you to start building your app with just presentational components first. Eventually you’ll realize that you are passing too many props down the intermediate components. When you notice that some components don’t use the props they receive but merely forward them down and you have to rewire all those intermediate components any time the children need more data, it’s a good time to introduce some container components. This way you can get the data and the behavior props to the leaf components without burdening the unrelated components in the middle of the tree. 1.2.3. Other Dichotomies It’s important that you understand that the distinction between the presentational components and the containers is not a technical one. Rather, it is a distinction in their purpose. By contrast, here are a few related (but different!) technical distinctions: Stateful and Stateless. Some components use React setState() method and some don’t. While container components tend to be stateful and presentational components tend to be stateless, this is not a hard rule. Presentational components can be stateful, and containers can be stateless too. Classes and Functions. Functional components are simpler to define but they lack certain features currently available only to class components. Some of these restrictions may go away in the future but they exist today. Because functional components are easier to understand, I suggest you to use them unless you need state, lifecycle hooks, or performance optimizations, which are only available to the class components at this time. Pure and Impure. People say that a component is pure if it is guaranteed to return the same result given the same props and state. Pure components can be defined both as classes and functions, and can be both stateful and stateless. Another important aspect of pure components is that they don’t rely on deep mutations in props or state, so their rendering performance can be optimized by a shallow comparison in their shouldComponentUpdate() hook. Currently only classes can define shouldComponentUpdate() but that may change in the future. Both presentational components and containers can fall into either of those buckets. In my experience, presentational components tend to be stateless pure functions, and containers tend to be stateful pure classes. However this is not a rule but an observation, and I’ve seen the exact opposite cases that made sense in specific circumstances. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/Pure_vs_Impure_functions.html": {
    "url": "React/Pure_vs_Impure_functions.html",
    "title": "Pure_vs_Impure_functions",
    "keywords": "",
    "body": "1. Pure vs impure function1. Pure vs impure function pure function 不修改外部变量包括 DOM，输入参数唯一则返回值唯一，没有负效应，容易测试。 The function should take in at least one argument. The function should return a value or another function. The function should not change or mutate any of its arguments. function addToArrayImpure(array, element) { array.push(element); return array; } function addToArrayPure(array, element) { return [...array, element]; // return array.concat(element); } function addToObjImpure(obj, prop, value) { obj[prop] = value; return obj; } function addToObjPure(obj, prop, value) { return Object.assign({}, obj, { [prop]: value, }); } // ES7 function addToObjPureSpread(obj, prop, value) { return { ...obj, [prop]: value, }; } let person = { name: 'guanghui' }; console.log(addToObjPure(person, 'age', 20)); const frederick = { name: 'Frederick Douglass', canRead: false, canWrite: false, }; const selfEducate = (person) => ({ ...person, canRead: true, canWrite: true, }); console.log(selfEducate(frederick)); console.log(frederick); // {name: \"Frederick Douglass\", canRead: true, canWrite: true} // {name: \"Frederick Douglass\", canRead: false, canWrite: false} In React, the UI is expressed with pure functions. In the following sample, Header is a pure function that can be used to create heading—one elements just like in the previous example. However, this function on its own does not cause side effects because it does not mutate the DOM. This function will create a heading-one element, and it is up to some other part of the application to use that element to change the DOM: const Header = (props) => {props.title}; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/react-router.html": {
    "url": "React/react-router.html",
    "title": "react-router",
    "keywords": "",
    "body": "1. React Router1.1. 基本使用1.2. 点击 button 跳转到新的 component1.3. 新转到的 component 获得之前 button 传递的参数1. React Router Concepts BrowserRouter as Router - is the component between which all the routes are nested. Our most parent component. Route - the component that helps specify views for each component, has many small nuances one needs to be aware of Link - just a link with prop to. NavLink - has activeClassName prop, to apply a css class when active Switch - used to make sure only one of the Routes is active at any moment (useful for showing a route without a path for paths that are not handled aka 404) instead of rendering all of the routes that are active, switch is gonna let only 1 route be active at a time Route path - prop takes string for the url path at which component should be active in the view Note: if a route has path='/first', it’s component will be active for all paths that start with /first to avoid the above, we need to prepend prop path with keyword exact component - takes a javascript expression referring to the component that one wants to link to the path render - this prop is useful when you don’t want to link the route to a component, but instead specify the JSX right there. This prop takes a value of a function that returns the JSX you wish this route to return. This is used mostly for the 404 pages I’m assuming, in a route that’s the last child of the switch component (and has no path prop value obviously). exact - prop makes sure the route is rendered/active only when the path matches exactly and not just partly Link This component is the basic anchor tag in react, except obviously it knows what component it originates in. to - prop takes the path to route to when the user clicks the link NavLink Composed of the component Link, except with additional functionality to make Links active when their path matches the current path. activeClassName - is the class that is applied to the NavLink component when the current path matches with the link’s path exact - this prop makes sure the activeClassName is applied only when the path has an exact match with the link’s path (not just partly, similar to the exact prop in routes) Query Params The to prop of the Link component of React Router accepts url path strings or an object with props: pathname: which takes a string for the link’s path search: takes a string beginning with ‘?’ for query params followed by the query param name value string React Router’s Route component passes a few props to the component it’s linked with. One of the prop is match which is an object with a property url which contains the current url’s path. The to value of a Link that routes to a sub-path of the current url should be composed of the this.props.match.url property, so that the path can be changed later without affecting the link. 1.1. 基本使用 import React, { Component } from 'react'; import { BrowserRouter, Route, Switch } from 'react-router-dom'; import Nav from './Nav'; import Home from './Home'; import Battle from './Battle'; import Result from './Result'; import Popular from './Popular'; class App extends React.Component { render() { return ( Not found} /> ); } } export default App; Nav.js import React from 'react'; import { NavLink } from 'react-router-dom'; function Nav() { return ( Home Battle Popular ); } export default Nav; 1.2. 点击 button 跳转到新的 component 返回当前 component 的 url: this.props.match.url. Link 组件中 to 定义 pathname 和 customParam import { Link } from 'react-router-dom'; Battle ; 1.3. 新转到的 component 获得之前 button 传递的参数 通过 location.customParam 获得参数，并用 queryString 转换数据 import queryString from 'query-string'; componentDidMount() { let players = queryString.parse(this.props.location.customParam); console.log(this.props.location.customParam); //?playerOneName=wghglory&playerTwoName=ff console.log(players); //{playerOneName: \"wghglory\", playerTwoName: \"ff\"} } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/react16.html": {
    "url": "React/react16.html",
    "title": "react16",
    "keywords": "",
    "body": "1. React 161.1. New render return types: fragments and strings1.2. Better error handling1.3. Portals1.4. Better server-side rendering1.5. Support for custom DOM attributes1.5.1. Reduced file size1.6. MIT licensed1.7. New core architecture1.8. Upgrading1.8.1. New deprecations1.8.2. React Addons1.8.3. Breaking changes1.8.4. Packaging1.9. JavaScript Environment Requirements1. React 16 We’re excited to announce the release of React v16.0! Among the changes are some long-standing feature requests, including fragments, error boundaries, portals, support for custom DOM attributes, improved server-side rendering, and reduced file size. 1.1. New render return types: fragments and strings You can now return an array of elements from a component’s render method. Like with other arrays, you’ll need to add a key to each element to avoid the key warning: render() { // No need to wrap list items in an extra element! return [ // Don't forget the keys :) First item, Second item, Third item, ]; } In the future, we’ll likely add a special fragment syntax to JSX that doesn’t require keys. We’ve added support for returning strings, too: render() { return 'Look ma, no spans!'; } See the full list of supported return types. 1.2. Better error handling Previously, runtime errors during rendering could put React in a broken state, producing cryptic error messages and requiring a page refresh to recover. To address this problem, React 16 uses a more resilient error-handling strategy. By default, if an error is thrown inside a component’s render or lifecycle methods, the whole component tree is unmounted from the root. This prevents the display of corrupted data. However, it’s probably not the ideal user experience. Instead of unmounting the whole app every time there’s an error, you can use error boundaries. Error boundaries are special components that capture errors inside their subtree and display a fallback UI in its place. Think of error boundaries like try-catch statements, but for React components. For more details, check out our previous post on error handling in React 16. demo: https://codepen.io/gaearon/pen/wqvxGa?editors=0010 1.3. Portals Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. render() { // React does *not* create a new div. It renders the children into `domNode`. // `domNode` is any valid DOM node, regardless of its location in the DOM. return ReactDOM.createPortal( this.props.children, domNode, ); } See a full example in the documentation for portals. 1.4. Better server-side rendering React 16 includes a completely rewritten server renderer. It’s really fast. It supports streaming, so you can start sending bytes to the client faster. And thanks to a new packaging strategy that compiles away process.env checks (Believe it or not, reading process.env in Node is really slow!), you no longer need to bundle React to get good server-rendering performance. Core team member Sasha Aickin wrote a great article describing React 16’s SSR improvements. According to Sasha’s synthetic benchmarks, server rendering in React 16 is roughly three times faster than React 15. “When comparing against React 15 with process.env compiled out, there’s about a 2.4x improvement in Node 4, about a 3x performance improvement in Node 6, and a full 3.8x improvement in the new Node 8.4 release. And if you compare against React 15 without compilation, React 16 has a full order of magnitude gain in SSR in the latest version of Node!” (As Sasha points out, please be aware that these numbers are based on synthetic benchmarks and may not reflect real-world performance.) In addition, React 16 is better at hydrating server-rendered HTML once it reaches the client. It no longer requires the initial render to exactly match the result from the server. Instead, it will attempt to reuse as much of the existing DOM as possible. No more checksums! In general, we don’t recommend that you render different content on the client versus the server, but it can be useful in some cases (e.g. timestamps). However, it’s dangerous to have missing nodes on the server render as this might cause sibling nodes to be created with incorrect attributes. See the documentation for ReactDOMServer for more details. 1.5. Support for custom DOM attributes Instead of ignoring unrecognized HTML and SVG attributes, React will now pass them through to the DOM. This has the added benefit of allowing us to get rid of most of React’s attribute whitelist, resulting in reduced file sizes. 1.5.1. Reduced file size Despite all these additions, React 16 is actually smaller compared to 15.6.1! react is 5.3 kb (2.2 kb gzipped), down from 20.7 kb (6.9 kb gzipped). react-dom is 103.7 kb (32.6 kb gzipped), down from 141 kb (42.9 kb gzipped). react + react-dom is 109 kb (34.8 kb gzipped), down from 161.7 kb (49.8 kb gzipped). That amounts to a combined 32% size decrease compared to the previous version (30% post-gzip). The size difference is partly attributable to a change in packaging. React now uses Rollup to create flat bundles for each of its different target formats, resulting in both size and runtime performance wins. The flat bundle format also means that React’s impact on bundle size is roughly consistent regardless of how you ship your app, whether it’s with Webpack, Browserify, the pre-built UMD bundles, or any other system. 1.6. MIT licensed In case you missed it, React 16 is available under the MIT license. We’ve also published React 15.6.2 under MIT, for those who are unable to upgrade immediately. 1.7. New core architecture React 16 is the first version of React built on top of a new core architecture, codenamed “Fiber.” You can read all about this project over on Facebook’s engineering blog. (Spoiler: we rewrote React!) Fiber is responsible for most of the new features in React 16, like error boundaries and fragments. Over the next few releases, you can expect more new features as we begin to unlock the full potential of React. Perhaps the most exciting area we’re working on is async rendering—a strategy for cooperatively scheduling rendering work by periodically yielding execution to the browser. The upshot is that, with async rendering, apps are more responsive because React avoids blocking the main thread. This demo provides an early peek at the types of problems async rendering can solve: Ever wonder what \"async rendering\" means? Here's a demo of how to coordinate an async React tree with non-React work https://t.co/3snoahB3uVpic.twitter.com/egQ988gBjR — Andrew Clark (@acdlite) September 18, 2017 Tip: Pay attention to the spinning black square. We think async rendering is a big deal, and represents the future of React. To make migration to v16.0 as smooth as possible, we’re not enabling any async features yet, but we’re excited to start rolling them out in the coming months. Stay tuned! 1.8. Upgrading Although React 16 includes significant internal changes, in terms of upgrading, you can think of this like any other major React release. We’ve been serving React 16 to Facebook and Messenger.com users since earlier this year, and we released several beta and release candidate versions to flush out additional issues. With minor exceptions, if your app runs in 15.6 without any warnings, it should work in 16. For deprecations listed in packaging below, codemods are provided to automatically transform your deprecated code. See the 15.5.0 blog post for more information, or browse the codemods in the react-codemod project. 1.8.1. New deprecations Hydrating a server-rendered container now has an explicit API. If you’re reviving server-rendered HTML, use ReactDOM.hydrate instead of ReactDOM.render. Keep using ReactDOM.render if you’re just doing client-side rendering. 1.8.2. React Addons As previously announced, we’ve discontinued support for React Addons. We expect the latest version of each addon (except react-addons-perf; see below) to work for the foreseeable future, but we won’t publish additional updates. Refer to the previous announcement for suggestions on how to migrate. react-addons-perf no longer works at all in React 16. It’s likely that we’ll release a new version of this tool in the future. In the meantime, you can use your browser’s performance tools to profile React components. 1.8.3. Breaking changes React 16 includes a number of small breaking changes. These only affect uncommon use cases and we don’t expect them to break most apps. React 15 had limited, undocumented support for error boundaries using unstable_handleError. This method has been renamed to componentDidCatch. You can use a codemod to automatically migrate to the new API. ReactDOM.render and ReactDOM.unstable_renderSubtreeIntoContainer now return null if called from inside a lifecycle method. To work around this, you can use portals or refs. setState: Calling setState with null no longer triggers an update. This allows you to decide in an updater function if you want to re-render. Calling setState directly in render always causes an update. This was not previously the case. Regardless, you should not be calling setState from render. setState callbacks (second argument) now fire immediately after componentDidMount / componentDidUpdate instead of after all components have rendered. When replacing with , B.componentWillMount now always happens before A.componentWillUnmount. Previously, A.componentWillUnmount could fire first in some cases. Previously, changing the ref to a component would always detach the ref before that component’s render is called. Now, we change the ref later, when applying the changes to the DOM. It is not safe to re-render into a container that was modified by something other than React. This worked previously in some cases but was never supported. We now emit a warning in this case. Instead you should clean up your component trees using ReactDOM.unmountComponentAtNode. See this example. componentDidUpdate lifecycle no longer receives prevContext param. (See #8631) Shallow renderer no longer calls componentDidUpdate because DOM refs are not available. This also makes it consistent with componentDidMount (which does not get called in previous versions either). Shallow renderer does not implement unstable_batchedUpdates anymore. ReactDOM.unstable_batchedUpdates now only takes one extra argument after the callback. 1.8.4. Packaging There is no react/lib/* and react-dom/lib/* anymore. Even in CommonJS environments, React and ReactDOM are precompiled to single files (“flat bundles”). If you previously relied on undocumented React internals, and they don’t work anymore, let us know about your specific case in a new issue, and we’ll try to figure out a migration strategy for you. There is no react-with-addons.js build anymore. All compatible addons are published separately on npm, and have single-file browser versions if you need them. The deprecations introduced in 15.x have been removed from the core package. React.createClass is now available as create-react-class, React.PropTypes as prop-types, React.DOM as react-dom-factories, react-addons-test-utils as react-dom/test-utils, and shallow renderer as react-test-renderer/shallow. See 15.5.0 and 15.6.0 blog posts for instructions on migrating code and automated codemods. The names and paths to the single-file browser builds have changed to emphasize the difference between development and production builds. For example: react/dist/react.js → react/umd/react.development.js react/dist/react.min.js → react/umd/react.production.min.js react-dom/dist/react-dom.js → react-dom/umd/react-dom.development.js react-dom/dist/react-dom.min.js → react-dom/umd/react-dom.production.min.js 1.9. JavaScript Environment Requirements React 16 depends on the collection types Map and Set. If you support older browsers and devices which may not yet provide these natively (e.g. IE core-js or babel-polyfill. A polyfilled environment for React 16 using core-js to support older browsers might look like: import 'core-js/es6/map'; import 'core-js/es6/set'; import React from 'react'; import ReactDOM from 'react-dom'; ReactDOM.render( Hello, world!, document.getElementById('root') ); React also depends on requestAnimationFrame (even in test environments). A simple shim for test environments would be: global.requestAnimationFrame = function(callback) { setTimeout(callback, 0); }; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/setStateAsync.html": {
    "url": "React/setStateAsync.html",
    "title": "setStateAsync",
    "keywords": "",
    "body": "1. React SetStateAsync1. React SetStateAsync We know React setState is an asynchronous function which accept a second parameter as a callback. Although Facebook recommends to write any code after setState in componentDidUpdate, sometimes we might want to write the task directly in setState. this.setState( { load: !this.state.load, count: this.state.count + 1, }, () => { console.log(this.state.count); console.log('加载完成'); }, ); It's better to use Promise than callback: class AwesomeProject extends React.Component { constructor(props) { super(props); this.state = { ipAddress: '', }; } setStateAsync(state) { return new Promise((resolve) => { this.setState(state, resolve); }); } async componentDidMount() { StatusBar.setNetworkActivityIndicatorVisible(true); const res = await fetch('https://api.ipify.org?format=json'); const { ip } = await res.json(); await this.setStateAsync({ ipAddress: ip }); StatusBar.setNetworkActivityIndicatorVisible(false); } render() { return ( My IP is {this.state.ipAddress || 'Unknown'} ); } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "React/Testing.html": {
    "url": "React/Testing.html",
    "title": "Testing",
    "keywords": "",
    "body": "1. Use shallow rendering1. Use shallow rendering Testing React components is still a bit of a tricky topic. Not because it's hard, but because it's still an evolving area, and no single approach has emerged as the 'best' one yet. At the moment, my go-to method is to use shallow rendering and prop assertions. Shallow rendering is nice, because it allows you to render a single component completely, but without delving into any of its child components to render those. Instead, the resulting object will tell you things like the type and props of the children. This gives us good isolation, allowing testing of a single component at a time. There are three types of component unit tests I find myself most commonly writing: Render logic Imagine a component that should conditionally display either an image, or a loading icon: const Image = (props) => { if (props.loading) { return ; } return ; }; We might test it like this: describe('Image', () => { it('renders a loading icon when the image is loading', () => { const image = shallowRender(); expect(image.type).toEqual(LoadingIcon); }); it('renders the image once it has loaded', () => { const image = shallowRender(); expect(image.type).toEqual('img'); }); }); Easy! I should point out that the API for shallow rendering is slightly more complicated than what I've shown. The shallowRender function used above is our own helper, which wraps the real API to make it easier to use. Revisiting our ListOfNumbers component above, here is how we might test that the map is done correctly: describe('ListOfNumbers', () => { it('renders an item for each provided number', () => { const listOfNumbers = shallowRender(); expect(listOfNumbers.props.numbers.length).toEqual(4); }); }); Prop transformations In the last example, we dug into the children of the component being tested, to make sure that they were rendered correctly. We can extend this by asserting that not only are the children there, but that they were given the correct props. This is particularly useful when a component does some transformation on its props, before passing them on. For example, the following component takes CSS class names as an array of strings, and passes them down as a single, space-separated string: const TextWithArrayOfClassNames = (props) => ( {props.text} ); describe('TextWithArrayOfClassNames', () => { it('turns the array into a space-separated string', () => { const text = 'Hello, world!'; const classNames = ['red', 'bold', 'float-right']; const textWithArrayOfClassNames = shallowRender( , ); const childClassNames = textWithArrayOfClassNames.props.children.props.className; expect(childClassNames).toEqual('red bold float-right'); }); }); One common criticism of this approach to testing is the proliferation of props.children.props.children... While it's not the prettiest code, personally I find that if I'm being annoyed by writing props.children too much in the one test, that's a sign that the component is too big, complex, or deeply nested, and should be split up. The other thing I often hear is that your tests become too dependent on the component's internal implementation, so that changing your DOM structure slightly causes all of your tests to break. This is definitely a fair criticism, and a brittle test suite is the last thing that anyone wants. The best way to manage this is to (wait for it) keep your components small and simple, which should limit the number of tests that break due to any one component changing. User interaction Of course, components are not just for display, they're also interactive: const RedInput = (props) => ; Here's my favorite way to test these: describe('RedInput', () => { it('passes the event to the given callback when the value changes', () => { const callback = jasmine.createSpy(); const redInput = shallowRender(); redInput.props.onChange('an event!'); expect(callback).toHaveBeenCalledWith('an event!'); }); }); It's a bit of a trivial example, but hopefully you get the idea. Integration testing So far I've only covered unit testing components in isolation, but you're also going to want some higher level tests in order to ensure that your application connects up properly and actually works. Render your entire tree of components (instead of shallow rendering). Reach into the DOM (using the React TestUtils, or jQuery, etc) to find the elements you care about the most, and then assert on their HTML attributes or contents, orsimulate DOM events and then assert on the side effects (DOM or route changes, AJAX calls, etc) On TDD In general, I don't use TDD when writing React components. When working on a component, I often find myself churning its structure quite a bit, as I try to land on the simplest HTML and CSS that looks right in whatever browsers I need to support. And because my component unit testing approach tends to assert on the component structure, TDD would cause me to be constantly fixing my tests as I tweak the DOM, which seems like a waste of time. The other factor to this is that the components should be so simple that the advantages of test-first are diminished. All of the complex logic and transformations are pulled out into action creators and reducers, which is where I can (and do) reap the benefits of TDD. Which brings me to my final point about testing. In this whole section, I've been talking about testing the components, and that's because there's no special information needed for testing the rest of a Redux-based app. As a framework, Redux has very little 'magic' that goes on behind the scenes, which I find reduces the need for excessive mocking or other test boilerplate. Everything is just plain old functions (many of them pure), which is a real breath of fresh air when it comes to testing. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Redux/": {
    "url": "Redux/",
    "title": "Redux",
    "keywords": "",
    "body": "1. TOC1. TOC Compose interview_redux Introduction Middleware passing_store redux-saga_vs_redux_thunk Redux 入门教程 1 Redux 入门教程 2 中间件与异步操作 Redux 入门教程 3React-Redux 的用法 数字加 1 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Redux/Compose.html": {
    "url": "Redux/Compose.html",
    "title": "Compose",
    "keywords": "",
    "body": "1. Compose1. Compose redux compose 是从右向左。跟自己用 reduce 写的相反。 Redux also comes with a compose function that you can use to compose several functions into a single function. It also composes functions from right to left as opposed to from left to right. If we just wanted to get a comma-delimited list of color titles, we could use this one crazy line of code: console.log( store .getState() .colors.map((c) => c.title) .join(', '), ); A more functional approach would be to break this down into smaller functions and compose them into a single function: import { compose } from 'redux'; // right to left const print = compose( (list) => console.log(list), (titles) => titles.join(', '), (map) => map((c) => c.title), (colors) => colors.map.bind(colors), (state) => state.colors, ); print(store.getState()); The compose function takes in functions as arguments and invokes the rightmost first. First it obtains the colors from state, then it returns a bound map function, followed by an array of color titles, which are joined as a comma-delimited list and finally logged to the console. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Redux/interview_redux.html": {
    "url": "Redux/interview_redux.html",
    "title": "interview_redux",
    "keywords": "",
    "body": "1. Redux 从设计到源码1.1. Redux 是什么？1.2. 为什么要用 Redux？1.3. Redux 思想追溯1.3.1. 什么是 ES？1.3.2. CQRS（Command Query Responsibility Segregation）是什么？1.3.3. Flux 是什么？2. 源码分析2.1. 入口文件 index.js2.2. 主流程文件：createStore.js2.3. bindActionCreators.js2.4. combineReducers.js-->用于合并 Reducer2.5. compose.js-->用于组合传入的函数2.6. applyMiddleware.js-->用于 Store 增强3. 最佳实践1. Redux 从设计到源码 1.1. Redux 是什么？ Redux 是 JavaScript 状态容器，能提供可预测化的状态管理。 它认为： Web 应用是一个状态机，视图与状态是一一对应的。 所有的状态，保存在一个对象里面。 我们先来看看“状态容器”、“视图与状态一一对应”以及“一个对象”这三个概念的具体体现。 如上图，Store 是 Redux 中的状态容器，它里面存储着所有的状态数据，每个状态都跟一个视图一一对应。 Redux 也规定，一个 State 对应一个 View。只要 State 相同，View 就相同，知道了 State，就知道 View 是什么样，反之亦然。 比如，当前页面分三种状态：loading（加载中）、success（加载成功）或者 error（加载失败），那么这三个就分别唯一对应着一种视图。 现在我们对“状态容器”以及“视图与状态一一对应”有所了解了，那么 Redux 是怎么实现可预测化的呢？我们再来看下 Redux 的工作流程。 首先，我们看下几个核心概念： Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个 Store。 State：Store 对象包含所有数据，如果想得到某个时点的数据，就要对 Store 生成快照，这种时点的数据集合，就叫做 State。 Action：State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。 Action Creator：View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦，所以我们定义一个函数来生成 Action，这个函数就叫 Action Creator。 Reducer：Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。 dispatch：是 View 发出 Action 的唯一方法。 然后我们过下整个工作流程： 首先，用户（通过 View）发出 Action，发出方式就用到了 dispatch 方法。 然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action，Reducer 会返回新的 State State 一旦有变化，Store 就会调用监听函数，来更新 View。 到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式保证了流程的清晰。 1.2. 为什么要用 Redux？ 前端复杂性的根本原因是大量无规律的交互和异步操作。 变化和异步操作的相同作用都是改变了当前 View 的状态，但是它们的无规律性导致了前端的复杂，而且随着代码量越来越大，我们要维护的状态也越来越多。 我们很容易就对这些状态何时发生、为什么发生以及怎么发生的失去控制。那么怎样才能让这些状态变化能被我们预先掌握，可以复制追踪呢？ 这就是 Redux 设计的动机所在。 Redux 试图让每个 State 变化都是可预测的，将应用中所有的动作与状态都统一管理，让一切有据可循。 如上图所示，如果我们的页面比较复杂，又没有用任何数据层框架的话，就是图片上这个样子：交互上存在父子、子父、兄弟组件间通信，数据也存在跨层、反向的数据流。 这样的话，我们维护起来就会特别困难，那么我们理想的应用状态是什么样呢？看下图： 架构层面上讲，我们希望 UI 跟数据和逻辑分离，UI 只负责渲染，业务和逻辑交由其它部分处理，从数据流向方面来说, 单向数据流确保了整个流程清晰。 我们之前的操作可以复制、追踪出来，这也是 Redux 的主要设计思想。 综上，Redux 可以做到： 每个 State 变化可预测。 动作与状态统一管理。 1.3. Redux 思想追溯 Redux 作者在 Redux.js 官方文档 Motivation 一章的最后一段明确提到： Following in the steps of Flux, CQRS, and Event Sourcing , Redux attempts to make state mutations predictable by imposing certain restrictions on how and when updates can happen. 我们就先了解下 Flux、CQRS、ES（Event Sourcing 事件溯源）这几个概念。 1.3.1. 什么是 ES？ 不是保存对象的最新状态，而是保存对象产生的事件。 通过事件追溯得到对象最新状态。 举个例子：我们平常记账有两种方式，直接记录每次账单的结果或者记录每次的收入/支出，那么我们自己计算的话也可以得到结果，ES 就是后者。 与传统增删改查关系式存储的区别： 传统的增删是以结果为导向的数据存储，ES 是以过程为导向存储。 CRUD 是直接对库进行操作。 ES 是在库里存了一系列事件的集合，不直接对库里记录进行更改。 优点： 高性能：事件是不可更改的，存储的时候并且只做插入操作，也可以设计成独立、简单的对象。所以存储事件的成本较低且效率较高，扩展起来也非常方便。 简化存储：事件用于描述系统内发生的事情，我们可以考虑用事件存储代替复杂的关系存储。 溯源：正因为事件是不可更改的，并且记录了所有系统内发生的事情，我们能用它来跟踪问题、重现错误，甚至做备份和还原。 缺点： 事件丢失：因为 ES 存储都是基于事件的，所以一旦事件丢失就很难保证数据的完整性。 修改时必须兼容老结构：指的是因为老的事件不可变，所以当业务变动的时候新的事件必须兼容老结构。 1.3.2. CQRS（Command Query Responsibility Segregation）是什么？ 顾名思义，“命令与查询职责分离”-->”读写分离”。 整体的思想是把 Query 操作和 Command 操作分成两块独立的库来维护，当事件库有更新时，再来同步读取数据库。 看下 Query 端，只是对数据库的简单读操作。然后 Command 端，是对事件进行简单的存储，同时通知 Query 端进行数据更新，这个地方就用到了 ES。 优点： CQ 两端分离，各自独立。 技术代码和业务代码完全分离。 缺点： 强依赖高性能可靠的分布式消息队列。 1.3.3. Flux 是什么？ Flux 是一种架构思想，下面过程中，数据总是“单向流动”，任何相邻的部分都不会发生数据的“双向流动”，这保证了流程的清晰。Flux 的最大特点，就是数据的“单向流动”。 用户访问 View。 View 发出用户的 Action。 Dispatcher 收到 Action，要求 Store 进行相应的更新。 Store 更新后，发出一个“change”事件。 介绍完以上之后，我们来整体做一下对比。 CQRS 与 Flux 相同：当数据在 write side 发生更改时，一个更新事件会被推送到 read side，通过绑定事件的回调，read side 得知数据已更新，可以选择是否重新读取数据。 差异：在 CQRS 中，write side 和 read side 分属于两个不同的领域模式，各自的逻辑封装和隔离在各自的 Model 中，而在 Flux 里，业务逻辑都统一封装在 Store 中。 Redux 与 Flux Redux 是 Flux 思想的一种实现，同时又在其基础上做了改进。Redux 还是秉承了 Flux 单向数据流、Store 是唯一的数据源的思想。 最大的区别： Redux 只有一个 Store。 Flux 中允许有多个 Store，但是 Redux 中只允许有一个，相较于 Flux，一个 Store 更加清晰，容易管理。Flux 里面会有多个 Store 存储应用数据，并在 Store 里面执行更新逻辑，当 Store 变化的时候再通知 controller-view 更新自己的数据；Redux 将各个 Store 整合成一个完整的 Store，并且可以根据这个 Store 推导出应用完整的 State。 同时 Redux 中更新的逻辑也不在 Store 中执行而是放在 Reducer 中。单一 Store 带来的好处是，所有数据结果集中化，操作时的便利，只要把它传给最外层组件，那么内层组件就不需要维持 State，全部经父级由 props 往下传即可。子组件变得异常简单。 Redux 中没有 Dispatcher 的概念。 Redux 去除了这个 Dispatcher，使用 Store 的 Store.dispatch()方法来把 action 传给 Store，由于所有的 action 处理都会经过这个 Store.dispatch()方法，Redux 聪明地利用这一点，实现了与 Koa、RubyRack 类似的 Middleware 机制。Middleware 可以让你在 dispatch action 后，到达 Store 前这一段拦截并插入代码，可以任意操作 action 和 Store。很容易实现灵活的日志打印、错误收集、API 请求、路由等操作。 除了以上，Redux 相对 Flux 而言还有以下特性和优点： 文档清晰，编码统一。 逆天的 DevTools，可以让应用像录像机一样反复录制和重放。 目前，美团外卖后端管理平台的上单各个模块已经逐步替换为 React+Redux 开发模式，流程的清晰为错误追溯和代码维护提供了便利，现实工作中也大大提高了人效。 2. 源码分析 查看源码的话先从 GitHub 把这个地址上拷下来，切换到 src 目录，如下图： 看下整体结构： 其中 utils 下面的 Warning.js 主要负责控制台错误日志的输出，我们直接忽略 index.js 是入口文件，createStore.js 是主流程文件，其余 4 个文件都是辅助性的 API。 我们先结合下流程分析下对应的源码。 首先，我们从 Redux 中引入 createStore 方法，然后调用 createStore 方法，并将 Reducer 作为参数传入，用来生成 Store。为了接收到对应的 State 更新，我们先执行 Store 的 subscribe 方法，将 render 作为监听函数传入。然后我们就可以 dispatchaction 了，对应更新 view 的 State。 那么我们按照顺序看下对应的源码： 2.1. 入口文件 index.js 入口文件，上面一堆检测代码忽略，看红框标出部分，它的主要作用相当于提供了一些方法，这些方法也是 Redux 支持的所有方法。 然后我们看下主流程文件：createStore.js。 2.2. 主流程文件：createStore.js createStore 主要用于 Store 的生成，我们先整理看下 createStore 具体做了哪些事儿。 首先，一大堆类型判断先忽略，可以看到声明了一系列函数，然后执行了 dispatch 方法，最后暴露了 dispatch、subscribe……几个方法。这里 dispatch 了一个 init Action 是为了生成初始的 State 树。 我们先挑两个简单的函数看下，getState 和 replaceReducer，其中 getState 只是返回了当前的状态。replaceReducer 是替换了当前的 Reducer 并重新初始化了 State 树。这两个方法比较简单，下面我们在看下其它方法。 订阅函数的主要作用是注册监听事件，然后返回取消订阅的函数，它把所有的订阅函数统一放一个数组里，只维护这个数组。 为了实现实时性，所以这里用了两个数组来分别处理 dispatch 事件和接收 subscribe 事件。 store.subscribe()方法总结： 入参函数放入监听队列 返回取消订阅函数 再来看下 store.dispatch()-->分发 action，修改 State 的唯一方式。 store.dispatch()方法总结： 调用 Reducer，传参（currentState，action）。 按顺序执行 listener。 返回 action。 到这儿的话，主流程我们就讲完了，下面我们讲下几个辅助的源码文件。 2.3. bindActionCreators.js bindActionCreators 把 action creators 转成拥有同名 keys 的对象，使用 dispatch 把每个 action creator 包装起来，这样可以直接调用它们。 实际情况用到的并不多，惟一的应用场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 Redux Store 或 dispatch 传给它。 2.4. combineReducers.js-->用于合并 Reducer 这个方法的主要功能是用来合并 Reducer，因为当我们应用比较大的时候 Reducer 按照模块拆分看上去会比较清晰，但是传入 Store 的 Reducer 必须是一个函数，所以用这个方法来作合并。代码不复杂，就不细讲了。它的用法和最后的效果可以看下上面左侧图。 2.5. compose.js-->用于组合传入的函数 compose 这个方法，主要用来组合传入的一系列函数，在中间件时会用到。可以看到，执行的最终结果是把各个函数串联起来。 2.6. applyMiddleware.js-->用于 Store 增强 中间件是 Redux 源码中比较绕的一部分，我们结合用法重点看下。 首先看下用法： const store = createStore(reducer,applyMiddleware(…middlewares)) or const store = createStore(reducer,{},applyMiddleware(…middlewares)) 可以看到，是将中间件作为 createStore 的第二个或者第三个参数传入，然后我们看下传入之后实际发生了什么。 从代码的最后一行可以看到，最后的执行代码相当于 applyMiddleware(…middlewares)(createStore)(reducer,preloadedState)然后我们去 applyMiddleware 里看它的执行过程。 可以看到执行方法有三层，那么对应我们源码看的话最终会执行最后一层。最后一层的执行结果是返回了一个正常的 Store 和一个被变更过的 dispatch 方法，实现了对 Store 的增强。 这里假设我们传入的数组 chain 是［f,g,h］，那么我们的 dispatch 相当于把原有 dispatch 方法进行 f,g,h 层层过滤，变成了新的 dispatch。 由此的话我们可以推出中间件的写法：因为中间件是要多个首尾相连的，需要一层层的“加工”，所以要有个 next 方法来独立一层确保串联执行，另外 dispatch 增强后也是个 dispatch 方法，也要接收 action 参数，所以最后一层肯定是 action。 再者，中间件内部需要用到 Store 的方法，所以 Store 我们放到顶层，最后的结果就是： 看下一个比较常用的中间件 redux－thunk 源码，关键代码只有不到 10 行。 作用的话可以看到，这里有个判断：如果当前 action 是个函数的话，return 一个 action 执行，参数有 dispatch 和 getState，否则返回给下个中间件。 这种写法就拓展了中间件的用法，让 action 可以支持函数传递。 我们来总结下这里面的几个疑点。 Q1：为什么要嵌套函数？为何不在一层函数中传递三个参数，而要在一层函数中传递一个参数，一共传递三层？ 因为中间件是要多个首尾相连的，对 next 进行一层层的“加工”，所以 next 必须独立一层。那么 Store 和 action 呢？Store 的话，我们要在中间件顶层放上 Store，因为我们要用 Store 的 dispatch 和 getState 两个方法。action 的话，是因为我们封装了这么多层，其实就是为了作出更高级的 dispatch 方法，是 dispatch，就得接受 action 这个参数。 Q2：middlewareAPI 中的 dispatch 为什么要用匿名函数包裹呢？ 我们用 applyMiddleware 是为了改造 dispatch 的，所以 applyMiddleware 执行完后，dispatch 是变化了的，而 middlewareAPI 是 applyMiddleware 执行中分发到各个 middleware，所以必须用匿名函数包裹 dispatch，这样只要 dispatch 更新了，middlewareAPI 中的 dispatch 应用也会发生变化。 Q3: 在 middleware 里调用 dispatch 跟调用 next 一样吗？ 因为我们的 dispatch 是用匿名函数包裹，所以在中间件里执行 dispatch 跟其它地方没有任何差别，而执行 next 相当于调用下个中间件。 到这儿为止，源码部分就介绍完了，下面总结下开发中的最佳实践。 3. 最佳实践 官网中对最佳实践总结的很到位，我们重点总结下以下几个: 用对象展开符增加代码可读性。 区分 smart component（know the State）和 dump component（完全不需要关心 State）。 component 里不要出现任何 async calls，交给 action creator 来做。 Reducer 尽量简单，复杂的交给 action creator。 Reducer 里 return state 的时候，不要改动之前 State，请返回新的。 immutable.js 配合效果很好（但同时也会带来强侵入性，可以结合实际项目考虑）。 action creator 里，用 promise/async/await 以及 Redux-thunk（redux-saga）来帮助你完成想要的功能。 action creators 和 Reducer 请用 pure 函数。 请慎重选择组件树的哪一层使用 connected component(连接到 Store)，通常是比较高层的组件用来和 Store 沟通，最低层组件使用这防止太长的 prop chain。 请慎用自定义的 Redux-middleware，错误的配置可能会影响到其他 middleware. 有些时候有些项目你并不需要 Redux（毕竟引入 Redux 会增加一些额外的工作量） Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Redux/Introduction.html": {
    "url": "Redux/Introduction.html",
    "title": "Introduction",
    "keywords": "",
    "body": "1. react redux 流程1.1. Redux benefits1.2. Concepts1.2.1. Reducer1.2.2. Action1.2.3. Store1.2.4. 如何发送 action1.2.5. Container1.3. 异步操作1. react redux 流程 react: Hey Action, someone clicked this \"save\" button action: thanks react! I will dispatch an action so reducers that care can update state reducer: thanks action. I see you passed me the current state and the action to perform. I will make a new copy of the state and return it store: thanks for updating the state reducer. I'll make sure all connected components are aware react-redux: I'll determine if I should tell react about this change so that it only has to update UI when necessary react: ooo! new data has been passed down via props from the store(connect, mapStateToProps, mapDispatchToProps). I will re-render the UI to reflect this 1.1. Redux benefits reducers are pure functions, which simply do oldState + action => newState. Each reducer computes a separate piece of state, which is then all composed together to form the whole application. This makes all your business logic and state transitions easy to test. Api 简单 容易理解流程 如果按照它推荐的方式 -- 视图组件和容器组建分离，容器组件状态通过 props 传到视图组件中，职责分明，每个组件单一、小。 1.2. Concepts 1.2.1. Reducer 根据之前 state 和 action 返回新的 state 1.2.2. Action 描述请求，传递需要的数据给 Reducer，这样 Reducer 根据 action 的参数返回新的 state 1.2.3. Store redux 根据 reducer 创建 store, 传递给 Provider ... import { createStore } from 'redux' import { Provider } from 'react-redux' import App from './components/App' import reducer from './reducers' const store = createStore(reducer) render( , document.getElementById('root') ) 1.2.4. 如何发送 action 一般在初始化或者按钮点击的时候，希望能够触发 dispatch(action)。下面讲实现。 App component App.js 作为启动组件，引入所有 Container import AddTodo from '../containers/AddTodo'; import VisibleTodoList from '../containers/VisibleTodoList'; const App = () => ( ); export default App; 1.2.5. Container container component 核心代码： connect(mapStateToProps, mapDispatchToProps)(PresentationalComponent); connect() without any parameter, means to not subscribe to the store. connect is a higher-order function that returns a function that returns a component. connect expects two arguments: mapStateToProps and mapDispatchToProps. Both are functions. It returns a function that expects a presentational component, and wraps it with a container that sends it data via props. The first function, mapStateToProps, injects state as an argument and returns an object that will be mapped to props. We set the colors property of the ColorList component to an array of sorted colors from state. The second function, mapDispatchToProps, injects the store’s dispatch function as an argument that can be used when the ColorList component invokes callback function properties. When the ColorList raises onRate or onRemove events, data about the color to rate or remove is obtained and dispatched. connect works in conjunction with the provider. The provider adds the store to the context and connect creates components that retrieve the store. When using connect, you do not have to worry about context. Container 引入需要的 Action 和视图组件。mapStateToProps 和 mapDispatchToProps 两个方法分别负责把 state 和 dispatch 映射到 props 中。connect 传递着两个方法，再 Wrap 视图组件。这样 presentational 组件就有了 active 和 onClick 两个 props，其中 onClick 执行的时候会 dispatch action。 注意，如果 connect 第二个参数 mapDispatchToProps 不传，则 dispatch 会以 props 注入到组件中！ 把 \bredux store 想象成一个 pie chart，里面有多少个 reducer 就负责有多少片 state 需要管理。mapStateToProps 可以 \b 暴露所需要的 state。每次 state 更新都会触发该方法。这里可能会有复杂耗时的 mapping 计算，可以用 reselect library memorizes expensive calls import { bindActionCreators } from 'redux'; function mapStateToProps(state, ownProps) { return { courses: state.courses, }; } // method 1: manually function mapDispatchToProps(dispatch) { return { createCourse(course, ownProps) { dispatch(courseActions.createCourse(course)); }, }; // return { // createCourse: (course) => { // dispatch(courseActions.createCourse(course)) // } // } } // method 2: bindActionCreators will find all actions in that file function mapDispatchToProps(dispatch, ownProps) { return { actions: bindActionCreators(courseActions, dispatch), }; } export default connect(mapStateToProps, mapDispatchToProps)(CoursesPage); 1.3. 异步操作 redux-thunk redux-saga Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Redux/Middleware.html": {
    "url": "Redux/Middleware.html",
    "title": "Middleware",
    "keywords": "",
    "body": "1. Middleware1.1. Applying Middleware to the Store1. Middleware Redux also has middleware. It acts on the store’s dispatch pipeline. In Redux, middleware consists of a series of functions that are executed in a row in the process of dispatching an action. Figure 8-7. HTTP request middleware pipeline These higher-order functions allow you to insert functionality before or after actions are dispatched and state is updated. Each middleware function is executed sequentially. Each piece of middleware is a function that has access to the action, a dispatch function, and a function that will call next. next causes the update to occur. Before next is called, you can modify the action. After next, the state will have changed. Figure 8-8. Middleware functions execute sequentially 1.1. Applying Middleware to the Store In this section, we are going to create a storeFactory. A factory is a function that manages the process of creating stores. In this case, the factory will create a store that has middleware for logging and saving data. The storeFactory will be one file that contains one function that groups everything needed to create the store. Whenever we need a store, we can invoke this function: const store = storeFactory(initialData) When we create the store, we create two pieces of middleware: the logger and the saver (Example 8-9). The data is saved to localStorage with middleware instead of the store method. Example 8-9. storeFactory: ./store/index.js import { createStore, combineReducers, applyMiddleware } from 'redux'; import { colors, sort } from './reducers'; import stateData from './initialState'; const logger = (store) => (next) => (action) => { let result; console.groupCollapsed('dispatching', action.type); console.log('prev state', store.getState()); console.log('action', action); result = next(action); console.log('next state', store.getState()); console.groupEnd(); }; const saver = (store) => (next) => (action) => { let result = next(action); localStorage['redux-store'] = JSON.stringify(store.getState()); return result; }; const storeFactory = (initialState = stateData) => applyMiddleware(logger, saver)(createStore)( combineReducers({ colors, sort }), localStorage['redux-store'] ? JSON.parse(localStorage['redux-store']) : stateData ); export default storeFactory; Both the logger and the saver are middleware functions. In Redux, middleware is defined as a higher-order function: it’s a function that returns a function that returns a function. The last function returned is invoked every time an action is dispatched. When this function is invoked, you have access to the action, the store, and the function for sending the action to the next middleware. Instead of exporting the store directly, we export a function, a factory that can be used to create stores. If this factory is invoked, then it will create and return a store that incorporates logging and saving. In the logger, before the action is dispatched, we open a new console group and log the current state and the current action. Invoking next pipes the action on to the next piece of middleware and eventually the reducers. The state at this point has been updated, so we log the changed state and end the console group. In the saver, we invoke next with the action, which will cause the state to change. Then we save the new state in localStorage and return the result, as in Example 8-9. In Example 8-10 we create a store instance using the storeFactory. Since we do not send any arguments to this store, the initial state will come from state data. Example 8-10. Creating a store using the factory import storeFactory from \"./store\" const store = storeFactory(true) store.dispatch( addColor(\"#FFFFFF\",\"Bright White\") ) store.dispatch( addColor(\"#00FF00\",\"Lawn\") ) store.dispatch( addColor(\"#0000FF\",\"Big Blue\") ) Every action dispatched from this store will add a new group of logs to the console, and the new state will be saved in localStorage. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Redux/passing_store.html": {
    "url": "Redux/passing_store.html",
    "title": "passing_store",
    "keywords": "",
    "body": "1. Passing store1.1. Provider from react-redux ✅1.2. Explicitly Passing the Store1.3. Passing the Store via Context1. Passing store 1.1. Provider from react-redux ✅ React Redux is a library that contains some tools to help ease the complexity involved with implicitly passing the store via context. Redux does not require that you use this library. However, using React Redux reduces your code’s complexity and may help you build apps a bit faster. react-redux supplies us with a component that we can use to set up our store in the context, the provider. We can wrap any React element with the provider and that element’s children will have access to the store via context. Instead of setting up the store as a context variable in the App component, we can keep the App component stateless: import { Menu, NewColor, Colors } from './containers'; const App = () => ( ); export default App; The provider adds the store to the context and updates the App component when actions have been dispatched. The provider expects a single child component: import React from 'react'; import { render } from 'react-dom'; import { Provider } from 'react-redux'; import App from './components/App'; import storeFactory from './store'; const store = storeFactory(); render( , document.getElementById('react-container'), ); The provider requires that we pass the store as a property. It adds the store to the context so that it can be retrieved by any child of the App component. Simply using the provider can save us some time and simplify our code. Once we’ve incorporated the provider, we can retrieve the store via context in child container components. However, React Redux provides us with another way to quickly create container components that work with the provider: the connect function. 1.2. Explicitly Passing the Store The first, and most logical, way to incorporate the store into your UI is to pass it down the component tree explicitly as a property. This approach is simple and works very well for smaller apps that only have a few nested components. Let’s take a look at how we can incorporate the store into the color organizer. In the ./index.js file, we will render an App component and pass it the store: import React from 'react'; import ReactDOM from 'react-dom'; import App from './components/App'; import storeFactory from './store'; const store = storeFactory(); const render = () => ReactDOM.render(, document.getElementById('react-container')); store.subscribe(render); render(); This is the ./index.js file. In this file, we create the store with the storeFactory and render the App component into the document. When the App is rendered the store is passed to it as a property. Every time the store changes, the render function will be invoked, which efficiently updates the UI with new state data. Now that we have passed the store to the App, we have to continue to pass it down to the child components that need it: import AddColorForm from './AddColorForm'; import SortMenu from './SortMenu'; import ColorList from './ColorList'; const App = ({ store }) => ( ); export default App; The App component is our root component. It captures the store from props and explicitly passes it down to its child components. The store is passed to the SortMenu, AddColorForm, and ColorList components as a property. Now that we have passed the store from the App, we can use it inside the child components. Remember we can read state from the store with store.getState, and we can dispatch actions to the store with store.dispatch. From the AddColorForm component, we can use the store to dispatch ADD_COLOR actions. When the user submits the form, we collect the color and the title from refs and use that data to create and dispatch a new ADD_COLOR action: import { PropTypes, Component } from 'react'; import { addColor } from '../actions'; const AddColorForm = ({ store }) => { let _title, _color; const submit = (e) => { e.preventDefault(); store.dispatch(addColor(_title.value, _color.value)); _title.value = ''; _color.value = '#000000'; _title.focus(); }; return ( (_title = input)} type=\"text\" placeholder=\"color title...\" required /> (_color = input)} type=\"color\" required /> ADD ); }; AddColorForm.propTypes = { store: PropTypes.object, }; export default AddColorForm; From this component, we import the necessary action creator, addColor. When the user submits the form, we’ll dispatch a new ADD_COLOR action directly to the store using this action creator. The ColorList component can use the store’s getState method to obtain the original colors and sort them appropriately. It can also dispatch RATE_COLOR and REMOVE_COLOR actions directly as they occur: import { PropTypes } from 'react'; import Color from './Color'; import { rateColor, removeColor } from '../actions'; import { sortFunction } from '../lib/array-helpers'; const ColorList = ({ store }) => { const { colors, sort } = store.getState(); const sortedColors = [...colors].sort(sortFunction(sort)); return ( {colors.length === 0 ? ( No Colors Listed. (Add a Color) ) : ( sortedColors.map((color) => ( store.dispatch(rateColor(color.id, rating))} onRemove={() => store.dispatch(removeColor(color.id))} /> )) )} ); }; ColorList.propTypes = { store: PropTypes.object, }; export default ColorList; The store has been passed all the way down the component tree to the ColorList component. This component interacts with the store directly. When colors are rated or removed, those actions are dispatched to the store. The store is also used to obtain the original colors. Those colors are duplicated and sorted according to the store’s sort property and saved as sortedColors. sortedColors is then used to create the UI. This approach is great if your component tree is rather small, like this color organizer. The drawback of using this approach is that we have to explicitly pass the store to child components, which means slightly more code and slightly more headaches than with other approaches. Additionally, the SortMenu, AddColorForm, and ColorList components require this specific store. It would be hard to reuse them in another application. 1.3. Passing the Store via Context In the last section, we created a store and passed it all the way down the component tree from the App component to the ColorList component. This approach required that we pass the store through every component that comes between the App and the ColorList. Let’s say we have some cargo to move from Washington, DC, to San Francisco, CA. We could use a train, but that would require that we lay tracks through at least nine states so that our cargo can travel to California. This is like explicitly passing the store down the component tree from the root to the leaves. You have to “lay tracks” through every component that comes between the origin and the destination. If using a train is like explicitly passing the store through props, then implicitly passing the store via context is like using a jet airliner. When a jet flies from DC to San Francisco, it flies over at least nine states—no tracks required. Similarly, we can take advantage of a React feature called context that allows us to pass variables to components without having to explicitly pass them down through the tree as properties.1 Any child component can access these context variables. If we were to pass the store using context in our color organizer app, the first step would be to refactor the App component to hold context. The App component will also need to listen to the store so that it can trigger a UI update every time the state changes: import { PropTypes, Component } from 'react'; import SortMenu from './SortMenu'; import ColorList from './ColorList'; import AddColorForm from './AddColorForm'; import { sortFunction } from '../lib/array-helpers'; class App extends Component { getChildContext() { return { store: this.props.store, }; } componentWillMount() { this.unsubscribe = store.subscribe(() => this.forceUpdate()); } componentWillUnmount() { this.unsubscribe(); } render() { const { colors, sort } = store.getState(); const sortedColors = [...colors].sort(sortFunction(sort)); return ( ); } } App.propTypes = { store: PropTypes.object.isRequired, }; App.childContextTypes = { store: PropTypes.object.isRequired, }; export default App; First, adding context to a component requires that you use the getChildContext lifecycle function. It will return the object that defines the context. In this case, we add the store to the context, which we can access through props. Next, you will need to specify childContextTypes on the component instance and define your context object. This is similar to adding propTypes or defaultProps to a component instance. However, for context to work, you must take this step. At this point, any children of the App component will have access to the store via the context. They can invoke store.getState and store.dispatch directly. The final step is to subscribe to the store and update the component tree every time the store updates state. This can be achieved with the mounting lifecycle functions (see “Mounting Lifecycle”). In componentWillMount, we can subscribe to the store and use this.forceUpdate to trigger the updating lifecycle, which will re-render our UI. In componentWillUnmount, we can invoke the unsubscribe function and stop listening to the store. Because the App component itself triggers the UI update, there is no longer a need to subscribe to the store from the entry ./index.js file; we are listening to store changes from the same component that adds the store to the context, App. Let’s refactor the AddColorForm component to retrieve the store and dispatch the ADD_COLOR action directly: const AddColorForm = (props, { store }) => { let _title, _color; const submit = (e) => { e.preventDefault(); store.dispatch(addColor(_title.value, _color.value)); _title.value = ''; _color.value = '#000000'; _title.focus(); }; return ( (_title = input)} type=\"text\" placeholder=\"color title...\" required /> (_color = input)} type=\"color\" required /> ADD ); }; AddColorForm.contextTypes = { store: PropTypes.object, }; The context object is passed to stateless functional components as the second argument, after props. We can use object destructuring to obtain the store from this object directly in the arguments. In order to use the store, we must define contextTypes on the AddColorForm instance. This is where we tell React which context variables this component will use. This is a required step. Without it, the store cannot be retrieved from the context. Let’s take a look at how to use context in a component class. The Color component can retrieve the store and dispatch RATE_COLOR and REMOVE_COLOR actions directly: import { PropTypes, Component } from 'react'; import StarRating from './StarRating'; import TimeAgo from './TimeAgo'; import FaTrash from 'react-icons/lib/fa/trash-o'; import { rateColor, removeColor } from '../actions'; class Color extends Component { render() { const { id, title, color, rating, timestamp } = this.props; const { store } = this.context; return ( {title} store.dispatch(removeColor(id))}> store.dispatch(rateColor(id, rating))} /> ); } } Color.contextTypes = { store: PropTypes.object, }; Color.propTypes = { id: PropTypes.string.isRequired, title: PropTypes.string.isRequired, color: PropTypes.string.isRequired, rating: PropTypes.number, }; Color.defaultProps = { rating: 0, }; export default Color; ColorList is now a component class, and can access context via this.context. Colors are now read directly from the store via store.getState. The same rules apply that do for stateless functional components. contextTypes must be defined on the instance. Retrieving the store from the context is a nice way to reduce your boilerplate, but this is not something that is required for every application. Dan Abramov, the creator of Redux, even suggests that these patterns do not need to be religiously followed. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Redux/redux-saga_vs_redux_thunk.html": {
    "url": "Redux/redux-saga_vs_redux_thunk.html",
    "title": "redux-saga_vs_redux_thunk",
    "keywords": "",
    "body": "1. Redux-saga vs Redux-thunk1. Redux-saga vs Redux-thunk https://stackoverflow.com/questions/34930735/pros-cons-of-using-redux-saga-with-es6-generators-vs-redux-thunk-with-es2017-asy/34933395#34933395 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Redux/Redux入门教程1.html": {
    "url": "Redux/Redux入门教程1.html",
    "title": "Redux 入门教程 1",
    "keywords": "",
    "body": "1. Redux 入门教程（一）：基本用法1.1. 你可能不需要 Redux1.2. 设计思想1.3. 基本概念和 API1.3.1. Store1.3.2. State1.3.3. Action1.3.4. Action Creator1.3.5. store.dispatch()1.3.6. Reducer1.3.7. store.subscribe()1.3.8. Store 的实现1.4. Reducer 的拆分1.5. 工作流程1.6. 实例：计数器1. Redux 入门教程（一）：基本用法 React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。有两个方面，它没涉及。 代码结构 组件之间的通信 对于大型的复杂应用来说，这两方面恰恰是最关键的。因此，只用 React 没法写大型应用。 为了解决这个问题，2014 年 Facebook 提出了 Flux 架构的概念，引发了很多的实现。2015 年，Redux 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。 本文详细介绍 Redux 架构，由于内容较多，全文分成三个部分。今天是第一部分，介绍基本概念和用法。 1.1. 你可能不需要 Redux 首先明确一点，Redux 是一个有用的架构，但不是非用不可。事实上，大多数情况，你可以不用它，只用 React 就够了。 \"如果你不知道是否需要 Redux，那就是不需要它。\" \"只有遇到 React 实在解决不了的问题，你才需要 Redux 。\" 简单说，如果你的 UI 层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。 用户的使用方式非常简单 用户之间没有协作 不需要与服务器大量交互，也没有使用 WebSocket 视图层（View）只从单一来源获取数据 上面这些情况，都不需要使用 Redux。 用户的使用方式复杂 不同身份的用户有不同的使用方式（比如普通用户和如普通用户和管理员） 多个用户之间可以协作 与服务器大量交互，或者使用了 WebSocket View 要从多个来源获取数据 上面这些情况才是 Redux 的适用场景：多交互、多数据源。 从组件角度看，如果你的应用有以下场景，可以考虑使用 Redux。 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 发生上面情况时，如果不使用 Redux 或者其他状态管理工具，不按照一定规律处理状态的读写，代码很快就会变成一团乱麻。你需要一种机制，可以在同一个地方查询状态、改变状态、传播状态的变化。 总之，不要把 Redux 当作万灵丹，如果你的应用没那么复杂，就没必要用它。另一方面，Redux 只是 Web 架构的一种解决方案，也可以选择其他方案。 1.2. 设计思想 Redux 的设计思想很简单，就两句话。 Web 应用是一个状态机，视图与状态是一一对应的。 所有的状态，保存在一个对象里面。 请务必记住这两句话，下面就是详细解释。 1.3. 基本概念和 API 1.3.1. Store Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。 Redux 提供 createStore 这个函数，用来生成 Store。 import { createStore } from 'redux'; const store = createStore(reducer); 上面代码中，createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。 1.3.2. State Store 对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。 当前时刻的 State，可以通过 store.getState() 拿到。 import { createStore } from 'redux'; const store = createStore(reducer); const state = store.getState(); Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。 1.3.3. Action State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。 Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置，社区有一个规范可以参考。 const action = { type: 'ADD_TODO', payload: 'Learn Redux', }; 上面代码中，Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux。 可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。 1.3.4. Action Creator View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。 const ADD_TODO = '添加 TODO'; function addTodo(text) { return { type: ADD_TODO, text, }; } const action = addTodo('Learn Redux'); 上面代码中，addTodo函数就是一个 Action Creator。 1.3.5. store.dispatch() store.dispatch()是 View 发出 Action 的唯一方法。 import { createStore } from 'redux'; const store = createStore(reducer); store.dispatch({ type: 'ADD_TODO', payload: 'Learn Redux', }); 上面代码中，store.dispatch接受一个 Action 对象作为参数，将它发送出去。 结合 Action Creator，这段代码可以改写如下。 store.dispatch(addTodo('Learn Redux')); 1.3.6. Reducer Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。 Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。 const reducer = function(state, action) { // ... return new_state; }; 整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子。 const defaultState = 0; const reducer = (state = defaultState, action) => { switch (action.type) { case 'ADD': return state + action.payload; default: return state; } }; const state = reducer(1, { type: 'ADD', payload: 2, }); 上面代码中，reducer 函数收到名为 ADD 的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。 实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch 方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。 import { createStore } from 'redux'; const store = createStore(reducer); 上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。 为什么这个函数叫做 Reducer 呢？因为它可以作为数组的reduce方法的参数。请看下面的例子，一系列 Action 对象按照顺序作为一个数组。 const actions = [ { type: 'ADD', payload: 0 }, { type: 'ADD', payload: 1 }, { type: 'ADD', payload: 2 }, ]; const total = actions.reduce(reducer, 0); // 3 上面代码中，数组actions表示依次有三个 Action，分别是加0、加1和加2。数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。 纯函数 Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。 纯函数是函数式编程的概念，必须遵守以下一些约束。 不得改写参数 不能调用系统 I/O 的 API 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果 由于 Reducer 是纯函数，就可以保证同样的 State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。 // State 是一个对象 function reducer(state, action) { return Object.assign({}, state, { thingToChange }); // 或者 return { ...state, ...newState }; } // State 是一个数组 function reducer(state, action) { return [...state, newItem]; } 最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。 1.3.7. store.subscribe() Store 允许使用 store.subscribe 方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。 import { createStore } from 'redux'; const store = createStore(reducer); store.subscribe(listener); 显然，只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。 store.subscribe 方法返回一个函数，调用这个函数就可以解除监听。 let unsubscribe = store.subscribe(() => console.log(store.getState())); unsubscribe(); 1.3.8. Store 的实现 store.getState() store.dispatch() store.subscribe() import { createStore } from 'redux'; let { subscribe, dispatch, getState } = createStore(reducer); createStore 方法还可以接受第二个参数，表示 State 的最初状态。这通常是服务器给出的。 // todoApp is reducer let store = createStore(todoApp, window.STATE_FROM_SERVER); 上面代码中，window.STATE_FROM_SERVER 就是整个应用的状态初始值。注意，如果提供了这个参数，它会覆盖 Reducer 函数的默认初始值。 下面是 createStore 方法的一个简单实现，可以了解一下 Store 是怎么生成的。 const createStore = (reducer) => { let state; let listeners = []; const getState = () => state; const dispatch = (action) => { state = reducer(state, action); listeners.forEach((listener) => listener()); }; const subscribe = (listener) => { listeners.push(listener); return () => { listeners = listeners.filter((l) => l !== listener); }; }; dispatch({}); return { getState, dispatch, subscribe }; }; 1.4. Reducer 的拆分 Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据，对于大型应用来说，这个 State 必然十分庞大，导致 Reducer 函数也十分庞大。 请看下面的例子。 const chatReducer = (state = defaultState, action = {}) { const { type, payload } = action; switch (type) { case ADD_CHAT: return Object.assign({}, state, { chatLog: state.chatLog.concat(payload) }); case CHANGE_STATUS: return Object.assign({}, state, { statusMessage: payload }); case CHANGE_USERNAME: return Object.assign({}, state, { userName: payload }); default: return state; } }; 上面代码中，三种 Action 分别改变 State 的三个属性。 ADD_CHAT：chatLog属性 CHANGE_STATUS：statusMessage属性 CHANGE_USERNAME：userName属性 这三个属性之间没有联系，这提示我们可以把 Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的 Reducer 即可。 const chatReducer = (state = defaultState, action = {}) => { return { chatLog: chatLog(state.chatLog, action), statusMessage: statusMessage(state.statusMessage, action), userName: userName(state.userName, action), }; }; 上面代码中，Reducer 函数被拆成了三个小函数，每一个负责生成对应的属性。 这样一拆，Reducer 就易读易写多了。而且，这种拆分与 React 应用的结构相吻合：一个 React 根组件由很多子组件构成。这就是说，子组件与子 Reducer 完全可以对应。 Redux 提供了一个combineReducers方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。 import { combineReducers } from 'redux'; const chatReducer = combineReducers({ chatLog, statusMessage, userName, }); export default chatReducer; 上面的代码通过combineReducers方法将三个子 Reducer 合并成一个大的函数。 这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法。 const reducer = combineReducers({ a: doSomethingWithA, b: processB, c: c, }); // 等同于 function reducer(state = {}, action) { return { a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action), }; } 总之，combineReducers()做的就是产生一个整体的 Reducer 函数。该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成一个大的 State 对象。 下面是combineReducer的简单实现。 const combineReducers = (reducers) => { return (state = {}, action) => { return Object.keys(reducers).reduce((nextState, key) => { nextState[key] = reducers[key](state[key], action); return nextState; }, {}); }; }; 你可以把所有子 Reducer 放在一个文件里面，然后统一引入。 import { combineReducers } from 'redux'; import * as reducers from './reducers'; const reducer = combineReducers(reducers); 1.5. 工作流程 首先，用户发出 Action。 store.dispatch(action); 然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。 // todoApp is reducer let nextState = todoApp(previousState, action); State 一旦有变化，Store 就会调用监听函数。 // 设置监听函数 store.subscribe(listener); listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。 function listener() { let newState = store.getState(); component.setState(newState); } 1.6. 实例：计数器 下面我们来看一个最简单的实例。 const Counter = ({ value }) => {value}; const render = () => { ReactDOM.render(, document.getElementById('root')); }; store.subscribe(render); render(); 上面是一个简单的计数器，唯一的作用就是把参数value的值，显示在网页上。Store 的监听函数设置为render，每次 State 的变化都会导致网页重新渲染。 下面加入一点变化，为Counter添加递增和递减的 Action。 const Counter = ({ value }) => ( {value} + - ); const reducer = (state = 0, action) => { switch (action.type) { case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; } }; const store = createStore(reducer); const render = () => { ReactDOM.render( store.dispatch({type: 'INCREMENT'})} onDecrement={() => store.dispatch({type: 'INECREMENT'})} />, document.getElementById('root') ); }; render(); store.subscribe(render); 完整的代码请看这里。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Redux/Redux入门教程2中间件与异步操作.html": {
    "url": "Redux/Redux入门教程2中间件与异步操作.html",
    "title": "Redux 入门教程 2 中间件与异步操作",
    "keywords": "",
    "body": "1. Redux 入门教程（二）：中间件与异步操作1.1. 中间件的概念1.2. 中间件的用法1.3. applyMiddlewares()1.4. 异步操作的基本思路1.5. redux-thunk 中间件1.6. redux-promise 中间件1. Redux 入门教程（二）：中间件与异步操作 异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。 怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：中间件（middleware）。 1.1. 中间件的概念 为了理解中间件，让我们站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？ Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。 View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。 Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。 想来想去，只有发送 Action 的这个步骤，即store.dispatch()方法，可以添加功能。举例来说，要添加日志功能，把 Action 和 State 打印出来，可以对store.dispatch进行如下改造。 let next = store.dispatch; store.dispatch = function dispatchAndLog(action) { console.log('dispatching', action); next(action); console.log('next state', store.getState()); }; 上面代码中，对store.dispatch进行了重定义，在发送 Action 前后添加了打印功能。这就是中间件的雏形。 中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。 1.2. 中间件的用法 本教程不涉及如何编写中间件，因为常用的中间件都有现成的，只要引用别人写好的模块即可。比如，上一节的日志中间件，就有现成的redux-logger模块。这里只介绍怎么使用中间件。 import { applyMiddleware, createStore } from 'redux'; import createLogger from 'redux-logger'; const logger = createLogger(); const store = createStore(reducer, applyMiddleware(logger)); 上面代码中，redux-logger提供一个生成器createLogger，可以生成日志中间件logger。然后，将它放在applyMiddleware方法之中，传入createStore方法，就完成了store.dispatch()的功能增强。 这里有两点需要注意： createStore方法可以接受整个应用的初始状态作为参数，那样的话，applyMiddleware就是第三个参数了。 const store = createStore(reducer, initial_state, applyMiddleware(logger)); 中间件的次序有讲究。 const store = createStore(reducer, applyMiddleware(thunk, promise, logger)); 上面代码中，applyMiddleware方法的三个参数，就是三个中间件。有的中间件有次序要求，使用前要查一下文档。比如，logger就一定要放在最后，否则输出结果会不正确。 1.3. applyMiddlewares() 看到这里，你可能会问，applyMiddlewares这个方法到底是干什么的？ 它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。下面是它的源码。 export default function applyMiddleware(...middlewares) { return (createStore) => (reducer, preloadedState, enhancer) => { var store = createStore(reducer, preloadedState, enhancer); var dispatch = store.dispatch; var chain = []; var middlewareAPI = { getState: store.getState, dispatch: (action) => dispatch(action), }; chain = middlewares.map((middleware) => middleware(middlewareAPI)); dispatch = compose(...chain)(store.dispatch); return { ...store, dispatch }; }; } 上面代码中，所有中间件被放进了一个数组chain，然后嵌套执行，最后执行store.dispatch。可以看到，中间件内部（middlewareAPI）可以拿到 getState和 dispatch 这两个方法。 1.4. 异步操作的基本思路 理解了中间件以后，就可以处理异步操作了。 同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。 操作发起时的 Action 操作成功时的 Action 操作失败时的 Action 以向服务器取出数据为例，三种 Action 可以有两种不同的写法。 // 写法一：名称相同，参数不同 { type: 'FETCH_POSTS' } { type: 'FETCH_POSTS', status: 'error', error: 'Oops' } { type: 'FETCH_POSTS', status: 'success', response: { ... } } // 写法二：名称不同 { type: 'FETCH_POSTS_REQUEST' } { type: 'FETCH_POSTS_FAILURE', error: 'Oops' } { type: 'FETCH_POSTS_SUCCESS', response: { ... } } 除了 Action 种类不同，异步操作的 State 也要进行改造，反映不同的操作状态。下面是 State 的一个例子。 let state = { // ... isFetching: true, didInvalidate: true, lastUpdated: 'xxxxxxx', }; 上面代码中，State 的属性isFetching表示是否在抓取数据。didInvalidate表示数据是否过时，lastUpdated表示上一次更新时间。 现在，整个异步操作的思路就很清楚了。 操作开始时，送出一个 Action，触发 State 更新为\"正在操作\"状态，View 重新渲染 操作结束后，再送出一个 Action，触发 State 更新为\"操作结束\"状态，View 再一次重新渲染 1.5. redux-thunk 中间件 异步操作至少要送出两个 Action：用户触发第一个 Action，这个跟同步操作一样，没有问题；如何才能在操作结束时，系统自动送出第二个 Action 呢？ 奥妙就在 Action Creator 之中。 class AsyncApp extends Component { componentDidMount() { const { dispatch, selectedPost } = this.props dispatch(fetchPosts(selectedPost)) } // ... 上面代码是一个异步组件的例子。加载成功后（componentDidMount方法），它送出了（dispatch方法）一个 Action，向服务器要求数据 fetchPosts(selectedSubreddit)。这里的fetchPosts就是 Action Creator。 下面就是fetchPosts的代码，关键之处就在里面。 const fetchPosts = postTitle => (dispatch, getState) => { dispatch(requestPosts(postTitle)); return fetch(`/some/API/${postTitle}.json`) .then(response => response.json()) .then(json => dispatch(receivePosts(postTitle, json))); }; }; // 使用方法一 store.dispatch(fetchPosts('reactjs')); // 使用方法二 store.dispatch(fetchPosts('reactjs')).then(() => console.log(store.getState()) ); 上面代码中，fetchPosts是一个 Action Creator（动作生成器），返回一个函数。这个函数执行后，先发出一个 Action（requestPosts(postTitle)），然后进行异步操作。拿到结果后，先将结果转成 JSON 格式，然后再发出一个 Action（ receivePosts(postTitle, json)）。 上面代码中，有几个地方需要注意。 fetchPosts返回了一个函数，而普通的 Action Creator 默认返回一个对象。 返回的函数的参数是dispatch和getState这两个 Redux 方法，普通的 Action Creator 的参数是 Action 的内容。 在返回的函数之中，先发出一个 Action（requestPosts(postTitle)），表示操作开始。 异步操作结束之后，再发出一个 Action（receivePosts(postTitle, json)），表示操作结束。 这样的处理，就解决了自动发送第二个 Action 的问题。但是，又带来了一个新的问题，Action 是由store.dispatch方法发送的。而store.dispatch方法正常情况下，参数只能是对象，不能是函数。 这时，就要使用中间件redux-thunk。 import { createStore, applyMiddleware } from 'redux'; import thunk from 'redux-thunk'; import reducer from './reducers'; // Note: this API requires redux@>=3.1.0 const store = createStore(reducer, applyMiddleware(thunk)); 上面代码使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。 因此，异步操作的第一种解决方案就是，写出一个返回函数的 Action Creator，然后使用redux-thunk中间件改造store.dispatch。 1.6. redux-promise 中间件 既然 Action Creator 可以返回函数，当然也可以返回其他值。另一种异步操作的解决方案，就是让 Action Creator 返回一个 Promise 对象。 这就需要使用redux-promise中间件。 import { createStore, applyMiddleware } from 'redux'; import promiseMiddleware from 'redux-promise'; import reducer from './reducers'; const store = createStore(reducer, applyMiddleware(promiseMiddleware)); 这个中间件使得store.dispatch方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法。写法一，返回值是一个 Promise 对象。 const fetchPosts = (dispatch, postTitle) => new Promise(function (resolve, reject) { dispatch(requestPosts(postTitle)); return fetch(`/some/API/${postTitle}.json`) .then(response => { type: 'FETCH_POSTS', payload: response.json() }); }); 写法二，Action 对象的payload属性是一个 Promise 对象。这需要从redux-actions模块引入createAction方法，并且写法也要变成下面这样。 import { createAction } from 'redux-actions'; class AsyncApp extends Component { componentDidMount() { const { dispatch, selectedPost } = this.props // 发出同步 Action dispatch(requestPosts(selectedPost)); // 发出异步 Action dispatch(createAction( 'FETCH_POSTS', fetch(`/some/API/${postTitle}.json`) .then(response => response.json()) )); } 上面代码中，第二个dispatch方法发出的是异步 Action，只有等到操作结束，这个 Action 才会实际发出。注意，createAction的第二个参数必须是一个 Promise 对象。 看一下redux-promise的源码，就会明白它内部是怎么操作的。 export default function promiseMiddleware({ dispatch }) { return (next) => (action) => { if (!isFSA(action)) { return isPromise(action) ? action.then(dispatch) : next(action); } return isPromise(action.payload) ? action.payload.then( (result) => dispatch({ ...action, payload: result }), (error) => { dispatch({ ...action, payload: error, error: true }); return Promise.reject(error); }, ) : next(action); }; } 从上面代码可以看出，如果 Action 本身是一个 Promise，它 resolve 以后的值应该是一个 Action 对象，会被dispatch方法送出（action.then(dispatch)），但 reject 以后不会有任何动作；如果 Action 对象的payload属性是一个 Promise 对象，那么无论 resolve 和 reject，dispatch方法都会发出 Action。 中间件和异步操作，就介绍到这里。下一篇文章将是最后一部分，介绍如何使用react-redux这个库。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Redux/Redux入门教程3React-Redux的用法.html": {
    "url": "Redux/Redux入门教程3React-Redux的用法.html",
    "title": "Redux 入门教程 3React-Redux 的用法",
    "keywords": "",
    "body": "1. Redux 入门教程（三）：React-Redux 的用法1.1. 一、UI 组件1.2. 二、容器组件1.3. 三、connect()1.3.1. 四、mapStateToProps()1.4. 五、mapDispatchToProps()1.5. 六、Provider 组件1.6. 七、实例：计数器1.7. 八、React-Router 路由库1. Redux 入门教程（三）：React-Redux 的用法 1.1. 一、UI 组件 React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。 UI 组件有以下几个特征。 只负责 UI 的呈现，不带有任何业务逻辑 没有状态（即不使用this.state这个变量） 所有数据都由参数（this.props）提供 不使用任何 Redux 的 API 下面就是一个 UI 组件的例子。 const Title = (value) => {value}; 因为不含有状态，UI 组件又称为\"纯组件\"，即它纯函数一样，纯粹由参数决定它的值。 1.2. 二、容器组件 容器组件的特征恰恰相反。 负责管理数据和业务逻辑，不负责 UI 的呈现 带有内部状态 使用 Redux 的 API 总之，只要记住一句话就可以了：UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。 你可能会问，如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个 UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。 React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。 1.3. 三、connect() React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。 import { connect } from 'react-redux'; const VisibleTodoList = connect()(TodoList); 上面代码中，TodoList是 UI 组件，VisibleTodoList就是由 React-Redux 通过connect方法自动生成的容器组件。 但是，因为没有定义业务逻辑，上面这个容器组件毫无意义，只是 UI 组件的一个单纯的包装层。为了定义业务逻辑，需要给出下面两方面的信息。 输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数 输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。 因此，connect方法的完整 API 如下。 import { connect } from 'react-redux'; const VisibleTodoList = connect(mapStateToProps, mapDispatchToProps)(TodoList); 上面代码中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。 1.3.1. 四、mapStateToProps() mapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。 作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。请看下面的例子。 const mapStateToProps = (state) => { return { todos: getVisibleTodos(state.todos, state.visibilityFilter), }; }; 上面代码中，mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值。 下面就是getVisibleTodos的一个例子，用来算出todos。 const getVisibleTodos = (todos, filter) => { switch (filter) { case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter((t) => t.completed); case 'SHOW_ACTIVE': return todos.filter((t) => !t.completed); default: throw new Error('Unknown filter: ' + filter); } }; mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。 mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。 // 容器组件的代码 // // All // const mapStateToProps = (state, ownProps) => { return { active: ownProps.filter === state.visibilityFilter, }; }; 使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。 connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅 Store，就是说 Store 的更新不会引起 UI 组件的更新。 1.4. 五、mapDispatchToProps() mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。 如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。 const mapDispatchToProps = (dispatch, ownProps) => { return { onClick: () => { dispatch({ type: 'SET_VISIBILITY_FILTER', filter: ownProps.filter, }); }, }; }; 从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。 如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的mapDispatchToProps写成对象就是下面这样。 const mapDispatchToProps = { onClick: (filter) => { type: 'SET_VISIBILITY_FILTER', filter: filter }; } 1.5. 六、Provider 组件 connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。 一种解决方法是将state对象作为参数，传入容器组件。但是，这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将state传下去就很麻烦。 React-Redux 提供Provider组件，可以让容器组件拿到state。 import { Provider } from 'react-redux'; import { createStore } from 'redux'; import todoApp from './reducers'; import App from './components/App'; let store = createStore(todoApp); render( , document.getElementById('root'), ); 上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。 它的原理是React组件的context属性，请看源码。 class Provider extends Component { getChildContext() { return { store: this.props.store, }; } render() { return this.props.children; } } Provider.childContextTypes = { store: React.PropTypes.object, }; 上面代码中，store放在了上下文对象context上面。然后，子组件就可以从context拿到store，代码大致如下。 class VisibleTodoList extends Component { componentDidMount() { const { store } = this.context; this.unsubscribe = store.subscribe(() => this.forceUpdate()); } render() { const props = this.props; const { store } = this.context; const state = store.getState(); // ... } } VisibleTodoList.contextTypes = { store: React.PropTypes.object, }; React-Redux自动生成的容器组件的代码，就类似上面这样，从而拿到store。 1.6. 七、实例：计数器 我们来看一个实例。下面是一个计数器组件，它是一个纯的 UI 组件。 class Counter extends Component { render() { const { value, onIncreaseClick } = this.props; return ( {value} Increase ); } } 上面代码中，这个 UI 组件有两个参数：value和onIncreaseClick。前者需要从state计算得到，后者需要向外发出 Action。 接着，定义value到state的映射，以及onIncreaseClick到dispatch的映射。 function mapStateToProps(state) { return { value: state.count, }; } function mapDispatchToProps(dispatch) { return { onIncreaseClick: () => dispatch(increaseAction), }; } // Action Creator const increaseAction = { type: 'increase' }; 然后，使用connect方法生成容器组件。 const App = connect(mapStateToProps, mapDispatchToProps)(Counter); 然后，定义这个组件的 Reducer。 // Reducer function counter(state = { count: 0 }, action) { const count = state.count; switch (action.type) { case 'increase': return { count: count + 1 }; default: return state; } } 最后，生成store对象，并使用Provider在根组件外面包一层。 const store = createStore(counter); ReactDOM.render( , document.getElementById('root'), ); 完整的代码看这里。 import React, { Component } from 'react'; import PropTypes from 'prop-types'; import ReactDOM from 'react-dom'; import { createStore } from 'redux'; import { Provider, connect } from 'react-redux'; // React component class Counter extends Component { render() { const { value, onIncreaseClick } = this.props; return ( {value} Increase ); } } Counter.propTypes = { value: PropTypes.number.isRequired, onIncreaseClick: PropTypes.func.isRequired, }; // Action const increaseAction = { type: 'increase' }; // Reducer function counter(state = { count: 0 }, action) { const count = state.count; switch (action.type) { case 'increase': return { count: count + 1 }; default: return state; } } // Store const store = createStore(counter); // Map Redux state to component props function mapStateToProps(state) { return { value: state.count, }; } // Map Redux actions to component props function mapDispatchToProps(dispatch) { return { onIncreaseClick: () => dispatch(increaseAction), }; } // Connected Component const App = connect(mapStateToProps, mapDispatchToProps)(Counter); ReactDOM.render( , document.getElementById('root'), ); 1.7. 八、React-Router 路由库 使用React-Router的项目，与其他项目没有不同之处，也是使用 Provider 在 BrowserRouter 外面包一层，毕竟 Provider 的唯一功能就是传入 store 对象。 const Root = ({ store }) => ( ); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Redux/数字加1.html": {
    "url": "Redux/数字加1.html",
    "title": "数字加 1",
    "keywords": "",
    "body": "1. Click button to add 11. Click button to add 1 \"prop-types\": \"^15.5.10\", \"react\": \"^15.0.2\", \"react-dom\": \"^15.0.2\", \"react-redux\": \"^4.4.5\", \"redux\": \"^3.5.2\" import React, { Component } from 'react'; import PropTypes from 'prop-types'; import ReactDOM from 'react-dom'; import { createStore } from 'redux'; import { Provider, connect } from 'react-redux'; // React UI component function Counter(props) { const { value, onIncreaseClick } = props; return ( {value} Increase ); } Counter.propTypes = { value: PropTypes.number.isRequired, onIncreaseClick: PropTypes.func.isRequired, }; // Action const increaseAction = { type: 'increase' }; // Reducer function counter(state = { count: 0 }, action) { const count = state.count; switch (action.type) { case 'increase': return { count: count + 1 }; default: return state; } } // Store const store = createStore(counter); // Map Redux state to component props function mapStateToProps(state) { return { value: state.count, }; } // Map Redux actions to component props function mapDispatchToProps(dispatch) { return { onIncreaseClick: () => dispatch(increaseAction), }; } // Connected Component, Container of Counter const App = connect(mapStateToProps, mapDispatchToProps)(Counter); ReactDOM.render( , document.getElementById('root'), ); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Sketch/": {
    "url": "Sketch/",
    "title": "Sketch",
    "keywords": "",
    "body": "1. TOC1. TOC shortcut Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Sketch/shortcut.html": {
    "url": "Sketch/shortcut.html",
    "title": "shortcut",
    "keywords": "",
    "body": "1. Sketch Shortcut1. Sketch Shortcut 插入 Insert： 新建画板 New Artboard -【 A 】 切片 Slice -【 S 】 矩形 Rectangle -【 R 】 圆角矩形 Rounded Rectangle -【 U 】 椭圆 Oval -【 O 】 直线 Line -【 L 】 矢量锚点 Vector Point -【 V 】 铅笔 Pencil -【 P 】 文字 Text -【 T 】 格式 Type： 加粗 Bold -【 Cmd + B 】 斜体 Italic -【 Cmd + I 】 下划线 Underline -【 Cmd + U 】 增大字体大小 Increase Font Size -【 Alt + Cmd (+) + 】 减小字体大小 Decrease Font Size -【 Alt + Cmd (+) – 】 增大字符间距 Increase Character Spacing -【 Alt + Control + L 】 减少字符间距 Decrease Character Spacing -【 Alt + Control + T 】 改变字体 Change Font -【 Cmd + T 】 文字变为轮廓 Convert Text to Outlines -【 Shift + Cmd + O 】 文字左对齐它的框 Align Left -【 Cmd + Shift + { 】 居中对齐 Align Center -【 Cmd + Shift + | 】 右对齐 Align Right -【 Cmd + Shift + } 】 emoji 特殊字符 Special Characters -【 Control + Cmd + Space 】 视图 Canvas View： 放大 Zoom In -【 Cmd (+) + 】 缩小 Zoom Out -【 Cmd (+) - 】 实际大小 Actual Size -【 Cmd + 0 】 全部画布适合窗口大小 Center Canvas -【 Cmd + 1 】 当前画布适合窗口大小 Zoom Selection -【 Cmd + 2 】 当前画布窗口居中 Center Selection -【 Cmd + 3 】 当前画布窗口显示 -【 Cmd + 4 】 显示 / 隐藏标尺 Toggle Rulers -【 Control + R 】 显示 / 隐藏网格 Toggle Grid -【 Control + G 】 显示 / 隐藏参考线 Toggle Layer Guides -【 Control + L 】 显示 / 隐藏像素 Toggle Pixels -【 Control + P 】 显示 / 隐藏手柄 Toggle Selection Handles -【 Control + H 】 窗口 Window： 文档间切换 Toggle between Documents -【 Cmd + ~ 】 显示 / 隐藏图层列表 Toggle Layers List -【 Alt + Cmd + 1 】 显示 / 隐藏详细面板 Toggle Inspector -【 Alt + Cmd + 2 】 显示 / 隐藏工具栏 Toggle Toolbar -【 Alt + Cmd + T 】 演示模式 Presentation Mode -【 Cmd + . 】 全屏模式 Enter Full screen -【 Control + Cmd + F 】 形状 Editing Shapes： 作为蒙版使用 Use as Mask span (Works for Layers & Groups) -【 Control + Cmd + M 】 合并形状 Union -【 Alt + Cmd + U 】 减去顶层形状 Substract -【 Alt + Cmd + S 】 保留重叠形状 Intersect -【 Alt + Cmd + I 】 排除重叠形状 Difference -【 Alt + Cmd + X 】 改变形状 Change Object Size -【 Cmd + Arrows 】 以 10 个单位来改变 Change Units by 10 -【 Shift + Cmd + Arrows 】 切换锚点式样 Change Vector Point Style -【 1, 2, 3, 4 】 图层 Editing Layers： 与其他图层的距离 Show Distance to other Layers -【 Alt 】 与组内图层的距离 Show Distance to other Layers inside Group -【 Alt + Cmd 】 副本 Duplicate -【 Cmd + D 】 复制式样 Copy Style -【 Alt + Cmd + C 】 粘贴式样 Paste Style -【 Alt + Cmd + V 】 采色器 Color Picker -【 Control + C 】 变形 Transform -【 Shift + Cmd + T 】 旋转 Rotate -【 Shift + Cmd + R 】 显示 / 隐藏填充部分 Toggle Fill -【 F 】 显示 / 隐藏描边部分 Toggle Border -【 B 】 编辑 Arranging Layers, Groups and Artboards： 上移一层 Bring Forward -【 Alt + Cmd + ↑ 】 置于顶层 Bring to Front -【 Control + Alt + Cmd + ↑ 】 下移一层 Send Backward -【 Alt + Cmd + ↓ 】 置于底层 Sent to Back -【 Control + Alt + Cmd + ↓ 】 隐藏 Hide -【 Shift + Cmd + H 】 锁定 Lock -【 Shift + Cmd + L 】 重命名 Rename -【 Cmd + R 】 编组 Group Layers -【 Cmd + G 】 取消编组 Ungroup Layers -【 Shift + Cmd + G 】 选择上方图层 Select Above Layer -【 Shift + Tab 】 选择下方图层 Select Layer Below -【 Tab 】 选择当前画板 Select Parent Artboard -【 Esc 】 查找图层 Find Layer by Name -【 Cmd + F 】 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Terminal/": {
    "url": "Terminal/",
    "title": "Terminal",
    "keywords": "",
    "body": "1. TOC1. TOC commands mac_curl_request vim Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Terminal/commands.html": {
    "url": "Terminal/commands.html",
    "title": "commands",
    "keywords": "",
    "body": "1. Mac useful commands1.1. kill port1.2. npm commands1.2.1. npm-check-updates1.2.2. yarn1.2.3. nvm1.2.4. File operation1.2.5. No access1. Mac useful commands ls # list files ls -a # list files including .gitignore, _book, etc 1.1. kill port macOS: ps aux | grep node lsof -i:3000 kill -9 windows: netstat -a -o -n taskkill /F /PID 1.2. npm commands npm init npm install [-g] [--save-dev] npm start npm t/test/tst npm version major/minor/patch yarn init yarn add [--dev] 1.2.1. npm-check-updates npm install -g npm-check-updates ncu # list ncu -u # update package version 1.2.2. yarn yarn config set registry https://registry.npm.taobao.org yarn add [--dev] # will automatically save package to devDependencies yarn global add yarn eslint --init # use yarn script instead npm run script yarn dev # upgrade all dependencies yarn upgrade-interactive yarn list --depth=0 1.2.3. nvm curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash # install nvm --version nvm ls-remote # 查看所有node版本 nvm use v6.10.2 # 切换node版本 nvm alias default v6.10.2 # 将此版本设为默认 1.2.4. File operation mkdir touch cat # review file content 1.2.5. No access sudo chown -R $USER /usr/lib/node_modules Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Terminal/mac_curl_request.html": {
    "url": "Terminal/mac_curl_request.html",
    "title": "mac_curl_request",
    "keywords": "",
    "body": "1. curl request1. curl request Using postman is a good option. POST: $ curl -X POST -H \"Content-Type: application/json\" -d '{\"firstName\":\"First\", \"lastName\":\"Last\",\"email\":\"user@example.com\",\"username\":\"username\",\"password\":\"password\"}' localhost:3000/users PUT: $ curl -X PUT -H \"Content-Type: application/json\" -d '{\"lastName\": \"Updated\"}' localhost:3000/users/[id] DELETE: $ curl -X DELETE localhost:3000/users/[id] Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Terminal/vim.html": {
    "url": "Terminal/vim.html",
    "title": "vim",
    "keywords": "",
    "body": "1. Vim1. Vim Hit the Esc key to enter \"Normal mode\". Then you can type : to enter \"Command-line mode\". A colon (:) will appear at the bottom of the screen and you can type in one of the following commands. To execute a command, press the Enter key. :q to quit (short for :quit) :q! to quit without saving (short for :quit!) :wq to write and quit :wq! to write and quit even if file has only read permission (if file does not have write permission: force write) :x to write and quit (similar to :wq, but only write if there are changes) :exit to write and exit (same as :x) :qa to quit all (short for :quitall) :cq to quit without saving and make Vim return non-zero error (i.e. exit with error) You can also exit Vim directly from \"Command mode\" by typing ZZ to save and quit (same as :x) or ZQ to just quit (same as :q!). (Note that case is important here. ZZ and zz do not mean the same thing.) Vim has extensive help - that you can access with the :help command - where you can find answers to all your questions and a tutorial for beginners. Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Typescript/": {
    "url": "Typescript/",
    "title": "Typescript",
    "keywords": "",
    "body": "1. TOC1. TOC 01_types-basic 02_types-advanced 03_decorator 04_namespace_modules 05_generic Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Typescript/01_types-basic.html": {
    "url": "Typescript/01_types-basic.html",
    "title": "01_types-basic",
    "keywords": "",
    "body": "1. Basic types1.1. Enums1.2. Destructuring assignments1.3. Spread operator1.4. Tuple types1.5. Union types: any one of them1.6. Intersection types: Specify a value that will contain all members of several types1.7. String literal types1.8. Type aliases1.9. * Mixins, I feel like composition rather than inheritance1.10. Optional and default parameter1.11. Function Overloading1.12. Interface1.12.1. Extending Interfaces1.13. Class Types1.14. Class, interface, enum demo1. Basic types 1.1. Enums enum Category { Biography = 1, Poetry, Fiction, } // 1, 2, 3 let favoriteCategory: Category = Category.Biography; console.log(favoriteCategory); // 1 let categoryString = Category[favoriteCategory]; // Biography 1.2. Destructuring assignments let medals: string[] = ['gold', 'silver', 'bronze']; let [first, second, third] = medals; let person = { name: 'Audrey', address: '123 Main Street', phone: '555-1212' }; let { name, address, phone } = person; let { title: bookTitle, author: bookAuthor } = book1; console.log(bookTitle); console.log(bookAuthor); function PrintBookInfo({ title: bookTitle, author: bookAuthor }: Book): void { console.log(`${bookTitle} was authored by ${bookAuthor}`); } 1.3. Spread operator let newBookIDs = [10, 20]; let allBookIDs = [1, 2, 3, ...newBookIDs]; function LogFavoriteBooks([book1, book2, ...others]: Book[]) { PrintBookInfo(book1); PrintBookInfo(book2); console.log(others); } let arr = [1, 2, 4]; let arr2 = [1, 3, 3, 4]; arr.push(...arr2); 1.4. Tuple types let myTuple: [number, string] = [10, 'Macbeth']; myTuple[0] = 'Hamlet'; // ERROR myTuple[1] = 20; // ERROR myTuple[2] = 'Hamlet'; myTuple[2] = 20; interface KeyValuePair extends Array { 0: K; 1: V; } let catalogLocation: KeyValuePair = ['A 123.456', book1]; catalogLocation[2] = 'some string'; 1.5. Union types: any one of them function PrintIdentifier(id: string | number) {} 1.6. Intersection types: Specify a value that will contain all members of several types function CreateCoolNewDevice(): Phone & Tablet {} 1.7. String literal types let empCategory: 'Manager' = 'Manager'; let empCategory: 'Manager' = 'Non-Manager'; // ERROR let empCategory: 'Manager' | 'Non-Manager' = 'Manager'; 1.8. Type aliases let empCategory: 'Manager' | 'Non-Manager' = 'Manager'; type EmployeeCategory = 'Manager' | 'Non-Manager'; let empCategory: EmployeeCategory = 'Manager'; 1.9. * Mixins, I feel like composition rather than inheritance function applyMixins(derivedCtor: any, baseCtors: any[]) { baseCtors.forEach((baseCtor) => { Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => { derivedCtor.prototype[name] = baseCtor.prototype[name]; }); }); } applyMixins(UniversityLibrarian, [Employee, Researcher]); // UniversityLibrarian has both employee and researcher members let newLibrarian = new UniversityLibrarian(); // newLibrarian.doResearch('Economics'); // researcher method 1.10. Optional and default parameter Optional parameters denoted with ? after parameter name and must appear at last. Default parameters may be set to a literal value or an expression function createCustomer(name: string = 'The C Programming Language', age?: number) {} 1.11. Function Overloading function GetTitles(author: string): string[]; function GetTitles(available: boolean): string[]; function GetTitles(bookProperty: any): string[] { if (typeof bookProperty == 'string') { // get books by author, add to foundTitles } else if (typeof bookProperty == 'boolean') { // get books by availability, add to foundTitles } return foundTitles; } 1.12. Interface interface Book { id: number; title: string; author: string; pages?: number; // optional markDamaged: (reason: string) => void; } interface for function type: function createCustomerID(name: string, id: number): string { return name + id; } interface stringGenerator { (chars: string, nums: number): string; } // let idGenerator: (chars: string, nums: number) => string; let idGenerator: stringGenerator; idGenerator = createCustomerID; 1.12.1. Extending Interfaces interface LibraryResource { catalogNumber: number; } interface Book { title: string; } interface Encyclopedia extends LibraryResource, Book { volume: number; } let book: Encyclopedia = { catalogNumber: 1234, title: 'The Book of Everything', volume: 1 }; 1.13. Class Types interface Librarian { doWork: () => void; } class ElementarySchoolLibrarian implements Librarian { doWork() { console.log('Reading to and teaching children...'); } } let kidsLibrarian: Librarian = newElementarySchoolLibrarian(); kidsLibrarian.doWork(); abstract class ReferenceItem { private _publisher: string; static department: string = 'Research'; constructor(public title: string, protected year: number) { console.log('Creating a new ReferenceItem...'); } get publisher(): string { return this._publisher.toUpperCase(); } set publisher(newPublisher: string) { this._publisher = newPublisher; } printItem(): void { console.log(`${this.title} was published in ${this.year}.`); console.log(`Department: ${ReferenceItem.department}`); } abstract printCitation(): void; } class Encyclopedia extends ReferenceItem { constructor(newTitle: string, newYear: number, public edition: number) { super(newTitle, newYear); } printItem(): void { super.printItem(); console.log(`Edition: ${this.edition} (${this.year})`); } printCitation(): void { console.log(`${this.title} - ${this.year}`); } } // other way to define inherited class let Newspaper = class extends ReferenceItem { printCitation(): void { console.log(`Newspaper: ${this.title}`); } }; let myPaper = new Newspaper('The Gazette', 2016); myPaper.printCitation(); // extends an anonymous class class Novel extends class { title: string; } { mainCharacter: string; } let favoriteNovel = new Novel(); 1.14. Class, interface, enum demo // enums.ts export enum Category { Biography, Poetry, Fiction, History, Children, } // interfaces.ts interface Book { id: number; title: string; author: string; available: boolean; category: Category; pages?: number; markDamaged?: DamageLogger; } interface DamageLogger { (reason: string): void; } interface Person { name: string; email: string; } interface Author extends Person { numBooksPublished: number; } interface Librarian extends Person { department: string; assistCustomer: (customerName: string) => void; } export { Book, DamageLogger, Author, Librarian }; // classes.ts import { Book, DamageLogger, Author, Librarian } from './interfaces'; class UniversityLibrarian implements Librarian { name: string; email: string; department: string; assistCustomer(customerName: string) { console.log(this.name + ' is assisting ' + customerName); } } export { UniversityLibrarian }; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Typescript/02_types-advanced.html": {
    "url": "Typescript/02_types-advanced.html",
    "title": "02_types-advanced",
    "keywords": "",
    "body": "1. Advanced Type1.1. Polymorphic this types1.2. Declaration merging1.3. Interface merging and module augmentation1.4. Type guards1.4.1. typeof: type name only allow: \"string, number, boolean, symbol\"1.4.2. instanceof: For class1.4.3. * User-Defined Type Guard: For interface1.5. Symbols1.5.1. Use cases1. Advanced Type 1.1. Polymorphic this types class Vehicle { drive(): this { // do something if (this instanceof Car) { console.log('car is driving'); } return this; } } let v = new Vehicle(); v.drive(); // returns Vehicle class Car extends Vehicle { carryPeople() { // do something return this; } } let c = new Car(); c.drive().carryPeople(); // a fluent API class Bus extends Vehicle { pay() { console.log('pay 2 yuan'); return this; } } let b = new Bus(); c.pay().drive(); 1.2. Declaration merging The compiler merges two separate declarations declared with the same name into a single definition. interface Employee { name: string; doWork: () => void; } interface Employee { title: string; phone: string; } // TypeScript Compiler will merge them: interface Employee { name: string; doWork: () => void; title: string; phone: string; } Allowed merges: Interfaces Enums Namespaces Namespaces with enums Namespaces with functions Namespaces with classes Disallowed merges: Classes with classes 1.3. Interface merging and module augmentation // universityLibrarian.ts: think this is an older version or third party lib. You cannot modify but extend it. export class UniversityLibrarian implements Interfaces.Librarian, Employee, Researcher { name: string; email: string; department: string; [CLASS_INFO](): void { console.log('This class represents a UniversityLibrarian.'); } static [Symbol.hasInstance](obj: Object) { return obj.hasOwnProperty('name') && obj.hasOwnProperty('assistCustomer'); } assistCustomer(customerName: string) { console.log(this.name + ' is assisting ' + customerName); } assistFaculty() { console.log('Assisting faculty.'); } // implementation of the following to be provided by the mixing function title: string; addToSchedule: () => void; logTitle: () => void; doResearch: (topic: string) => void; } // new extension file: universityLibExt.ts import { UniversityLibrarian } from './classes'; declare module './classes' { export interface UniversityLibrarian { phone: string; hostSeminar(topic: string): void; } } UniversityLibrarian.prototype.hostSeminar = function(topic) { console.log('Hosting a seminar on ' + topic); }; // app.ts import { UniversityLibrarian } from './classes'; import 'universityLibExt'; // note: add ts suffix doesn't work var u = new UniversityLibrarian(); u.hostSeminar('aya'); 1.4. Type guards 1.4.1. typeof: type name only allow: \"string, number, boolean, symbol\" let x: string | number = 12; if (typeof x === 'string') { // x is a string } else { // x is a number } 1.4.2. instanceof: For class class Phone { callSomeone() { console.log('call someone'); } } class Tablet { watchMovie() { console.log('watch movie'); } } const device: Phone | Tablet = new Phone(); if (device instanceof Phone) { device.callSomeone(); } 1.4.3. * User-Defined Type Guard: For interface interface Vehicle { numberOfWheels: number; } function isVehicle(v: any): v is Vehicle { return (v).numberOfWheels !== undefined; } let c = new Car(); if (isVehicle(c)) { // it's a vehicle } 1.5. Symbols ES2015 feature Primitive data type Unique Immutable let mySymbol = Symbol('first_symbol'); let anotherSymbol = Symbol('first_symbol'); // console.log(mySymbol === anotherSymbol); // false // console.log(typeof mySymbol); let myObject = { [mySymbol]: 'value for my symbol key', }; 1.5.1. Use cases Unique Constants Computed Property Declarations Customize Internal Language Behavior Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Typescript/03_decorator.html": {
    "url": "Typescript/03_decorator.html",
    "title": "03_decorator",
    "keywords": "",
    "body": "1. Decorator1.1. What are decorators?1.2. Decorator syntax1.2.1. Simple function decorator1.2.2. decorator factory1.2.3. Class Decorator1. Decorator 1.1. What are decorators? Proposed feature for JavaScript Declarative programming Implemented as function Can attached to: Properties, Parameters, Accessors, Methods, Classes 1.2. Decorator syntax 1.2.1. Simple function decorator function uiElement(target: Function) { // do ui stuff } function deprecated(t: any, p: string, d: PropertyDescriptor) { console.log('This method will go away soon.'); } @uiElement class ContactForm { @deprecated someOldMethod() {} } 1.2.2. decorator factory function uiElement(element: string) { return function(target: Function) { console.log(`Creating new element: ${element}`); }; } @uiElement('SimpleContactForm') class ContactForm { @deprecated someOldMethod() {} } 1.2.3. Class Decorator Class constructor will be passed as parameter to decorator Constructor is replaced if there is a return value (TFunction) Return void if constructor is not to be replaced (target: TFunction) => TFunction | void; Creating class decorators that replace constructor functions Property Decorators: First parameter target is either constructor function or class prototype Second parameter propertyKey is the name of the decorated member function MyPropertyDecorator(target: Object, propertyKey: string) { // do decorator stuff } Parameter Decorators: First parameter is either constructor function or class prototype Second parameter is the name of the decorated member Third parameter is the ordinal index of the decorated parameter function MyParameterDecorator(target: Object, propertyKey: string, parameterIndex: number) { // do decorator stuff } Property Descriptors: Object that describes a property and how it can be manipulated interface PropertyDescriptor { configurable?: boolean; enumerable?: boolean; value?: any; // “value” property contains the function definition for class methods writable?: boolean; // “writable” property specifies if “value” is rea get?(): any; set?(v: any): void; } Method and Accessor Decorators: First parameter is either constructor function or class prototype Second parameter is the name of the decorated member Third parameter is the property descriptor of the decorated member function MyMethodDecorator(target: Object, propertyKey: string, descriptor: PropertyDescriptor) { // do decorator stuff } demo: // decorators: export function sealed(name: string) { return function(target: Function): void { console.log(`Sealing the constructor: ${name}`); Object.seal(target); Object.seal(target.prototype); }; } export function logger(target: TFunction): TFunction { let newConstructor: Function = function() { console.log(`Creating new instance.`); console.log(target); }; newConstructor.prototype = Object.create(target.prototype); newConstructor.prototype.constructor = target; return newConstructor; } export function writable(isWritable: boolean) { return function(target: Object, propertyKey: string, descriptor: PropertyDescriptor) { console.log(`Setting ${propertyKey}.`); descriptor.writable = isWritable; }; } // usage: @logger @sealed('UniversityLibrarian') export class UniversityLibrarian implements Interfaces.Librarian, Employee, Researcher { name: string; email: string; department: string; assistCustomer(customerName: string) { console.log(this.name + ' is assisting ' + customerName); } @writable(true) assistFaculty() { console.log('Assisting faculty.'); } // implementation of the following to be provided by the mixing function title: string; addToSchedule: () => void; logTitle: () => void; doResearch: (topic: string) => void; } @logger export class PublicLibrarian implements Interfaces.Librarian { name: string; email: string; department: string; assistCustomer(customerName: string) { console.log('Assisting customer.'); } @writable(false) teachCommunity() { console.log('Teaching community.'); } } // test decorator: let lib1 = new UniversityLibrarian(); let lib2 = new PublicLibrarian(); try { lib1.assistFaculty = () => console.log('assistFaculty replacement method'); lib2.teachCommunity = () => console.log('teachCommunity replacement method'); } catch (error) { console.log(error.message); } lib1.assistFaculty(); lib2.teachCommunity(); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Typescript/04_namespace_modules.html": {
    "url": "Typescript/04_namespace_modules.html",
    "title": "04_namespace_modules",
    "keywords": "",
    "body": "1. Namespace and modules1.1. Namespace1.2. Modules1. Namespace and modules official: http://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html 1.1. Namespace // membership.ts namespace Membership { export function AddMember(name: string) { // add a new member } export namespace Cards { export function IssueCard(memberNumber: number) { // issue new card } } } // in other file /// let memberName: string = 'Elaine'; let memberNumber: number = 789; Membership.AddMember(memberName); Membership.Cards.IssueCard(memberNumber); Typescript official demo: // Validation.ts namespace Validation { export interface StringValidator { isAcceptable(s: string): boolean; } } // LettersOnlyValidator.ts /// namespace Validation { const lettersRegexp = /^[A-Za-z]+$/; export class LettersOnlyValidator implements StringValidator { isAcceptable(s: string) { return lettersRegexp.test(s); } } } // ZipCodeValidator.ts /// namespace Validation { const numberRegexp = /^[0-9]+$/; export class ZipCodeValidator implements StringValidator { isAcceptable(s: string) { return s.length === 5 && numberRegexp.test(s); } } } // Test.ts /// /// /// // Some samples to try let strings = ['Hello', '98052', '101']; // Validators to use let validators: { [s: string]: Validation.StringValidator } = {}; validators['ZIP code'] = new Validation.ZipCodeValidator(); validators['Letters only'] = new Validation.LettersOnlyValidator(); // Show whether each string passed each validator for (let s of strings) { for (let name in validators) { console.log( `\"${s}\" - ${validators[name].isAcceptable(s) ? 'matches' : 'does not match'} ${name}`, ); } } 1.2. Modules periodicals.ts: export interface Periodical { issueNumber: number; } export class Magazine implements Periodical { issueNumber: number; } export function getMagazineByIssueNumber(issue: number): Magazine { // retrieve and return a magazine } // OR interface Periodical { issueNumber: number; } class Magazine implements Periodical { issueNumber: number; } function getMagazineByIssueNumber(issue: number): Magazine { // retrieve and return a magazine } export { Periodical, Magazine, getMagazineByTitle as GetMag }; In another file: import { Magazine, Magazine, getMag } from './periodicals'; // OR import * as mag from './periodicals'; let kidMag: mag.Magazine = mag.getMag('Games and Stuff!'); default export: // movie.ts export default class { title: string; director: string; } // other file import anyName from './movie’; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Typescript/05_generic.html": {
    "url": "Typescript/05_generic.html",
    "title": "05_generic",
    "keywords": "",
    "body": "1. Generic1. Generic let poetryBooks: Book[]; let fictionBooks: Array = [ { id: 10, title: 'The C Programming Language', author: 'K & R', available: true, category: Category.Software, }, { id: 11, title: 'Code Complete', author: 'Steve McConnell', available: true, category: Category.Software, }, ]; let historyBooks = new Array(5); generic functions: function logAndReturn(thing: T): T { console.log(thing); return thing; } let someString: string = logAndReturn('log this'); let newMag: Magazine = { title: 'Web DevMonthly' }; let someMag: Magazine = logAndReturn(newMag); generic interfaces: interface Inventory { getNewestItem: () => T; addItem: (newItem: T) => void; getAllItems: () => Array; } let bookInventory: Inventory = something; // populate the inventory here... let allBooks: Array = bookInventory.getAllItems(); generic class: class Catalog implements Inventory { private catalogItems = new Array(); addItem(newItem: T) { this.catalogItems.push(newItem); } // implement other interface methods here } let bookCatalog = new Catalog(); generic constraint: interface CatalogItem { catalogNumber: number; } class Catalog implements Inventory { // implement interface methods here } interface ShelfItem { title: string; } export default class Shelf { private _items: Array = new Array(); add(item: T): void { this._items.push(item); } getFirst(): T { return this._items[0]; } find(title: string): T { return this._items.find((item) => item.title === title); } printTitles(): void { this._items.forEach((item) => console.log(item.title)); } } let inventory: Array = [ { id: 10, title: 'The C Programming Language', author: 'K & R', available: true, category: Category.Software, }, { id: 11, title: 'Code Complete', author: 'Steve McConnell', available: true, category: Category.Software, }, ]; let bookShelf: Shelf = new Shelf(); inventory.forEach((book) => bookShelf.add(book)); let firstBook: Book = bookShelf.getFirst(); let magazines: Array = [ { title: 'Programming Language Monthly', publisher: 'Code Mags' }, { title: 'Literary Fiction Quarterly', publisher: 'College Press' }, { title: 'Five Points', publisher: 'GSU' }, ]; let magazineShelf: Shelf = new Shelf(); magazines.forEach((mag) => magazineShelf.add(mag)); magazineShelf.printTitles(); let firstMagazine: Magazine = magazineShelf.getFirst(); let numberShelf: Shelf = new Shelf(); [5, 10, 15].forEach((num) => numberShelf.add(num)); let softwareBook = bookShelf.find('Code Complete'); console.log(`${softwareBook.title} (${softwareBook.author})`); export function deleteFromIndex2(inventory: Array): Array { return inventory.splice(2, inventory.length); } let purgedBooks: Array = deleteFromIndex2(inventory); purgedBooks.forEach((book) => console.log(book.title)); let purgedNums: Array = deleteFromIndex2([1, 2, 3, 4]); console.log(purgedNums); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/": {
    "url": "Vue/",
    "title": "Vue",
    "keywords": "",
    "body": "1. TOC1. TOC 01_components 02_modal 03_vue_router 04_plugin 05_mixin 06_vuex 07_vue_source 08_vue_source2 09_vue_svg_icon 10_acl 11_navbar 12_mock 13_unit_test 14_ssr_nuxt 15_ssr_vue 16_vue_typescript 2wayBinding_modifier communications_props_event customDirective dynamicComponent life_cycle mixin slots vue_interview watch Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:11:41 "
  },
  "Vue/01_components.html": {
    "url": "Vue/01_components.html",
    "title": "01_components",
    "keywords": "",
    "body": "1. 组件化常用技术1.1. 组件传值、通信1.1.1. 1. 父组件 => 子组件：1.1.2. 2. 子组件 => 父组件：自定义事件1.1.3. 3. 兄弟组件：通过共同祖辈组件1.1.4. 4. 祖先和后代之间1.1.5. 5. 任意两个组件之间：事件总线 或 vuex1.2. 插槽1.3. 表单组件实现1.3.1. Input1.3.2. FormItem1.3.3. Form1.4. 异步更新1. 组件化常用技术 1.1. 组件传值、通信 1.1.1. 1. 父组件 => 子组件： 属性 props // parent passes msg to child: ; // child props: { msg: String; } 引用 refs // parent attaches ref to child: // parent mounted() { this.$refs.hw.xx = 'xxx' } 子组件 children // parent mounted() { this.$children[0].xx = 'xxx' // ❎子元素不保证顺序，所以 children[0] 可能不是想要的！！！无需 ref，少用 } 1.1.2. 2. 子组件 => 父组件：自定义事件 // child: this.$emit('add', param) // parent: // ⚠️: 事件的监听者是 child，谁 emit 谁监听！helloWorld 监听了 @childEmit，只不过是 parent 执行了回调函数 1.1.3. 3. 兄弟组件：通过共同祖辈组件 通过共同的祖辈组件搭桥，$parent 或 $root。 // brother1 this.$parent.$on('foo', handle); // brother2 this.$parent.$emit('foo'); 1.1.4. 4. 祖先和后代之间 provide/inject：能够实现祖先给后代传值，常用高阶插件、组件库提供用例，并不推荐直接用于应用程序代码中。 // ancestor provide() { return {foo: 'foo value'} } // descendant inject: ['foo'] 1.1.5. 5. 任意两个组件之间：事件总线 或 vuex 事件总线：创建一个 Bus 类负责事件派发、监听和回调管理。 实践中可以直接用 Vue 替代 Bus，因为它已经实现了影响的功能 // Bus：事件派发、监听和回调管理 class Bus{ class Bus { constructor() { /* { eventName1:[fn1,fn2], eventName2:[fn3,fn4], } */ this.callbacks = {}; } callbacks; $on(name, fn) { this.callbacks[name] = this.callbacks[name] || []; this.callbacks[name].push(fn); } $emit(name, args) { if (this.callbacks[name]) { this.callbacks[name].forEach((cb) => cb(args)); } } } // main.js Vue.prototype.$bus = new Bus(); // child1 this.$bus.$on('foo', handle); // child2 this.$bus.$emit('foo'); vuex：创建唯一的全局数据管理者 store，通过它管理数据并通知组件状态变更 1.2. 插槽 Vue 2.6.0 之后采用全新 v-slot 语法取代之前的 slot、slot-scope 匿名插槽 // comp1 // parent hello 具名插槽 // comp2 // parent 具名插槽 内容... 作用域插槽（数据部分来自父元素，部分来自子元素） // Comp3 作用域插槽 export default { data() { return { bar: 'bar value', }; }, }; // parent 来自子组件数据：{{ctx.foo}} 1.3. 表单组件实现 1.3.1. Input 双向绑定：@input、:value 派发校验事件 派发校验事件 export default { inheritAttrs: false, props: { value: { type: String, default: '' } }, methods: { onInput(e) { this.$emit('input', e.target.value); this.$parent.$emit('validate'); }, }, }; 1.3.2. FormItem 给 Input 预留插槽 - slot 能够展示 label 和校验信息 能够进行校验 import Schema from 'async-validator'; export default { inject: ['form'], props: { label: { type: String, default: '' }, prop: { type: String }, }, data() { return { errorMessage: '' }; }, mounted() { this.$on('validate', () => { this.validate(); }); }, methods: { validate() { // 做校验 const value = this.form.model[this.prop]; const rules = this.form.rules[this.prop]; // npm i async-validator -S const desc = { [this.prop]: rules }; const schema = new Schema(desc); // return的是校验结果的Promise return schema.validate({ [this.prop]: value }, (errors) => { if (errors) { this.errorMessage = errors[0].message; } else { this.errorMessage = ''; } }); }, }, }; 1.3.3. Form 给 FormItem 留插槽 设置数据和校验规则 全局校验 export default { provide() { return { form: this }; }, props: { model: { type: Object, required: true }, rules: { type: Object } }, methods: { validate(cb) { const tasks = this.$children.filter((item) => item.prop).map((item) => item.validate()); // 所有任务都通过才算校验通过 Promise.all(tasks) .then(() => cb(true)) .catch(() => cb(false)); }, }, }; 1.4. 异步更新 {{foo}} s.innerHTML // foo 假设原始值 foo this.foo = 'bar' s.innerHTML // foo this.$nextTick(()=>{ s.innerHTML // bar }) Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/02_modal.html": {
    "url": "Vue/02_modal.html",
    "title": "02_modal",
    "keywords": "",
    "body": "1. 实现弹窗组件1.1. create1.2. 创建通知组件，Notice.vue1.3. 使⽤ create api1.4. Understand render function1. 实现弹窗组件 弹窗这类组件的特点是它们在当前 vue 实例例之外独⽴立存在，通常挂载于 body；它们是通过 JS 动态创建的，不需要在任何组件中声明。常⻅见使⽤用姿势： this.$create(Notice, { title: '社会你杨哥喊你来搬砖', message: '提示信息', duration: 1000 }).show(); 1.1. create create 函数⽤于动态创建指定组件实例并挂载⾄ body import Vue from 'vue'; // 创建指定组件实例并挂载于 body 上 export default function create(Component, props) { // 0. 创建 vue 实例 const vm = new Vue({ // render provides a function h, which renders VNode. render函数将传⼊入组件配置对象转换为虚拟dom render(h) { return h(Component, { props }); }, }).$mount(); // 执⾏行行挂载函数，但未指定挂载⽬目标，表示只执⾏行行初始化⼯工作。不允许直接挂在 body 上，后续通过 document.body 原生挂载 // 1. 上面的 vm 去帮我们创建组件实例 // Ctor = Vue.extend({ data }); // new Ctor(); // 2. 通过$children获取该组件实例 console.log(vm.$root); const comp = vm.$children[0]; // 3. append to body document.body.appendChild(vm.$el); // 虚拟 dom component instance .$el 找到 nativeElement // 4. clear func comp.remove = () => { document.body.removeChild(vm.$el); vm.$destroy(); }; // 5. 返回组件实例 return comp; } 1.2. 创建通知组件，Notice.vue {{ title }} &times; {{ message }} export default { props: { title: { type: String, default: '', }, message: { type: String, default: '', }, duration: { type: Number, default: 10000, }, }, data() { return { isShow: false, }; }, methods: { show() { this.isShow = true; setTimeout(() => { this.hide(); }, this.duration); }, hide() { this.isShow = false; this.remove(); }, }, }; 1.3. 使⽤ create api 测试 components/form/index.vue import Notice from '@/components/notice'; import create from '@/utils/create'; export default { methods: { onLogin() { // 弹窗实例 let notice; this.$refs.loginForm.validate((isValid) => { notice = create(Notice, { title: 'xxx', message: isValid ? '登录！！！' : '有错！！！', duration: 10000 }); notice.show(); }); } } }; 1.4. Understand render function render(h) { return h(tag, {props}, [children]) } Render second parameter: createElement 函数 { // 与 `v-bind:class` 的 API 相同， // 接受⼀个字符串、对象或字符串和对象组成的数组 \"class\": { \"foo\": true, \"bar\": false }, // 与 `v-bind:style` 的 API 相同， // 接受⼀个字符串、对象，或对象组成的数组 \"style\": { \"color\": \"red\", \"fontSize\": \"14px\" }, // 普通的 HTML 特性 \"attrs\": { \"id\": \"foo\" }, // 组件 prop \"props\": { \"myProp\": \"bar\" }, // DOM 属性 \"domProps\": { \"innerHTML\": \"baz\" }, // 事件监听器在 `on` 属性内， // 但不再⽀持如 `v-on:keyup.enter` 这样的修饰器。 // 需要在处理函数中⼿动检查 keyCode。 \"on\": { \"click\": this.clickHandler } } demo: // I want to render this html to UI: aaa // Vue create a component MyComp, in template we can Vue.component('MyComp', { // way1: won't work in vue-cli project since pre-compile is not supported // template: 'aaa' // way 2 render(h) { return h('div', { class: { foo: true }, attrs: { id: 'box' } }, [ h('span', 'test render function'), ]); }, // way 3: jsx via babel loader sugar // render(h) { // return ( // // test render function // // ); // } }); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/03_vue_router.html": {
    "url": "Vue/03_vue_router.html",
    "title": "03_vue_router",
    "keywords": "",
    "body": "1. Vue Router1.1. 安装1.2. 配置1.2.1. 指定路由器1.2.2. 路由视图1.2.3. 导航链接1.2.4. 路由嵌套1.3. 动态路由1.4. 路由守卫1.4.1. 全局守卫，router.js1.4.2. 路由独享守卫1.4.3. 组件内的守卫1.5. vue router 根据服务端动态加载1.6. 面包屑1.7. Vue Router 源码实现原理1. Vue Router 1.1. 安装 vue add router 1.2. 配置 // router.js import Vue from 'vue'; import Router from 'vue-router'; import Home from './views/Home.vue'; Vue.use(Router); // 引⼊Router插件 export default new Router({ mode: 'history', // 模式：hash | history | abstract base: process.env.BASE_URL, // http://localhost:8080/cart, cart is baseurl routes: [ { path: '/', name: 'home', component: Home }, { path: '/about', name: 'about', // 路由层级代码分割，⽣成分⽚(about.[hash].js) // 当路由房问时会懒加载. component: () => import(/* webpackChunkName: \"about\" */ './views/About.vue') } ] }); 1.2.1. 指定路由器 // main.js new Vue({ router, render: (h) => h(App) }).$mount('#app'); 1.2.2. 路由视图 1.2.3. 导航链接 Home About 1.2.4. 路由嵌套 应⽤界⾯通常由多层嵌套的组件组合⽽成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层 组件。 配置嵌套路由，router.js { \"path\": \"/\", \"component\": Home, \"children\": [{ \"path\": \"/list\", \"name\": \"list\", \"component\": List }] } ⽗组件需要添加插座，Home.vue ⾸⻚ 1.3. 动态路由 我们经常需要把某种模式匹配到的所有路由，全都映射到同⼀个组件。 详情⻚路由配置，router.js { \"path\": \"/\", \"component\": Home, \"children\": [ { \"path\": \"\", \"name\": \"home\", \"component\": List }, { \"path\": \"detail/:id\", \"component\": Detail } ] } 跳转，List.vue web全栈 获取参数，Detail.vue 商品详情 {{$route.params.id}} 传递路由组件参数： { \"path\": \"detail/:id\", \"component\": Detail, \"props\": true } 组件中以属性⽅式获取： export default { props: ['id'] }; 1.4. 路由守卫 路由导航过程中有若⼲⽣命周期钩⼦，可以在这⾥实现逻辑控制。 1.4.1. 全局守卫，router.js // 路由配置 { path: \"/about\", name: \"about\", meta: { auth: true }, // 需要认证 component: () => import( /* webpackChunkName: \"about\" */ \"./views/About.vue\") } // 守卫 router.beforeEach((to, from, next) => { // 要访问/about且未登录需要去登录 if (to.meta.auth && !window.isLogin) { if (window.confirm('请登录')) { window.isLogin = true; next(); // 登录成功，继续 } else { next('/'); // 放弃登录，回⾸⻚ } } else { next(); // 不需登录，继续 } }); 1.4.2. 路由独享守卫 beforeEnter(to, from, next) { // 路由内部知道⾃⼰需要认证 if (!window.isLogin) { // ... } else { next(); } } 1.4.3. 组件内的守卫 export default { beforeRouteEnter(to, from, next) {}, beforeRouteUpdate(to, from, next) {}, beforeRouteLeave(to, from, next) {} }; 1.5. vue router 根据服务端动态加载 利⽤$router.addRoutes()可以实现动态路由添加，常⽤于⽤户权限控制。 // 返回数据可能是这样的 [ { path: '/', name: 'home', component: 'Home' // Note 这里实际想要 HomeComponent，但后端只能返回 string，所以下面做一个映射 } ]; // 异步获取路路由 api.getRoutes().then((routes) => { const routeConfig = routes.map((route) => mapComponent(route)); router.addRoutes(routeConfig); }); // 映射关系 const compMap = { Home: () => import('./view/Home.vue') }; // 递归替换 function mapComponent(route) { route.component = compMap[route.component]; if (route.children) { route.children = route.children.map((child) => mapComponent(child)); } return route; } 1.6. 面包屑 利⽤$route.matched 可得到路由匹配数组，按顺序解析可得路由层次关系。 // Breadcrumb.vue watch: { $route() { // [{name:'home',path:'/'},{name:'list',path:'/list'}] console.log(this.$route.matched); // ['home','list'] this.crumbData = this.$route.matched.map(m => m.name) } } 1.7. Vue Router 源码实现原理 // router-my.js /** * vue router 源码实现 * 测试注意： * 不要出现router-view嵌套，因为没有考虑，把Home中的router-view先禁⽤用 * 导航链接修改为hash */ import Vue from 'vue'; // import Router from 'vue-router'; // official vue-router import Router from './vue-router-my'; // 源码实现 import About from './views/About'; import Home2 from './views/Home2'; import Message from './views/Message'; Vue.use(Router); const router = new Router({ routes: [ { path: '/', name: 'home', component: Home2 }, { path: '/about', name: 'about', component: About }, { path: '/personal', name: 'personal', component: () => import(/* webpackChunkName: \"personal\" */ './views/Personal.vue') }, { // in-component guard path: '/message', name: 'message', component: Message } ] }); export default router; // vue-router-my.js let Vue; class VueRouter { constructor(options) { this.$options = options; // 创建一个路由path和route映射 this.routeMap = {}; // 将来当前路径current需要响应式 // 利用Vue响应式原理可以做到这一点 this.app = new Vue({ data: { current: '/' } }); } init() { // 绑定浏览器事件 this.bindEvents(); // 解析路由配置 this.createRouteMap(this.$options); // 创建router-link和router-view this.initComponent(); } bindEvents() { window.addEventListener('hashchange', this.onHashChange.bind(this)); window.addEventListener('load', this.onHashChange.bind(this)); } onHashChange() { // http://localhost/#/home this.app.current = window.location.hash.slice(1) || '/'; } createRouteMap(options) { options.routes.forEach((item) => { // ['/home']: {path:'/home',component:Home} this.routeMap[item.path] = item; }); } initComponent() { // 声明两个全局组件 Vue.component('router-link', { props: { to: String }, render(h) { // 目标是：xxx return h('a', { attrs: { href: '#' + this.to } }, this.$slots.default); // return {this.$slots.default} } }); // hash -> current -> render Vue.component('router-view', { // 箭头函数能保留this指向，这里指向VueRouter实例 render: (h) => { console.log(this.routeMap); console.log(this.app.current); const Comp = this.routeMap[this.app.current].component; // 这里可能报错，必须要在 routeMap 中找到一个组件，因为初始定义了 current: /, 要求路由配置必须有 / 的配置 return h(Comp); } }); } } // 把VueRouter变为插件 VueRouter.install = function(_Vue) { Vue = _Vue; // 这里保存，上面使用 // 混入任务 Vue.mixin({ // 混入：就是扩展Vue beforeCreate() { // 这里的代码将来会在外面初始化的时候被调用 // 这样我们就实现了Vue扩展 // this是谁？ Vue组件实例 // 但是这里只希望根组件执行一次 if (this.$options.router) { Vue.prototype.$router = this.$options.router; this.$options.router.init(); } } }); }; export default VueRouter; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/04_plugin.html": {
    "url": "Vue/04_plugin.html",
    "title": "04_plugin",
    "keywords": "",
    "body": "1. Vue plugin1.1. demo: move bus to a plugin1. Vue plugin // 插件定义 MyPlugin.install = function(Vue, options) { // 1. 添加全局⽅法或属性 Vue.myGlobalMethod = function() { // 逻辑... }; // 2. 添加全局资源 Vue.directive('my-directive', { bind(el, binding, vnode, oldVnode) { // 逻辑... }, }); // 3. 注⼊组件选项 Vue.mixin({ created: function() { // 逻辑... }, }); // 4. 添加实例⽅法 Vue.prototype.$myMethod = function(methodOptions) { // 逻辑... }; }; // 插件使⽤ Vue.use(MyPlugin); 1.1. demo: move bus to a plugin // plugins/bus.js class Bus { constructor() {} emit() {} on() {} } Bus.install = function(Vue) { // Vue.prototype.$bus = new Bus(); Vue.prototype.$bus = new Vue(); // event bus }; export default Bus; Use this plugin: // main.js import Bus from './plugins/bus'; Vue.use(Bus); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/05_mixin.html": {
    "url": "Vue/05_mixin.html",
    "title": "05_mixin",
    "keywords": "",
    "body": "1. Vue Mixin1.1. demo:1. Vue Mixin 混⼊ (mixin) 提供了⼀种分发 Vue 组件中可复⽤功能的灵活⽅式 // 定义⼀个混⼊对象 var myMixin = { created: function() { this.hello(); }, methods: { hello: function() { console.log('hello from mixin!'); }, }, }; // 定义⼀个使⽤混⼊对象的组件 var Component = Vue.extend({ mixins: [myMixin] }); 1.1. demo: // mixins/emitter.js // refer https://github.com/ElemeFE/element/blob/dev/src/mixins/emitter.js 参考 broadcast, dispatch export default { methods: { // child 向 root 发 $dispatch(eventName, data) { let parent = this.$parent; // 查找父元素 while (parent) { // 父元素用$emit触发 parent.$emit(eventName, data); // 递归查找父元素 parent = parent.$parent; } }, // current 向 children 发 $broadcast(eventName, data) { broadcast.call(this, eventName, data); }, }, }; function broadcast(eventName, data) { this.$children.forEach((child) => { // 子元素触发$emit child.$emit(eventName, data); if (child.$children.length) { // 递归调用，通过call修改this指向 child broadcast.call(child, eventName, data); } }); } /* moved from main.js Vue.prototype.$dispatch = function(eventName, data) { let parent = this.$parent; // 查找父元素 while (parent) { // 父元素用$emit触发 parent.$emit(eventName, data); // 递归查找父元素 parent = parent.$parent; } }; Vue.prototype.$broadcast = function(eventName, data) { broadcast.call(this, eventName, data); }; */ Use the mixin in a component: import emitter from '@/mixins/emitter'; export default { mixins: [emitter], methods: { onInput(e) { this.$dispatch('validate'); // mixin emitter dispatch } } }; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/06_vuex.html": {
    "url": "Vue/06_vuex.html",
    "title": "06_vuex",
    "keywords": "",
    "body": "1. vuex 数据管理1.1. 整合 vuex1.1.1. 核⼼概念1.1.2. 状态和状态变更1.1.3. 派⽣状态 - getters1.1.4. 动作 - actions1.2. 模块化1.3. vuex 原理解析1.3.1. 实现 actions1.3.2. 实现 getters1. vuex 数据管理 Vuex 是⼀个专为 Vue.js 应⽤开发的状态管理模式，集中式存储管理应⽤所有组件的状态。 Vuex 遵循“单向数据流”理念，易于问题追踪以及提⾼代码可维护性。 Vue 中多个视图依赖于同⼀状态时，视图间传参和状态同步⽐较困难，Vuex 能够很好解决该问题。 1.1. 整合 vuex vue add vuex 1.1.1. 核⼼概念 state 状态、数据 mutations 更改状态的函数 actions 异步操作 store 包含以上概念的容器 1.1.2. 状态和状态变更 state 保存数据状态，mutations ⽤于修改状态(like reducer) // store.js export default new Vuex.Store({ state: { count: 0 }, mutations: { increment(state, n = 1) { state.count += n; }, }, }); 使⽤状态，vuex/index.vue, commit like dispatch an action 冲啊，⼿榴弹扔了{{ $store.state.count }}个 扔⼀个 export default { methods: { add() { this.$store.commit('increment'); }, }, }; 1.1.3. 派⽣状态 - getters 从 state 派⽣出新状态，类似计算属性 export default new Vuex.Store({ getters: { score(state) { return `共扔出：${state.count}`; }, }, }); 登录状态⽂字，App.vue {{$store.getters.score}} 1.1.4. 动作 - actions 复杂业务逻辑，类似于 controller, effect。或者多个 commit 一起执行 export default new Vuex.Store({ actions: { incrementAsync({ commit }) { setTimeout(() => { commit('increment', 2); }, 1000); }, }, }); 使⽤ actions： 冲啊，⼿榴弹扔了{{ $store.state.count }}个 蓄⼒扔俩 export default { methods: { addAsync() { this.$store.dispatch('incrementAsync'); }, }, }; 1.2. 模块化 按模块化的⽅式编写代码，store.js const count = { namespaced: true, // ... }; export default new Vuex.Store({ modules: { a: count } }); 使⽤变化，components/vuex/module.vue 冲啊，⼿榴弹扔了{{ $store.state.a.count }}个 {{ $store.getters['a/score'] }} 扔⼀个 蓄⼒扔俩 export default { methods: { add() { this.$store.commit('a/increment'); }, addAsync() { this.$store.dispatch('a/incrementAsync'); }, }, }; 1.3. vuex 原理解析 初始化：Store 声明、install 实现，，vuex-my.js： let Vue; function install(_Vue) { Vue = _Vue; // 这样store执⾏的时候，就有了Vue，不⽤import // 这也是为啥Vue.use必须在新建store之前 Vue.mixin({ beforeCreate() { // 这样才能获取到传递进来的store // 只有root元素才有store，所以判断⼀下 if (this.$options.store) { Vue.prototype.$store = this.$options.store; } }, }); } class Store { constructor(options = {}) { this.state = new Vue({ data: options.state }); this.mutations = options.mutations || {}; } // 注意这⾥⽤箭头函数形式，后⾯actions实现时会有作⽤ commit = (type, arg) => { this.mutations[type](this.state, arg); }; } export default { Store, install }; 1.3.1. 实现 actions class Store { constructor(options = {}) { this.actions = options.actions; } dispatch(type, arg) { this.actions[type]({ commit: this.commit, state: this.state }, arg); } } 1.3.2. 实现 getters class Store { constructor(options = {}) { options.getters && this.handleGetters(options.getters); } handleGetters(getters) { this.getters = {}; // 定义this.getters // 遍历getters选项，为this.getters定义property // 属性名就是选项中的key，只需定义get函数保证其只读性 Object.keys(getters).forEach((key) => { // 这样这些属性都是只读的 Object.defineProperty(this.getters, key, { get: () => { // 注意依然是箭头函数 return getters[key](this.state); }, }); }); } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/07_vue_source.html": {
    "url": "Vue/07_vue_source.html",
    "title": "07_vue_source",
    "keywords": "",
    "body": "1. vue 工作机制1.1. 初始化1.2. 编译1.3. 虚拟 dom1.3.1. 更新1.4. property/Dep/Watcher 对应关系1.5. compile 原理1.6. 代码1. vue 工作机制 模拟 Vue1.0 简易版：每个变量对应一个 watcher，程序变大时候性能变差。所以 vue2.0 引入了虚拟 DOM，每个组件对应一个 watcher。 1.1. 初始化 在 new Vue() 时会调⽤ init() 进⾏初始化，会初始化各种实例⽅法、全局⽅法、执⾏⼀些⽣命周期、 初始化 props、data 等状态。其中最重要的是 data 的「响应化」处理。 初始化之后调⽤ $mount 挂载组件，主要执⾏编译和⾸次更新 1.2. 编译 编译模块分为三个阶段 parse：使⽤正则解析 template 中的 vue 的指令(v-xxx) 变量等等 形成抽象语法树 AST optimize：标记⼀些静态节点，⽤作后⾯的性能优化，在 diﬀ 的时候直接略过 generate：把第⼀部⽣成的 AST 转化为渲染函数 render function 1.3. 虚拟 dom Virtual DOM 是 react ⾸创，Vue2 开始⽀持，就是⽤ JavaScript 对象来描述 dom 结构，数据修改的时候，我们先修改虚拟 dom 中的数据，然后数组做 diﬀ，最后再汇总所有的 diﬀ，⼒求做最少的 dom 操作，毕竟 js ⾥对⽐很快，⽽真实的 dom 操作太慢 // vdom { \"tag\": \"div\", \"props\": { \"name\": \"开课吧\", \"style\": { \"color\": \"red\" }, \"onClick\": \"xx\" }, \"children\": [ { \"tag\": \"a\", \"text\": \"click me\" } ] } click me 1.3.1. 更新 数据修改触发 setter，然后监听器会通知进⾏修改，通过对⽐新旧 vdom 树，得到最⼩修改，就是 patch ，然后只需要把这些差异修改即可 1.4. property/Dep/Watcher 对应关系 1.5. compile 原理 1.6. 代码 // vue.js class MyVue { constructor(options) { this.$options = options; this.$data = options.data; // 响应式处理 this.observe(this.$data); new Compile(options.el, this); if (options.created) { options.created.call(this); } } // data 可能有嵌套，要递归 observe(value) { // 这里只处理 object，demo 不处理 array 的响应式 if (!value || typeof value !== 'object') { return; } Object.keys(value).forEach((key) => { // 响应式处理 this.defineReactive(value, key, value[key]); // 代理data中的属性到vue根上 this.proxyData(key); }); } defineReactive(obj, key, val) { // recursive this.observe(val); const dep = new Dep(); // 每个dep实例和data中每个key有一对一关系 Object.defineProperty(obj, key, { get() { // 依赖收集 Dep.target && dep.addDep(Dep.target); return val; }, set(newVal) { if (newVal !== val) { val = newVal; // console.log(key + ' is updated'); dep.notify(); } }, }); } // 在vue根上定义属性代理data中的数据 proxyData(key) { // this 指的 MyVue 实例。把 $data 里面内容挂在到 instance 下 Object.defineProperty(this, key, { get() { return this.$data[key]; }, set(newVal) { this.$data[key] = newVal; }, }); } } // 创建Dep：管理所有Watcher class Dep { constructor() { // 存储所有依赖 this.watchers = []; } addDep(watcher) { this.watchers.push(watcher); } notify() { this.watchers.forEach((watcher) => watcher.update()); } } // 创建Watcher：保存data中数值和页面中的挂钩关系 class Watcher { constructor(vm, key, cb) { // 创建实例时立刻将该实例指向Dep.target便于依赖收集 this.vm = vm; this.key = key; this.cb = cb; //触发依赖收集 Dep.target = this; this.vm[this.key]; //触发依赖收集 Dep.target = null; } // 更新 update() { console.warn(this.key + '更新了！'); // DOM operation in future this.cb.call(this.vm, this.vm[this.key]); } } // 遍历dom结构，解析指令和插值表达式 class Compile { // el-带编译模板，vm-KVue实例 constructor(el, vm) { this.$vm = vm; this.$el = document.querySelector(el); // 把模板中的内容移到片段操作，dom操作会提⾼效率 this.$fragment = this.node2Fragment(this.$el); // 执行编译，同时进⾏依赖收集 this.compile(this.$fragment); // 放回$el中 this.$el.appendChild(this.$fragment); } // 移动DOM 到 fragment，之后再放回来 node2Fragment(el) { // 创建片段 const fragment = document.createDocumentFragment(); let child; while ((child = el.firstChild)) { fragment.appendChild(child); } return fragment; } compile(el) { const childNodes = el.childNodes; Array.from(childNodes).forEach((node) => { if (node.nodeType === 1) { // 元素 // console.log('编译元素' + node.nodeName); this.compileElement(node); } else if (this.isInterpolation(node)) { // 插值表达式，只关心 {{xxx}} // console.log('编译插值文本' + node.textContent); this.compileText(node); } // 递归子节点 if (node.children && node.childNodes.length > 0) { this.compile(node); } }); } // 文本替换 {{xxxx}} compileText(node) { // console.log(RegExp.$1); // console.log(this.$vm[RegExp.$1]); // 表达式 const exp = RegExp.$1; this.update(node, this.$vm, exp, 'text'); // text 指令和 v-text 指令都调用同一方法 } compileElement(node) { // 关心属性：k-text 最终会执行 text()。 const nodeAttrs = node.attributes; Array.from(nodeAttrs).forEach((attr) => { // 规定：k-xxx=\"yyy\" const attrName = attr.name; //k-xxx const exp = attr.value; //yyy if (this.isDirective(attrName)) { const dir = attrName.substring(2); this[dir] && this[dir](node, this.$vm, exp); } if (this.isEvent(attrName)) { const dir = attrName.substring(1); this.eventHandler(node, this.$vm, exp, dir); } }); } // 事件处理理: 给node添加事件监听，dir-事件名称 // 通过vm.$options.methods[exp]可获得回调函数 eventHandler(node, vm, exp, dir) { let fn = vm.$options.methods && vm.$options.methods[exp]; if (dir && fn) { node.addEventListener(dir, fn.bind(vm)); } } isInterpolation(node) { return node.nodeType == 3 && /\\{\\{(.*)\\}\\}/.test(node.textContent); } isDirective(attr) { return attr.indexOf('k-') === 0; } isEvent(attr) { return attr.indexOf('@') === 0; } update(node, vm, exp, dir) { const updaterFn = this[dir + 'Updater']; updaterFn && updaterFn(node, this.$vm[exp]); // 首次初始化 // 创建Watcher实例，依赖收集完成了 new Watcher(this.$vm, exp, function(value) { updaterFn && updaterFn(node, value); }); } text(node, vm, exp) { this.update(node, vm, exp, 'text'); } textUpdater(node, value) { node.textContent = value; } html(node, vm, exp) { this.update(node, vm, exp, 'html'); } htmlUpdater(node, value) { node.innerHTML = value; } model(node, vm, exp) { this.update(node, vm, exp, 'model'); node.addEventListener('input', (e) => { vm[exp] = e.target.value; }); } modelUpdater(node, value) { node.value = value; } } Vue Reactive Demo Name: {{name}} Age: {{age}} Change name const app = new MyVue({ el: '#app', data: { name: 'I am test.', age: 12, html: '这是一个按钮', }, created() { console.log('开始啦'); setTimeout(() => { this.name = '我是测试'; }, 1500); }, methods: { changeName() { this.name = '哈喽，开课吧'; this.age = 1; }, }, }); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/08_vue_source2.html": {
    "url": "Vue/08_vue_source2.html",
    "title": "08_vue_source2",
    "keywords": "",
    "body": "1. Vue v2.6.9 源码1.1. 整理理启动顺序1.2. 数据响应式1.3. 虚拟 DOM1.3.1. patch1.3.2. patchVnode1.3.3. updateChildren1.3.4. 属性更新如何实现的1.4. 模板编译1.4.1. 体验模板编译1.4.2. 模板编译过程1.4.3. 3. 代码⽣成 - generate1.4.4. v-if、v-for 学习1.4.5. 插槽1. Vue v2.6.9 源码 调试 vue 项⽬的⽅式 安装依赖: npm i 安装打包⼯工具: npm i rollup -g 修改 package.json ⾥里里⾯面 dev 脚本: \"dev\": \"rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev\" 执⾏行行打包: npm run dev 修改 samples ⾥里里⾯面的⽂文件引⽤用新⽣生成的 vue.js vue 是如何启动的 vue 响应式机制逐⾏分析 1.1. 整理理启动顺序 platforms/web/entry-runtime-with-compiler.js: /* new Vue({ template:dom }).$mount('#app') */ // 定义 mount：new Vue({ template:dom }).$mount('#app') const mount = Vue.prototype.$mount; // 挂载时执⾏mountComponent，将dom内容追加⾄el Vue.prototype.$mount = function(el?: string | Element, hydrating?: boolean): Component { el = el && query(el); // ... const options = this.$options; // 如果options 有 render，直接调用，如果没有 render，根据 template 生成 render 函数 // resolve template/el and convert to render function !!! if (!options.render) { let template = options.template; if (template) { // 判断 template 传入的类型做不同处理 if (typeof template === 'string') { if (template.charAt(0) === '#') { template = idToTemplate(template); } } else if (template.nodeType) { template = template.innerHTML; } } else if (el) { template = getOuterHTML(el); } if (template) { const { render, staticRenderFns } = compileToFunctions( template, { // ... }, this, ); options.render = render; options.staticRenderFns = staticRenderFns; } } // 调用 mount() return mount.call(this, el, hydrating); }; src\\platforms\\web\\runtime\\index.js 挂载时执⾏ mountComponent，将 dom 内容追加⾄ el // public mount method Vue.prototype.$mount = function(el?: string | Element, hydrating?: boolean): Component { el = el && inBrowser ? query(el) : undefined; return mountComponent(this, el, hydrating); // mountComponent! }; core/instance/lifecycle.js 创建组件更新函数，创建组件 watcher 实例。 // Line 172 updateComponent = () => { // ⾸先执行 vm._render() 返回VNode // 然后VNode作为参数执行update做dom更新 vm._update(vm._render(), hydrating); }; new Watcher( vm, updateComponent, noop, { before() { if (vm._isMounted && !vm._isDestroyed) { callHook(vm, 'beforeUpdate'); } }, }, true /* isRenderWatcher */, ); src\\core\\index.js initGlobalAPI(Vue); // 主要做这些事 Vue.set(), Vue.delete, Vue.nextTick... src\\core\\instance\\index.js function Vue(options) { this._init(options); } initMixin(Vue); // 实现上⾯面的_init这个初始化⽅方法 stateMixin(Vue); eventsMixin(Vue); lifecycleMixin(Vue); renderMixin(Vue); initMixin(Vue): // 重要，这里列出了执行顺序 initLifecycle(vm); initEvents(vm); initRender(vm); callHook(vm, 'beforeCreate'); initInjections(vm); // resolve injections before data/props。defineReactive(vm, key, result[key]) 所以跨层注入也有响应式。 initState(vm); initProvide(vm); // resolve provide after data/props callHook(vm, 'created'); initLifecycle: parent, children 等。parent 先于 child 创建 initEvents: 事件监听初始化 initInjections: 获取注⼊入数据并做响应化 initState: 初始化 props, methods, data, computed, watch 等 initProvide: 注⼊入数据处理理 stateMixin: 实现 watch, set, $delete eventsMixin(Vue): 实现 emit, on.. lifecycleMixin(Vue): 实现 _update, forceUpdate, destroy renderMixin(Vue): _render, $nextTick 1.2. 数据响应式 src\\core\\instance\\state.js // Line54: InitData(), 数组和对象响应化处理理逻辑 proxy(vm, `_data`, key); // 把 vue.$data.key 挂载到 vue.key 中 observe(data, true /* asRootData */); src\\core\\observer\\index.js // Line 124 ob = new Observer(value) return ob /** * 对象响应化调用 defineReactive */ walk (obj: Object) {} /** * 数组元素响应化 */ observeArray (items: Array) {} /** line 132 对象响应化处理理逻辑 * Define a reactive property on an Object. */ export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean ) { const dep = new Dep() // ... let childOb = !shallow && observe(val) // 数据拦截 Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { // Dep watch 管理 dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, set: function reactiveSetter (newVal) { // ... if (setter) { setter.call(obj, newVal) } else { val = newVal } childOb = !shallow && observe(newVal) dep.notify() } }) } 数组响应式 数组比较特别，它的操作⽅法不会触发 setter，需要特别处理 Observer 把修改过的数组拦截⽅法替换到当前数组对象上可以改变其⾏为 // line 48 if (hasProto) { //数组存在原型就覆盖其原型 protoAugment(value, arrayMethods); } else { //不不存在就直接定义拦截⽅方法 copyAugment(value, arrayMethods, arrayKeys); } this.observeArray(value); src\\core\\observer\\array.js 修改数组 7 个变更⽅法使其可以发送更新通知 arrayMethods methodsToPatch.forEach(function(method) { // cache original method const original = arrayProto[method]; def(arrayMethods, method, function mutator(...args) { //该⽅方法默认⾏为 const result = original.apply(this, args); //得到observer const ob = this.__ob__; let inserted; switch (method) { case 'push': case 'unshift': inserted = args; break; case 'splice': inserted = args.slice(2); break; } if (inserted) ob.observeArray(inserted); // notify change // 额外的事情是通知更新 ob.dep.notify(); return result; }); }); src\\core\\observer\\watcher.js // watcher和dep互相添加引⽤ addDep (dep: Dep) { const id = dep.id if (!this.newDepIds.has(id)) { this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) { dep.addSub(this) } } } watcher 更新逻辑: 通常情况下会执⾏ queueWatcher，执行异步更新 update () { /* istanbul ignore else */ if (this.lazy) { this.dirty = true } else if (this.sync) { this.run() } else { queueWatcher(this) } } src\\core\\observer\\scheduler.js queueWatcher 推⼊入队列，下个刷新周期执⾏批量任务，这是 vue 异步更新实现的关键 // Line 158 queue.push(watcher); nextTick(flushSchedulerQueue); nextTick 将 flushSchedulerQueue 加⼊入回调数组，启动 timerFunc 准备执⾏ callbacks.push(() => cb.call(ctx)); timerFunc(); // line 44 timerFunc 指定了了 vue 异步执⾏策略，根据执⾏环境，⾸选 Promise，备选依次为: MutationObserver、setImmediate、setTimeout 1.3. 虚拟 DOM src\\core\\instance\\render.js: 获取组件 vnode // Line 71 const { render, _parentVnode } = vm.$options; // Line 91 vnode = render.call(vm._renderProxy, vm.$createElement); src\\core\\instance\\lifecycle.js: 执行 patching 算法，初始化或更新 vnode ⾄$el // line 67 if (!prevVnode) { // initial render: 如果没有老vnode，说明在初始化 vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */); } else { // updates: 更新周期直接diff，返回新的dom vm.$el = vm.__patch__(prevVnode, vnode); } src\\platforms\\web\\runtime\\patch.js: 定义组件实例补丁方法 Vue.prototype.__patch__ = inBrowser ? patch : noop; src\\core\\vdom\\patch.js: 创建浏览器平台特有 patch 函数，主要负责 dom 更新操作 // 扩展操作:把通⽤模块和浏览器中特有模块合并 const modules = platformModules.concat(baseModules); // 工厂函数:创建浏览器特有的patch函数，这⾥主要解决跨平台问题 export const patch: Function = createPatchFunction({ nodeOps, modules }); 1.3.1. patch 那么 patch 如何⼯作的呢？ ⾸先说⼀下 patch 的核⼼ diﬀ 算法：通过同层的树节点进⾏⽐较⽽⾮对树进⾏逐层搜索遍历的⽅式，所以时间复杂度只有 O(n)，是⼀种相当⾼效的算法。 同层级只做三件事：增删改。 具体规则是：new VNode 不存在就删；old VNode 不存在就增；都存在就⽐较类型，类型不同直接替换、类型相同执⾏更新； /*createPatchFunction的返回值，⼀个patch函数*/ return function patch(oldVnode, vnode, hydrating, removeOnly) { /*vnode不存在则删*/ if (isUndef(vnode)) { if (isDef(oldVnode)) invokeDestroyHook(oldVnode); return; } let isInitialPatch = false; const insertedVnodeQueue = []; if (isUndef(oldVnode)) { /*oldVnode不存在则创建新节点*/ // empty mount (likely as component), create new root element isInitialPatch = true; createElm(vnode, insertedVnodeQueue); } else { /*oldVnode有nodeType，说明传递进来⼀个DOM元素*/ const isRealElement = isDef(oldVnode.nodeType); if (!isRealElement && sameVnode(oldVnode, vnode)) { // patch existing root node /*是组件且是同⼀个节点的时候打补丁*/ patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly); } else { /*传递进来oldVnode是dom元素*/ if (isRealElement) { // mounting to a real element // check if this is server-rendered content and if we can perform // a successful hydration. if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) { oldVnode.removeAttribute(SSR_ATTR); hydrating = true; } if (isTrue(hydrating)) { if (hydrate(oldVnode, vnode, insertedVnodeQueue)) { invokeInsertHook(vnode, insertedVnodeQueue, true); return oldVnode; } } // either not server-rendered, or hydration failed. // create an empty node and replace it // 将该dom元素清空 oldVnode = emptyNodeAt(oldVnode); } // replacing existing element const oldElm = oldVnode.elm; const parentElm = nodeOps.parentNode(oldElm); // create new node createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm), ); // update parent placeholder node element, recursively if (isDef(vnode.parent)) { let ancestor = vnode.parent; const patchable = isPatchable(vnode); while (ancestor) { for (let i = 0; i 1.3.2. patchVnode 两个 VNode 类型相同，就执⾏更新操作，包括三种类型操作：属性更新 PROPS、⽂本更新 TEXT、⼦节点更新 REORDER patchVnode 具体规则如下： 如果新旧 VNode 都是静态的，同时它们的 key 相同（代表同⼀节点），并且新的 VNode 是 clone 或 者是标记了 v-once，那么只需要替换 elm 以及 componentInstance 即可。 新⽼节点均有 children ⼦节点，则对⼦节点进⾏ diﬀ 操作，调⽤ updateChildren，这个 updateChildren 也是 diﬀ 的核⼼。 如果⽼节点没有⼦节点⽽新节点存在⼦节点，先清空⽼节点 DOM 的⽂本内容，然后为当前 DOM 节 点加⼊⼦节点。 当新节点没有⼦节点⽽⽼节点有⼦节点的时候，则移除该 DOM 节点的所有⼦节点。 当新⽼节点都⽆⼦节点的时候，只是⽂本的替换。 /*patch VNode节点*/ function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) { /*两个VNode节点相同则直接返回*/ if (oldVnode === vnode) { return; } if (isDef(vnode.elm) && isDef(ownerArray)) { // clone reused vnode vnode = ownerArray[index] = cloneVNode(vnode); } const elm = (vnode.elm = oldVnode.elm); /* 如果新旧VNode都是静态的，同时它们的key相同（代表同⼀节点）， 并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染⼀次）， 那么只需要替换elm以及componentInstance即可。 */ if ( isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) { vnode.elm = oldVnode.elm; vnode.componentInstance = oldVnode.componentInstance; return; } /*如果存在data.hook.prepatch则要先执⾏*/ let i; const data = vnode.data; if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) { i(oldVnode, vnode); } const oldCh = oldVnode.children; const ch = vnode.children; /*执⾏属性、事件、样式等等更新操作*/ if (isDef(data) && isPatchable(vnode)) { for (i = 0; i 1.3.3. updateChildren updateChildren 主要作⽤是⽤⼀种较⾼效的⽅式⽐对新旧两个 VNode 的 children 得出最⼩操作补丁。执⾏⼀个双循环是传统⽅式，vue 中针对 web 场景特点做了特别的算法优化。 在新⽼两组 VNode 节点的左右头尾两侧都有⼀个变量标记，在遍历过程中这⼏个变量都会向中间靠拢。 当 oldStartIdx > oldEndIdx 或者 newStartIdx > newEndIdx 时结束循环。 下⾯是遍历规则： ⾸先，oldStartVnode、oldEndVnode 与 newStartVnode、newEndVnode 两两交叉⽐较，共有 4 种⽐较 ⽅法。 当 oldStartVnode 和 newStartVnode 或者 oldEndVnode 和 newEndVnode 满⾜ sameVnode，直接将该 VNode 节点进⾏ patchVnode 即可，不需再遍历就完成了⼀次循环。如下图， 如果 oldStartVnode 与 newEndVnode 满⾜ sameVnode。说明 oldStartVnode 已经跑到了 oldEndVnode 后⾯去了，进⾏ patchVnode 的同时还需要将真实 DOM 节点移动到 oldEndVnode 的后⾯。 如果 oldEndVnode 与 newStartVnode 满⾜ sameVnode，说明 oldEndVnode 跑到了 oldStartVnode 的前 ⾯，进⾏ patchVnode 的同时要将 oldEndVnode 对应 DOM 移动到 oldStartVnode 对应 DOM 的前⾯。 如果以上情况均不符合，则在 old VNode 中找与 newStartVnode 满⾜ sameVnode 的 vnodeToMove，若 存在执⾏ patchVnode，同时将 vnodeToMove 对应 DOM 移动到 oldStartVnode 对应的 DOM 的前⾯。 当然也有可能 newStartVnode 在 old VNode 节点中找不到⼀致的 key，或者是即便 key 相同却不是 sameVnode，这个时候会调⽤ createElm 创建⼀个新的 DOM 节点。 ⾄此循环结束，但是我们还需要处理剩下的节点。 当结束时 oldStartIdx > oldEndIdx，这个时候旧的 VNode 节点已经遍历完了，但是新的节点还没有。说 明了新的 VNode 节点实际上⽐⽼的 VNode 节点多，需要将剩下的 VNode 对应的 DOM 插⼊到真实 DOM 中，此时调⽤ addVnodes（批量调⽤ createElm 接⼝）。 但是，当结束时 newStartIdx > newEndIdx 时，说明新的 VNode 节点已经遍历完了，但是⽼的节点还有 剩余，需要从⽂档中删 的节点删除。 function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) { let oldStartIdx = 0; let newStartIdx = 0; let oldEndIdx = oldCh.length - 1; let oldStartVnode = oldCh[0]; let oldEndVnode = oldCh[oldEndIdx]; let newEndIdx = newCh.length - 1; let newStartVnode = newCh[0]; let newEndVnode = newCh[newEndIdx]; let oldKeyToIdx, idxInOld, elmToMove, refElm; // 确保移除元素在过度动画过程中待在正确的相对位置，仅⽤于 const canMove = !removeOnly // 循环条件：任意起始索引超过结束索引就结束 while (oldStartIdx oldEndIdx) { /*全部⽐较完成以后，发现oldStartIdx > oldEndIdx的话，说明⽼节点已经遍历完了，新节 点⽐⽼节点多，所以这时候多出来的新节点需要⼀个⼀个创建出来加⼊到真实DOM中*/ refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm; addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue); } else if (newStartIdx > newEndIdx) { /*如果全部⽐较完成以后发现newStartIdx > newEndIdx，则说明新节点已经遍历完了，⽼节 点多余新节点，这个时候需要将多余的⽼节点从真实DOM中移除*/ removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx); } } 1.3.4. 属性更新如何实现的 //patch.js const hooks = ['create', 'activate', 'update', 'remove', 'destroy']; export function createPatchFunction(backend) { // 传递进来的扩展模块和节点操作对象 const { modules, nodeOps } = backend; for (i = 0; i 1.4. 模板编译 模板编译的主要⽬标是将模板(template)转换为渲染函数(render) Vue 2.0 需要⽤到 VNode 描述视图以及各种交互，⼿写显然不切实际，因此⽤户只需编写类似 HTML 代码 的 Vue 模板，通过编译器将模板转换为可返回 VNode 的 render 函数。 1.4.1. 体验模板编译 带编译器的版本中，可以使⽤ template 或 el 的⽅式声明模板 Vue.js测试 {{foo}} // 使⽤el⽅式 new Vue({ data: { foo: 'foo' }, el: '#demo' }); const app = new Vue({}); // 输出render函数 console.log(app.$options.render); 输出结果⼤致如下： function anonymous() { with (this) { return _c('div', { attrs: { id: 'demo' } }, [ _c('h1', [_v('Vue.js测试')]), _v(' '), _c('p', [_v(_s(foo))]), ]); } } 元素节点使⽤ createElement 创建，别名_c 本⽂节点使⽤ createTextVNode 创建，别名_v 表达式先使⽤ toString 格式化，别名_s 1.4.2. 模板编译过程 实现模板编译共有三个阶段：解析、优化和⽣成 1. 解析 - parse 解析器将模板解析为抽象语法树 AST，只有将模板解析成 AST 后，才能基于它做优化或者⽣成代码字符 串。 调试查看得到的 AST，/src/compiler/parser/index.js，结构如下： 解析器内部分了 HTML 解析器、⽂本解析器和过滤器解析器，最主要是 HTML 解析器，核⼼算法说明： //src/compiler/parser/index.js parseHTML(template, { start(tag, attrs, unary) {}, // 遇到开始标签的处理 end() {}, // 遇到结束标签的处理 chars(text) {}, // 遇到⽂本标签的处理 comment(text) {}, // 遇到注释标签的处理 }); 2. 优化 - optimize 优化器的作⽤是在 AST 中找出静态⼦树并打上标记。静态⼦树是在 AST 中永远不变的节点，如纯⽂本节 点。 标记静态⼦树的好处： 每次重新渲染，不需要为静态⼦树创建新节点 虚拟 DOM 中 patch 时，可以跳过静态⼦树 代码实现，src/compiler/optimizer.js - optimize export function optimize(root: ?ASTElement, options: CompilerOptions) { if (!root) return (isStaticKey = genStaticKeysCached(options.staticKeys || '')); isPlatformReservedTag = options.isReservedTag || no; // 找出静态节点并标记 markStatic(root); // 找出静态根节点并标记 markStaticRoots(root, false); } 标记结束 1.4.3. 3. 代码⽣成 - generate 将 AST 转换成渲染函数中的内容，即代码字符串。 generate ⽅法⽣成渲染函数代码，src/compiler/codegen/index.js export function generate(ast: ASTElement | void, options: CompilerOptions): CodegenResult { const state = new CodegenState(options); const code = ast ? genElement(ast, state) : '_c(\"div\")'; return { render: `with(this){return ${code}}`, staticRenderFns: state.staticRenderFns }; } //⽣成的code⻓这样 `_c('div',{attrs:{\"id\":\"demo\"}},[ _c('h1',[_v(\"Vue.js测试\")]), _c('p',[_v(_s(foo))]) ])`; 1.4.4. v-if、v-for 学习 着重观察⼏个结构性指令的解析过程 // 解析v-if，parser/index.js function processIf(el) { const exp = getAndRemoveAttr(el, 'v-if'); // 获取v-if=“exp\"中exp并删除v-if属性 if (exp) { el.if = exp; // 为ast添加if表示条件 addIfCondition(el, { // 为ast添加ifConditions表示各种情况对应结果 exp: exp, block: el, }); } else { // 其他情况处理 if (getAndRemoveAttr(el, 'v-else') != null) { el.else = true; } const elseif = getAndRemoveAttr(el, 'v-else-if'); if (elseif) { el.elseif = elseif; } } } // 代码⽣成，codegen/index.js function genIfConditions( conditions: ASTIfConditions, state: CodegenState, altGen?: Function, altEmpty?: string, ): string { const condition = conditions.shift(); // 每次处理⼀个条件 if (condition.exp) { // 每种条件⽣成⼀个三元表达式 return `(${condition.exp})?${genTernaryExp(condition.block)}:${genIfConditions( conditions, state, altGen, altEmpty, )}`; } else { return `${genTernaryExp(condition.block)}`; } // v-if with v-once should generate code like (a)?_m(0):_m(1) function genTernaryExp(el) {} } 解析结果： ⽣成结果： `with(this){return _c('div',{attrs:{\"id\":\"demo\"}},[ (foo) ? _c('h1',[_v(_s(foo))]) : _c('h1',[_v(\"no title\")]), _v(\" \"),_c('abc')],1)}`; 1.4.5. 插槽 组件编译的顺序是先编译⽗组件，再编译⼦组件。 普通插槽是在⽗组件编译和渲染阶段⽣成 vnodes ，数据的作⽤域是⽗组件，⼦组件渲染的时候直接拿 到这些渲染好的 vnodes 。 作⽤域插槽，⽗组件在编译和渲染阶段并不会直接⽣成 vnodes ，⽽是在⽗节点保留⼀个 scopedSlots 对象，存储着不同名称的插槽以及它们对应的渲染函数，只有在编译和渲染⼦组件阶段才会执⾏这个渲染函数⽣成 vnodes ，由于是在⼦组件环境执⾏的，所以对应的数据作⽤域是⼦组件实 例。 解析相关代码： // processSlotContent：处理 const slotBinding = getAndRemoveAttrByRegex(el, slotRE); if (slotBinding) { // 查找v-slot:xxx const { name, dynamic } = getSlotName(slotBinding); // name是xxx el.slotTarget = name; // xxx赋值到slotTarget el.slotTargetDynamic = dynamic; el.slotScope = slotBinding.value || emptySlotScopeToken; // yyy赋值到 slotScope } // processSlotOutlet：处理 if (el.tag === 'slot') { el.slotName = getBindingAttr(el, 'name'); // 获取slot的name并赋值到slotName } ⽣成相关代码： // genScopedSlot：这⾥把slotScope作为形参转换为⼯⼚函数返回内容 const fn = `function(${slotScope}){` + `return ${ el.tag === 'template' ? el.if && isLegacySyntax ? `(${el.if})?${genChildren(el, state) || 'undefined'}:undefined` : genChildren(el, state) || 'undefined' : genElement(el, state) }}`; // reverse proxy v-slot without scope on this.$slots const reverseProxy = slotScope ? `` : `,proxy:true`; return `{key:${el.slotTarget || `\"default\"`},fn:${fn}${reverseProxy}}`; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/09_vue_svg_icon.html": {
    "url": "Vue/09_vue_svg_icon.html",
    "title": "09_vue_svg_icon",
    "keywords": "",
    "body": "1. 最佳实践1.1. 项⽬配置1.1.1. 链式操作：演示 webpack 规则配置，custom icon1. 最佳实践 1.1. 项⽬配置 npm run eject vue.conﬁg.js 做⼀些基础配置：指定应⽤上下⽂、端⼝号、主⻚ title // vue.config.js const port = 7070; const title = 'vue in practice'; module.exports = { publicPath: '/best-practice', // 部署应⽤包时的基本 URL devServer: { port }, configureWebpack: { // 向index.html注⼊标题 name: title } }; // index.html 1.1.1. 链式操作：演示 webpack 规则配置，custom icon 范例：项⽬要使⽤ icon，传统⽅案是图标字体(字体⽂件+样式⽂件)，不便维护；svg ⽅案采⽤ svgsprite-loader ⾃动加载打包，⽅便维护。 使⽤ icon 前先安装依赖：svg-sprite-loader npm i svg-sprite-loader -D vue inspect -h Usage: inspect [options] [paths...] inspect the webpack config in a project with vue-cli-service Options: --mode --rule inspect a specific module rule --plugin inspect a specific plugin --rules list all module rule names --plugins list all plugin names -v --verbose Show full function definitions in output -h, --help output usage information 复制图标 svg code，存⼊ src/icons/svg 中。修改规则和新增规则： vue.conﬁg.js chainWebpack(config) { // 配置svg规则排除icons⽬录中svg⽂件处理 config.module.rule('svg').exclude.add(resolve('src/icons')); // 新增icons规则，设置svg-sprite-loader处理icons⽬录中的svg config.module .rule('icons') //新增icons规则 .test(/\\.svg$/) //匹配后缀 .include.add(resolve('src/icons')) //加入include array .end() //add完上下⽂是数组不是icons规则，使⽤end()回退 .use('svg-sprite-loader') // 添加loader .loader('svg-sprite-loader') // 切换上下文到loader .options({ symbolId: 'icon-[name]' }) //指定选项 .end(); } 检查配置： vue inspect --rule svg /* config.module.rule('svg') */ { test: /\\.(svg)(\\?.*)?$/, exclude: [ '/Users/guanghuiw/My/kaikaba/vue-learning/src/icons' ], use: [ { loader: 'file-loader', options: { name: 'img/[name].[hash:8].[ext]' } } ] } 图标⾃动导⼊ /* 图标自动导入, note main.js needs import './icons'; */ import Vue from 'vue'; import Icon from '@/components/Icon.vue'; // 利用webpack 的require.context自动导入 const req = require.context('./svg', false, /\\.svg$/); // 遍历加载上下⽂中所有项 // 返回的req是只去加载svg目录中的模块的函数 req.keys().map(req); // console.log(req.keys()); // [\"./qq.svg\", \"./wechat.svg\"] // Icon组件全局注册一下 Vue.component('Icon', Icon); 创建 Icon 组件: export default { name: 'Icon', props: { name: { type: String, required: true, }, className: { type: String, default: '', }, }, computed: { iconName() { return `#icon-${this.name}`; }, svgClass() { if (this.className) { return 'svg-icon ' + this.className; } else { return 'svg-icon'; } }, }, }; .svg-icon { width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; } 注册: // icons/index.js /* 图标自动导入, note main.js needs import './icons'; */ import Vue from 'vue'; import Icon from '@/components/Icon.vue'; // Icon组件全局注册一下 Vue.component('Icon', Icon); // main.js import './icons'; 使⽤: Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/10_acl.html": {
    "url": "Vue/10_acl.html",
    "title": "10_acl",
    "keywords": "",
    "body": "1. 权限控制 ACL1.1. 局部权限控制：比如一个页面，不同角色看到不同 button。1. 权限控制 ACL 路由分为两种， constantRoutes 和 asyncRoutes 。 定义路由，router/index.js import Vue from 'vue'; import Router from 'vue-router'; import Layout from '@/layout'; // 布局页 Vue.use(Router); // 通用页面 export const constRoutes = [ { path: '/login', component: () => import('@/views/Login'), hidden: true, // 导航菜单忽略该项 }, { path: '/', component: Layout, // 应用布局 redirect: '/home', children: [ { path: 'home', component: () => import(/* webpackChunkName: \"home\" */ '@/views/Home.vue'), name: 'home', meta: { title: 'Home', // 导航菜单项标题 icon: 'qq', // 导航菜单项图标 }, }, ], }, ]; // 权限⻚⾯ export const asyncRoutes = [ { path: '/about', component: Layout, redirect: '/about/index', children: [ { path: 'index', component: () => import('@/views/About.vue'), name: 'about', meta: { title: 'About', icon: 'qq', // 角色决定将来那些用户可以看到该路由 roles: ['admin', 'editor'], }, }, ], }, { path: '/message', component: Layout, redirect: '/message/index', children: [ { path: 'index', component: () => import('@/views/Message.vue'), name: 'message', meta: { title: 'Message', icon: 'wechat', // 角色决定将来那些用户可以看到该路由 roles: ['admin'], }, }, ], }, { path: '/personal', component: () => import('@/views/Personal.vue'), name: 'personal', meta: { title: 'personal', }, }, ]; export default new Router({ mode: 'history', base: process.env.BASE_URL, routes: constRoutes, }); 路由守卫，创建./src/router/guard.js，并在 main.js 中引⼊ /* 在main.js中引⼊ */ // 做全局路由守卫，不同用户角色，可以看到不同的 route。 import router from './index'; import store from '@/store'; import { getToken } from '@/utils/auth'; // 从cookie获取令牌 const whiteList = ['/login']; router.beforeEach(async (to, from, next) => { const hasToken = getToken(); if (hasToken) { // 登录用户访问 login 为他转到 home if (to.path === '/login') { next({ path: '/' }); } else { //已登录, 访问其他页面，获取用户角色 const hasRoles = store.getters.roles && store.getters.roles.length > 0; if (hasRoles) { next(); } else { try { // 先请求获取用户信息 const { roles } = await store.dispatch('user/getInfo'); // 根据当前用户角色动态生成路由 const accessRoutes = await store.dispatch('permission/generateRoutes', roles); // 添加这些路由至路由器 router.addRoutes(accessRoutes); // 继续路由切换，确保addRoutes完成 next({ ...to, replace: true }); } catch (error) { // 出错需重置令牌并重新登录（令牌过期、网络错误等原因） await store.dispatch('user/resetToken'); alert(error || '出错了'); next(`/login?redirect=${to.path}`); } } } } else { // ⽤户⽆令牌 if (whiteList.indexOf(to.path) !== -1) { // ⽩名单路由放过 next(); } else { // 重定向⾄登录⻚ next(`/login?redirect=${to.path}`); } } }); utils/auth.js import Cookies from 'js-cookie'; export function getToken() { return Cookies.get('token'); } export function setToken(token) { return Cookies.set('token', token); } export function removeToken() { return Cookies.remove('token'); } vuex 相关模块实现，创建 store/index.js import Vue from 'vue'; import Vuex from 'vuex'; import user from './user'; import permission from './permission'; Vue.use(Vuex); export default new Vuex.Store({ modules: { permission, user, }, // 全局定义getters便于访问 getters: { roles: (state) => state.user.roles, }, }); user 模块：⽤户数据、⽤户登录等，store/user.js import { getToken, setToken, removeToken } from '@/utils/auth'; const state = { token: getToken(), roles: [], // 用户角色 }; const mutations = { SET_TOKEN: (state, token) => { state.token = token; }, SET_ROLES: (state, roles) => { state.roles = roles; }, }; const actions = { // POST user login login({ commit }, userInfo) { const { username } = userInfo; return new Promise((resolve, reject) => { setTimeout(() => { if (username === 'admin' || username === 'jerry') { commit('SET_TOKEN', username); setToken(username); resolve(); } else { reject('用户名、密码错误'); } }, 200); }); }, // get user info getInfo({ commit, state }) { return new Promise((resolve) => { setTimeout(() => { const roles = state.token === 'admin' ? ['admin'] : ['editor']; commit('SET_ROLES', roles); resolve({ roles }); }, 200); }); }, // remove token resetToken({ commit }) { return new Promise((resolve) => { commit('SET_TOKEN', ''); commit('SET_ROLES', []); removeToken(); resolve(); }); }, }; export default { namespaced: true, state, mutations, actions, }; permission 模块：路由配置信息、路由⽣成逻辑, store/permission.js import { asyncRoutes, constRoutes } from '@/router'; /** * 根据路由meta.role确定是否当前用户拥有访问权限 * 某条路由上表明哪些角色可以访问，当前用户的角色是否在其中 * @roles 用户拥有角色 * @route 待判定路由 */ function hasPermission(roles, route) { // 如果当前路由有roles字段则需判断用户访问权限 if (route.meta && route.meta.roles) { // 若用户拥有的角色中有被包含在待判定路由角色表中的则拥有访问权 return roles.some((role) => route.meta.roles.includes(role)); } else { // 没有设置roles则无需判定即可访问 return true; } } /** * 递归过滤AsyncRoutes路由表，找到当前用户对应角色所能访问的路由 * @routes 待过滤路由表，首次传入的就是AsyncRoutes * @roles 用户拥有角色 */ export function filterAsyncRoutes(routes, roles) { const res = []; routes.forEach((route) => { // 复制一份 const tmp = { ...route }; // 如果用户有访问权则加入结果路由表 if (hasPermission(roles, tmp)) { // 如果存在子路由则递归过滤之 if (tmp.children) { tmp.children = filterAsyncRoutes(tmp.children, roles); } res.push(tmp); } }); return res; } const state = { routes: [], // 完整路由表(跟角色无关、不需登录的路由 + 不同角色允许的路由) addRoutes: [], // 用户可访问路由表 }; const mutations = { SET_ROUTES: (state, routes) => { // 保存能够访问的动态路由 state.addRoutes = routes; // 全部路由 state.routes = constRoutes.concat(routes); }, }; const actions = { // 路由生成：在得到用户角色后会第一时间调用 generateRoutes({ commit }, roles) { return new Promise((resolve) => { let accessedRoutes; // 用户是管理员则拥有完整访问权限 if (roles.includes('admin')) { accessedRoutes = asyncRoutes || []; } else { // 否则需要根据角色做过滤处理 accessedRoutes = filterAsyncRoutes(asyncRoutes, roles); } commit('SET_ROUTES', accessedRoutes); resolve(accessedRoutes); }); }, }; export default { namespaced: true, state, mutations, actions, }; 布局⻚⾯，layout/index.vue --> ⽤户登录⻚⾯，views/Login.vue Login Page (username: admin or jerry) 登录 export default { data() { return { username: 'admin', }; }, methods: { async login() { try { await this.$store.dispatch('user/login', { username: this.username }); this.$router.push({ path: '/' }); } catch (error) { alert(error); } }, }, }; 1.1. 局部权限控制：比如一个页面，不同角色看到不同 button。 // directive/permission.js /* 局部权限控制 该指令通过传递进来的权限数组和当前用户角色数组过滤 如果用户拥有要求的权限则可以看到，否则删除指令挂钩dom元素 */ import store from '@/store'; export default { // el-挂载dom // binding- v-permission=\"[]\" {value:[]} inserted(el, binding) { // 获取值 const { value: permissionRoles } = binding; // 获取用户角色 const roles = store.getters.roles; // 合法性判断 if (permissionRoles && permissionRoles instanceof Array && permissionRoles.length > 0) { // 判断用户角色中是否有要求的 const hasPermission = roles.some((role) => { return permissionRoles.includes(role); }); // 如果没有权限则删除当前dom // 和 v-if区别，v-if 更早执行，element 都不回加载。这个是加载后再删除。 if (!hasPermission) { el.parentNode && el.parentNode.removeChild(el); } } else { throw new Error('需要指定数组类型权限，如v-permission。。。'); } }, }; register this directive globally in main.js // main.js import permission from '@/directive/permission'; Vue.directive('permission', permission); // globally register directive Use this directive editor button admin button Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/11_navbar.html": {
    "url": "Vue/11_navbar.html",
    "title": "11_navbar",
    "keywords": "",
    "body": "1. 根据 ACL 动态生成 navbar1.1. 导航菜单⽣成1.2. 利⽤ element-ui 做⼀个更⾼逼格的导航1. 根据 ACL 动态生成 navbar 1.1. 导航菜单⽣成 导航菜单是根据路由信息并结合权限判断⽽动态⽣成的。它需要⽀持路由的多级嵌套，所以这⾥要⽤到递归组件。 菜单结构是典型递归组件，利⽤之前实现的 tree 组件。 数据准备，添加 getter ⽅法，store/index.js getters: { permission_routes: state => state.permission.routes, } 修改 sidemenu/index.vue import { mapGetters } from 'vuex'; import Item from './Item'; export default { components: { Item, }, computed: { ...mapGetters(['permission_routes']), }, }; Item.vue 改造 {{ model.meta.title }} [{{ open ? '-' : '+' }}] {{ model.meta.title }} import path from 'path'; export default { name: 'Item', props: { model: Object, // 新增basePath保存⽗路由path basePath: { type: String, default: '' }, }, data: function() { return { open: false, // 打开状态 }; }, computed: { isFolder: function() { // 是否有子树 return this.model.children && this.model.children.length; }, }, methods: { // 拼接⼦路由完整path resolvePath(routePath) { return path.resolve(this.basePath, routePath); }, toggle: function() { if (this.isFolder) { this.open = !this.open; } }, }, }; 1.2. 利⽤ element-ui 做⼀个更⾼逼格的导航 // sidebar/index.vue import { mapGetters } from 'vuex'; import SidebarItem from './SidebarItem'; export default { components: { SidebarItem }, computed: { ...mapGetters(['permission_routes']), activeMenu() { const route = this.$route; const { meta, path } = route; // 默认激活项 if (meta.activeMenu) { return meta.activeMenu; } return path; }, variables() { return { menuText: '#bfcbd9', menuActiveText: '#409EFF', menuBg: '#304156', }; }, }, }; // sidebar/sidebarItem.vue import path from 'path'; import Item from './Item'; export default { name: 'SidebarItem', components: { Item }, props: { // route object item: { type: Object, required: true }, isNest: { type: Boolean, default: false }, basePath: { type: String, default: '' }, }, data() { this.onlyOneChild = null; return {}; }, methods: { hasOneShowingChild(children = [], parent) { const showingChildren = children.filter((item) => { if (item.hidden) { return false; } else { // 如果只有⼀个⼦菜单时设置 this.onlyOneChild = item; return true; } }); // 当只有⼀个⼦路由，该⼦路由默认显示 if (showingChildren.length === 1) { return true; } // 没有⼦路由则显示⽗路由 if (showingChildren.length === 0) { this.onlyOneChild = { ...parent, path: '', noShowingChildren: true }; return true; } return false; }, resolvePath(routePath) { return path.resolve(this.basePath, routePath); }, }, }; // sidebar/item.vue export default { name: 'MenuItem', functional: true, props: { icon: { type: String, default: '' }, title: { type: String, default: '' } }, render(h, context) { const { icon, title } = context.props; const vnodes = []; if (icon) { vnodes.push(); } if (title) { vnodes.push({title}); } return vnodes; }, }; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/12_mock.html": {
    "url": "Vue/12_mock.html",
    "title": "12_mock",
    "keywords": "",
    "body": "1. 数据交互1.1. 封装 request1.1.1. way 1: vue.config.js do 数据 mock1.1.2. way 2 线上 mock：easy-mock1.1.3. way 3 proxy local1. 数据交互 1.1. 封装 request 安装 axios: npm i axios -S 创建@/utils/request.js import axios from 'axios'; import { MessageBox, Message } from 'element-ui'; import store from '@/store'; import { getToken } from '@/utils/auth'; // 创建axios实例 const service = axios.create({ baseURL: process.env.VUE_APP_BASE_API, // url基础地址，解决不同数据源url变化问题 // withCredentials: true, // 跨域时若要发送cookies需设置该选项 timeout: 5000, // 超时 }); // 请求拦截 service.interceptors.request.use( (config) => { // do something if (store.getters.token) { // 设置令牌请求头 config.headers['Authorization'] = 'Bearer ' + getToken(); } return config; }, (error) => { // 请求错误预处理 //console.log(error) return Promise.reject(error); }, ); // 响应拦截 service.interceptors.response.use( // 通过⾃定义code判定响应状态，也可以通过HTTP状态码判定 (response) => { // 仅返回数据部分 const res = response.data; // code不为1则判定为⼀个错误 if (res.code !== 1) { Message({ message: res.message || 'Error', type: 'error', duration: 5 * 1000 }); // 假设：10008-⾮法令牌; 10012-其他客户端已登录; 10014-令牌过期; if (res.code === 10008 || res.code === 10012 || res.code === 10014) { // 重新登录 MessageBox.confirm('登录状态异常，请重新登录', '确认登录信息', { confirmButtonText: '重新登录', cancelButtonText: '取消', type: 'warning', }).then(() => { store.dispatch('user/resetToken').then(() => { location.reload(); }); }); } return Promise.reject(new Error(res.message || 'Error')); } else { return res; } }, (error) => { //console.log(\"err\" + error); // for debug Message({ message: error.message, type: 'error', duration: 5 * 1000 }); return Promise.reject(error); }, ); export default service; 设置 VUE_APP_BASE_API 环境变量，创建 .env.development ⽂件 # base api VUE_APP_BASE_API = '/dev-api' store/index.js 添加 token 的 getter ⽅法 token: (state) => state.user.token; 测试代码，创建@/api/user.js import request from '@/utils/request'; export function login(data) { return request({ url: '/user/login', method: 'post', data }); } export function getInfo() { return request({ url: '/user/info', method: 'get', }); } 1.1.1. way 1: vue.config.js do 数据 mock 本地 mock 修改 vue.conﬁg.js，给 devServer 添加相关代码： devServer: { // ... before: (app) => { app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ extended: true })); app.post('/dev-api/user/login', (req, res) => { const { username } = req.body; if (username === 'admin' || username === 'jerry') { res.json({ code: 1, data: username }); } else { res.json({ code: 10204, message: '⽤户名或密码错误' }); } }); app.get('/dev-api/user/info', (req, res) => { const auth = req.headers['authorization']; const roles = auth.split(' ')[1] === 'admin' ? ['admin'] : ['editor']; res.json({ code: 1, data: roles }); }); } }, post 请求需额外安装依赖： npm i body-parser -D 调⽤接⼝，@/store/user.js import { getToken, setToken, removeToken } from '@/utils/auth'; import { login, getInfo } from '@/api/user'; const state = { token: getToken(), roles: [], // 用户角色 }; const mutations = { SET_TOKEN: (state, token) => { state.token = token; }, SET_ROLES: (state, roles) => { state.roles = roles; }, }; const actions = { // POST user login login({ commit }, userInfo) { // 调⽤并处理结果，错误处理已拦截⽆需处理 return login(userInfo).then((res) => { commit('SET_TOKEN', res.data); setToken(res.data); }); /* const { username } = userInfo; return new Promise((resolve, reject) => { setTimeout(() => { if (username === 'admin' || username === 'jerry') { commit('SET_TOKEN', username); setToken(username); resolve(); } else { reject('用户名、密码错误'); } }, 200); }); */ }, // get user info getInfo({ commit, state }) { return getInfo(state.token).then(({ data: roles }) => { commit('SET_ROLES', roles); return { roles }; }); /* return new Promise((resolve) => { setTimeout(() => { const roles = state.token === 'admin' ? ['admin'] : ['editor']; commit('SET_ROLES', roles); resolve({ roles }); }, 200); }); */ }, // remove token resetToken({ commit }) { return new Promise((resolve) => { commit('SET_TOKEN', ''); commit('SET_ROLES', []); removeToken(); resolve(); }); }, }; export default { namespaced: true, state, mutations, actions, }; 1.1.2. way 2 线上 mock：easy-mock 登录 easy-mock ⽹站 创建⼀个项⽬ 创建需要的接⼝ 调⽤：修改 base_url，.env.development VUE_APP_BASE_API = 'https://easymock.com/mock/5cdcc3fdde625c6ccadfd70c/kkb-cart' 1.1.3. way 3 proxy local 开发时解决跨域，原理把浏览器请求通过 web devServer 来请求，再转发给 local mock server，浏览器不直接请求 local mock server。 如果请求的接⼝在另⼀台服务器上，开发时则需要设置代理避免跨域问题 添加代理配置，vue.conﬁg.js devServer: { proxy: { // 代理 /dev-api/user/login 到 http://127.0.0.1:3000/user/login [process.env.VUE_APP_BASE_API]: { target: `http://127.0.0.1:3000/`, changeOrigin: true, pathRewrite: { ['^' + process.env.VUE_APP_BASE_API]: '' } } } }, 创建⼀个独⽴接⼝服务器，~/mock-server/index.js const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); app.use( bodyParser.urlencoded({ extended: true, }), ); app.post('/user/login', (req, res) => { const { username } = req.body; if (username === 'admin' || username === 'jerry') { res.json({ code: 1, data: username }); } else { res.json({ code: 10204, message: '⽤户名或密码错误' }); } }); app.get('/user/info', (req, res) => { const roles = req.headers['authorization'].split(' ')[1] ? ['admin'] : ['editor']; res.json({ code: 1, data: roles, }); }); app.listen(3000); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/13_unit_test.html": {
    "url": "Vue/13_unit_test.html",
    "title": "13_unit_test",
    "keywords": "",
    "body": "1. Unit test1.1. e2e test1. Unit test vue add @vue/unit-jest 和 vue add @vue/e2e-cypress jest.config.js module.exports = { collectCoverage: true, collectCoverageFrom: ['src/**/*.{js,vue}'], }; components/test.vue {{ message }} 点击 export default { data() { return { message: 'vue-text', count: 0 }; }, created() { this.message = '开课吧'; }, methods: { changeMsg() { if (this.count > 1) { this.message = 'count⼤于1'; } else { this.message = '按钮点击'; } }, changeCount() { this.count += 1; }, }, }; tests/unit/test.spec.js // 导⼊ Vue.js 和组件，进⾏测试 import Vue from 'vue'; import { mount } from '@vue/test-utils'; import TestComp from '@/components/Test.vue'; describe('TestComp', () => { // 检查原始组件选项 it('由created⽣命周期', () => { expect(typeof TestComp.created).toBe('function'); }); // 评估原始组件选项中的函数的结果 it('初始data是vue-text', () => { // 检查data函数存在性 expect(typeof TestComp.data).toBe('function'); // 检查data返回的默认值 const defaultData = TestComp.data(); expect(defaultData.message).toBe('vue-text'); }); it('mount之后测data是开课吧', () => { const vm = new Vue(TestComp).$mount(); expect(vm.message).toBe('开课吧'); }); it('按钮点击后', () => { const wrapper = mount(TestComp); wrapper.find('button').trigger('click'); // 测试数据变化 expect(wrapper.vm.message).toBe('按钮点击'); // 测试html渲染结果 expect(wrapper.find('span').html()).toBe('按钮点击'); // 等效的⽅式 expect(wrapper.find('span').text()).toBe('按钮点击'); }); }); 1.1. e2e test e2e/specs/test.js // 借⽤浏览器的能⼒，站在⽤户测试⼈员的⻆度，输⼊框，点击按钮等，完全模拟⽤户，这个和具体的框 架关系不⼤，完全模拟浏览器⾏为 // https://docs.cypress.io/api/introduction/api.html describe('My First Test', () => { it('Visits the app root url', () => { cy.visit('/'); cy.contains('h2', 'Custom Form'); }); }); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/14_ssr_nuxt.html": {
    "url": "Vue/14_ssr_nuxt.html",
    "title": "14_ssr_nuxt",
    "keywords": "",
    "body": "1. SSR: server render1.1. nuxt 渲染过程1.2. nuxt 安装1.2.1. 路由⽣成1.2.2. 导航1.2.3. 动态路由 routes with optional parameter1.2.4. 嵌套路由1.2.5. 默认布局1.2.6. ⾃定义布局1.2.7. ⾃定义错误⻚⾯1.2.8. ⻚⾯1.2.9. 自定义 loading 页面1.3. 异步数据1.3.1. 1. 接⼝准备1.3.2. 2. 整合 axios1.3.3. 3. 配置：nuxt.conﬁg.js1.3.4. 4. 获取商品列表，index.vue1.3.5. 5. 商品详情页 meta 标签填充1.4. 中间件1.5. 插件1.6. 服务端渲染应⽤部署1.7. 静态应⽤部署1.8. FAQ1. SSR: server render https://ssr.vuejs.org/zh/ https://nuxtjs.org/ 1.1. nuxt 渲染过程 生命周期流程图，红框内的是 Nuxt 的生命周期(运行在服务端)，黄框内同时运行在服务端&&客户端上，绿框内则运行在客户端 红框、黄框内的周期都不存在 Window 对象 export default { asyncData() { console.log(window) // 服务端报错 }, fetch() { console.log(window) // 服务端报错 }, created () { console.log(window) // undefined }, mounted () { console.log(window) // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …} } } 1.2. nuxt 安装 npx create-nuxt-app 1.2.1. 路由⽣成 pages ⽬录中所有 *.vue ⽂件⾃动⽣成应⽤的路由配置 查看.nuxt/router.js 验证⽣成路由 1.2.2. 导航 添加路由导航，layouts/default.vue Home Admin Cart page not pre-fetched 禁⽤预加载： page not pre-fetched 1.2.3. 动态路由 routes with optional parameter 以下划线作为前缀的 .vue ⽂件 或 ⽬录会被定义为动态路由，如下⾯⽂件结构 pages/ --| detail/ ----| _id.vue any Folder or File starts with _ will generate optional parameter in a route. e.g. pages/detail/_id.vue will generate below: { \"path\": \"/detail/:id?\", \"component\": _063cf108, \"name\": \"detail-id\" } in the _id.vue page, we can access the optional parameter by $route.params.id. detail with id: {{ $route.params.id }} export default { // 如果校验失败，则自动跳转到错误页面 validate({ params, query }) { return /^\\d+$/.test(Number(params.id)); // must be number } }; 1.2.4. 嵌套路由 创建内嵌⼦路由，你需要添加⼀个 .vue ⽂件，同时添加⼀个与该⽂件同名的⽬录⽤来存放⼦视图组件。 构造⽂件结构如下： pages/ --| nested/ ----| test.vue --| nested.vue nested.vue nested.vue nested/test.vue nested/test.vue Try to accesslocalhost:3000/nested and localhost:3000/nested/test. The first only displays nested.vue, the latter displays both nested.vue and nested/test.vue. Route is { \"path\": \"/nested\", \"component\": _21365f83, \"name\": \"nested\", \"children\": [ { \"path\": \"test\", \"component\": _7e192564, \"name\": \"nested-test\" } ] } 1.2.5. 默认布局 查看 layouts/default.vue 1.2.6. ⾃定义布局 创建空⽩布局⻚⾯ layouts/blank.vue ，⽤于 login.vue ⻚⾯ pages/login.vue 使⽤⾃定义布局： export default { layout: 'blank' }; 1.2.7. ⾃定义错误⻚⾯ 创建 layouts/error.vue Whenever this is an error, display this page. More nuxt error {{ error }} Page not found An error occurred Home page export default { props: ['error'], layout: 'blank', // use blank layout. otherwise use default layout as well. you can set a custom layout for the error page }; 1.2.8. ⻚⾯ ⻚⾯组件就是 Vue 组件，只不过 Nuxt.js 为这些组件添加了⼀些特殊的配置项给⾸⻚添加标题和 meta // index.vue export default { components: { Logo, }, head() { return { title: '课程列表', meta: [{ name: 'description', hid: 'description', content: 'set page meta' }], link: [{ rel: 'favicon', href: 'favicon.ico' }], }; }, }; 1.2.9. 自定义 loading 页面 nuxt.config.js module.exports = { loading: '~/components/loading.vue', }; loading.vue: Loading... export default { data: () => ({ loading: false, }), methods: { start() { this.loading = true; }, finish() { this.loading = false; }, }, }; .loading-page { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.9); text-align: center; padding-top: 200px; font-size: 48px; font-family: sans-serif; z-index: 999; } in a component, either mounted or asyncData hook. mounted() { // test loading component this.$nextTick(() => { this.$nuxt.$loading.start(); setTimeout(() => this.$nuxt.$loading.finish(), 1000); }); } // test loading component asyncData() { return new Promise((resolve) => { setTimeout(function() { resolve({}); }, 1000); }); } 1.3. 异步数据 asyncData ⽅法使得我们可以在设置组件数据之前异步获取或处理数据。 范例：获取商品数据 1.3.1. 1. 接⼝准备 安装依赖： npm i koa-router koa-bodyparser -S 创建接⼝⽂件，server/api.js /** * API Server, can be java */ const Koa = require('koa'); const bodyparser = require('koa-bodyparser'); const router = require('koa-router')({ prefix: '/api' }); // add prefix for each api const app = new Koa(); // 设置cookie加密秘钥 app.keys = ['some secret', 'another secret']; const goods = [ { id: 1, name: 'Web全栈架构师', price: 2000 }, { id: 2, name: 'Python架构师', price: 1000 }, ]; // 上面定义了为每个请求添加 api prefix router.post('/login', (ctx) => { const user = ctx.request.body; if (user.username === 'jerry' && user.password === '123') { // 将token存⼊cookie const token = 'a mock token'; ctx.cookies.set('token', token); ctx.body = { ok: 1, token }; } else { ctx.body = { ok: 0 }; } }); router.get('/goods', (ctx) => { ctx.body = { ok: 1, goods }; }); router.get('/goods/:id', (ctx) => { ctx.body = { ok: 1, good: goods.find((good) => good.id == ctx.params.id) }; }); // 解析post数据并注册路由 app.use(bodyparser()); app.use(router.routes()); app.listen(8080, () => console.log('api服务已启动')); 1.3.2. 2. 整合 axios 安装@nuxt/axios 模块： npm install @nuxtjs/axios -S 注意 $axios.get and $axios.$get 不一样！后者不需要 data.res! 1.3.3. 3. 配置：nuxt.conﬁg.js { \"modules\": [\"@nuxtjs/axios\"], \"axios\": { \"proxy\": true }, \"proxy\": { \"/api\": \"http://localhost:8080\" } } 1.3.4. 4. 获取商品列表，index.vue id name price {{ g.id }} {{ g.name }} {{ g.price }} export default { // todo: learn asyncData and fetch async asyncData({ $axios, isDev, route, store, env, params, query, req, res, redirect, error }) { // $axios is exposed due to nuxt modules: ['@nuxtjs/axios'] try { const { ok, goods } = await $axios.$get('/api/goods'); if (ok) { return { goods }; } error('failed to fetch data'); } catch (err) { error(err); // redirect('/route-path'); } }, head() { return { title: '课程列表', meta: [{ name: 'description', hid: 'description', content: 'set page meta' }], link: [{ rel: 'favicon', href: 'favicon.ico' }] }; }, data() { return { goods: [ { id: 3, name: 'FE engineering', price: 3000 }, { id: 4, name: 'C#架构师', price: 4000 } ] }; } }; 1.3.5. 5. 商品详情页 meta 标签填充 {{ good.name }} detail with id: {{ $route.params.id }} export default { // todo: asyncData is earlier than fetch async asyncData({ $axios, isDev, route, store, env, params, query, req, res, redirect, error }) { // $axios is exposed due to nuxt modules: ['@nuxtjs/axios'] console.log('asyncData: ', $axios); try { const { ok, good } = await $axios.$get(`/api/goods/${params.id}`); if (ok) { return { good }; } error('failed to fetch data'); } catch (err) { error(err); // redirect('/route-path'); } }, head() { return { meta: [ { name: 'keywords', content: `${this.good.name},无限宝石,无限元宝`, }, ], title: this.good.name, }; }, validate({ params, query }) { return /^\\d+$/.test(Number(params.id)); // must be number }, }; 1.4. 中间件 中间件会在⼀个⻚⾯或⼀组⻚⾯渲染之前运⾏我们定义的函数，常⽤于权限控制、校验等任务。 范例代码：管理员⻚⾯保护 创建 middleware/auth.js /* 全局的 guard，没有 token 则跳到登录页 */ export default function({ route, redirect, store }) { console.log('auth'); // 上下⽂中通过store访问vuex中的全局状态 // 通过vuex中令牌存在与否判断是否登录 if (!store.state.user.token) { redirect('/login?redirect=' + route.path); } } 注册中间件，pages/admin.vue: export default { middleware: ['auth'] } 以上中间件需要使用 vuex store。判断 vuex 里面 user 模块是否有 token，token 是从服务端 cookie 中传进来。现写 vuex。 状态管理 vuex 应⽤根⽬录下如果存在 store ⽬录，Nuxt.js 将启⽤ vuex 状态树。 范例：⽤户登录及登录状态保存，创建 store/user.js Middleware/auth 比 plugins/interceptor 执行的早 export const state = () => ({ token: '' }); export const mutations = { init(state, token) { state.token = token; }, }; export const getters = { isLogin(state) { return !!state.token; }, }; export const actions = { login({ commit, getters }, u) { return this.$axios.$post('/api/login', u).then(({ token }) => { if (token) { commit('init', token); } return getters.isLogin; }); }, }; Login.vue, 服务端 username is jerry, password is 123 Login vue will use blank layout, so the navigation won't appear. Login export default { layout: 'blank', // use blank layout data() { return { user: { username: '', password: '', }, }; }, methods: { login() { this.$store.dispatch('user/login', this.user).then((ok) => { if (ok) { const redirect = this.$route.query.redirect || '/'; this.$router.push(redirect); } }); }, }, }; unlogin user tries to access admin page, auth middleware is executed and cannot find token from vuex user store, so user is redirected to login page. After user inputs credentials, login will dispatch user/login, and then store actions send api request to server. Server put token to vuex store, Login callback redirects to admin page. Question: I login already and land on refresh page. Now if I refresh admin page, what will happen? Answer: Even token was in the vuex store, after refreshing page, the vuex store token is lost. So page will be kicked to login page. To solve this issue, we need to set server's cookie into vuex at nuxtServerInit hook. nuxtServerInit 通过在 store 的根模块中定义 nuxtServerInit ⽅法，将服务端的⼀些数据传到客户端。 安装依赖模块：`npm i -S cookie-universal-nuxt nuxt.config.js 中注册 modules: [\"cookie-universal-nuxt\"], 登录状态初始化，store/index.js export const actions = { // 该 action 只能出现在 index // 只在服务端执行一次，在 middleware 之前。很早 nuxtServerInit({ commit }, { app }) { console.log('nuxtServerInit'); // app is nuxt context // 获取 cookie, npm install cookie-universal-nuxt const token = app.$cookies.get('token'); if (token) { /* persistent in server. If not, refresh page will clear vuex, so the token is lost. SSR needs to remind fill vuex */ console.log('nuxtServerInit: token:' + token); // will print in server // 每次刷新、首次加载页面，把服务端 cookie 写入 vuex user 模块。这样 auth middleware，interceptor plugin 才能从 vuex 中找到 token！！！ commit('user/init', token); } }, }; 这样登陆用户刷新 admin 也会停留。状态保持住了。 1.5. 插件 Nuxt.js 会在运⾏应⽤之前执⾏插件函数，需要引⼊或设置 Vue 插件、⾃定义模块和第三⽅模块时特别有⽤。 范例：添加请求拦截器附加 token，创建 plugins/interceptor.js // https://axios.nuxtjs.org/extend // add token to all requests if any export default function({ $axios, store, redirect }) { // nuxt.config.js modules @nuxtjs/axios 提供的 $axios。 // 基本配置 $axios.defaults.timeout = 10000; $axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; // 要使用本 interceptor 需要在 nuxt.config.js plugins 中注册 $axios.onRequest((config) => { console.log('Making request to ' + config.url); if (store.state.user.token) { config.headers.Authorization = 'Bearer ' + store.state.user.token; } return config; }); // 返回回调 $axios.onResponse((res) => {}); $axios.onError((error) => { const code = parseInt(error.response && error.response.status); // this happens before component's asyncData try/catch error if (code === 404) { redirect('/not-found'); } }); } 注册插件，nuxt.conﬁg.js plugins: [\"@/plugins/interceptor\"] 1.6. 服务端渲染应⽤部署 # 要先启动 api server。 npm run build npm start # 渲染服务器和客户端在一起 dist folder is under .nuxt folder. 1.7. 静态应⽤部署 Nuxt.js 可依据路由配置将应⽤静态化，使得我们可以将应⽤部署⾄任何⼀个静态站点主机服务商。github pages, blog... 需要 api server, render server both open! npm run generate dist folder is under root, not .nuxt folder 1.8. FAQ 没有 keep-alive 由于是服务端渲染，所以不支持组件的keep-alive，那自然activated、deactivated这两个生命周期也没了 登录状态？ vue-cli项目中，我们可以用vuex-persistedstate，它可以使vuex 的状态持久化，页面刷新都不会丢失，原理当然是localStorage 啦！当然我更喜欢用vue-cookies进行保存token，问题来了，nuxt项目怎么保存登录状态呢？当然上面这两种方法我们都可以使用，但是有个问题，由于在created钩子中不存在window对象(获取cookie、localStorage都需要window对象)，当你需要判断是否存在token的时候，你必须要在mounted 进行操作，这说明页面进来的一瞬间你无法得知是否已经登录了，这会导致显示用户名、组件显示于隐藏都慢半拍 nuxt非常友好，它提供了fetch 钩子，还有nuxtServerInit，这两个钩子都运行在服务端并且我们能很快速地操作store fetch, asyncData, created 区别 asyncData 最早，然后 fetch，最后 created 是 client 的事件。asyncData 获取服务端数据，为模板提供数据。fetch 也获取服务端数据，然后 store commit。 // asyncData is earlier than fetch async asyncData({ $axios, isDev, route, store, env, params, query, req, res, redirect, error }) { // $axios is exposed due to nuxt modules: ['@nuxtjs/axios'] try { const { ok, goods } = await $axios.$get('/api/goods'); if (ok) { return { goods }; } error('failed to fetch data'); } catch (err) { error(err); // redirect('/route-path'); } }, /* 1. 如果页面组件设置了fetch方法，它会在组件每次加载前被调用（在服务端或切换至目标路由之前） 2. fetch 请求 server 后进行 commit 3. 这里 fetch 做的事类似 nuxtServerInit */ async fetch({ store, params, $axios }) { // console.log('fetch: ', $axios); // const { data } = await $axios.$get('/api/token'); 实际项目会 get currentUser const { ok, token } = await $axios.$post('/api/login', { username: 'jerry', password: '123' }); if (ok) { store.commit('user/init', token); } }, created() { // console.log('created: ', this.$axios); } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/15_ssr_vue.html": {
    "url": "Vue/15_ssr_vue.html",
    "title": "15_ssr_vue",
    "keywords": "",
    "body": "1. Vue SSR 实战1.1. 安装依赖1.2. 启动脚本1.3. 构建步骤1.4. 路由 Vue-router1.5. csr 和 ssr 通用1.6. 整合 Vuex1.6.1. 安装 vuex1. Vue SSR 实战 https://github.com/eddyerburgh/vue-cli-ssr-example 1.1. 安装依赖 npm install vue-server-renderer express --save 1.2. 启动脚本 server/index.js const express = require('express'); const Vue = require('vue'); const app = express(); const renderer = require('vue-server-renderer').createRenderer(); // ⻚⾯ const page = new Vue({ data: { name: '开课吧', count: 1 }, template: ` {{name}} {{count}} `, }); app.get('/', async function(req, res) { try { // renderToString可以将vue实例转换为html字符串 const html = await renderer.renderToString(page); res.send(html); } catch (error) { res.status(500).send('internal server error'); } }); app.listen(3000, () => { console.log('渲染服务端启动成功 at http://localhost:3000'); }); Access localhost:3000 check element: . 1.3. 构建步骤 webpack 根据执⾏环境⽣成 server bundle 和 client bundle 1.4. 路由 Vue-router 单⻚应⽤的⻚⾯路由，都是前端控制，后端只负责提供数据 ⼀个简单的单⻚应⽤，使⽤ vue-router,为了⽅便前后端公⽤路由数据，我们新建 router.js 对外暴露 createRouter npm i vue-router -s // router/index.js import Vue from 'vue'; import Router from 'vue-router'; import Index from '@/components/Index'; Vue.use(Router); // 导出工厂，因为服务端渲染要为不同用户的请求都创建新的 router，状态隔离。 export function createRouter() { return new Router({ routes: [ { path: '/', component: Index }, { path: '/detail', component: () => import('@/components/Detail.vue') }, ], }); } // components/Detail.vue Detail page export default {}; // components/Index.vue Index page export default {}; // components/App.vue Home Detail 1.5. csr 和 ssr 通用 Create app.js: // entry-server.js, entry-client.js both use this import Vue from 'vue'; import App from './App.vue'; import { createRouter } from './router'; // 创建 Vue 实例 export function createApp(context) { const router = createRouter(); const app = new Vue({ router, context, render: (h) => h(App) }); return { app, router }; } csr 的⼊⼝⽂件 entry-client.js import { createApp } from './app'; const { app, router } = createApp(); router.onReady(() => { app.$mount('#app'); }); ssr 的⼊⼝⽂件 entry-server.js import { createApp } from './app'; export default (context) => { // 我们返回⼀个 Promise // 确保路由或组件准备就绪 return new Promise((resolve, reject) => { const { app, router } = createApp(context); // 跳转到⾸屏的地址 router.push(context.url); router.onReady(() => { resolve(app); }, reject); }); }; 后端加⼊ webpack npm install cross-env vue-server-renderer webpack-node-externals lodash.merge --save vue.config.js const VueSSRServerPlugin = require('vue-server-renderer/server-plugin'); const VueSSRClientPlugin = require('vue-server-renderer/client-plugin'); // 优化 const nodeExternals = require('webpack-node-externals'); const merge = require('lodash.merge'); // 根据 WEBPACK_TARGET 作相应输出 const TARGET_NODE = process.env.WEBPACK_TARGET === 'node'; const target = TARGET_NODE ? 'server' : 'client'; module.exports = { css: { extract: false, }, outputDir: `./dist/${target}`, configureWebpack: () => ({ // 将 entry 指向应⽤程序的 server / client ⽂件 entry: `./src/entry-${target}.js`, // 对 bundle renderer 提供 source map ⽀持 devtool: 'source-map', target: TARGET_NODE ? 'node' : 'web', node: TARGET_NODE ? undefined : false, output: { libraryTarget: TARGET_NODE ? 'commonjs2' : undefined, }, // https://webpack.js.org/configuration/externals/#function // https://github.com/liady/webpack-node-externals // 外置化应⽤程序依赖模块。可以使服务器构建速度更快， // 并⽣成较⼩的 bundle ⽂件。 externals: TARGET_NODE ? nodeExternals({ // 不要外置化 webpack 需要处理的依赖模块。 // 你可以在这⾥添加更多的⽂件类型。例如，未处理 *.vue 原始⽂件， // 你还应该将修改 `global`（例如 polyfill）的依赖模块列⼊⽩名单 whitelist: [/\\.css$/], }) : undefined, optimization: { splitChunks: TARGET_NODE ? false : undefined, }, plugins: [TARGET_NODE ? new VueSSRServerPlugin() : new VueSSRClientPlugin()], }), chainWebpack: (config) => { config.module .rule('vue') .use('vue-loader') .tap((options) => { merge(options, { optimizeSSR: false, }); }); }, }; 服务器启动⽂件，server.js const fs = require('fs'); const express = require('express'); const app = express(); // 第 2 步：获得⼀个createBundleRenderer const { createBundleRenderer } = require('vue-server-renderer'); const bundle = require('./dist/server/vue-ssr-server-bundle.json'); const clientManifest = require('./dist/client/vue-ssr-client-manifest.json'); const renderer = createBundleRenderer(bundle, { runInNewContext: false, template: fs.readFileSync('./src/index.temp.html', 'utf-8'), clientManifest: clientManifest, }); function renderToString(context) { return new Promise((resolve, reject) => { renderer.renderToString(context, (err, html) => { resolve(html); }); }); } // 开放dist⽬录 app.use(express.static('./dist/client')); app.get('*', async (req, res) => { console.log(req.url, 123); try { const context = { title: 'ssr test', url: req.url }; const html = await renderToString(context); res.send(html); } catch (error) { res.status(500).send('internal server error'); } }); app.listen(3000, () => { console.log('渲染服务端启动成功 at http://localhost:3000'); }); 宿主⽂件 src/index.temp.html vue-ssr 脚本配置 package.json \"build:client\": \"vue-cli-service build\", \"build:server\": \"cross-env WEBPACK_TARGET=node vue-cli-service build -mode server\", \"build\": \"npm run build:client && npm run build:server\", 1.6. 整合 Vuex 1.6.1. 安装 vuex npm install --save vuex store/index.js import Vue from 'vue'; import Vuex from 'vuex'; Vue.use(Vuex); export function createStore() { return new Vuex.Store({ state: { count: 108 }, mutations: {}, actions: {}, }); } update app.js: 挂载 store // entry-server.js, entry-client.js both use this import Vue from 'vue'; import App from './App.vue'; import { createRouter } from './router'; + import { createStore } from './store'; // 创建 Vue 实例 export function createApp(context) { const router = createRouter(); + const store = createStore(); const app = new Vue({ router, + store, context, render: (h) => h(App) }); return { app, router }; } 使⽤ src/components/index.vue: num:{{$store.state.count}} Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/16_vue_typescript.html": {
    "url": "Vue/16_vue_typescript.html",
    "title": "16_vue_typescript",
    "keywords": "",
    "body": "1. Vue typescript1.1. 准备⼯作1.2. Class and Function1.3. Generic and Decorator1.4. vuex1.5. Function overloading1.6. Decorator 原理1.7. 自己实现一个装饰器1. Vue typescript 1.1. 准备⼯作 新建⼀个基于 ts 的 vue 项⽬ vue create vue-ts 选项选择： ⾃定义选项 - Manually select features 添加 ts ⽀持 - TypeScript 基于类的组件 - y tslint 已存在项⽬ vue add @vue/typescript 1.2. Class and Function class 是语法糖，它指向的就是构造函数。 class Person { // 类指向构造函数 constructor(private name: string, private age: number) { // constructor是默认⽅法，new实例时⾃动调⽤ this.name = name; // 属性会声明在实例上，因为this指向实例 this.age = age; } public say() { // ⽅法会声明在原型上 return '我的名字叫' + this.name + '今年' + this.age + '岁了'; } } console.log(typeof Person); // function console.log(Person === Person.prototype.constructor); // true // 等效于 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.say = function() { return '我的名字叫' + this.name + '今年' + this.age + '岁了'; }; 1.3. Generic and Decorator /* generic */ export interface Result { ok: 0 | 1; data: T[]; } export interface Feature { id: number; name: string; } // hello.vue {{ feature.name }} 回车添加 feature Total count: {{ count }} msg from parent: {{ msg }} boy in ts: {{ boy }} import { Component, Prop, Vue, Emit, Watch } from 'vue-property-decorator'; import { Feature } from '@/models/feature'; import { Result } from '@/models/result'; function getData(): Promise> { const data: any[] = [{ id: 1, name: 'hello' }, { id: 2, name: 'world' }]; // return Promise.resolve>({ ok: 1, data }); return new Promise((resolve) => setTimeout(() => resolve({ ok: 1, data }), 1000)); } @Component({ // 这里最好传与 hello 不是密切相关的内容，比如 mixin，component。props 还是放在里面好。 props: { msg: { type: String, default: 'hhh~', }, }, }) export default class Hello extends Vue { @Prop({ type: String, default: 'derek~' }) private boy!: string; // 相当 data 属性 private features: Feature[] = []; constructor() { super(); } @Watch('features', { immediate: true, deep: true, }) private featuresChange(newVal: any, oldVal: any) { console.log(newVal, oldVal); } // 不给 emit 传参，事件名就是方法名； @Emit() private addFeature(event: any) { const feature = { id: this.features.length + 1, name: event.target.value }; this.features.push(feature); event.target.value = ''; // 如果没有返回值，形参是事件参数 // 有返回值，返回值就是事件参数 return feature; } private async created() { console.log('created lifecycle'); this.features = (await getData()).data; } get count() { return this.features.length; } } Parent Component: import Hello from '@/components/Hello'; import Feature from '@/models/feature'; export default { name: 'about', components: { Hello }, methods: { wow(feature) { alert(feature.name); }, }, }; 1.4. vuex 安装: npm i vuex-class -S 定义状态，store.js import Vue from 'vue'; import Vuex from 'vuex'; Vue.use(Vuex); export default new Vuex.Store({ state: { features: [{ id: 1, name: 'hello' }, { id: 2, name: 'world' }], }, mutations: { addFeatureMutation(state: any, featureName) { state.features.push({ id: state.features.length + 1, name: featureName }); }, }, actions: { addFeatureAction({ commit }, featureName) { commit('addFeatureMutation', featureName); }, }, }); Hello.vue 使用 vuex。 import { State, Action, Mutation } from 'vuex-class'; @Component export default class Feature extends Vue { // 状态、动作、变更映射 @State features!: string[]; @Action addFeatureAction; @Mutation addFeatureMutation; private addFeature(event) { this.addFeatureAction(event.target.value); // or // this.addFeatureMutation(event.target.value); event.target.value = ''; } } 1.5. Function overloading /** * function overloading */ // declaration function getInfo(param: object): string; function getInfo(param: string | number): object; // implementation function getInfo(param: any): any { if (typeof param === 'object') { return 'derek'; } else { return { name: param }; } } // usage getInfo('ddd'); 1.6. Decorator 原理 /* Decorator */ // 1. 类装饰器 function log(target: Function) { // target is the constructor console.log(target === Foo); // true target.prototype.log = function() { console.log(this.bar); }; } @log class Foo { @mua public girl!: string; public bar = 'bar'; @dong public baz(val: string) { this.bar = val; } } const foo = new Foo(); // @ts-ignore foo.log(); // 2. ⽅法装饰器 function dong(target: any, name: string, descriptor: any) { // target是原型或构造函数 Foo {}，name是⽅法名 baz，descriptor是属性描述符 { value: [Function: baz], ... } // ⽅法的定义⽅式：Object.defineProperty(target, name, descriptor) console.log(target[name] === descriptor.value); // 这⾥通过修改descriptor.value扩展了bar⽅法 const baz = descriptor.value; // 之前的⽅法 descriptor.value = function(val: string) { console.log('dong~~'); baz.call(this, val); }; return descriptor; } foo.baz('derek'); // 3. 属性装饰器 function mua(target: any, name: string) { // target是原型或构造函数，name是属性名 console.log(target === Foo.prototype); target[name] = 'mua~~~'; } console.log(foo.girl); 1.7. 自己实现一个装饰器 {{ msg }} import { Prop, Vue } from 'vue-property-decorator'; function Component(options: any) { return function(target: Function) { return Vue.extend(options); }; } @Component({ props: { msg: { type: String, default: '' } }, }) export default class Decorator extends Vue {} 探究 vue-property-decorator 中各装饰器实现原理 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/2wayBinding_modifier.html": {
    "url": "Vue/2wayBinding_modifier.html",
    "title": "2wayBinding_modifier",
    "keywords": "",
    "body": "1. 2 way binding with central object and modifier1. 2 way binding with central object and modifier input binding: v-model can bind a central object -- blog in this case. Of course we need to include this object in data function. lazy modifier lets the output delays until input blurs. lazy uses onchange event while oninput is default behavior. checkbox binding: bind values to array. Any selected checkbox will add its value to the array. select dropdown binding: bind model in select tag rather than option. selected value will be bind into a string. But if select has multiple attr, it should bind to an array. Add a New Blog Post Blog Title: Blog Content: Blog Categories: Ninjas Wizards Mario Cheese Author: {{ author }} Preview blog Blog title: {{ blog.title }} Blog content: {{ blog.content }} Blog Categories: {{ category }} Author: {{ blog.author }} export default { data () { return { blog: { title: '', content: '', categories: [], author: '' }, authors: ['The Net Ninja', 'The Angular Avenger', 'The Vue Vindicator'] } }, methods: { } } #add-blog *{ box-sizing: border-box; } #add-blog{ margin: 20px auto; max-width: 500px; } label{ display: block; margin: 20px 0 10px; } input[type=\"text\"], textarea{ display: block; width: 100%; padding: 8px; } #preview{ padding: 10px 20px; border: 1px dotted #ccc; margin: 30px 0; } h3{ margin-top: 10px; } #checkboxes input{ display: inline-block; margin-right: 10px; } #checkboxes label{ display: inline-block; margin-top: 0; } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/communications_props_event.html": {
    "url": "Vue/communications_props_event.html",
    "title": "communications_props_event",
    "keywords": "",
    "body": "1. Vue Components' Communication by props and event1.1. Parent to Child -- props1.2. primitive and reference types1.3. Child to Parent -- Event1.4. Event bus1.5. 结合 react 的思考1. Vue Components' Communication by props and event 1.1. Parent to Child -- props props 用于 parent component 发送到 child component。 App.vue: import Child from './components/Child.vue' export default { components: { 'app-child': Child }, data() { return { message: 'hello' } } } Child.vue: {{ msg }} export default { // props: ['msg'], props: { 'msg': { type: String, required: true } }, data() { return { } } } 需要注意的点： Parent 使用 v-bind 进行 props 传递, Child 用 props 接收 Child props 也可以完成 validation 1.2. primitive and reference types primitive types: string, number, boolean reference types: array, object 假设 Parent 传递的 props 是一个 array，这个 array 的 props 被多个 Child 使用，则在一个 Child 中进行修改 array，其实是修改了 data source，因为是通过引用传递的。这样其他 Child 的数据也会被改变。对数据共享来说是好事。Children 之间没有对 reference types 进行隔离。 如果 Parent 传递的 props 是 primitive types，一个 Child 修改只影响自身，其他 Child 不会被修改。如果希望数据同步，有这两做法： 被修改的 Child emit event，Parent 订阅这个 event，回调函数中修改属性，这样所以 Children 重新渲染 不通过 Parent，希望 Child2 直接关注 Child1 的状态，使用 event bus 1.3. Child to Parent -- Event App.vue: 父级通过 v-on:子组件 emit 名字 = 回调函数 实现对子组件事件的订阅。回调函数进行数据处理。 import Header from './components/Header.vue'; import Footer from './components/Footer.vue'; export default { components: { 'app-header': Header, 'app-footer': Footer }, data () { return { title: 'Vue Wizards' } }, methods: { updateTitle: function(updatedTitle){ this.title = updatedTitle; } } } Header.vue: 子组件在某个函数中 emit 某个自定义事件和数据 -- this.$emit('changeTitle', 'Vue Ninjas'); {{ title }} export default { props: { title: { type: String, required: true } }, data(){ return{ } }, methods: { changeTitle: function(){ this.$emit('changeTitle', 'Vue Ninjas'); } } } Footer.vue: 另一个子组件因为父级 title props 改变而重新渲染，数据也就改变了。 Copyright 2017 {{ title }} export default { props: { title: { type: String, required: true } }, data(){ return{ } } } 1.4. Event bus Event bus is a vue instance. main.js: export const bus = new Vue(); Header.vue: 引起变化的子组件。 {{ title }} // 引入 event bus import { bus } from '../main'; export default { props: { title: { type: String, required: true } }, data(){ return{ } }, methods: { changeTitle: function(){ // 修改自己的 title 属性 this.title = 'Vue Ninjas'; // 向 bus emit 事件 bus.$emit('titleChanged', 'Vue Ninjas'); } } } Footer.vue: 关心 Header 的子组件。 Copyright 2017 {{ title }} // 引入 event bus import { bus } from '../main'; export default { props: { title: { type: String, required: true } }, data(){ return{ } }, // 生命周期钩子，创建时候 bus 就订阅事件 created(){ bus.$on('titleChanged', (data) => { this.title = data; }); } } 1.5. 结合 react 的思考 Vue 的组件间通信简单说就是 props 和 event emit。子级 emit，父级订阅之并在回调函数中修改 props 数据，子级重新渲染。 react 父级向子级通信也是通过 props。子级向父级：子级某个函数调用 setState 去修改父级的 state，而这个 setState 也是通过 props 传递给子级的。react 可能需要把多个子级都需要的数据提取到父级 state 中。 Vue 子组件之间可以通过 Event bus 直接进行通信。React 单项数据流不推荐这种做法，但可以通过 context API 进行跨多个 level 组件间的 props 传输。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/customDirective.html": {
    "url": "Vue/customDirective.html",
    "title": "customDirective",
    "keywords": "",
    "body": "1. custom directive1.1. globally 实现 2 个自定义 directive。1.2. locally register1. custom directive 1.1. globally 实现 2 个自定义 directive。 v-rainbow 用于给 array 数据遍历时显示随机颜色。v-theme 用于设置 div 的宽度，类似 bootstrap container。 All Blog Articles {{ blog.title }} {{ blog.body }} export default { data () { return { blogs: [] } }, created() { this.$http.get('http://jsonplaceholder.typicode.com/posts').then(function(data){ this.blogs = data.body.slice(0,10); }); } } main.js: import Vue from 'vue'; import VueResource from 'vue-resource'; import App from './App.vue'; // Use vue-resource package Vue.use(VueResource); // global filter Vue.filter('to-uppercase', function(value) { return value.toUpperCase(); }); // Global Custom directives Vue.directive('rainbow', { bind(el, binding, vnode) { el.style.color = '#' + Math.random() .toString(16) .slice(2, 8); }, }); Vue.directive('theme', { bind(el, binding, vnode) { // =后面的通过 value 获取。v-theme:column=\"wide\" if (binding.value == 'wide') { el.style.maxWidth = '1260px'; } else if ((binding.value = 'narrow')) { el.style.maxWidth = '560px'; } // :后面的通过 arg 获取。v-theme:column=\"something\" if (binding.arg == 'column') { el.style.background = '#ddd'; el.style.padding = '20px'; } }, }); new Vue({ el: '#app', render: (h) => h(App), }); 1.2. locally register All Blog Articles {{ blog.title | toUppercase }} {{ blog.body }} export default { data () { return { blogs: [], search: '' } }, methods: { }, created() { this.$http.get('http://jsonplaceholder.typicode.com/posts').then(function(data){ this.blogs = data.body.slice(0,10); }); }, computed: { filteredBlogs: function(){ return this.blogs.filter((blog) => { return blog.title.match(this.search); }); } }, filters: { /*'to-uppercase': function(value){ return value.toUpperCase(); }*/ toUppercase(value){ return value.toUpperCase(); } }, directives: { 'rainbow' :{ bind(el, binding, vnode){ el.style.color = \"#\" + Math.random().toString(16).slice(2, 8); } } } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/dynamicComponent.html": {
    "url": "Vue/dynamicComponent.html",
    "title": "dynamicComponent",
    "keywords": "",
    "body": "1. dynamic components1. dynamic components 我们有时候想动态切换不同的组件。 就可以实现。我们可以进一步通过 v-bind 进行绑定。 keep-alive 的作用: 默认在切换 component 时候之前的组件被 destroy，所以再回到原来的组件一切需要重新创建，之前填写的数据，data 里面的数据都重置，如果想不去 destroy，还 retain 之前的状态需要 keep-alive。 react 里面是通过 {this.state.something && } 实现。改变 state 就可以动态渲染或删除组件。 --> Show form one Show form two import formOne from './components/formOne.vue'; import formTwo from './components/formTwo.vue'; export default { components: { 'form-one': formOne, 'form-two': formTwo }, data () { return { dynamicForm: 'form-one' } } } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/life_cycle.html": {
    "url": "Vue/life_cycle.html",
    "title": "life_cycle",
    "keywords": "",
    "body": "1. Vue life cycle demo1. Vue life cycle demo Growler Please check the console window Update Button Clicks: {{ counter }} Update Destroy document.getElementById('destroyButton').addEventListener('click', function() { growler.$destroy(); }); var growler = new Vue({ el: '#growler', data: { counter: 0 }, methods: { onUpdateClick: function() { this.counter = this.counter + 1; } }, beforeCreate: function() { console.log('beforeCreate'); }, created: function() { console.log('created'); }, beforeMount: function() { console.log('beforeMount'); }, mounted: function() { console.log('mounted'); }, beforeUpdate: function() { console.log('beforeUpdate'); }, updated: function() { console.log('updated'); }, beforeDestroy: function() { console.log('beforeDestroy'); }, destroyed: function() { console.log('afterDestroy'); } }); Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/mixin.html": {
    "url": "Vue/mixin.html",
    "title": "mixin",
    "keywords": "",
    "body": "1. mixin1. mixin 为了提取不同组件相同的功能。比如 showBlog 展示 blog title and content，listBlog 只展示 title。但是他们都有一个过滤 searchTerm 来显示过滤后 blog 的功能。这个 computed 属性可以提取出来。 components/showBlog.vue: All Blog Articles {{ blog.title }} {{ blog.body }} import searchMixin from '../mixins/searchMixin'; export default { data () { return { blogs: [], search: '' } }, created() { this.$http.get('http://jsonplaceholder.typicode.com/posts').then(function(data){ this.blogs = data.body.slice(0,10); }); }, mixins: [searchMixin] } components/listBlogs.vue: List Blog Titles {{ blog.title }} import searchMixin from '../mixins/searchMixin'; export default { data () { return { blogs: [], search: '' } }, created() { this.$http.get('http://jsonplaceholder.typicode.com/posts').then(function(data){ this.blogs = data.body.slice(0,10); }); }, mixins: [searchMixin] } mixins/searchMixin.js： export default { computed: { filteredBlogs: function() { return this.blogs.filter((blog) => { return blog.title.match(this.search); }); }, }, }; Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/slots.html": {
    "url": "Vue/slots.html",
    "title": "slots",
    "keywords": "",
    "body": "1. Vue slot 和组件封装1. Vue slot 和组件封装 slot 典型使用场景就是 组件封装，能确保最终显示的 UI 样式，开发者只需要关心具体要传入什么控件。有点类似 react 中的 children props。 下面的例子：每个元素写上 slot=“xxx” attr，在子级 form-helper 内部通过 确定渲染位置。 App.vue: 父级组件 {{ title }} This is some info about the form Submit import formHelper from './components/formHelper.vue' export default { components: { 'form-helper': formHelper }, data () { return { 'title': 'This is the title of a form' } }, methods: { handleSubmit: function(){ alert('thanks for submitting'); } } } formHelper.vue: 子组件 Please fill out our form... link 1 link 2 link 3 link 4 export default { components: { }, data () { return { } }, methods: { } } h1{ text-align: center; } form{ width: 100%; max-width: 960px; margin: 0 auto; } #useful-links ul{ padding: 0; } #useful-links li{ display: inline-block; margin-right: 10px; } form > div{ padding: 20px; background: #eee; margin: 20px 0; } #form-header{ background: #ddd; border: 1px solid #bbb; } Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  },
  "Vue/vue_interview.html": {
    "url": "Vue/vue_interview.html",
    "title": "vue_interview",
    "keywords": "",
    "body": "1. Vue interview1.1.1. 关于 Vue 生命周期，下列选项不正确的是()[单选题]1.1.2. 对于 vue 中数据响应式原理说法，不正确的是()[多选题]1.1.3. Vue 中组件参数传递，不正确的是()[单选]1.1.4. 关于 v-model 说法不正确的是()[单选]1.1.5. 下列说法不正确的是哪项()[单选题]1.1.6. 下列说法不正确的是哪项()[单选题]1.1.7. 下列关于 vuex 描述，不正确的是哪项()[单选题]1.1.8. 下列关于 vue-router 的描述，不正确的是()[单选题]1.1.9. 关于 vue 服务器渲染，下列说法不正确的()[单选题]1.1.10. 关于 typescript 在 vue 中的应用，说法不正确的是()[单选题]1.1.11. 下列关于 vue 说法不正确的是()[单选题]1.1.12. 下列关于 vue 原理哪些是正确的()[多选]1.1.13. 什么是 mvvm1.1.14. mvvm 和 mvc 区别？1.1.15. vue 的优点是什么?1.1.16. vue 生命周期的理解？1.1.17. 为什么 vue 中 data 必须是一个函数？1.1.18. 组件之间的传值？1.1.19. active-class 是哪个组件的属性？1.1.20. 路由之间跳转？1.1.21. 懒加载（按需加载路由）（常考）1.1.22. vue-router 有哪几种导航钩子?1.1.23. 自定义指令(v-check, v-focus) 的方法有哪些? 它有哪些钩子函数? 还有哪些钩子函数参数1.1.24. vue 的双向绑定的原理是什么(常考)1.1.25. vuex 的 store 特性是什么1.1.26. vuex 的 getter 特性是什么1.1.27. vuex 的 mutation 特性是什么1.1.28. 不用 vuex 会带来什么问题1.1.29. vuex 原理1.1.30. 使用 Vuex 只需执行 Vue.use(Vuex)，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？美团1.1.31. state 内部支持模块配置和模块嵌套，如何实现的？美团1.1.32. 在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？美团1.1.33. Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？美团1.1.34. 调试时的\"时空穿梭\"功能是如何实现的？美团1. Vue interview Reference: https://www.jianshu.com/u/56b92d335d13 1.1.1. 关于 Vue 生命周期，下列选项不正确的是()[单选题] a. vue 实例从创建到销毁的过程，就是生命周期。 b. 页面首次加载会触发 beforeCreate,created,beforeMount,mounted,beforeUpdate,updated c. created 标识完成数据观测，属性和方法的运算，初始化时间，$el 属性还没有显示出来 d. dom 渲染在 mounted 中就完成了 答案解析： b. 首次加载触发，beforeCreate,created,beforeMount,mounted beforeUpdate,updated 只有数据更新时候才会触发 1.1.2. 对于 vue 中数据响应式原理说法，不正确的是()[多选题] a. 采用数据劫持方式，即 Object.defineProperty()劫持 data 中各个属性来实现数据响应式 b. 视图中变化通过 watcher 更新 data 中的数据 c. 若 data 中某个属性多次变化，watcher 仅会进入更新队列 1 次 d. 通过变异过程进行依赖收集 答案解析： b. watcher 更新 UI 界面，不是更新数据 d. 编译唯一目的是生成 render 函数，依赖收集只在各个组件初始化中过程收集依赖 1.1.3. Vue 中组件参数传递，不正确的是()[单选] a. 子组件给父组件传值，使用 emit 方法 b. 子组件使用 emit('someevent')派发事件,父组件使用@someevent 监听 c. 祖孙组件之间可以使用 provide 和 inject 方式跨层级相互传值 d. 度组件给子组件传值，子组件通过 props 接收数据 答案解析： c. 祖孙传值使用 provide 和 inject 方式是对的，但是错误在于这种方法都是单向的，无法互相传值（文字游戏） 1.1.4. 关于 v-model 说法不正确的是()[单选] a. v-model 能够实现双向绑定 b. v-model 本质上是语法糖，负责监听用户输入时间以及更新数据 c. v-model 是内置指令，不能使用在自定义组件上 d. 对 input 使用 v-model 实际上是指定其：value 和 input 答案解析： c. v-model 是可以使用在自定义组件上的， 子组件在 props 中通过 value 接收数据，通过$emit('input')去派发事件 1.1.5. 下列说法不正确的是哪项()[单选题] a. key 的作用是为了高效的更新虚拟 DOM b. 若指定了组件的 template 选项，render 函数不会执行 c. 使用vm.$nextTick可以确获得 DOM 异步更新的结果 d. 若没有 el 选项，vm.$mount(dom)可以将 Vue 实例挂载于指定元素上 答案解析： b. el 与 template 存在竞争关系，render 函数一定会执行，有 render 函数 template 会被忽略 Vue 推荐在绝大多数情况下使用 template 来创建你的 HTML 特殊情况下使用 render 函数(使用 JavaScript 的编程能力和创建 HTML)，它比 template 更接近编译器。 看原理 (Vue 原理)[https://www.jianshu.com/p/c1b835e9ed86] 1.1.6. 下列说法不正确的是哪项()[单选题] a. 使用this.$parent查找当前组件的父组件 b. 使用this.$children按照顺序查找当前组件的直接子组件 c. 使用this.$root查找根组件，并可以配合$children遍历全部组件 d. 使用this.$refs查找命名子组件 答案解析： b. 查找的子组件不知道具体顺序 1.1.7. 下列关于 vuex 描述，不正确的是哪项()[单选题] a. Vuex 是一个状态管理模式 b. Vuex 主要用于多视图之间状态全局共享与管理 c. 在 Vuex 中改变状态可以通过 mutaions 和 actions d. Vuex 通过 Vue 实现状态响应式，因此只能使用于 Vue 答案解析： c 改变状态的是 mutations，actions 内部也是通过 context.commit 的 mutations 的方法 1.1.8. 下列关于 vue-router 的描述，不正确的是()[单选题] a. vue-router 常用模式 hash 和 history b. 可以通过 addRoutes 方法动态添加路由 c. 可以通过 beforeEnter 对单个组件进行路由守卫 d. vue-router 借助 Vue 实现路由信息响应式，因此只能用于 Vue 答案解析： c beforeEnter 是对单个路由的守卫，不是单个组件 1.1.9. 关于 vue 服务器渲染，下列说法不正确的()[单选题] a. 通过服务器渲染，可以优化 SEO 抓取，提升首页加载速度 b. 某些生命周期钩子函数 如(beforeCreate,created) 可以运行在服务端和客户端 c. 服务器渲染的 vue.js 是同构开发，因为 vue 扩展库可以在服务端应用正常运行 d. 组件渲染为服务端的 HTML 字符串，将他们直接发送到浏览器，最后在客户端上\"激活\"为可交互的应用 答案解析： c 服务端是否可以使用 vue 扩展库没有明确的说明 1.1.10. 关于 typescript 在 vue 中的应用，说法不正确的是()[单选题] a. 使用 typeScript 可以获得静态类型检查以及最新的 ECMAscript 特性 b. typeScript 是 Javascript 类型的超集，它可以编译成纯 Javascript。意味着你完成可以使用 JS 语法编写 TS 代码 c. 使用 Vue.extend({})方式声明组件不能获得 TypeScript 类型推断能力 d. 基于类的 Vue 组件中如果要声明初始数据可以直接声明为实例的属性，如 message:string='Hello' 答案解析： c. Vue.extend({})可以声明组件 1.1.11. 下列关于 vue 说法不正确的是()[单选题] a. vue 简单易上手，性能高效，还便于与第三方库或既有项目整合 b. vue 构建的项目复杂度增加较快，仅适合中小型项目 c. vue 基于组件构建应用，代码组织简洁，易理解，易维护 d. vue 借助虚拟 DOM 实现跨平台，服务端渲染，以及性能良好的 DOM 更新策略 答案解析： b Vue0 后优化了 watcher，以组件为单位添加 watcher，(数量降低了) 异步更新数据，（数据变化并非实时更新，每种数据仅仅进入更新队列 1 次）https://www.jianshu.com/p/463c7f7669df 最大程度精确了虚拟 DOM 树数据更新位置，(通过 diff 与 patch 实现 新旧虚拟 DOM 树比对，只对变化位置数据更新) 提高了渲染的性能所以可以使用在大型项目上了 1.1.12. 下列关于 vue 原理哪些是正确的()[多选] a. Vue 中数据变更通知，通过拦截数组操作方法实现 b. 编译器目标是创建渲染函数，渲染函数执行得到 VNODE 树 c. 组件内 data 发生变化会通知其对应的 Watcher 执行异步更新 d. patching 算法首先是进行同层级比较，可以执行的操作是节点的增加，删除和更新 答案解析： abcd - a. 数组的 7 种拦截数据的方法 push() 从数组末尾添加值。 pop() 删除并返回数组的最后一个元素。 shift() 把数组的第一个元素从其中删除，并返回第一个元素的值。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 splice() 向/从数组中添加/删除项目，然后返回被删除的项目。 sort() 对数组的元素进行排序。 reverse() 用于颠倒数组中元素的顺序 b. 正确，见 Vue 原理摘录图 1 c. 正确，见 Vue 原理摘录图 1 触发了 setter 方法，通知对应组件的 watcher 执行异步更新 d. 正确，参照网上牛人的文章 1.1.13. 什么是 mvvm MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。 在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 1.1.14. mvvm 和 mvc 区别？ mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到 View 。 1.1.15. vue 的优点是什么? 低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的\"View\"上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。 可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。 可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。 1.1.16. vue 生命周期的理解？ 总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。 创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。 载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，dat- a. message 还未替换。在 mounted 阶段，vue 实例挂载完成，dat- a. message 成功渲染。 更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。 销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在。 1.1.17. 为什么 vue 中 data 必须是一个函数？ 对象为引用类型，当重用组件时，由于数据对象都指向同一个 data 对象，当在一个组件中修改 data 时，其他重用的组件中的 data 会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object 的实例），引用地址不同，则不会出现这个问题。 1.1.18. 组件之间的传值？ vue-cli 笔记 1.1.19. active-class 是哪个组件的属性？ vue-router 模块的 router-link 组件修改 router 按钮激活 class，一共 2 个地方，一个是在 router 的配置实例中 linkActiveClass，一个是在 router-link 标签上 active-class 优先级，标签上的权重更高 1.1.20. 路由之间跳转？ 声明式（标签跳转） 编程式（ js 跳转） router.push('index') 1.1.21. 懒加载（按需加载路由）（常考） webpack 中提供了 require.ensure()来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。 不进行页面按需加载引入方式：import home from '../../common/home.vue' 进行页面按需加载的引入方式：const home = r => require.ensure( [], () => r (require('../../common/home.vue'))) 1.1.22. vue-router 有哪几种导航钩子? 全局导航钩子 router.beforeEach(to, from, next), router.beforeResolve(to, from, next), router.afterEach(to, from ,next) 单独路由独享组件 beforeEnter 组件内钩子 beforeRouteEnter, beforeRouteUpdate, beforeRouteLeave 1.1.23. 自定义指令(v-check, v-focus) 的方法有哪些? 它有哪些钩子函数? 还有哪些钩子函数参数 全局定义指令：在 vue 对象的 directive 方法里面有两个参数, 一个是指令名称, 另一个是函数。 组件内定义指令：directives 钩子函数: bind(绑定事件出发)、inserted(节点插入时候触发)、update(组件内相关更新) 钩子函数参数： el、binding 1.1.24. vue 的双向绑定的原理是什么(常考) vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。具体步骤：第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化 第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是: 在自身实例化时往属性订阅器(dep)里面添加自己自身必须有一个 update()方法待属性变动 dep.notice()通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。 第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。 1.1.25. vuex 的 store 特性是什么 vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 datastate 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性 1.1.26. vuex 的 getter 特性是什么 getter 可以对 state 进行计算操作，它就是 store 的计算属性虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 getters 1.1.27. vuex 的 mutation 特性是什么 action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态 action 可以包含任意异步操作 vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中如果请求来的数据不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 vuex 的 state 里如果被其他地方复用，请将请求放入 action 里，方便复用，并包装成 promise 返回 1.1.28. 不用 vuex 会带来什么问题 可维护性会下降，你要修改数据，你得维护 3 个地方 可读性下降，因为一个组件里的数据，你根本就看不出来是从哪里来的 增加耦合，大量的上传派发，会让耦合性大大的增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背 1.1.29. vuex 原理 vuex 仅仅是作为 vue 的一个插件而存在，不像 Redux,MobX 等库可以应用于所有框架，vuex 只能使用在 vue 上，很大的程度是因为其高度依赖于 vue 的 computed 依赖检测系统以及其插件系统， vuex 整体思想诞生于 flux,可其的实现方式完完全全的使用了 vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对对象 Property set get 方法的代理劫持。最后一句话结束 vuex 工作原理，vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件； 1.1.30. 使用 Vuex 只需执行 Vue.use(Vuex)，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？美团 Vue.use(Vuex) 方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的 store 中。因此在 VueComponent 任意地方都能够通过 this.store 访问到该 store。 1.1.31. state 内部支持模块配置和模块嵌套，如何实现的？美团 在 store 构造方法中有 makeLocalContext 方法，所有 module 都会有一个 local context，根据配置时的 path 进行匹配。所以执行如 dispatch('submitOrder', payload)这类 action 时，默认的拿到都是 module 的 local state，如果要访问最外层或者是其他 module 的 state，只能从 rootState 按照 path 路径逐步进行访问。 1.1.32. 在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？美团 store 初始化时，所有配置的 action 和 mutation 以及 getters 均被封装过。在执行如 dispatch('submitOrder', payload)的时候，actions 中 type 为 submitOrder 的所有处理方法都是被封装后的，其第一个参数为当前的 store 对象，所以能够获取到 { dispatch, commit, state, rootState } 等数据。 1.1.33. Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？美团 Vuex 中修改 state 的唯一渠道就是执行 commit('xx', payload) 方法，其底层通过执行 this._withCommit(fn) 设置_committing 标志变量为 true，然后才能修改 state，修改完毕还需要还原_committing 变量。外部修改虽然能够直接修改 state，但是并没有修改_committing 标志位，所以只要 watch 一下 state，state change 时判断是否_committing 值为 true，即可判断修改的合法性。 1.1.34. 调试时的\"时空穿梭\"功能是如何实现的？美团 devtoolPlugin 中提供了此功能。因为 dev 模式下所有的 state change 都会被记录下来，'时空穿梭' 功能其实就是将当前的 state 替换为记录中某个时刻的 state 状态，利用 store.replaceState(targetState) 方法将执行 this._vm.state = state 实现。 Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 14:10:40 "
  },
  "Vue/watch.html": {
    "url": "Vue/watch.html",
    "title": "watch",
    "keywords": "",
    "body": "1. Vue watch shallow and deep1. Vue watch shallow and deep Shallow watch by default: .footer { border-top-width: 2px; } An example of a watched property. Beer Price {{ beer.name }} {{ beer.price }} buy Subtotal {{ subTotal }} var growler = new Vue({ el: '#growler', data: { beers: [{ name: 'Ahool Ale', price: 2.80 }, { name: 'Agogwe Ale', price: 2.38 }, { name: 'Aswang Ale', price: 3.05 }, { name: \"Buru's Barley Wine\", price: 2.95 }, { name: 'Hyote Chocolate Stout', price: 4.68 }, { name: 'Igopogo Pilsner', price: 3.40 }, { name: 'Jackalobe Lager', price: 2.49 }, { name: 'Mahamba Barley Wine', price: 4.89 }, { name: 'Megalodon Pale Ale', price: 3.76 }, { name: 'Pope Lick Porter', price: 3.52 }, { name: 'Chocolate Pukwudgie Stout', price: 4.17 }, { name: 'Sharlie Pilsner', price: 2.92 }, { name: 'Sigbin Stout', price: 2.49 }, { name: 'Snallygaster Pale Ale', price: 3.64 }, { name: 'Tikibalang Barley Wine', price: 4.21 }, { name: 'Pale Popobawa Ale', price: 4.34 }, { name: 'North Adjule Lager', price: 3.84 } ], shoppingCart: [], subTotal: 0.00 }, watch: { shoppingCart: function () { this.updateSubTotal(); } }, created: function () { this.updateSubTotal(); }, methods: { updateSubTotal: function () { var length = this.shoppingCart.length; var t = 0; for (var i = 0; i Deep watch: Only for scenarios needed since it's bad for performance. .footer { border-top-width:2px; } An example of a watched property. Beer Price {{ beer.name }} {{ beer.price }} buy Subtotal {{ shoppingCart.subTotal }} var growler = new Vue({ el: '#growler', data: { beers: [ { name: 'Ahool Ale', price: 2.80 }, { name: 'Agogwe Ale', price: 2.38 }, { name: 'Aswang Ale', price: 3.05 }, { name: \"Buru's Barley Wine\", price: 2.95 }, { name: 'Hyote Chocolate Stout', price: 4.68 }, { name: 'Igopogo Pilsner', price: 3.40 }, { name: 'Jackalobe Lager', price: 2.49 }, { name: 'Mahamba Barley Wine', price: 4.89 }, { name: 'Megalodon Pale Ale', price: 3.76 }, { name: 'Pope Lick Porter', price: 3.52 }, { name: 'Chocolate Pukwudgie Stout', price: 4.17 }, { name: 'Sharlie Pilsner', price: 2.92 }, { name: 'Sigbin Stout', price: 2.49 }, { name: 'Snallygaster Pale Ale', price: 3.64 }, { name: 'Tikibalang Barley Wine', price: 4.21 }, { name: 'Pale Popobawa Ale', price: 4.34 }, { name: 'North Adjule Lager', price: 3.84 } ], shoppingCart: { items: [], subTotal: 0.00 } }, watch: { shoppingCart: { handler: function(latest, original) { this.updateSubTotal() }, deep: true } }, created: function() { this.updateSubTotal(); }, methods: { updateSubTotal: function() { var length = this.shoppingCart.items.length; var t = 0; for (var i=0; i Copyright © Guanghui Wang all right reserved，powered by GitbookFile Modified： 2019-08-25 13:56:34 "
  }
}
