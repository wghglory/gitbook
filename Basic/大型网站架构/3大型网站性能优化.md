# 网站性能测试

1. 性能测试指标：①响应时间；②并发数；③吞吐量；④性能计数器；
2. 性能测试方法：①性能测试；②负载测试；③压力测试；④稳定性测试；
3. 性能优化策略：

　　①性能分析：检查请求处理各个环节的日志，分析哪个环节响应时间不合理，检查监控数据分析影响性能的因素；

　　②性能优化：Web前端优化，应用服务器优化，存储服务器优化；
　
# 性能优化

![](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261244136275208.jpg)

### web前端

1. 浏览器缓存：设置http头中Cache-Control和Expires属性

2. 使用页面压缩：可以对html、css、js文件启用Gzip压缩，可以达到较高的压缩效率，但是压缩会对服务器及浏览器产生一定的压力

    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-241644523465045.gif)

    > PS：Gzip压缩效率非常高，通常可以达到**70%**的压缩率，也就是说，如果你的网页有30K，压缩之后就变成了9K左右。想要启用Gzip压缩，提高浏览速度，可以浏览这篇文章：[http://www.chinaz.com/web/2012/1017/278682.shtml](http://www.chinaz.com/web/2012/1017/278682.shtml)

3. 合理布局页面：

    CSS：**把样式表置于顶部，浏览器会在下载完全部CSS之后才开始对整个页面进行渲染**，因此最好将CSS放在页面最上面；**避免使用CSS表达式（expression_r）**；用link代替@import；避免使用滤镜；
    
    JavaScript：**把脚本置于页面底部，浏览器在加载JS后会立即执行，有可能会阻塞整个页面，造成页面显示缓慢**；使用外部JavaScript和CSS；削减JavaScript和CSS；**剔除重复脚本；减少DOM访问**；开发智能事件处理程序；

4. 减少Cookie传输：一方面，太大的Cookie会严重影响数据传输；另一方面，对于某些静态资源的访问（如CSS、JS等）发送Cookie没有意义

5. 减少http请求：因为http是无状态的，每次请求的开销都比较昂贵（需要建立通信链路、进行数据传输，而服务器端对于每个http请求都需要启动独立的线程去处理）；减少http的主要手段是**合并CSS、合并JS、合并图片（CSS精灵，利用偏移定位image）**；

6. CDN：内容分发网络（Content Delivery Network，简称CDN）

    它**将数据缓存在离用户最近的节点**，缩短用户查看对象的延迟，提高用户访问网站的响应速度与网站的可用性，解决网络带宽小、用户访问量大、网点分布不均等问题。[http://baike.baidu.com/view/8689800.htm?from_id=420951&type=search&fromtitle=CDN&fr=aladdin](http://baike.baidu.com/view/8689800.htm?from_id=420951&type=search&fromtitle=CDN&fr=aladdin)
    
    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-241716505178557.jpg)

7. 反向代理

    反向代理服务器位于网站机房，代理网站Web服务器接收Http请求
    
    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261433239245494.png)
    
    反向代理服务器具有以下功能：
    　　①保护网站安全：任何来自Internet的请求都必须先经过代理服务器
    　　②通过配置缓存功能加速Web请求：减轻真实Web服务器的负载压力
    　　③实现负载均衡：均衡地分发请求，平衡集群中各个服务器的负载压力

### 应用服务器端：服务器本地缓存和分布式缓存

1. 分布式缓存：

    > ***PS：***网站性能优化第一定律：**优先考虑使用缓存优化性能**。缓存是指将数据存储在相对较高访问速度的存储介质中（如内存），以供系统进行快速处理响应用户请求。
    
    ①缓存本质是一个**内存Hash表**，数据以(Key,Value)形式存储在内存中。
    
    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261456467218523.png)
    
    ②缓存主要用来**存放那些读写比很高、很少变化的数据**，如商品的类目信息、热门商品信息等。这样，应用程序读取数据时，先到缓存中取，如缓存中没有或失效，再到数据库中取出，重新写入缓存以供下一次访问。因此，可以**很好地改善系统性能，提高数据读取速度，降低存储访问压力**。
    
    ③分布式缓存架构：一方面是以以JBoss Cache为代表的**互相通信**派；另一方面是以Memcached为代表的**互不通信**派；
    
    　　JBoss Cache需要将缓存信息同步到集群中的所有机器，代价比较大；而Memcached采用一种集中式的缓存集群管理，缓存与应用分离部署，应用程序通过**一致性Hash算法**选择缓存服务器远程访问缓存数据，缓存服务器之间互不通信，因而集群规模可以轻易地扩容，具有良好的伸缩性。
    
    　　Memcached由两个核心组件组成：服务端（ms）和客户端（mc），在一个memcached的查询中，mc先通过计算key的hash值来确定kv对所处在的ms位置。当ms确定后，客户端就会发送一个查询请求给对应的ms，让它来查找确切的数据。因为这之间没有交互以及多播协议，所以 memcached交互带给网络的影响是最小化的。
    
    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261544020179188.jpg)
    
2. 异步操作：

    ①使用**消息队列**将调用异步化，可改善网站的扩展性，还可改善网站性能；

    ![](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261559020964401.jpg)

    ②消息队列具有**削峰**的作用->将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务；

3. 使用集群：

    Web服务器集群、数据库服务器集群、分布式缓存服务器集群等等，通过部署多台服务器共同对外提供同类服务，提高整体处理能力。

    ①在高并发场景下，使用**负载均衡**技术为一个应用构建多台服务器组成的服务器集群；

    ![](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261605265029573.jpg)

    ②可以避免单一服务器因负载压力过大而响应缓慢，使用户请求具有**更好的响应延迟特性**；

    ③负载均衡可以采用硬件设备，也可以采用软件负载。商用硬件负载设备（例如出名的F5）成本通常较高（一台几十万上百万很正常），所以在条件允许的情况下我们会采用软负载，软负载解决的两个核心问题是：选谁、转发，其中最著名的是**LVS**（Linux Virtual Server）。

    > **PS：**LVS是四层负载均衡，也就是说建立在OSI模型的第四层——传输层之上，传输层上有我们熟悉的TCP/UDP，LVS支持TCP/UDP的负载均衡。
> 
> LVS的转发主要通过修改IP地址（NAT模式，分为源地址修改SNAT和目标地址修改DNAT）、修改目标MAC（DR模式）来实现。有关LVS的详情请参考：[http://www.importnew.com/11229.html](http://www.importnew.com/11229.html)

4. 代码优化：

    ①多线程：使用多线程的原因：一是IO阻塞，二是多CPU，都是为了最大限度地利用CPU资源，提高系统吞吐能力，改善系统性能；

    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261618330337528.png)

    ②资源复用：目的是**减少开销很大的系统资源的创建和销毁**，主要采用两种模式实现：单例（Singleton）和对象池（Object Pool）。例如，在.NET开发中，经常使用到的线程池，数据库连接池等，本质上都是对象池。

    ③数据结构：在不同场合合理使用恰当的数据结构，可以极大优化程序的性能。

    ④垃圾回收：理解垃圾回收机制有助于程序优化和参数调优，以及编写内存安安全的代码。这里主要针对Java（JVM）和C#（CLR）一类的具有GC（垃圾回收机制）的语言。

    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261632435027419.png)


### 数据库服务器端

1. 索引：索引（index）是对数据库表中一个或多个列（例如，employee 表的姓氏 (name) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。

    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-241730096119150.png)

    > PS：要注意的是，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。

2. 缓存：数据库缓存是介于应用程序和物理数据源之间，其作用是为了降低应用程序对数据库的物理数据源访问的频次，从而提高了应用的运行性能。

3. SQL优化：当一个基于数据库的应用程序运行起来很慢时，90%的可能都是由于数据访问程序的问题，要么是没有优化，要么是没有按最佳方法编写代码，因此你需要审查和优化你的数据访问/处理程序。具体可以浏览这篇文章：[http://www.cnblogs.com/Shaina/archive/2012/04/22/2464576.html](http://www.cnblogs.com/Shaina/archive/2012/04/22/2464576.html)

4. NoSQL：方兴未艾的NoSQL数据库通过优化数据模型、存储结构、伸缩性等手段在性能方面的优势日趋明显。

5. 存储性能优化

（1）机械硬盘 还是 固态硬盘？

（2）B+树 vs LSM树

　　①传统关系型数据库广泛采用B+树，B+树是对数据排好序后再存储，加快数据检索速度。

![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261639333141252.jpg)

> **PS：**目前大多数DB多采用两级索引的B+树，树的层次最多三层。因此可能需要**5次磁盘访问**才能更新一条记录（三次磁盘访问获得数据索引及行ID，一次数据文件读操作，一次数据文件写操作，终于知道数据库操作有多麻烦多耗时了）

　　②NoSQL（例如：HBase）产品广泛采用LSM树：

　　具体思想是：**将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘。**不过读取的时候稍微麻烦，需要合并磁盘中历史数据和内存中最近的修改操作，所以写入性能大大提升，读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件。

　　LSM树的原理是：把一棵大树拆分成N棵小树，它首先写入内存中，随着小树越来越大，内存中的小树会被清除并写入到磁盘中，磁盘中的树定期可以做合并操作，合并成一棵大树，以优化读性能。

![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261658010299461.jpg)

　　LSM树的优势在于：在LSM树上进行一次数据更新不需要磁盘访问，在内存即可完成，速度远快于B+树。










