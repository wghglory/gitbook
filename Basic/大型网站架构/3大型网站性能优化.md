# 网站性能测试

1.  性能测试指标：① 响应时间；② 并发数；③ 吞吐量；④ 性能计数器；
2.  性能测试方法：① 性能测试；② 负载测试；③ 压力测试；④ 稳定性测试；
3.  性能优化策略：

① 性能分析：检查请求处理各个环节的日志，分析哪个环节响应时间不合理，检查监控数据分析影响性能的因素；

② 性能优化：Web 前端优化，应用服务器优化，存储服务器优化；

# 性能优化

![](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261244136275208.jpg)

### web 前端

1.  浏览器缓存：设置 http 头中 Cache-Control 和 Expires 属性

2.  使用页面压缩：可以对 html、css、js 文件启用 Gzip 压缩，可以达到较高的压缩效率，但是压缩会对服务器及浏览器产生一定的压力

    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-241644523465045.gif)

    > PS：Gzip 压缩效率非常高，通常可以达到**70%**的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右。想要启用 Gzip 压缩，提高浏览速度，可以浏览这篇文章：[http://www.chinaz.com/web/2012/1017/278682.shtml](http://www.chinaz.com/web/2012/1017/278682.shtml)

3.  合理布局页面：

    CSS：**把样式表置于顶部，浏览器会在下载完全部 CSS 之后才开始对整个页面进行渲染**，因此最好将 CSS 放在页面最上面；**避免使用 CSS 表达式（expression_r）**；用 link 代替@import；避免使用滤镜；

    JavaScript：**把脚本置于页面底部，浏览器在加载 JS 后会立即执行，有可能会阻塞整个页面，造成页面显示缓慢**；使用外部 JavaScript 和 CSS；削减 JavaScript 和 CSS；**剔除重复脚本；减少 DOM 访问**；开发智能事件处理程序；

4.  减少 Cookie 传输：一方面，太大的 Cookie 会严重影响数据传输；另一方面，对于某些静态资源的访问（如 CSS、JS 等）发送 Cookie 没有意义

5.  减少 http 请求：因为 http 是无状态的，每次请求的开销都比较昂贵（需要建立通信链路、进行数据传输，而服务器端对于每个 http 请求都需要启动独立的线程去处理）；减少 http 的主要手段是**合并 CSS、合并 JS、合并图片（CSS 精灵，利用偏移定位 image）**；

6.  CDN：内容分发网络（Content Delivery Network，简称 CDN）

    它**将数据缓存在离用户最近的节点**，缩短用户查看对象的延迟，提高用户访问网站的响应速度与网站的可用性，解决网络带宽小、用户访问量大、网点分布不均等问题。[http://baike.baidu.com/view/8689800.htm?from_id=420951&type=search&fromtitle=CDN&fr=aladdin](http://baike.baidu.com/view/8689800.htm?from_id=420951&type=search&fromtitle=CDN&fr=aladdin)

    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-241716505178557.jpg)

7.  反向代理

    反向代理服务器位于网站机房，代理网站 Web 服务器接收 Http 请求

    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261433239245494.png)

    反向代理服务器具有以下功能：　　 ① 保护网站安全：任何来自 Internet 的请求都必须先经过代理服务器　　 ② 通过配置缓存功能加速 Web 请求：减轻真实 Web 服务器的负载压力　　 ③ 实现负载均衡：均衡地分发请求，平衡集群中各个服务器的负载压力

### 应用服务器端：服务器本地缓存和分布式缓存

1.  分布式缓存：

    > **_PS：_**网站性能优化第一定律：**优先考虑使用缓存优化性能**。缓存是指将数据存储在相对较高访问速度的存储介质中（如内存），以供系统进行快速处理响应用户请求。

    ① 缓存本质是一个**内存 Hash 表**，数据以(Key,Value)形式存储在内存中。

    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261456467218523.png)

    ② 缓存主要用来**存放那些读写比很高、很少变化的数据**，如商品的类目信息、热门商品信息等。这样，应用程序读取数据时，先到缓存中取，如缓存中没有或失效，再到数据库中取出，重新写入缓存以供下一次访问。因此，可以**很好地改善系统性能，提高数据读取速度，降低存储访问压力**。

    ③ 分布式缓存架构：一方面是以以 JBoss Cache 为代表的**互相通信**派；另一方面是以 Memcached 为代表的**互不通信**派；

    JBoss Cache 需要将缓存信息同步到集群中的所有机器，代价比较大；而 Memcached 采用一种集中式的缓存集群管理，缓存与应用分离部署，应用程序通过**一致性 Hash 算法**选择缓存服务器远程访问缓存数据，缓存服务器之间互不通信，因而集群规模可以轻易地扩容，具有良好的伸缩性。

    Memcached 由两个核心组件组成：服务端（ms）和客户端（mc），在一个 memcached 的查询中，mc 先通过计算 key 的 hash 值来确定 kv 对所处在的 ms 位置。当 ms 确定后，客户端就会发送一个查询请求给对应的 ms，让它来查找确切的数据。因为这之间没有交互以及多播协议，所以 memcached 交互带给网络的影响是最小化的。

    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261544020179188.jpg)

2.  异步操作：

    ① 使用**消息队列**将调用异步化，可改善网站的扩展性，还可改善网站性能；

    ![](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261559020964401.jpg)

    ② 消息队列具有**削峰**的作用->将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务；

3.  使用集群：

        Web服务器集群、数据库服务器集群、分布式缓存服务器集群等等，通过部署多台服务器共同对外提供同类服务，提高整体处理能力。

        ①在高并发场景下，使用**负载均衡**技术为一个应用构建多台服务器组成的服务器集群；

        ![](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261605265029573.jpg)

        ②可以避免单一服务器因负载压力过大而响应缓慢，使用户请求具有**更好的响应延迟特性**；

        ③负载均衡可以采用硬件设备，也可以采用软件负载。商用硬件负载设备（例如出名的F5）成本通常较高（一台几十万上百万很正常），所以在条件允许的情况下我们会采用软负载，软负载解决的两个核心问题是：选谁、转发，其中最著名的是**LVS**（Linux Virtual Server）。

        > **PS：**LVS是四层负载均衡，也就是说建立在OSI模型的第四层——传输层之上，传输层上有我们熟悉的TCP/UDP，LVS支持TCP/UDP的负载均衡。

    > LVS 的转发主要通过修改 IP 地址（NAT 模式，分为源地址修改 SNAT 和目标地址修改 DNAT）、修改目标 MAC（DR 模式）来实现。有关 LVS 的详情请参考：[http://www.importnew.com/11229.html](http://www.importnew.com/11229.html)

4.  代码优化：

    ① 多线程：使用多线程的原因：一是 IO 阻塞，二是多 CPU，都是为了最大限度地利用 CPU 资源，提高系统吞吐能力，改善系统性能；

    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261618330337528.png)

    ② 资源复用：目的是**减少开销很大的系统资源的创建和销毁**，主要采用两种模式实现：单例（Singleton）和对象池（Object Pool）。例如，在.NET 开发中，经常使用到的线程池，数据库连接池等，本质上都是对象池。

    ③ 数据结构：在不同场合合理使用恰当的数据结构，可以极大优化程序的性能。

    ④ 垃圾回收：理解垃圾回收机制有助于程序优化和参数调优，以及编写内存安安全的代码。这里主要针对 Java（JVM）和 C#（CLR）一类的具有 GC（垃圾回收机制）的语言。

    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261632435027419.png)

### 数据库服务器端

1.  索引：索引（index）是对数据库表中一个或多个列（例如，employee 表的姓氏 (name) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。

    ![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-241730096119150.png)

    > PS：要注意的是，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。

2.  缓存：数据库缓存是介于应用程序和物理数据源之间，其作用是为了降低应用程序对数据库的物理数据源访问的频次，从而提高了应用的运行性能。

3.  SQL 优化：当一个基于数据库的应用程序运行起来很慢时，90%的可能都是由于数据访问程序的问题，要么是没有优化，要么是没有按最佳方法编写代码，因此你需要审查和优化你的数据访问/处理程序。具体可以浏览这篇文章：[http://www.cnblogs.com/Shaina/archive/2012/04/22/2464576.html](http://www.cnblogs.com/Shaina/archive/2012/04/22/2464576.html)

4.  NoSQL：方兴未艾的 NoSQL 数据库通过优化数据模型、存储结构、伸缩性等手段在性能方面的优势日趋明显。

5.  存储性能优化

（1）机械硬盘 还是 固态硬盘？

（2）B+树 vs LSM 树

① 传统关系型数据库广泛采用 B+树，B+树是对数据排好序后再存储，加快数据检索速度。

![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261639333141252.jpg)

> **PS：**目前大多数 DB 多采用两级索引的 B+树，树的层次最多三层。因此可能需要**5 次磁盘访问**才能更新一条记录（三次磁盘访问获得数据索引及行 ID，一次数据文件读操作，一次数据文件写操作，终于知道数据库操作有多麻烦多耗时了）

②NoSQL（例如：HBase）产品广泛采用 LSM 树：

具体思想是：**将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘。**不过读取的时候稍微麻烦，需要合并磁盘中历史数据和内存中最近的修改操作，所以写入性能大大提升，读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件。

LSM 树的原理是：把一棵大树拆分成 N 棵小树，它首先写入内存中，随着小树越来越大，内存中的小树会被清除并写入到磁盘中，磁盘中的树定期可以做合并操作，合并成一棵大树，以优化读性能。

![-c](http://om1o84p1p.bkt.clouddn.com/2017-03-14-261658010299461.jpg)

LSM 树的优势在于：在 LSM 树上进行一次数据更新不需要磁盘访问，在内存即可完成，速度远快于 B+树。
